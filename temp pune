


// controllers/denverLiveOccupancyController.js

const { DateTime }       = require('luxon');
const { denver }         = require('../config/siteConfig');
const doorFloorMap       = require('../data/denverDoorFloorMap');
const { monitoredDoors } = require('../data/strictDoorList');
const sql                = require('mssql');
const normalizeKey       = require('../data/normalizeKey');

const warnedKeys = new Set();


// Increase timeout and add retry logic
async function safeQueryWithTimeout(req, sqlText, timeoutMs = 60000) { // Increased to 60s
  let timer = null;
  let timedOut = false;

  const cancelIfTimeout = () => {
    timedOut = true;
    try {
      if (typeof req.cancel === 'function') req.cancel();
    } catch (e) {
      // ignore
    }
  };

  const qPromise = (async () => {
    try {
      const result = await req.query(sqlText);
      return result;
    } finally {
      if (timer) clearTimeout(timer);
    }
  })();

  timer = setTimeout(cancelIfTimeout, timeoutMs);

  try {
    const res = await qPromise;
    if (timedOut) throw new Error('Query canceled after timeout');
    return res;
  } catch (err) {
    if (timedOut) err.message = `Query timed out after ${timeoutMs}ms`;
    throw err;
  }
}

// build a Set of normalized door___direction keys
const normalizedMonitoredKeys = new Set(
  Object.entries(monitoredDoors).map(([door, dir]) => normalizeKey(door, dir))
);

/** Determine floor label, fallback to “HQ. N.” parsing **/
function mapDoorToFloor(rawDoor, rawDir) {
  const key = normalizeKey(rawDoor, rawDir);
  if (doorFloorMap[key]) return doorFloorMap[key];
  const m = rawDoor.match(/HQ\.\s*(\d{1,2})\b/);
  if (m) return `Floor ${m[1]}`;
  if (!warnedKeys.has(key)) {
    console.warn(`⛔ Unmapped door-floor key: "${key}"`);
    warnedKeys.add(key);
  }
  return 'Unknown Floor';
}

/** Strip any trailing “_HH:MM:SS” from a door name **/
function stripTimeSuffix(doorRaw) {
  return doorRaw.replace(/_[0-9]{2}:[0-9]{2}:[0-9]{2}$/, '');
}

/**
 * Compare a DB row's Dateonly (yyyy-MM-dd) to either "today in Denver" OR a supplied reference DateTime (also Denver).
 * - dateOnly: string like '2025-09-11'
 * - referenceDt: optional luxon DateTime (zone 'America/Denver') to treat as "today"
 */
function isSameDenverDate(dateOnly, referenceDt = null) {
  if (!dateOnly) return false;
  const swipeDate = DateTime.fromISO(dateOnly, { zone: 'America/Denver' }).toFormat('yyyy-LL-dd');
  const today = referenceDt
    ? referenceDt.setZone('America/Denver').toFormat('yyyy-LL-dd')
    : DateTime.now().setZone('America/Denver').toFormat('yyyy-LL-dd');
  return swipeDate === today;
}


// Optimized query with better filtering

async function fetchNewEvents(since, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    let pool;
    try {
      pool = await denver.getPool();
    } catch (err) {
      console.error(`❌ Attempt ${attempt}: Failed to get Denver pool:`, err);
      if (attempt === maxRetries) return [];
      await new Promise(resolve => setTimeout(resolve, 2000 * attempt));
      continue;
    }

    if (!pool) {
      console.warn(`⚠️ Attempt ${attempt}: No pool available`);
      if (attempt === maxRetries) return [];
      await new Promise(resolve => setTimeout(resolve, 2000 * attempt));
      continue;
    }

    const req = pool.request();
    req.input('since', sql.DateTime2, since);

    // Optimized query - simplified and more efficient
    const queryText = `
      SELECT 
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        CONVERT(VARCHAR(10), DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC), 23) AS Dateonly,
        CONVERT(VARCHAR(8), DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC), 108) AS Swipe_Time,
        t1.ObjectName1,
        CASE 
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM ACVSUJournal_00010029.dbo.ACVSUJournalLog t1
      LEFT JOIN ACVSCore.Access.Personnel t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN ACVSCore.Access.PersonnelType t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred t5a 
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred t5d 
        ON t1.XmlGUID = t5d.GUID AND t5d.Name = 'Direction'
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxml t_xml 
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE t1.MessageType = 'CardAdmitted'
        AND t1.ObjectName2 LIKE '%HQ%'
        AND t1.MessageUTC >= DATEADD(MINUTE, t1.MessageLocaleOffset, @since)
      ORDER BY t1.MessageUTC ASC
    `;

    const t0 = Date.now();
    try {
      const { recordset } = await safeQueryWithTimeout(req, queryText, 60000); // 60s timeout
      const took = Date.now() - t0;
      // console.log(`[DENVER] fetchNewEvents: got ${recordset.length} rows in ${took}ms`);
      return recordset || [];
    } catch (err) {
      console.error(`❌ Attempt ${attempt}: fetchNewEvents query error:`, err.message);
      
      // Reset pool on timeout
      if (err.message.includes('timed out') || err.code === 'ECANCEL') {
        try {
          if (pool && typeof pool.close === 'function') {
            await pool.close();
          }
        } catch (e) { /* ignore */ }
        denverPoolPromise = null;
      }

      if (attempt === maxRetries) {
        console.error('❌ All retry attempts failed for fetchNewEvents');
        return [];
      }
      
      // Wait before retry (exponential backoff)
      await new Promise(resolve => setTimeout(resolve, 3000 * attempt));
    }
  }
  return [];
}

async function fetchEventsWindowUntil(until) {
  let pool;
  try {
    pool = await denver.poolPromise;
  } catch (err) {
    console.error('❌ Failed to get Denver pool in fetchEventsWindowUntil():', err);
    return [];
  }
  if (!pool) return [];

  try {
    const req = pool.request();
    req.input('until', sql.DateTime2, until);

    const { recordset } = await req.query(`
      WITH CombinedQuery AS (
        SELECT
          DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
          t1.ObjectName1,
          CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR) END AS EmployeeID,
          t1.ObjectIdentity1 AS PersonGUID,
          t3.Name AS PersonnelType,
          COALESCE(TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'), sc.value) AS CardNumber,
          t5a.value AS AdmitCode,
          t5d.value AS Direction,
          t1.ObjectName2 AS Door
        FROM ACVSUJournal_00010029.dbo.ACVSUJournalLog t1
        LEFT JOIN ACVSCore.Access.Personnel t2 ON t1.ObjectIdentity1 = t2.GUID
        LEFT JOIN ACVSCore.Access.PersonnelType t3 ON t2.PersonnelTypeId  = t3.ObjectID
        LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred t5a ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
        LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred t5d ON t1.XmlGUID = t5d.GUID AND t5d.Name = 'Direction'
        LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxml t_xml ON t1.XmlGUID = t_xml.GUID
        LEFT JOIN (
          SELECT GUID, value
          FROM ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred
          WHERE Name IN ('Card','CHUID')
        ) sc ON t1.XmlGUID = sc.GUID
        WHERE
          t1.MessageType = 'CardAdmitted'
          AND t1.ObjectName2 LIKE '%HQ%'
          AND DATEADD(MINUTE,-1 * t1.MessageLocaleOffset, t1.MessageUTC) <= @until
          AND DATEADD(HOUR, -24, @until) < DATEADD(MINUTE,-1 * t1.MessageLocaleOffset, t1.MessageUTC)
      )
      SELECT
        LocaleMessageTime,
        CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
        CONVERT(VARCHAR(8) , LocaleMessageTime, 108) AS Swipe_Time,
        EmployeeID, PersonGUID, ObjectName1, PersonnelType,
        CardNumber, AdmitCode, Direction, Door
      FROM CombinedQuery
      ORDER BY LocaleMessageTime ASC;
    `);
    return recordset || [];
  } catch (err) {
    console.error('❌ fetchEventsWindowUntil query error — resetting Denver poolPromise:', err);
    try { denver.poolPromise = null; } catch (e) { /* ignore */ }
    return [];
  }
}






// --- ONLY endpoint: Snapshot endpoint for Denver with date + time ---
// GET /api/occupancy-at-time-denver?date=YYYY-MM-DD&time=HH:MM[:SS]
exports.getDenverSnapshotAtDateTime = async (req, res) => {
  try {
    const { date, time } = req.query;
    if (!date || !time) {
      return res.status(400).json({
        error: 'missing query params: expected ?date=YYYY-MM-DD&time=HH:MM[:SS]'
      });
    }

    // Validate date
    const dateMatch = /^(\d{4})-(\d{2})-(\d{2})$/.exec(date);
    if (!dateMatch) return res.status(400).json({ error: 'invalid "date" format; expected YYYY-MM-DD' });

    // Validate time
    const timeMatch = /^([0-1]\d|2[0-3]):([0-5]\d)(?::([0-5]\d))?$/.exec(time);
    if (!timeMatch) return res.status(400).json({ error: 'invalid "time" format; expected HH:MM or HH:MM:SS' });

    const year   = Number(dateMatch[1]);
    const month  = Number(dateMatch[2]);
    const day    = Number(dateMatch[3]);
    const hour   = Number(timeMatch[1]);
    const minute = Number(timeMatch[2]);
    const second = timeMatch[3] ? Number(timeMatch[3]) : 0;

    // Build Denver-local datetime
    const atDt = DateTime.fromObject(
      { year, month, day, hour, minute, second, millisecond: 0 },
      { zone: 'America/Denver' }
    );

    if (!atDt.isValid) {
      return res.status(400).json({ error: 'invalid date+time combination' });
    }

    const untilJsDate = atDt.toJSDate();

    // fetch with 24h window ending at requested datetime
    const events = await fetchEventsWindowUntil(untilJsDate);

    // filter only events on that Denver local date
    const targetDate = atDt.toFormat('yyyy-LL-dd');
    const filtered = events.filter(e => e.Dateonly === targetDate);

    // build occupancy payload (pass atDt so date checks use it)
    const payload = buildOccupancyForToday(filtered, [], atDt);

    return res.json(payload);
  } catch (err) {
    console.error('getDenverSnapshotAtDateTime error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};

// helper: computeVisitedToday using optional reference date
// Counts any swipe (In or Out) on the same Denver date and up to referenceDt (if provided).
function computeVisitedToday(allEvents, referenceDt = null) {
  const seen = new Map(); // key -> PersonnelType

  allEvents.forEach(evt => {
    // Must be same Denver date as referenceDt (or today when referenceDt null)
    if (!isSameDenverDate(evt.Dateonly, referenceDt)) return;

    // If referenceDt provided, ensure the event's local datetime <= referenceDt
    if (referenceDt) {
      // Prefer Dateonly + Swipe_Time (DB local fields)
      if (!evt.Dateonly || !evt.Swipe_Time) return;
      const evtDt = DateTime.fromISO(`${evt.Dateonly}T${evt.Swipe_Time}`, { zone: 'America/Denver' });
      if (!evtDt.isValid) return;
      if (evtDt > referenceDt.setZone('America/Denver')) return;
    }

    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    if (!key) return;
    if (!seen.has(key)) {
      seen.set(key, evt.PersonnelType);
    }
  });

  let employees = 0, contractors = 0;
  seen.forEach(type => {
    if (type === 'Employee' || type === 'Terminated Personnel') employees++;
    else contractors++;
  });

  return { total: seen.size, employees, contractors };
}


// Build occupancy for "today" where "today" can be the real today OR the date represented by atDt (Denver)
function buildOccupancyForToday(allEvents, freshEvents = [], atDt = null) {
  // reference DateTime in Denver (null => live now)
  const refDt = atDt ? atDt.setZone('America/Denver') : null;

  // canonical person key
  const personKey = (evt) => evt.PersonGUID || evt.EmployeeID || evt.CardNumber;

  // derive a Luxon DateTime in America/Denver for the event.
  // Prefer Dateonly + Swipe_Time (these are the DB's local values). Fallback to parsing LocaleMessageTime.
  const eventDtFor = (evt) => {
    if (evt && evt.Dateonly && evt.Swipe_Time) {
      const iso = `${evt.Dateonly}T${evt.Swipe_Time}`; // e.g. "2025-09-17T00:26:55"
      const dt = DateTime.fromISO(iso, { zone: 'America/Denver' });
      if (dt.isValid) return dt;
    }
    if (evt && evt.LocaleMessageTime) {
      // Last resort: parse LocaleMessageTime as ISO and convert to Denver.
      // NOTE: this is fallback only — avoid relying on it for correctness.
      const dt = DateTime.fromISO(evt.LocaleMessageTime, { zone: 'utc' }).setZone('America/Denver');
      if (dt.isValid) return dt;
    }
    return null;
  };

  // ---------- PREFILTER: only keep events on same Denver date and (if refDt) that occurred <= refDt
  const relevantEvents = allEvents.filter(evt => {
    if (!isSameDenverDate(evt.Dateonly, refDt)) return false;
    if (!refDt) return true;
    const eDt = eventDtFor(evt);
    if (!eDt) return false; // cannot compare -> discard
    return eDt <= refDt;
  });

  // ---------- A) Evict “Out of office” using the last event per person (by eventDt)
  const lastByPerson = new Map(); // personKey -> evt
  const lastDtByPerson = new Map(); // personKey -> DateTime

  relevantEvents.forEach(evt => {
    const key = personKey(evt);
    const eDt = eventDtFor(evt);
    if (!eDt) return; // skip malformed
    const prevDt = lastDtByPerson.get(key);
    if (!prevDt || eDt > prevDt) {
      lastDtByPerson.set(key, eDt);
      lastByPerson.set(key, evt);
    }
  });

  const evicted = new Set();
  lastByPerson.forEach(evt => {
    if (
      evt.Direction === 'OutDirection'
      && mapDoorToFloor(evt.Door, evt.Direction) === 'Out of office'
    ) {
      evicted.add(personKey(evt));
    }
  });

  // active events are relevantEvents minus evicted persons
  const activeEvents = relevantEvents.filter(evt => !evicted.has(personKey(evt)));

  // ---------- 1) Live occupancy dedupe by last InDirection (use eventDt ordering)
  const todayIn = activeEvents.filter(e => e.Direction === 'InDirection');

  const latestByPerson = new Map();
  const latestDtByPerson = new Map();
  todayIn.forEach(e => {
    const key = personKey(e);
    const eDt = eventDtFor(e);
    if (!eDt) return;
    const prev = latestDtByPerson.get(key);
    if (!prev || eDt > prev) {
      latestDtByPerson.set(key, eDt);
      latestByPerson.set(key, e);
    }
  });
  const finalList = Array.from(latestByPerson.values());
  

  // ---------- 2) Floor breakdown & personnel counts (live)
  let employees = 0, contractors = 0;
  const floorMap = {};
  finalList.forEach(e => {
    const fl = mapDoorToFloor(e.Door, e.Direction);
    floorMap[fl] = floorMap[fl] || [];
    floorMap[fl].push(e);
    if (e.PersonnelType === 'Employee' || e.PersonnelType === 'Terminated Personnel') employees++;
    else if (e.PersonnelType) contractors++;
  });

  const floorBreakdown = Object.entries(floorMap).map(([floor, occ]) => {
    let empCount = 0, contractorCount = 0, tempBadgeCount = 0, otherCount = 0;
    occ.forEach(e => {
      switch (e.PersonnelType) {
        case 'Employee':
        case 'Terminated Personnel':
          empCount++; break;
        case 'Contractor':
        case 'Terminated Contractor':
          contractorCount++; break;
        case 'Temp Badge':
          tempBadgeCount++; break;
        default:
          otherCount++;
      }
    });
    return {
      floor,
      total: occ.length,
      employees: empCount,
      contractors: contractorCount,
      tempBadge: tempBadgeCount,
      others: otherCount,
      occupants: occ
    };
  });

  // ---------- 3) Personnel breakdown
  const personnelBreakdown = Array.from(
    finalList.reduce((m, e) => {
      m.set(e.PersonnelType, (m.get(e.PersonnelType) || 0) + 1);
      return m;
    }, new Map()),
    ([personnelType, count]) => ({ personnelType, count })
  );

  // ---------- 4) Swipe stats (fresh only) — count only up to refDt
  const countUpToRef = (evt) => {
    if (!isSameDenverDate(evt.Dateonly, refDt)) return false;
    if (!refDt) return true;
    const eDt = eventDtFor(evt);
    if (!eDt) return false;
    return eDt <= refDt;
  };
  const totalInSwipes = (freshEvents || []).filter(e => e.Direction === 'InDirection' && countUpToRef(e)).length;
  const totalOutSwipes = (freshEvents || []).filter(e => e.Direction === 'OutDirection' && countUpToRef(e)).length;

  // ---------- 5) Floor In/Out summary (strict doors only)
  const validEvents = relevantEvents.filter(evt => {
    const doorNoTime = stripTimeSuffix(evt.Door.trim());
    const key = normalizeKey(doorNoTime, (evt.Direction || '').trim());
    return normalizedMonitoredKeys.has(key);
  });

  // Dedupe per person+floor+direction using eventDt ordering
  const deduped = new Map(); // mapKey -> evt
  validEvents.forEach(evt => {
    const rawNoTime = stripTimeSuffix(evt.Door);
    const m = rawNoTime.match(/HQ\.\s*(\d{1,2})\b/);
    const floor = m ? `Floor ${m[1]}` : 'Unknown Floor';

    const mapKey = `${personKey(evt)}___${floor}___${evt.Direction}`;
    const prev = deduped.get(mapKey);
    const nowDt = eventDtFor(evt);
    if (!nowDt) return;
    if (!prev) {
      deduped.set(mapKey, evt);
    } else {
      const prevDt = eventDtFor(prev);
      if (!prevDt || nowDt > prevDt) deduped.set(mapKey, evt);
    }
  });

  // Aggregate in/out per floor
  const floorMapIO = {};
  for (const evt of deduped.values()) {
    const rawNoTime = stripTimeSuffix(evt.Door);
    const m = rawNoTime.match(/HQ\.\s*(\d{1,2})\b/);
    const floor = m ? `Floor ${m[1]}` : 'Unknown Floor';

    if (!floorMapIO[floor]) floorMapIO[floor] = { inSwipes: 0, outSwipes: 0, inSet: new Set(), outSet: new Set() };
    const id = personKey(evt);
    if (evt.Direction === 'InDirection') {
      floorMapIO[floor].inSwipes++;
      floorMapIO[floor].inSet.add(id);
    } else {
      floorMapIO[floor].outSwipes++;
      floorMapIO[floor].outSet.add(id);
    }
  }

  const floorInOutSummary = Object.entries(floorMapIO).map(([floor, stats]) => {
    const inOnly = [...stats.inSet].filter(id => !stats.outSet.has(id));
    return {
      floor,
      inSwipes: stats.inSwipes,
      outSwipes: stats.outSwipes,
      inOnlyCount: inOnly.length,
      inOnlyPersons: inOnly
    };
  });

  // ---------- 6) Visited today breakdown (reuse computeVisitedToday; it already supports referenceDt)
  // const visited = computeVisitedToday(allEvents, refDt);
  const visited = computeVisitedToday(relevantEvents, refDt);

const visitedOccupants = relevantEvents
  .filter(e => eventDtFor(e) && eventDtFor(e) <= refDt)
  .reduce((map, e) => {
    const key = personKey(e);
    if (!map.has(key)) map.set(key, e); // keep first event for identity
    return map;
  }, new Map());

  // Build final payload
  const asOfLocal = refDt ? refDt.toISO() : DateTime.now().setZone('America/Denver').toISO();
  const asOfUTC = refDt ? refDt.toUTC().toISO() : new Date().toISOString();

  return {
    asOfLocal,
    asOfUTC,
    currentCount: finalList.length,
    floorBreakdown,
    personnelSummary: { employees, contractors },
    personnelBreakdown,
    totalVisitedToday: visited.total,
    visitedToday: {
      employees: visited.employees,
      contractors: visited.contractors,
      total: visited.total
    },
     visitedOccupants: Array.from(visitedOccupants.values()),  // 👈 new full list
    swipeStats: { totalInSwipes, totalOutSwipes },
    floorInOutSummary
  };
}


const EventEmitter = require('events');
const updates = new EventEmitter();
let latestSnapshot = null;
let denverBackgroundStarted = false;

function startDenverBackgroundWorker() {
  if (denverBackgroundStarted) return;
  denverBackgroundStarted = true;

  (async () => {
    console.log('[DENVER-BG] starting background poller');
    let lastSeen = new Date(Date.now() - 60 * 1000); // small lookback to avoid gaps
    const eventsBuffer = [];
    let consecutiveErrors = 0;

    while (true) {
      try {
        const fresh = await fetchNewEvents(lastSeen);
        if (fresh && fresh.length) {
          const lastEvt = fresh[fresh.length - 1];
          lastSeen = lastEvt && lastEvt.LocaleMessageTime ? new Date(lastEvt.LocaleMessageTime) : new Date();
          eventsBuffer.push(...fresh);
          // prune buffer to today's Denver date
          const todayDenver = DateTime.now().setZone('America/Denver').toISODate();
          for (let i = eventsBuffer.length - 1; i >= 0; i--) {
            if (!eventsBuffer[i].Dateonly || eventsBuffer[i].Dateonly !== todayDenver) eventsBuffer.splice(i, 1);
          }
        }

        // Build snapshot using your existing builder
        const payload = buildOccupancyForToday(eventsBuffer, fresh || [], null);
        latestSnapshot = payload;
        updates.emit('update', payload);

        consecutiveErrors = 0;
      } catch (err) {
        consecutiveErrors++;
        console.error('[DENVER-BG] polling error:', err);
        // Reset the pool so the next cycle will re-create it
        try { denver.poolPromise = null; } catch (e) { /* ignore */ }
        if (consecutiveErrors > 3) {
          await new Promise(r => setTimeout(r, 5000));
        }
      }

      await new Promise(r => setTimeout(r, 1000)); // 1s cadence (tune if needed)
    }
  })().catch(err => {
    console.error('[DENVER-BG] background worker crashed:', err);
    denverBackgroundStarted = false;
  });
}

// Live SSE endpoint with heartbeat + non-overlap + logging
exports.getDenverLiveOccupancy = async (req, res) => {
  try {
    // ensure poolPromise at least initialised (does not throw)
    const poolMaybe = await denver.poolPromise;
    if (!poolMaybe) {
      console.warn('⚠️ Denver poolPromise resolved to null — DB likely unavailable');
    }
  } catch (err) {
    console.error('❌ Failed to initialize Denver pool in SSE endpoint:', err);
    // still continue but logs will show missing DB
  }

  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive'
  });
  res.write('\n');

  // heartbeat comment every 15s so clients do not time out
  const heartbeat = setInterval(() => {
    try {
      // SSE comment keeps connection alive but is ignored by EventSource data parser
      res.write(': heartbeat\n\n');
      if (typeof res.flush === 'function') res.flush();
    } catch (err) {
      console.warn('⚠️ Failed to send heartbeat (connection likely closed):', err);
    }
  }, 15_000);

  let lastSeen = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const events = [];
  let pushRunning = false;
  let consecutiveDbErrors = 0;

  const push = async () => {
    if (pushRunning) {
      // console.debug('[DENVER] push already running — skipping this tick');
      return;
    }
    pushRunning = true;
    try {
      const fresh = await fetchNewEvents(lastSeen);

      if (fresh.length) {
        // update lastSeen to the latest event's LocaleMessageTime (string or Date)
        const lastEvt = fresh[fresh.length - 1];
        if (lastEvt && lastEvt.LocaleMessageTime) {
          lastSeen = new Date(lastEvt.LocaleMessageTime);
        } else {
          lastSeen = new Date();
        }
        events.push(...fresh);
        // console.log(`[DENVER] pushed ${fresh.length} new events — events buffer now ${events.length}`);
      }

      // prune events not on today's Denver date (keep memory small)
      const todayDenver = DateTime.now().setZone('America/Denver').toISODate();
      for (let i = events.length - 1; i >= 0; i--) {
        const ts = events[i].Dateonly || (events[i].LocaleMessageTime ? DateTime.fromISO(events[i].LocaleMessageTime, { zone: 'utc' }).setZone('America/Denver').toISODate() : null);
        if (!ts || ts !== todayDenver) events.splice(i, 1);
      }

      // build payload
      let payload;
      try {
        payload = buildOccupancyForToday(events, fresh, null); // live mode (null => uses now)
      } catch (err) {
        console.error('[DENVER] Error building payload:', err);
        payload = {
          asOfLocal: DateTime.now().setZone('America/Denver').toISO(),
          asOfUTC: new Date().toISOString(),
          currentCount: 0,
          floorBreakdown: [],
          personnelSummary: { employees: 0, contractors: 0 },
          personnelBreakdown: [],
          totalVisitedToday: 0,
          visitedToday: { employees: 0, contractors: 0, total: 0 },
          swipeStats: { totalInSwipes: 0, totalOutSwipes: 0 },
          floorInOutSummary: []
        };
      }

      // write SSE event
      const sid = Date.now();
      try {
        res.write(`id: ${sid}\n`);
        res.write(`data: ${JSON.stringify(payload)}\n\n`);
        if (typeof res.flush === 'function') res.flush();
        // console.debug(`[DENVER] wrote payload id=${sid}`);
      } catch (err) {
        console.warn('[DENVER] Failed to write SSE payload (connection likely closed):', err);
      }

      consecutiveDbErrors = 0;
    } catch (err) {
      consecutiveDbErrors++;
      console.error('[DENVER] push top-level error:', err);
      // back off a bit if DB failing repeatedly
      if (consecutiveDbErrors > 3) {
        console.warn(`[DENVER] ${consecutiveDbErrors} consecutive DB errors — sleeping 5s before next try`);
        await new Promise(r => setTimeout(r, 5000));
      }
    } finally {
      pushRunning = false;
    }
  };

  await push();
  const timer = setInterval(push, 1000); // 1s interval (user requested)

  req.on('close', () => {
    clearInterval(timer);
    clearInterval(heartbeat);
    console.log('[DENVER] SSE client disconnected, cleared timers');
  });
};



