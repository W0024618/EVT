D:\Email Automation\frontend_1\.env


REACT_APP_API_BASE=http://10.199.22.57:5000
REACT_APP_API_KEY=1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed
REACT_APP_API_KEY_DISPLAY=**MASKED**
PORT=3010







D:\Email Automation\frontend_1\src\EmailDashboard.js

import React, { useState, useEffect } from 'react';
import ResizableCard from './ResizableCard';
import './App.css';

function EmailDashboard() {
  const [sentCount, setSentCount] = useState(0);
  const [emails, setEmails] = useState([]);
  const [exceptions, setExceptions] = useState([]);
  const [skip, setSkip] = useState(0);
  const [emailCount, setEmailCount] = useState(0);
  const [fetchError, setFetchError] = useState(null);
  const [loading, setLoading] = useState(true);
  const [nextLoading, setNextLoading] = useState(false);
  const [prevLoading, setPrevLoading] = useState(false);
  const [refreshLoading, setRefreshLoading] = useState(false);
  const [receivedCount, setReceivedCount] = useState(0);

  const fetchInboxEmails = async (isRefresh = false) => {
    if (!isRefresh) setLoading(true);
    try {
      const response = await fetch(`http://localhost:5000/email/inbox?top=10&skip=${skip}&folder=inbox&api_key=${process.env.REACT_APP_API_KEY}`, {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
      });
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      }
      const data = await response.json();
      console.log('Raw inbox response:', data);
      const emailData = Array.isArray(data) ? data : data.emails || [];
      if (!Array.isArray(emailData)) {
        throw new Error('Response is not an array or does not contain an emails array');
      }
      const transformedEmails = emailData.map(email => ({
        ...email,
        from: Array.isArray(email.from) ? email.from.join(',') : email.from || '',
        to: Array.isArray(email.to) ? email.to.join(',') : email.to || '',
        cc: Array.isArray(email.cc) ? email.cc.join(',') : email.cc || '',
        bcc: Array.isArray(email.bcc) ? email.bcc.join(',') : email.bcc || ''
      }));
      console.log('Transformed emails:', transformedEmails);
      setEmails(transformedEmails);
      setEmailCount(transformedEmails.length);
      setFetchError(null);
    } catch (error) {
      console.error('Error fetching inbox emails:', error);
      setEmails([]);
      setEmailCount(0);
      setFetchError(error.message);
    } finally {
      setLoading(false);
      setNextLoading(false);
      setPrevLoading(false);
      setRefreshLoading(false);
    }
  };

  useEffect(() => {
    const fetchResponsesSent = async () => {
      try {
        const response = await fetch(`/email/responses-sent?api_key=${process.env.REACT_APP_API_KEY}`);
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        const data = await response.json();
        setSentCount(data.sent_count || 0);
      } catch (error) {
        console.error('Error fetching responses sent:', error);
      }
    };

    const fetchResponsesReceived = async () => {
      try {
        const response = await fetch(`/email/responses-received?api_key=${process.env.REACT_APP_API_KEY}`);
        const data = await response.json();
        setReceivedCount(data.sent_count || 0);
      } catch (error) {
        console.error('Error fetching responses received:', error);
      }
    };

    const fetchExceptions = async () => {
      try {
        const response = await fetch(`/email/exceptions?api_key=${process.env.REACT_APP_API_KEY}`);
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        const data = await response.json();
        setExceptions(data.exceptions.map(item => item.email) || []);
      } catch (error) {
        console.error('Error fetching exceptions:', error);
      }
    };

    fetchResponsesSent();
    fetchResponsesReceived();
    fetchInboxEmails();
    fetchExceptions();

    const interval = setInterval(() => {
      fetchResponsesSent();
      fetchExceptions();
    }, 30000);

    return () => clearInterval(interval);
  }, [skip]);

  const handleNext = () => {
    setNextLoading(true);
    setSkip(prev => prev + 10);
  };

  const handlePrevious = () => {
    setPrevLoading(true);
    setSkip(prev => Math.max(0, prev - 10));
  };

  const handleRefresh = () => {
    setRefreshLoading(true);
    fetchInboxEmails(true);
  };

  const renderLoadingAnimation = (type) => (
    <div style={{
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      background: 'rgba(0, 0, 0, 0.7)',
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center',
      justifyContent: 'center',
      color: '#fff',
      zIndex: 1000
    }}>
      <div style={{
        width: '50px',
        height: '50px',
        border: '5px solid #fff',
        borderTop: `5px solid ${type === 'next' ? '#3498db' : type === 'prev' ? '#2ecc71' : type === 'refresh' ? '#2ecc71' : '#2ecc71'}`,
        borderRadius: '50%',
        animation: 'spin 1s linear infinite'
      }} />
      <div style={{
        width: '60%',
        height: '10px',
        background: '#3a3a3a',
        borderRadius: '5px',
        overflow: 'hidden',
        marginTop: '15px'
      }}>
        <div style={{
          width: '100%',
          height: '100%',
          background: `linear-gradient(to right, ${type === 'next' ? '#2ecc71, #3498db' : type === 'prev' ? '#2ecc71, #3498db' : type === 'refresh' ? '#2ecc71, #3498db' : '#2ecc71, #3498db'})`,
          animation: 'slide 2s infinite'
        }} />
      </div>
      <p style={{ marginTop: '15px' }}>
        {type === 'next' ? 'Loading Next 10 Emails...' : type === 'prev' ? 'Loading Previous 10 Emails...' : type === 'refresh' ? 'Refreshing Emails...' : 'Loading Emails...'}
      </p>
    </div>
  );

  return (
    <div style={{ height: '1080px', width: '1920px', background: '#000', marginRight: '-20px' }}>
      <header className="table-header">
        <h1 className="text-3xl font-bold neon-text">EMAIL ANALYSIS DASHBOARD</h1>
      </header>
      <div
        className="dashboard-grid"
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(10, 1fr)',
          gridAutoRows: 'auto',
          gap: '15px',
          marginBottom: '-20px',
          marginRight: '-85px',
          position: 'relative'
        }}
      >
        <ResizableCard
          id="card1"
          label="Total Responses Received"
          type="Summary"
          chartData={{ value: receivedCount }}
          style={{ gridColumn: 'span 2.5', gridRow: '1', width: '100%', marginTop: '-5px' }}
        />
        <ResizableCard
          id="card2"
          label="Total Responses Sent"
          type="Summary"
          chartData={{ value: sentCount }}
          style={{ gridColumn: 'span 2.5', gridRow: '1', width: '100%', marginTop: '-5px'  }}
        />
        <ResizableCard
          id="card3"
          label=""
          type="Summary"
          chartData={{ value: '' }}
          style={{ gridColumn: 'span 2.5', gridRow: '1', width: '100%', marginTop: '-5px'  }}
        />
        <ResizableCard
          id="card4"
          label=""
          type="Summary"
          chartData={{ value: '' }}
          style={{ gridColumn: 'span 2.5', gridRow: '1', width: '100%', marginTop: '-5px'  }}
        />
        <ResizableCard
          id="card5"
          label="Emails"
          type="EmailList"
          chartData={{ emails }}
          onEmailRefresh={handleRefresh}
          style={{ gridColumn: 'span 3', gridRow: '2', position: 'relative' }}
        >
          {loading && renderLoadingAnimation('initial')}
          {nextLoading && renderLoadingAnimation('next')}
          {prevLoading && renderLoadingAnimation('prev')}
          {refreshLoading && renderLoadingAnimation('refresh')}
          {!loading && !nextLoading && !prevLoading && !refreshLoading && fetchError ? (
            <p style={{ color: '#ff0707ff', padding: '10px' }}>Error: {fetchError}</p>
          ) : !loading && !nextLoading && !prevLoading && !refreshLoading && (
            <div style={{ marginTop: '10px', display: 'flex', justifyContent: 'space-between' }}>
              <button
                onClick={handlePrevious}
                disabled={skip === 0 || loading || nextLoading || prevLoading || refreshLoading}
                style={{
                  padding: '5px 10px',
                  background: skip === 0 ? '#555' : '#2ecc71',
                  color: '#fff',
                  border: 'none',
                  borderRadius: '4px',
                  cursor: skip === 0 || loading || nextLoading || prevLoading || refreshLoading ? 'not-allowed' : 'pointer',
                  fontSize: '0.9rem'
                }}
              >
                Previous 10
              </button>
              <button
                onClick={handleNext}
                disabled={emailCount < 10 || loading || nextLoading || prevLoading || refreshLoading}
                style={{
                  padding: '5px 10px',
                  background: emailCount < 10 ? '#555' : '#2ecc71',
                  color: '#fff',
                  border: 'none',
                  borderRadius: '4px',
                  cursor: emailCount < 10 || loading || nextLoading || prevLoading || refreshLoading ? 'not-allowed' : 'pointer',
                  fontSize: '0.9rem'
                }}
              >
                Next 10
              </button>
            </div>
          )}
        </ResizableCard>
        <ResizableCard
          id="card6"
          label="Exception List"
          type="ExceptionList"
          chartData={{ exceptions, setExceptions }}
          style={{ gridColumn: 'span 3', gridRow: '2', marginLeft: '-80px' }}
        />
      </div>
      <style>
        {`
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
          @keyframes slide {
            0% { transform: translateX(-100%); }
            50% { transform: translateX(0); }
            100% { transform: translateX(100%); }
          }
        `}
      </style>
    </div>
  );
}

export default EmailDashboard;








D:\Email Automation\frontend_1\src\EmailTable.js


import React, { useState, useEffect } from 'react';
import './App.css';

const alarmOptions = [
  'clearance',
  'lost',
  'wrong pin',
  'expired',
  'disabled',
  'clearance_non_employee',
  'lost_non_employee',
  'wrong pin_non_employee',
  'expired_non_employee',
  'disabled_non_employee',
  'held_open',
  'forced_open',
  'fire_event',
];

function EmailTable({ dateFrom, dateTo }) {
  const [emailLogs, setEmailLogs] = useState([]);
  const [exceptions, setExceptions] = useState([]);
  const [templatesMap, setTemplatesMap] = useState({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [selectedAlarm, setSelectedAlarm] = useState('All');
  const [employeeIdFilter, setEmployeeIdFilter] = useState('');
  const [employeeNameFilter, setEmployeeNameFilter] = useState('');

  useEffect(() => {
    async function fetchData() {
      setLoading(true);
      setError(null);
      
      try {
        // Fetch exceptions first
        const exceptionsResponse = await fetch(`/email/exceptions?api_key=${process.env.REACT_APP_API_KEY}`);
        if (!exceptionsResponse.ok) {
          throw new Error('Failed to fetch exceptions');
        }
        const exceptionsData = await exceptionsResponse.json();
        
        // Handle exceptions data structure - extract just the email addresses
        let exceptionEmails = [];
        if (Array.isArray(exceptionsData)) {
          exceptionEmails = exceptionsData.map(item => item.email || item).filter(email => email);
        } else if (exceptionsData.exceptions) {
          exceptionEmails = exceptionsData.exceptions.map(item => item.email || item).filter(email => email);
        }
        
        setExceptions(exceptionEmails);

        // Fetch email logs
        const logsResponse = await fetch(`/get/email-logs?api_key=${process.env.REACT_APP_API_KEY}`);
        if (!logsResponse.ok) {
          throw new Error('Failed to fetch email logs');
        }
        const logsDataRaw = await logsResponse.json();
        
        // Handle if logs API returns an object instead of array
        const logsData = Array.isArray(logsDataRaw) 
          ? logsDataRaw 
          : (logsDataRaw.logs || logsDataRaw.data || []);
        
        setEmailLogs(logsData);
        
      } catch (err) {
        console.error('Error fetching data:', err);
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }

    fetchData();
  }, []); // Removed dateFrom, dateTo dependencies since API doesn't use them

  const formatDateTime = (dateTimeString) => {
    if (!dateTimeString) return { date: 'N/A', time: 'N/A' };
    
    try {
      const dateObj = new Date(dateTimeString);
      const date = dateObj.toLocaleDateString();
      const time = dateObj.toLocaleTimeString();
      return { date, time };
    } catch (error) {
      return { date: 'N/A', time: 'N/A' };
    }
  };

  // Filter logs based on selected alarm, employee ID, and employee name
  const filteredLogs = emailLogs.filter(log => {
    const alarmMatch = selectedAlarm === 'All' || log.alert_type?.toLowerCase() === selectedAlarm.toLowerCase();
    const employeeIdMatch = !employeeIdFilter || log.employee_id?.toString().toLowerCase().includes(employeeIdFilter.toLowerCase());
    const employeeNameMatch = !employeeNameFilter || log.employee_name?.toLowerCase().includes(employeeNameFilter.toLowerCase());
    return alarmMatch && employeeIdMatch && employeeNameMatch;
  });

  if (loading) {
    return (
      <div className="table-fixed">
        <header className="table-header" style={{ display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: '10px', padding: '10px' }}>
          <h1 className="text-3xl font-bold neon-text">EMAIL LOGS</h1>
        </header>
        <div style={{ textAlign: 'center', padding: '20px' }}>
          Loading email logs...
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="table-fixed">
        <header className="table-header" style={{ display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: '10px', padding: '10px' }}>
          <h1 className="text-3xl font-bold neon-text">EMAIL LOGS</h1>
        </header>
        <div style={{ textAlign: 'center', padding: '20px', color: 'red' }}>
          Error: {error}
        </div>
      </div>
    );
  }

  return (
    <div className="table-fixed">
      <header className="table-header" style={{ display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: '10px', padding: '10px' }}>
        <h1 className="text-3xl font-bold neon-text">EMAIL LOGS</h1>
        <div style={{ marginLeft: 'auto', fontSize: '0.9rem', color: '#00ff9d' }}>
          Total Records: {filteredLogs.length}
        </div>
      </header>
      
      <div className="table-wrapper">
        <table className="custom-table" style={{ tableLayout: 'auto', width: '100%' }}>
          <thead>
            <tr>
              <th style={{ padding: '12px 8px', textAlign: 'center', height: '50px' }}>
                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '5px' }}>
                  <span>ALARM</span>
                  <select
                    value={selectedAlarm}
                    onChange={e => setSelectedAlarm(e.target.value)}
                    style={{
                      backgroundColor: '#3a3a3a',
                      border: '1px solid #555',
                      borderRadius: '4px',
                      color: '#00ff9d',
                      padding: '2px 4px',
                      fontSize: '0.8rem',
                      fontWeight: '600',
                      width: '100px'
                    }}
                  >
                    <option value="All">All</option>
                    {alarmOptions.map(alarm => (
                      <option key={alarm} value={alarm}>
                        {alarm.toUpperCase().replace(/_/g, ' ')}
                      </option>
                    ))}
                  </select>
                </div>
              </th>
              <th style={{ padding: '12px 8px', textAlign: 'center', height: '50px' }}>DATE</th>
              <th style={{ padding: '12px 8px', textAlign: 'center', height: '50px' }}>TIME</th>
              <th style={{ padding: '12px 8px', textAlign: 'center', height: '50px' }}>
                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '5px' }}>
                  <span>EMPLOYEE ID</span>
                  <input
                    type="text"
                    placeholder="Type to filter"
                    value={employeeIdFilter}
                    onChange={e => setEmployeeIdFilter(e.target.value)}
                    style={{
                      backgroundColor: '#3a3a3a',
                      border: '1px solid #555',
                      borderRadius: '4px',
                      color: '#00ff9d',
                      padding: '2px 4px',
                      fontSize: '0.8rem',
                      width: '100px',
                      textAlign: 'center'
                    }}
                  />
                </div>
              </th>
              <th style={{ padding: '12px 8px', textAlign: 'center', height: '50px' }}>
                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '5px' }}>
                  <span>EMPLOYEE NAME</span>
                  <input
                    type="text"
                    placeholder="Type to filter"
                    value={employeeNameFilter}
                    onChange={e => setEmployeeNameFilter(e.target.value)}
                    style={{
                      backgroundColor: '#3a3a3a',
                      border: '1px solid #555',
                      borderRadius: '4px',
                      color: '#00ff9d',
                      padding: '2px 4px',
                      fontSize: '0.8rem',
                      width: '120px',
                      textAlign: 'center'
                    }}
                  />
                </div>
              </th>
              <th style={{ padding: '12px 8px', textAlign: 'center', height: '50px' }}>ACTION TAKEN</th>
              {/* <th style={{ padding: '12px 8px', textAlign: 'center', height: '50px' }}>EXCEPTION MAIL</th> */}
            </tr>
          </thead>
          <tbody>
            {filteredLogs.length === 0 ? (
              <tr>
                <td colSpan="7" style={{ textAlign: 'center', padding: '15px', height: '60px' }}>
                  No records available for the selected filters.
                </td>
              </tr>
            ) : (
              filteredLogs.map((log, index) => {
                const { date, time } = formatDateTime(log.sent_time);
                
                return (
                  <tr key={log.id || log.log_id || index}>
                    <td style={{ padding: '12px 8px', textAlign: 'center', height: '50px' }}>
                      {log.alert_type ? log.alert_type.toUpperCase() : 'N/A'}
                    </td>
                    <td style={{ padding: '12px 8px', textAlign: 'center', height: '50px' }}>
                      {date}
                    </td>
                    <td style={{ padding: '12px 8px', textAlign: 'center', height: '50px' }}>
                      {time}
                    </td>
                    <td style={{ padding: '12px 8px', textAlign: 'center', height: '50px' }}>
                      {log.employee_id || 'N/A'}
                    </td>
                    <td style={{ padding: '12px 8px', textAlign: 'center', height: '50px' }}>
                      {log.employee_name || 'N/A'}
                    </td>
                    <td style={{ padding: '12px 8px', textAlign: 'center', height: '50px' }}>
                      {log.action_taken || 'N/A'}
                    </td>
                    {/* <td style={{ 
                      padding: '12px 8px', 
                      textAlign: 'center', 
                      height: '50px',
                      fontSize: '0.8rem',
                      color: '#ff6b6b'
                    }}>
                      {exceptions.length > 0 ? exceptions.join(', ') : 'No exceptions'}
                    </td> */}
                  </tr>
                );
              })
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}

export default EmailTable;




//D:\Email Automation\frontend_1\src\App.js




//D:\Email Automation\frontend_1\src\App.js

import React, { useState, useMemo, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { Chart, registerables } from 'chart.js';
import { debounce } from 'lodash';
import './App.css';
import Table from './Table';
import Occupancy from './Occupancy';
import Occtable from './Occtable';
import ResizableCard from './ResizableCard';
import { dummyData } from './dummyData';
import cityCoordinates from './cityCoordinates.json';
import 'leaflet/dist/leaflet.css';
import EmailDashboard from './EmailDashboard';
import TempSettings from './TempSettings';
import EmailTable from './EmailTable';
import PptExporter from './PptExporter';
// Import your SVG files here
import DashboardIcon from './Icons/dashboard-svgrepo-com.svg';
import TableIcon from './Icons/table-svgrepo-com.svg';
import OccupancyIcon from './Icons/group-svgrepo-com.svg';
import OccTableIcon from './Icons/table-svgrepo-com.svg';
import EmailIcon from './Icons/email-1-svgrepo-com.svg';
import EmailTempIcon from './Icons/email-settings-svgrepo-com.svg';
import EmailTableIcon from './Icons/table-svgrepo-com.svg';
import BackIcon from './Icons/home-svgrepo-com.svg';

Chart.register(...registerables);

function App() {
  const navigate = useNavigate();
  const [currentView, setCurrentView] = useState('dashboard');
  const [selectedRegion1, setSelectedRegion1] = useState('All');
  const [selectedPriority1, setSelectedPriority1] = useState('All');
  const [selectedTableRegion, setSelectedTableRegion] = useState('All');
  const [selectedDataType, setSelectedDataType] = useState('All');
  const today = new Date().toISOString().slice(0, 10);
  const [dateFrom, setDateFrom] = useState(today);
  const [dateTo, setDateTo] = useState(today);
  const [selectedAlert, setSelectedAlert] = useState(null);
  const [selectedCity, setSelectedCity] = useState(null);
  const [sizes, setSizes] = useState({
    location2: { width: 450, height: 400 },
    office: { width: 900, height: 400 },
    map: { width: 300, height: 200 },
    alerts: { width: 300, height: 200 },
  });
  const [alertsRaw, setAlertsRaw] = useState([]);
  const [cityChartData2, setCityChartData2] = useState(null);
  const [officeByRegionData, setOfficeByRegionData] = useState(dummyData.officeChartByRegion);
  const [violationChartData, setViolationChartData] = useState(null);
  const [alertsListData, setAlertsListData] = useState(dummyData.alertsData);
  const [fetchError, setFetchError] = useState(null);
  const [selectedMapRegion, setSelectedMapRegion] = useState('All');
  const [selectedBarRegion2, setSelectedBarRegion2] = useState('EMEA');
  const [allMarkers, setAllMarkers] = useState([]);

  // Auto-refresh state
  const [isAutoRefresh, setIsAutoRefresh] = useState(true);
  const [lastRefreshTime, setLastRefreshTime] = useState(new Date().toLocaleTimeString());
  const POLLING_INTERVAL = 1000; // 1 second
  const BACK_NAVIGATION_URL = 'http://192.168.1.100:3000'; // Replace with your back navigation URL

  const handleResize = (key, width, height) => {
    setSizes(prev => ({
      ...prev,
      [key]: { width: Math.max(width, 250), height: Math.max(height, 200) },
    }));
  };

  const handleRegionClick = (region) => {
    setSelectedTableRegion(region);
    setSelectedCity(null);
    setSelectedAlert(null);
    setCurrentView('table');
  };

  const handleAlertClick = (alert) => {
    const fullAlert = filteredAlerts.find(a =>
      `${a.EmployeeID || ''}_${a.Swipe_Time || ''}_${a.PartitionName || ''}` === alert.rowId
    );
   
    if (fullAlert) {
      console.log('Full alert found:', fullAlert);
      const selectedAlertData = {
        rowId: alert.rowId,
        employeeId: fullAlert.EmployeeID || '',
        employeeName: fullAlert.ObjectName1 || '',
        location: fullAlert.PartitionName?.trim() || '',
        region: fullAlert.Region?.trim() || 'All',
        doorName: fullAlert.ObjectName2 || '',
        time: fullAlert.Swipe_Time || '',
        reason: fullAlert.Alert_Type || '',
        actionTaken: fullAlert.ObjectName3 || 'no action taken',
        dateOnly: fullAlert.DateOnly || '',
        priority: alert.priority
      };
     
      console.log('Setting selected alert:', selectedAlertData);
      setSelectedAlert(selectedAlertData);
      setSelectedTableRegion(selectedAlertData.region);
      setSelectedCity(selectedAlertData.location);
      setDateFrom(selectedAlertData.dateOnly || today);
      setDateTo(selectedAlertData.dateOnly || today);
    } else {
      console.log('Full alert not found, using basic alert data');
      setSelectedAlert(alert);
      setSelectedTableRegion('All');
      setSelectedCity(null);
      setDateFrom(today);
      setDateTo(today);
    }
   
    setCurrentView('table');
  };

  const handleCityClick = (city, region) => {
    setSelectedCity(city);
    setSelectedTableRegion(region);
    setSelectedAlert(null);
    setCurrentView('table');
  };

  const priorityMap = useMemo(() => ({
    Clearance: 'Medium',
    Disabled: 'High',
    'Wrong PIN': 'Low',
    'Site Code': 'Low',
    'Facility Code': 'Low',
    'Expired': 'Medium',
    'Lost': 'Medium',
    'Stolen': 'High',
    'Unknown Card': 'Low',
    'Not Activated': 'Low',
    'FORCED OPEN': 'Critical',
    'HELD OPEN': 'Critical',
    'FIRE EVENT': 'Critical',
  }), []);

  const alarmTypes = ['HELD OPEN', 'FORCED OPEN', 'FIRE EVENT'];

  const regionBounds = {
    APAC: [[-45, 60], [45, 180]],
    NAMER: [[25, -125], [50, -65]],
    EMEA: [[30, -30], [70, 60]],
    LACA: [[-35, -90], [15, -30]],
    All: [[-60, -180], [80, 180]]
  };

  const regionCities = useMemo(() => ({
    NAMER: ['Denver', 'New York', 'Miami', 'Austin'],
    EMEA: ['LT.Vilnius', 'UK.London', 'AT.Vienna', 'IT.Rome', 'IE.Dublin', 'ES.Madrid', 'DU.Abu Dhab', 'MA.Casablanca', 'RU.Moscow', 'AUT.Vienna'],
    LACA: ['MX.Mexico City', 'AR.Cordoba', 'PE.Lima', 'PA.Panama City', 'BR.Sao Paulo', 'CR.Costa Rica Partition', 'Barbados'],
    APAC: ['Pune', 'CN.Beijing', 'Taguig City', 'Quezon City', 'JP.Tokyo', 'MY.Kuala Lumpur', 'APAC.Default', 'IN.HYD'],
  }), []);

  const executiveSummary = useMemo(() => {
    const totalAlerts = alertsListData.length;
    const criticalAlerts = alertsListData.filter(a => a.priority === 'Critical').length;
    const highAlerts = alertsListData.filter(a => a.priority === 'High').length;
    const mediumAlerts = alertsListData.filter(a => a.priority === 'Medium').length;
    const lowAlerts = alertsListData.filter(a => a.priority === 'Low').length;

    const alertTypeCounts = {};
    alertsListData.forEach(alert => {
      alertTypeCounts[alert.alertType] = (alertTypeCounts[alert.alertType] || 0) + 1;
    });

    const regionalData = Object.keys(regionCities).map(region => {
      const regionAlerts = alertsListData.filter(alert => alert.region === region);
      return {
        region,
        total: regionAlerts.length,
        critical: regionAlerts.filter(a => a.priority === 'Critical').length,
        high: regionAlerts.filter(a => a.priority === 'High').length,
        medium: regionAlerts.filter(a => a.priority === 'Medium').length,
        low: regionAlerts.filter(a => a.priority === 'Low').length,
      };
    });

    return {
      totalAlerts,
      criticalAlerts,
      highAlerts,
      mediumAlerts,
      lowAlerts,
      alertTypeCounts,
      regionalData,
      mostVulnerableCity: cityChartData2?.mostVulnerableCity || 'None'
    };
  }, [alertsListData, cityChartData2, regionCities]);

  const cache = { api: {}, memo: {} };

  const fetchAlerts = useCallback(async (retries = 3, delay = 1000) => {
    console.log(`Fetching alert logs from /alert-logs-sqlite for ${dateFrom} to ${dateTo}... Attempt: ${new Date().toISOString()}`);
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);
        const response = await fetch(`/alert-logs-sqlite?api_key=${process.env.REACT_APP_API_KEY}&from_date=${dateFrom}&to_date=${dateTo}`, {
          method: 'GET',
          headers: { 
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache'
          },
          signal: controller.signal,
        });
        clearTimeout(timeoutId);
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        const data = await response.json();
        if (!Array.isArray(data)) throw new Error('Response is not an array');
        const knownIds = new Set();
        const newRows = data.filter(row => {
          const rowId = `${row.EmployeeID || ''}_${row.Swipe_Time || ''}_${row.PartitionName || ''}`;
          if (!knownIds.has(rowId)) {
            knownIds.add(rowId);
            return true;
          }
          return false;
        });
        console.log(`Fetched ${newRows.length} new rows`, newRows.slice(0, 5));
        setAlertsRaw(newRows);
        setFetchError(null);
        setLastRefreshTime(new Date().toLocaleTimeString());
        return;
      } catch (e) {
        console.error(`Fetch attempt ${attempt} failed:`, e.message);
        if (attempt === retries) setFetchError(e.message);
        else await new Promise(res => setTimeout(res, delay));
      }
    }
  }, [dateFrom, dateTo]);

  // Initial fetch
  useEffect(() => {
    fetchAlerts();
  }, [fetchAlerts]);

  // Auto-refresh polling (1 second interval)
  useEffect(() => {
    if (!isAutoRefresh) {
      console.log('Auto-refresh is paused');
      return;
    }

    console.log(`Setting up auto-refresh with ${POLLING_INTERVAL / 1000}s interval`);
    const intervalId = setInterval(() => {
      console.log('Auto-refreshing data...');
      fetchAlerts();
    }, POLLING_INTERVAL);

    return () => {
      console.log('Clearing auto-refresh interval');
      clearInterval(intervalId);
    };
  }, [isAutoRefresh, fetchAlerts, POLLING_INTERVAL]);

  const filteredAlerts = useMemo(() => {
    const cacheKey = `${dateFrom}_${dateTo}_${selectedDataType}_${JSON.stringify(alertsRaw)}`;
    if (cache.memo[cacheKey]) {
      console.log('Using cached filteredAlerts for', cacheKey);
      return cache.memo[cacheKey];
    }
    console.log(`Computing filteredAlerts for dateFrom: ${dateFrom}, dateTo: ${dateTo}, selectedDataType: ${selectedDataType}, alertsRaw length: ${alertsRaw.length}`);
    let result = alertsRaw.filter(a => {
      if (!dateFrom || !dateTo) return true;
      const date = a.DateOnly;
      return date >= dateFrom && date <= dateTo;
    });
    if (selectedDataType === 'Alarms') {
      result = result.filter(a => alarmTypes.includes(a.Alert_Type));
    } else if (selectedDataType === 'Violations') {
      result = result.filter(a => !alarmTypes.includes(a.Alert_Type));
    }
    console.log(`filteredAlerts length: ${result.length}`, result.slice(0, 5));
    cache.memo[cacheKey] = result;
    return result;
  }, [alertsRaw, dateFrom, dateTo, selectedDataType, alarmTypes]);

  const cityChartData2Memo = useMemo(() => {
    const cacheKey = `${JSON.stringify(filteredAlerts)}_${selectedBarRegion2}_${selectedDataType}`;
    if (cache.memo[cacheKey]) {
      console.log('Using cached cityChartData2Memo for', cacheKey);
      return cache.memo[cacheKey];
    }
    if (!filteredAlerts.length) return null;
    const cities = regionCities[selectedBarRegion2] || [];
    const alarmCounts = {};
    const violationCounts = {};
    cities.forEach(city => {
      alarmCounts[city] = 0;
      violationCounts[city] = 0;
    });
    filteredAlerts.forEach(a => {
      const city = a.PartitionName?.trim();
      const region = a.Region?.trim();
      if (region === selectedBarRegion2 && city && cities.includes(city)) {
        if (alarmTypes.includes(a.Alert_Type)) {
          alarmCounts[city] = (alarmCounts[city] || 0) + 1;
        } else {
          violationCounts[city] = (violationCounts[city] || 0) + 1;
        }
      } else if (city && !cities.includes(city)) {
        console.warn(`City ${city} not found in region ${selectedBarRegion2}`);
      }
    });
    let mostVulnerableCity = 'None';
    let maxViolations = 0;
    cities.forEach(city => {
      if (violationCounts[city] > maxViolations) {
        maxViolations = violationCounts[city];
        mostVulnerableCity = city;
      }
    });
    const result = {
      labels: cities,
      datasets: JSON.stringify([
        {
          label: 'ALARMS',
          data: cities.map(city => alarmCounts[city]),
          backgroundColor: '#e74c3c27',
          borderColor: '#e74c3c',
          borderWidth: 2,
          borderRadius: 5,
        },
        {
          label: 'VIOLATIONS',
          data: cities.map(city => violationCounts[city]),
          backgroundColor: '#2ecc7127',
          borderColor: '#2ecc71',
          borderWidth: 2,
          borderRadius: 5,
        },
      ]),
      mostVulnerableCity: maxViolations > 0 ? mostVulnerableCity : 'None'
    };
    cache.memo[cacheKey] = result;
    return result;
  }, [filteredAlerts, selectedBarRegion2, regionCities, selectedDataType, alarmTypes]);

  const violationChartDataMemo = useMemo(() => {
    const cacheKey = `${JSON.stringify(filteredAlerts)}_${selectedRegion1}`;
    if (cache.memo[cacheKey]) {
      console.log('Using cached violationChartDataMemo for', cacheKey);
      return cache.memo[cacheKey];
    }
    if (!filteredAlerts.length) return null;
    const violationTypes = [...new Set(filteredAlerts
      .filter(a => !alarmTypes.includes(a.Alert_Type))
      .map(a => a.Alert_Type))].sort();
    let datasets = [];
    let mostCommonViolation = null;
    let maxRegionPartition = {};
    const regionColors = {
      APAC: { border: '#2ecc71', background: '#2ecc7127' },
      EMEA: { border: '#e74c3c', background: '#e74c3c27' },
      NAMER: { border: '#3498db', background: '#3498db27' },
      LACA: { border: '#f1c40f', background: '#f1c40f27' },
    };
    if (selectedRegion1 === 'All') {
      const regions = ['APAC', 'EMEA', 'NAMER', 'LACA'];
      datasets = regions.map(region => {
        const counts = {};
        const regionPartitionCounts = {};
        violationTypes.forEach(type => {
          counts[type] = 0;
          regionPartitionCounts[type] = {};
        });
        filteredAlerts.forEach(a => {
          const type = a.Alert_Type;
          const alertRegion = a.Region?.trim();
          const partition = a.PartitionName?.trim();
          if (!alarmTypes.includes(type) && alertRegion === region && partition) {
            counts[type] = (counts[type] || 0) + 1;
            const key = `${alertRegion}:${partition}`;
            regionPartitionCounts[type][key] = (regionPartitionCounts[type][key] || 0) + 1;
          }
        });
        violationTypes.forEach(type => {
          let maxKey = null;
          let maxValue = 0;
          Object.entries(regionPartitionCounts[type]).forEach(([key, value]) => {
            if (value > maxValue) {
              maxValue = value;
              maxKey = key;
            }
          });
          if (maxKey) {
            const [regionName, partitionName] = maxKey.split(':');
            maxRegionPartition[`${type}_${regionName}`] = `${regionName}: ${partitionName}`;
          }
        });
        return {
          label: `Violations (${region})`,
          data: violationTypes.map(type => counts[type] || 0),
          fill: false,
          backgroundColor: regionColors[region].background,
          borderColor: regionColors[region].border,
          tension: 0.4,
        };
      });
    } else {
      const counts = {};
      const regionPartitionCounts = {};
      violationTypes.forEach(type => {
        counts[type] = 0;
        regionPartitionCounts[type] = {};
      });
      filteredAlerts.forEach(a => {
        const type = a.Alert_Type;
        const region = a.Region?.trim();
        const partition = a.PartitionName?.trim();
        if (!alarmTypes.includes(type) && region && partition) {
          if (selectedRegion1 === region) {
            counts[type] = (counts[type] || 0) + 1;
            const key = `${region}:${partition}`;
            regionPartitionCounts[type][key] = (regionPartitionCounts[type][key] || 0) + 1;
          }
        }
      });
      let maxCount = 0;
      violationTypes.forEach(type => {
        if (counts[type] > maxCount) {
          maxCount = counts[type];
          mostCommonViolation = type;
        }
      });
      violationTypes.forEach(type => {
        let maxKey = null;
        let maxValue = 0;
        Object.entries(regionPartitionCounts[type]).forEach(([key, value]) => {
          if (value > maxValue) {
            maxValue = value;
            maxKey = key;
          }
        });
        if (maxKey) {
          const [regionName, partitionName] = maxKey.split(':');
          maxRegionPartition[type] = `${regionName}: ${partitionName}`;
        }
      });
      datasets = [{
        label: `Violations (${selectedRegion1})`,
        data: violationTypes.map(type => counts[type] || 0),
        fill: false,
        backgroundColor: regionColors[selectedRegion1]?.background || '#16a34a27',
        borderColor: regionColors[selectedRegion1]?.border || '#16a34a',
        tension: 0.4,
      }];
    }
    const result = {
      labels: violationTypes,
      datasets: JSON.stringify(datasets),
      mostCommonViolation: selectedRegion1 !== 'All' ? mostCommonViolation : null,
      maxRegionPartition: JSON.stringify(maxRegionPartition)
    };
    cache.memo[cacheKey] = result;
    return result;
  }, [filteredAlerts, selectedRegion1, alarmTypes]);

  const officeByRegionDataMemo = useMemo(() => {
    const cacheKey = `${JSON.stringify(filteredAlerts)}_${selectedDataType}`;
    if (cache.memo[cacheKey]) {
      console.log('Using cached officeByRegionDataMemo for', cacheKey);
      return cache.memo[cacheKey];
    }
    const officeChart = {};
    Object.keys(regionCities).forEach(region => {
      officeChart[region] = {};
      ['All', 'Critical', 'High', 'Medium', 'Low'].forEach(pri => {
        const filteredByPri = pri === 'All' ? filteredAlerts : filteredAlerts.filter(a => priorityMap[a.Alert_Type] === pri);
        const cityCounts = {};
        regionCities[region].forEach(city => { cityCounts[city] = 0; });
        filteredByPri.forEach(({ Region, PartitionName }) => {
          if (Region?.trim() === region && PartitionName?.trim()) {
            const city = PartitionName.trim();
            if (regionCities[region].includes(city)) {
              cityCounts[city] = (cityCounts[city] || 0) + 1;
            }
          }
        });
        officeChart[region][pri] = {
          labels: regionCities[region],
          datasets: JSON.stringify([{
            label: `${selectedDataType} in ${region} (${pri})`,
            data: Object.values(cityCounts),
            fill: true,
            backgroundColor: 'rgba(52,152,219,0.2)',
            borderColor: '#3498db',
            tension: 0.4,
          }]),
        };
      });
    });
    cache.memo[cacheKey] = officeChart;
    return officeChart;
  }, [filteredAlerts, priorityMap, regionCities, selectedDataType]);

  const allMarkersMemo = useMemo(() => {
    const cityAlertCounts = filteredAlerts.reduce((acc, a) => {
      const city = a.PartitionName?.trim();
      if (city) {
        acc[city] = acc[city] || { total: 0, violations: 0 };
        acc[city].total += 1;
        if (!alarmTypes.includes(a.Alert_Type)) {
          acc[city].violations += 1;
        }
      }
      return acc;
    }, {});
    const markers = [];
    Object.keys(cityCoordinates).forEach(region => {
      if (!Array.isArray(cityCoordinates[region])) {
        console.warn(`Invalid cityCoordinates for region: ${region}, value: ${JSON.stringify(cityCoordinates[region])}`);
        return;
      }
      cityCoordinates[region].forEach(city => {
        if (!city || !city.coordinates || !city.key || !city.name) {
          console.warn(`Invalid city entry in ${region}: ${JSON.stringify(city)}`);
          return;
        }
        const coords = city.coordinates;
        if (
          Array.isArray(coords) &&
          coords.length === 2 &&
          typeof coords[0] === 'number' &&
          typeof coords[1] === 'number' &&
          !isNaN(coords[0]) &&
          !isNaN(coords[1]) &&
          coords[0] !== null &&
          !isNaN(coords[1]) &&
          coords[1] !== null
        ) {
          markers.push({
            pos: [coords[0], coords[1]],
            label: city.name,
            popup: `${selectedDataType}: ${cityAlertCounts[city.key]?.total || 0}`,
            key: city.key,
            hasAlerts: (cityAlertCounts[city.key]?.total || 0) > 0,
            region: region,
            violationCount: cityAlertCounts[city.key]?.violations || 0
          });
        } else {
          console.warn(`Invalid or null coordinates for city: ${city.key}, coordinates: ${JSON.stringify(city.coordinates)}`);
        }
      });
    });
    console.log('Generated markers:', markers);
    return markers;
  }, [filteredAlerts, selectedDataType, alarmTypes]);

  const alertsListDataMemo = useMemo(() => {
    return filteredAlerts.map(a => ({
      office: a.PartitionName,
      priority: priorityMap[a.Alert_Type] || 'Low',
      alertType: a.Alert_Type || 'Unknown',
      rowId: `${a.EmployeeID || ''}_${a.Swipe_Time || ''}_${a.PartitionName || ''}`,
      region: a.Region?.trim() || '',
      employeeId: a.EmployeeID || '',
      employeeName: a.ObjectName1 || '',
      dateOnly: a.DateOnly || '',
      time: a.Swipe_Time || ''
    }));
  }, [filteredAlerts, priorityMap]);

  const debouncedSetChartData = debounce((city2, violation, office, markers, alertsList) => {
    console.log('Batch updating chart data');
    setCityChartData2(city2);
    setViolationChartData(violation);
    setOfficeByRegionData(office);
    setAllMarkers(Array.isArray(markers) ? markers : []);
    setAlertsListData(alertsList);
  }, 100);

  useEffect(() => {
    debouncedSetChartData(
      cityChartData2Memo,
      violationChartDataMemo,
      officeByRegionDataMemo,
      allMarkersMemo,
      alertsListDataMemo
    );
    return () => debouncedSetChartData.cancel();
  }, [cityChartData2Memo, violationChartDataMemo, officeByRegionDataMemo, allMarkersMemo, alertsListDataMemo]);

  const priorityCounts = useMemo(() => {
    return alertsListData.reduce((acc, a) => {
      acc[a.priority] = (acc[a.priority] || 0) + 1;
      return acc;
    }, {});
  }, [alertsListData]);

  const filteredMarkers = useMemo(() => {
    if (selectedMapRegion === 'All') return allMarkers;
    return allMarkers.filter(m => regionCities[selectedMapRegion].includes(m.key));
  }, [allMarkers, selectedMapRegion, regionCities]);

  const renderDashboard = () => (
    <>
      <div className="date-filter-container" style={{ display: 'flex', gap: '10px', flexWrap: 'wrap', alignItems: 'center' }}>
        {/* Back Button
        <button
          onClick={() => window.location.href = 'http://10.199.22.57:3014'}
          className="back-btn"
          style={{
            position: 'absolute',
            left: '-1460px',
            top: '0px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            width: '40px',
            height: '30.5px',
            padding: '8px',
            backgroundColor: '#3a3a3a',
            border: '1px solid #555',
            borderRadius: '6px',
            cursor: 'pointer',
            transition: 'all 0.2s ease'
          }}
          onMouseEnter={(e) => {
            e.currentTarget.style.backgroundColor = '#4a4a4a';
            e.currentTarget.style.borderColor = '#00ff9d';
          }}
          onMouseLeave={(e) => {
            e.currentTarget.style.backgroundColor = '#3a3a3a';
            e.currentTarget.style.borderColor = '#555';
          }}
        >
          <img 
            src={BackIcon} 
            alt="Back"
            style={{
              width: '24px',
              height: '22px',
              filter: 'brightness(0) saturate(100%) invert(70%)'
            }}
          />
        </button> */}

        <input
          type="date"
          value={dateFrom}
          onChange={e => setDateFrom(e.target.value)}
          placeholder="From Date"
          style={{ padding: '4px', fontSize: '0.8rem', color: '#fff', backgroundColor: '#3a3a3a', border: '1px solid #555', borderRadius: '4px' }}
        />
        <input
          type="date"
          value={dateTo}
          onChange={e => setDateTo(e.target.value)}
          placeholder="To Date"
          style={{ padding: '4px', fontSize: '0.8rem', color: '#fff', backgroundColor: '#3a3a3a', border: '1px solid #555', borderRadius: '4px' }}
        />
        
        
        {/* <button
          onClick={() => setIsAutoRefresh(!isAutoRefresh)}
          style={{
            padding: '6px 12px',
            fontSize: '0.8rem',
            color: '#fff',
            backgroundColor: isAutoRefresh ? '#2ecc71' : '#e74c3c',
            border: '1px solid #555',
            borderRadius: '4px',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            gap: '5px'
          }}
        >
          <span style={{
            width: '8px',
            height: '8px',
            borderRadius: '50%',
            backgroundColor: '#fff',
            animation: isAutoRefresh ? 'pulse 2s infinite' : 'none'
          }} />
          {isAutoRefresh ? 'Auto-Refresh ON (1s)' : 'Auto-Refresh OFF'}
        </button> */}

        {/* Manual refresh button */}
        {/* <button
          onClick={() => fetchAlerts()}
          style={{
            padding: '6px 12px',
            fontSize: '0.8rem',
            color: '#fff',
            backgroundColor: '#3498db',
            border: '1px solid #555',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          Refresh Now
        </button> */}

        {/* Last refresh time indicator */}
        {/* <span style={{
          fontSize: '0.75rem',
          color: '#888',
          padding: '4px 8px'
        }}>
          Last updated: {lastRefreshTime}
        </span> */}
        
        {/* PowerPoint Export Button */}
        <PptExporter
          dateFrom={dateFrom}
          dateTo={dateTo}
          alertsData={alertsListData}
          executiveSummary={executiveSummary}
          chartData={violationChartData}
          regionData={regionCities}
        />
      </div>
      <header className="table-header" style={{ marginLeft: '0px' }}>
        <h1 className="text-3xl font-bold neon-text" style={{marginLeft: '0px', marginTop: '6px'}}>ALARM ANALYSIS DASHBOARD</h1>
      </header>
      <div className="dashboard-grid" style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 0.3fr', gridAutoRows: 'auto', gap: '1rem' }}>
        <ResizableCard
          id="office1"
          label={
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', color: '#00ff9d', fontSize: '21px', fontWeight: '500' }}>
              <span>GLOBAL VIOLATIONS & ALARMS</span>
              <div>
                <select
                  value={selectedRegion1}
                  onChange={e => setSelectedRegion1(e.target.value)}
                  style={{ marginLeft: '10px', padding: '4px', fontSize: '0.8rem', color: '#fff', backgroundColor: '#3a3a3a', border: '1px solid #555', borderRadius: '4px' }}
                >
                  <option value="All">All</option>
                  {Object.keys(regionCities).map(region => (
                    <option key={region} value={region}>{region}</option>
                  ))}
                </select>
              </div>
            </div>
          }
          size={sizes.office}
          onResize={handleResize}
          type="Line"
          chartData={violationChartData}
          selectedRegion={selectedRegion1}
          style={{ gridColumn: '1 / 3', gridRow: '2' }}
          fetchError={fetchError}
        />
        <ResizableCard
          id="location2"
          label={
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', color: '#00ff9d', fontSize: '21px', fontWeight: '500' }}>
              <span>LOCALISED ALARMS & VIOLATIONS</span>
              <select
                value={selectedBarRegion2}
                onChange={e => setSelectedBarRegion2(e.target.value)}
                style={{ marginLeft: '10px', padding: '4px', fontSize: '0.8rem', color: '#fff', backgroundColor: '#3a3a3a', border: '1px solid #555', borderRadius: '4px' }}
              >
                {Object.keys(regionCities).map(region => (
                  <option key={region} value={region}>{region}</option>
                ))}
              </select>
            </div>
          }
          size={sizes.location2}
          onResize={handleResize}
          type="Bar"
          chartData={cityChartData2}
          style={{ gridColumn: '1 / 3', gridRow: '1 / span 1' }}
          fetchError={fetchError}
          onCityClick={(city) => handleCityClick(city, selectedBarRegion2)}
        />
        <ResizableCard
          id="map"
          label={
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', color: '#00ff9d', fontSize: '21px', fontWeight: '500' }}>
              <span>ALARM LOCATIONS MAP</span>
              <select value={selectedMapRegion} onChange={e => setSelectedMapRegion(e.target.value)} style={{ marginLeft: '10px', padding: '4px', fontSize: '0.8rem', color: '#fff', backgroundColor: '#3a3a3a', border: '1px solid #555', borderRadius: '4px' }}>
                <option value="All">All</option>
                {Object.keys(cityCoordinates).map(region => (
                  <option key={region} value={region}>{region}</option>
                ))}
              </select>
            </div>
          }
          size={sizes.map}
          onResize={handleResize}
          type="Map"
          chartData={{ markers: filteredMarkers, region: selectedMapRegion, bounds: regionBounds }}
          style={{ gridColumn: '3 / 4', gridRow: '1' }}
          onCityClick={(city, region) => handleCityClick(city, region)}
        />
        <ResizableCard
          id="alerts"
          label={
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', color: '#00ff9d', fontSize: '21px', fontWeight: '500' }}>
              <span>GLOBAL ALARM ALERTS</span>
            </div>
          }
          size={sizes.alerts}
          onResize={handleResize}
          type="CustomList"
          chartData={{ alerts: alertsListData, counts: priorityCounts }}
          style={{ gridColumn: '3 / 4', gridRow: '2' }}
          onAlertClick={handleAlertClick}
        />
      </div>
    </>
  );

  const navigationItems = [
    {
      view: 'back',
      icon: BackIcon,
      aly: 'Back',
      isExternal: true,
      url: 'http://10.199.22.57:3014',
      label: 'Home'
    },
    { 
      view: 'dashboard', 
      icon: DashboardIcon,
      alt: 'Dashboard',
      label: 'Dashboard'
    },
    { 
      view: 'table', 
      icon: TableIcon,
      alt: 'Table',
      label: 'Table'
    },
    // { 
    //   view: 'occupancy', 
    //   icon: OccupancyIcon,
    //   alt: 'Occupancy',
    //   label: 'Occupancy'
    // },
    // { 
    //   view: 'occtable', 
    //   icon: OccTableIcon,
    //   alt: 'Occupancy Table',
    //   label: 'Occ Table'
    // },
    { 
      view: 'email', 
      icon: EmailIcon,
      alt: 'Email',
      label: 'Email'
    },
    { 
      view: 'emailtemp', 
      icon: EmailTempIcon,
      alt: 'Email Templates',
      label: 'Templates'
    },
    { 
      view: 'emailtable', 
      icon: EmailTableIcon,
      alt: 'Email Table',
      label: 'Email Table'
    },
  ];

 return (
  <div className="app-container">
    <aside className="sidebar" style={{marginTop:"-18px"}}>
      {navigationItems.map(({ view, icon, alt, label, isExternal, url }) => (
        <button
          key={view}
          onClick={() => {
            if (isExternal && url) {
              window.location.href = url;
            } else {
              setCurrentView(view);
              navigate('/');
            }
          }}
          className="nav-btn"
          disabled={!isExternal && currentView === view}
          style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            padding: '12px 8px',
            width: '70px',
            height: '70px',
            margin: '6px auto',
            borderRadius: '8px',
            border: 'none',
            backgroundColor: !isExternal && currentView === view ? '#2ecc71' : 'transparent',
            transition: 'all 0.2s ease',
            cursor: (!isExternal && currentView === view) ? 'default' : 'pointer',
            gap: '4px'
          }}
          onMouseEnter={(e) => {
            if (isExternal || currentView !== view) {
              e.currentTarget.style.backgroundColor = '#3a3a3a';
            }
          }}
          onMouseLeave={(e) => {
            if (isExternal) {
              e.currentTarget.style.backgroundColor = 'transparent';
            } else if (currentView !== view) {
              e.currentTarget.style.backgroundColor = 'transparent';
            } else {
              e.currentTarget.style.backgroundColor = '#2ecc71';
            }
          }}
        >
          <img 
            src={icon} 
            alt={alt}
            style={{
              width: '24px',
              height: '24px',
              filter: (!isExternal && currentView === view)
                ? 'brightness(0) saturate(100%) invert(100%)' 
                : 'brightness(0) saturate(100%) invert(70%)',
              transition: 'filter 0.2s ease'
            }}
          />
          <span 
            style={{ 
              fontSize: '10px',
              fontWeight: '500',
              color: (!isExternal && currentView === view) ? '#fff' : '#b3b3b3',
              textAlign: 'center',
              lineHeight: '1',
              transition: 'color 0.2s ease',
              whiteSpace: 'nowrap',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              maxWidth: '60px'
            }}
          >
            {label}
          </span>
        </button>
      ))}
    </aside>
    <main className="main-content">
      {currentView === 'dashboard' && renderDashboard()}
      {currentView === 'table' && (
        <Table
          selectedRegionProp={selectedTableRegion}
          dateFrom={dateFrom}
          dateTo={dateTo}
          setDateFrom={setDateFrom}
          setDateTo={setDateTo}
          selectedAlert={selectedAlert}
          selectedDataType={selectedDataType}
          selectedCityProp={selectedCity}
        />
      )}
      {currentView === 'occupancy' && <Occupancy />}
      {currentView === 'occtable' && <Occtable />}
      {currentView === 'email' && <EmailDashboard />}
      {currentView === 'emailtemp' && <TempSettings />}
      {currentView === 'emailtable' && (
        <EmailTable
        dateFrom={dateFrom}
        dateTo={dateTo}
         />)}
    </main>
  </div>
);
}

const RegionSelector = ({ selected, onChange, selectedPriority, onPriorityChange, options }) => (
  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', color: '#00ff9d', fontSize: '21px', fontWeight: '500' }}>
    <span>Alarm Responses  Office Wise</span>
    <select
      value={selected}
      onChange={e => onChange(e.target.value)}
      style={{ marginLeft: '10px', padding: '4px', fontSize: '0.8rem', color: '#fff', backgroundColor: '#3a3a3a', border: '1px solid #555', borderRadius: '4px' }}
    >
      {Object.keys(options).map(region => (
        <option key={region} value={region}>{region}</option>
      ))}
    </select>
    <select
      value={selectedPriority}
      onChange={e => onPriorityChange(e.target.value)}
      style={{ marginLeft: '10px', padding: '4px', fontSize: '0.8rem', color: '#fff', backgroundColor: '#3a3a3a', border: '1px solid #555', borderRadius: '4px' }}
    >
      <option value="All">All</option>
      <option value="Critical">Critical</option>
      <option value="High">High</option>
      <option value="Medium">Medium</option>
      <option value="Low">Low</option>
    </select>
  </div>
);

export default App;

