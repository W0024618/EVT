PS D:\DASHBOARD\swipeData\employee-ai-insights> node server.js
‚ñ∂Ô∏é Loading: D:\DASHBOARD\swipeData\employee-ai-insights\server.js
‚ñ∂Ô∏é CWD: D:\DASHBOARD\swipeData\employee-ai-insights
employeeRoutes not loaded: argument handler must be a function
‚úîÔ∏è  Server listening on http://0.0.0.0:3013
‚úÖ MSSQL pool connected
‚úÖ Denver MSSQL pool connected
‚û°Ô∏é GET /api/live-occupancy
‚û°Ô∏é GET /api/live-occupancy
‚û°Ô∏é GET /api/live-occupancy-denver
‚ùå Denver MSSQL pool error: TimeoutError: operation timed out for an unknown reason
    at D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\tarn\dist\PendingOperation.js:14:27
    at runNextTicks (node:internal/process/task_queues:65:5)
    at listOnTimeout (node:internal/timers:549:9)
    at process.processTimers (node:internal/timers:523:7)
[DENVER] push top-level error: TimeoutError: operation timed out for an unknown reason
    at D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\tarn\dist\PendingOperation.js:14:27
    at runNextTicks (node:internal/process/task_queues:65:5)
    at listOnTimeout (node:internal/timers:549:9)
    at process.processTimers (node:internal/timers:523:7)
‚û°Ô∏é GET /api/live-occupancy-denver
[DENVER] SSE client disconnected, cleared timers
‚ùå Denver MSSQL pool error: TimeoutError: operation timed out for an unknown reason
    at D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\tarn\dist\PendingOperation.js:14:27
    at runNextTicks (node:internal/process/task_queues:65:5)
    at listOnTimeout (node:internal/timers:549:9)
    at process.processTimers (node:internal/timers:523:7)
[DENVER] push top-level error: TimeoutError: operation timed out for an unknown reason
    at D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\tarn\dist\PendingOperation.js:14:27
    at runNextTicks (node:internal/process/task_queues:65:5)
    at listOnTimeout (node:internal/timers:549:9)
    at process.processTimers (node:internal/timers:523:7)
‚ùå Denver pool connection failed: ConnectionError: Failed to connect to SRVWUDEN0891V:1433 in 30000ms
    at D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\mssql\lib\tedious\connection-pool.js:85:17
    at Connection.onConnect (D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\tedious\lib\connection.js:8
49:9)
    at Object.onceWrapper (node:events:633:26)
    at Connection.emit (node:events:518:28)
    at Connection.emit (D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\tedious\lib\connection.js:970:18
)
    at Connection.connectTimeout (D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\tedious\lib\connection
.js:1222:10)
    at Timeout._onTimeout (D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\tedious\lib\connection.js:116
7:12)
    at listOnTimeout (node:internal/timers:588:17)
    at process.processTimers (node:internal/timers:523:7) {
  code: 'ETIMEOUT',
  originalError: ConnectionError: Failed to connect to SRVWUDEN0891V:1433 in 30000ms
      at Connection.connectTimeout (D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\tedious\lib\connecti
on.js:1222:26)
      at Timeout._onTimeout (D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\tedious\lib\connection.js:1
167:12)
      at listOnTimeout (node:internal/timers:588:17)
      at process.processTimers (node:internal/timers:523:7) {
    code: 'ETIMEOUT'
  }
}
‚è≥ Retrying Denver pool connect (3 left)‚Ä¶
‚ùå MSSQL global error: TimeoutError: operation timed out for an unknown reason
    at D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\tarn\dist\PendingOperation.js:17:27
    at runNextTicks (node:internal/process/task_queues:65:5)
    at listOnTimeout (node:internal/timers:549:9)
    at process.processTimers (node:internal/timers:523:7)
‚ùå MSSQL pool error: TimeoutError: operation timed out for an unknown reason
    at D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\tarn\dist\PendingOperation.js:17:27
    at runNextTicks (node:internal/process/task_queues:65:5)
    at listOnTimeout (node:internal/timers:549:9)
    at process.processTimers (node:internal/timers:523:7)
‚ùå Unhandled Rejection at: Promise {
  <rejected> TimeoutError: operation timed out for an unknown reason
      at D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\tarn\dist\PendingOperation.js:17:27
      at runNextTicks (node:internal/process/task_queues:65:5)
      at listOnTimeout (node:internal/timers:549:9)
      at process.processTimers (node:internal/timers:523:7)
} reason: Error: operation timed out for an unknown reason
    at D:\DASHBOARD\swipeData\employee-ai-insights\node_modules\tarn\dist\PendingOperation.js:17:27
    at runNextTicks (node:internal/process/task_queues:65:5)
    at listOnTimeout (node:internal/timers:549:9)
    at process.processTimers (node:internal/timers:523:7)
‚úÖ MSSQL pool connected





check above error message carefully due to above error API got disconnect with connnectionand we got late reply ...
need to fix this issue expected is never came above error 


so check below file carefully and fix the error message carefully....

If error came due to diffrent diffrent time out so fix timer issue fetch every seconds data ...1 sec...





// config/siteConfig.js
const { sql, getPool } = require('./db');

// Pune uses the shared getPool():
const punePoolPromise = getPool();

// Denver pool configuration
const denverConfig = {
  user:     'GSOC_Test',
  password: 'Westernccure@2025',
  server:   'SRVWUDEN0891V',
  database: 'ACVSUJournal_00010028',
  options: {
    encrypt:               true,
    trustServerCertificate: true
  },
  pool: {
    max:                  5,
    min:                  0,

    // Make these extremely large so that Tarn will never time us out
    idleTimeoutMillis:    2147483647,
    acquireTimeoutMillis: 2147483647
  },
  connectionTimeout: 30000,  // 30 seconds to establish
  requestTimeout:    0       // no timeout on individual queries
};

let denverPoolPromise = null;

async function getDenverPool(attempts = 3) {
  // If a pool promise is already in-flight (or resolved), return it.
  if (denverPoolPromise) {
    return denverPoolPromise;
  }

  denverPoolPromise = (async () => {
    const pool = new sql.ConnectionPool(denverConfig);

    // If this pool ever errors, reset the promise so that
    // next time we can try to re-connect.
    pool.on('error', err => {
      console.error('‚ùå Denver MSSQL pool error:', err);
      denverPoolPromise = null;
    });

    try {
      await pool.connect();
      console.log('‚úÖ Denver MSSQL pool connected');
      return pool;
    } catch (err) {
      console.error('‚ùå Denver pool connection failed:', err);
      denverPoolPromise = null;

      if (attempts > 0) {
        console.log(`‚è≥ Retrying Denver pool connect (${attempts} left)‚Ä¶`);
        await new Promise(res => setTimeout(res, 3000));
        return getDenverPool(attempts - 1);
      }

      // If all retries fail, re¬≠throw so that calling code can catch it.
      throw err;
    }
  })().catch(err => {
    // Catch any unhandled rejection here so it never propagates
    // out of the immediate getDenverPool() call.
    console.error('‚ùå Denver pool promise ultimately failed:', err);
    denverPoolPromise = null;
    return null;
  });

  return denverPoolPromise;
}

// Every 5 minutes, ping Denver so it never goes idle.
// If ping fails, reset the poolPromise (so next request will re-connect).
setInterval(async () => {
  try {
    const pool = await getDenverPool();
    if (pool) {
      await pool.request().query('SELECT 1');
      // console.log('üîÑ Denver keep-alive succeeded');
    }
  } catch (err) {
    console.error('‚ö†Ô∏è Denver keep-alive failed, resetting poolPromise:', err);
    denverPoolPromise = null;
  }
}, 5 * 60 * 1000);

module.exports = {
  pune: {
    name:        'Pune',
    poolPromise: punePoolPromise,
    sql
  },
  denver: {
    name:        'Denver',
    poolPromise: getDenverPool(),
    sql
  }
};






// controllers/denverLiveOccupancyController.js

const { DateTime }       = require('luxon');
const { denver }         = require('../config/siteConfig');
const doorFloorMap       = require('../data/denverDoorFloorMap');
const { monitoredDoors } = require('../data/strictDoorList');
const sql                = require('mssql');
const normalizeKey       = require('../data/normalizeKey');

const warnedKeys = new Set();

// build a Set of normalized door___direction keys
const normalizedMonitoredKeys = new Set(
  Object.entries(monitoredDoors).map(([door, dir]) => normalizeKey(door, dir))
);

/** Determine floor label, fallback to ‚ÄúHQ. N.‚Äù parsing **/
function mapDoorToFloor(rawDoor, rawDir) {
  const key = normalizeKey(rawDoor, rawDir);
  if (doorFloorMap[key]) return doorFloorMap[key];
  const m = rawDoor.match(/HQ\.\s*(\d{1,2})\b/);
  if (m) return `Floor ${m[1]}`;
  if (!warnedKeys.has(key)) {
    console.warn(`‚õî Unmapped door-floor key: "${key}"`);
    warnedKeys.add(key);
  }
  return 'Unknown Floor';
}

/** Strip any trailing ‚Äú_HH:MM:SS‚Äù from a door name **/
function stripTimeSuffix(doorRaw) {
  return doorRaw.replace(/_[0-9]{2}:[0-9]{2}:[0-9]{2}$/, '');
}

/**
 * Compare a DB row's Dateonly (yyyy-MM-dd) to either "today in Denver" OR a supplied reference DateTime (also Denver).
 * - dateOnly: string like '2025-09-11'
 * - referenceDt: optional luxon DateTime (zone 'America/Denver') to treat as "today"
 */
function isSameDenverDate(dateOnly, referenceDt = null) {
  if (!dateOnly) return false;
  const swipeDate = DateTime.fromISO(dateOnly, { zone: 'America/Denver' }).toFormat('yyyy-LL-dd');
  const today = referenceDt
    ? referenceDt.setZone('America/Denver').toFormat('yyyy-LL-dd')
    : DateTime.now().setZone('America/Denver').toFormat('yyyy-LL-dd');
  return swipeDate === today;
}

async function fetchNewEvents(since) {
  let pool;
  try {
    pool = await denver.poolPromise;
  } catch (err) {
    console.error('‚ùå Failed to get Denver pool in fetchNewEvents():', err);
    return [];
  }
  if (!pool) return [];

  const req = pool.request();
  req.input('since', sql.DateTime2, since);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]' ,'varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM ACVSUJournal_00010029.dbo.ACVSUJournalLog t1
      LEFT JOIN ACVSCore.Access.Personnel     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN ACVSCore.Access.PersonnelType t3 ON t2.PersonnelTypeId  = t3.ObjectID
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Name = 'Direction'
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxml t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType   = 'CardAdmitted'
        AND t1.ObjectName2 LIKE '%HQ%'
        AND DATEADD(MINUTE,-1* t1.MessageLocaleOffset, t1.MessageUTC) >=@since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8),  LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID, PersonGUID, ObjectName1, PersonnelType,
      CardNumber, AdmitCode, Direction, Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  return recordset;
}

// fetch events in 24h window ending at `until`
async function fetchEventsWindowUntil(until) {
  let pool;
  try {
    pool = await denver.poolPromise;
  } catch (err) {
    console.error('‚ùå Failed to get Denver pool in fetchEventsWindowUntil():', err);
    return [];
  }
  if (!pool) return [];

  const req = pool.request();
  req.input('until', sql.DateTime2, until);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR) END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'), sc.value) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM ACVSUJournal_00010029.dbo.ACVSUJournalLog t1
      LEFT JOIN ACVSCore.Access.Personnel t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN ACVSCore.Access.PersonnelType t3 ON t2.PersonnelTypeId  = t3.ObjectID
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred t5a ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred t5d ON t1.XmlGUID = t5d.GUID AND t5d.Name = 'Direction'
      LEFT JOIN ACVSUJournal_00010029.dbo.ACVSUJournalLogxml t_xml ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM ACVSUJournal_00010029.dbo.ACVSUJournalLogxmlShred
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.ObjectName2 LIKE '%HQ%'
        AND DATEADD(MINUTE,-1 * t1.MessageLocaleOffset, t1.MessageUTC) <= @until
        AND DATEADD(HOUR, -24, @until) < DATEADD(MINUTE,-1 * t1.MessageLocaleOffset, t1.MessageUTC)
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8) , LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID, PersonGUID, ObjectName1, PersonnelType,
      CardNumber, AdmitCode, Direction, Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  return recordset;
}

// --- ONLY endpoint: Snapshot endpoint for Denver with date + time ---
// GET /api/occupancy-at-time-denver?date=YYYY-MM-DD&time=HH:MM[:SS]
exports.getDenverSnapshotAtDateTime = async (req, res) => {
  try {
    const { date, time } = req.query;
    if (!date || !time) {
      return res.status(400).json({
        error: 'missing query params: expected ?date=YYYY-MM-DD&time=HH:MM[:SS]'
      });
    }

    // Validate date
    const dateMatch = /^(\d{4})-(\d{2})-(\d{2})$/.exec(date);
    if (!dateMatch) return res.status(400).json({ error: 'invalid "date" format; expected YYYY-MM-DD' });

    // Validate time
    const timeMatch = /^([0-1]\d|2[0-3]):([0-5]\d)(?::([0-5]\d))?$/.exec(time);
    if (!timeMatch) return res.status(400).json({ error: 'invalid "time" format; expected HH:MM or HH:MM:SS' });

    const year   = Number(dateMatch[1]);
    const month  = Number(dateMatch[2]);
    const day    = Number(dateMatch[3]);
    const hour   = Number(timeMatch[1]);
    const minute = Number(timeMatch[2]);
    const second = timeMatch[3] ? Number(timeMatch[3]) : 0;

    // Build Denver-local datetime
    const atDt = DateTime.fromObject(
      { year, month, day, hour, minute, second, millisecond: 0 },
      { zone: 'America/Denver' }
    );

    if (!atDt.isValid) {
      return res.status(400).json({ error: 'invalid date+time combination' });
    }

    const untilJsDate = atDt.toJSDate();

    // fetch with 24h window ending at requested datetime
    const events = await fetchEventsWindowUntil(untilJsDate);

    // filter only events on that Denver local date
    const targetDate = atDt.toFormat('yyyy-LL-dd');
    const filtered = events.filter(e => e.Dateonly === targetDate);

    // build occupancy payload (pass atDt so date checks use it)
    const payload = buildOccupancyForToday(filtered, [], atDt);

    return res.json(payload);
  } catch (err) {
    console.error('getDenverSnapshotAtDateTime error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};

// --------------------------
// helper: computeVisitedToday using optional reference date
// function computeVisitedToday(allEvents, referenceDt = null) {
//   const seen = new Map(); // key -> PersonnelType
//   allEvents.forEach(evt => {
//     if (evt.Direction === 'InDirection' && isSameDenverDate(evt.Dateonly, referenceDt)) {
//       const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
//       if (!seen.has(key)) {
//         seen.set(key, evt.PersonnelType);
//       }
//     }
//   });
//   let emp = 0, ctr = 0;
//   seen.forEach(type => {
//     if (type === 'Employee' || type === 'Terminated Personnel') emp++;
//     else ctr++;
//   });
//   return { total: seen.size, employees: emp, contractors: ctr };
// }




// --------------------------
// helper: computeVisitedToday using optional reference date
// Counts any swipe (In or Out) on the same Denver date and up to referenceDt (if provided).
function computeVisitedToday(allEvents, referenceDt = null) {
  const seen = new Map(); // key -> PersonnelType

  allEvents.forEach(evt => {
    // Must be same Denver date as referenceDt (or today when referenceDt null)
    if (!isSameDenverDate(evt.Dateonly, referenceDt)) return;

    // If referenceDt provided, ensure the event's local datetime <= referenceDt
    if (referenceDt) {
      // Prefer Dateonly + Swipe_Time (DB local fields)
      if (!evt.Dateonly || !evt.Swipe_Time) return;
      const evtDt = DateTime.fromISO(`${evt.Dateonly}T${evt.Swipe_Time}`, { zone: 'America/Denver' });
      if (!evtDt.isValid) return;
      if (evtDt > referenceDt.setZone('America/Denver')) return;
    }

    const key = evt.PersonGUID || evt.EmployeeID || evt.CardNumber;
    if (!key) return;
    if (!seen.has(key)) {
      seen.set(key, evt.PersonnelType);
    }
  });

  let employees = 0, contractors = 0;
  seen.forEach(type => {
    if (type === 'Employee' || type === 'Terminated Personnel') employees++;
    else contractors++;
  });

  return { total: seen.size, employees, contractors };
}



// Build occupancy for "today" where "today" can be the real today OR the date represented by atDt (Denver)
function buildOccupancyForToday(allEvents, freshEvents = [], atDt = null) {
  // reference DateTime in Denver (null => live now)
  const refDt = atDt ? atDt.setZone('America/Denver') : null;

  // canonical person key
  const personKey = (evt) => evt.PersonGUID || evt.EmployeeID || evt.CardNumber;

  // derive a Luxon DateTime in America/Denver for the event.
  // Prefer Dateonly + Swipe_Time (these are the DB's local values). Fallback to parsing LocaleMessageTime.
  const eventDtFor = (evt) => {
    if (evt && evt.Dateonly && evt.Swipe_Time) {
      const iso = `${evt.Dateonly}T${evt.Swipe_Time}`; // e.g. "2025-09-17T00:26:55"
      const dt = DateTime.fromISO(iso, { zone: 'America/Denver' });
      if (dt.isValid) return dt;
    }
    if (evt && evt.LocaleMessageTime) {
      // Last resort: parse LocaleMessageTime as ISO and convert to Denver.
      // NOTE: this is fallback only ‚Äî avoid relying on it for correctness.
      const dt = DateTime.fromISO(evt.LocaleMessageTime, { zone: 'utc' }).setZone('America/Denver');
      if (dt.isValid) return dt;
    }
    return null;
  };

  // ---------- PREFILTER: only keep events on same Denver date and (if refDt) that occurred <= refDt
  const relevantEvents = allEvents.filter(evt => {
    if (!isSameDenverDate(evt.Dateonly, refDt)) return false;
    if (!refDt) return true;
    const eDt = eventDtFor(evt);
    if (!eDt) return false; // cannot compare -> discard
    return eDt <= refDt;
  });

  // ---------- A) Evict ‚ÄúOut of office‚Äù using the last event per person (by eventDt)
  const lastByPerson = new Map(); // personKey -> evt
  const lastDtByPerson = new Map(); // personKey -> DateTime

  relevantEvents.forEach(evt => {
    const key = personKey(evt);
    const eDt = eventDtFor(evt);
    if (!eDt) return; // skip malformed
    const prevDt = lastDtByPerson.get(key);
    if (!prevDt || eDt > prevDt) {
      lastDtByPerson.set(key, eDt);
      lastByPerson.set(key, evt);
    }
  });

  const evicted = new Set();
  lastByPerson.forEach(evt => {
    if (
      evt.Direction === 'OutDirection'
      && mapDoorToFloor(evt.Door, evt.Direction) === 'Out of office'
    ) {
      evicted.add(personKey(evt));
    }
  });

  // active events are relevantEvents minus evicted persons
  const activeEvents = relevantEvents.filter(evt => !evicted.has(personKey(evt)));

  // ---------- 1) Live occupancy dedupe by last InDirection (use eventDt ordering)
  const todayIn = activeEvents.filter(e => e.Direction === 'InDirection');

  const latestByPerson = new Map();
  const latestDtByPerson = new Map();
  todayIn.forEach(e => {
    const key = personKey(e);
    const eDt = eventDtFor(e);
    if (!eDt) return;
    const prev = latestDtByPerson.get(key);
    if (!prev || eDt > prev) {
      latestDtByPerson.set(key, eDt);
      latestByPerson.set(key, e);
    }
  });
  const finalList = Array.from(latestByPerson.values());
  

  // ---------- 2) Floor breakdown & personnel counts (live)
  let employees = 0, contractors = 0;
  const floorMap = {};
  finalList.forEach(e => {
    const fl = mapDoorToFloor(e.Door, e.Direction);
    floorMap[fl] = floorMap[fl] || [];
    floorMap[fl].push(e);
    if (e.PersonnelType === 'Employee' || e.PersonnelType === 'Terminated Personnel') employees++;
    else if (e.PersonnelType) contractors++;
  });

  const floorBreakdown = Object.entries(floorMap).map(([floor, occ]) => {
    let empCount = 0, contractorCount = 0, tempBadgeCount = 0, otherCount = 0;
    occ.forEach(e => {
      switch (e.PersonnelType) {
        case 'Employee':
        case 'Terminated Personnel':
          empCount++; break;
        case 'Contractor':
        case 'Terminated Contractor':
          contractorCount++; break;
        case 'Temp Badge':
          tempBadgeCount++; break;
        default:
          otherCount++;
      }
    });
    return {
      floor,
      total: occ.length,
      employees: empCount,
      contractors: contractorCount,
      tempBadge: tempBadgeCount,
      others: otherCount,
      occupants: occ
    };
  });

  // ---------- 3) Personnel breakdown
  const personnelBreakdown = Array.from(
    finalList.reduce((m, e) => {
      m.set(e.PersonnelType, (m.get(e.PersonnelType) || 0) + 1);
      return m;
    }, new Map()),
    ([personnelType, count]) => ({ personnelType, count })
  );

  // ---------- 4) Swipe stats (fresh only) ‚Äî count only up to refDt
  const countUpToRef = (evt) => {
    if (!isSameDenverDate(evt.Dateonly, refDt)) return false;
    if (!refDt) return true;
    const eDt = eventDtFor(evt);
    if (!eDt) return false;
    return eDt <= refDt;
  };
  const totalInSwipes = (freshEvents || []).filter(e => e.Direction === 'InDirection' && countUpToRef(e)).length;
  const totalOutSwipes = (freshEvents || []).filter(e => e.Direction === 'OutDirection' && countUpToRef(e)).length;

  // ---------- 5) Floor In/Out summary (strict doors only)
  const validEvents = relevantEvents.filter(evt => {
    const doorNoTime = stripTimeSuffix(evt.Door.trim());
    const key = normalizeKey(doorNoTime, (evt.Direction || '').trim());
    return normalizedMonitoredKeys.has(key);
  });

  // Dedupe per person+floor+direction using eventDt ordering
  const deduped = new Map(); // mapKey -> evt
  validEvents.forEach(evt => {
    const rawNoTime = stripTimeSuffix(evt.Door);
    const m = rawNoTime.match(/HQ\.\s*(\d{1,2})\b/);
    const floor = m ? `Floor ${m[1]}` : 'Unknown Floor';

    const mapKey = `${personKey(evt)}___${floor}___${evt.Direction}`;
    const prev = deduped.get(mapKey);
    const nowDt = eventDtFor(evt);
    if (!nowDt) return;
    if (!prev) {
      deduped.set(mapKey, evt);
    } else {
      const prevDt = eventDtFor(prev);
      if (!prevDt || nowDt > prevDt) deduped.set(mapKey, evt);
    }
  });

  // Aggregate in/out per floor
  const floorMapIO = {};
  for (const evt of deduped.values()) {
    const rawNoTime = stripTimeSuffix(evt.Door);
    const m = rawNoTime.match(/HQ\.\s*(\d{1,2})\b/);
    const floor = m ? `Floor ${m[1]}` : 'Unknown Floor';

    if (!floorMapIO[floor]) floorMapIO[floor] = { inSwipes: 0, outSwipes: 0, inSet: new Set(), outSet: new Set() };
    const id = personKey(evt);
    if (evt.Direction === 'InDirection') {
      floorMapIO[floor].inSwipes++;
      floorMapIO[floor].inSet.add(id);
    } else {
      floorMapIO[floor].outSwipes++;
      floorMapIO[floor].outSet.add(id);
    }
  }

  const floorInOutSummary = Object.entries(floorMapIO).map(([floor, stats]) => {
    const inOnly = [...stats.inSet].filter(id => !stats.outSet.has(id));
    return {
      floor,
      inSwipes: stats.inSwipes,
      outSwipes: stats.outSwipes,
      inOnlyCount: inOnly.length,
      inOnlyPersons: inOnly
    };
  });

  // ---------- 6) Visited today breakdown (reuse computeVisitedToday; it already supports referenceDt)
  // const visited = computeVisitedToday(allEvents, refDt);
  const visited = computeVisitedToday(relevantEvents, refDt);

const visitedOccupants = relevantEvents
  .filter(e => eventDtFor(e) && eventDtFor(e) <= refDt)
  .reduce((map, e) => {
    const key = personKey(e);
    if (!map.has(key)) map.set(key, e); // keep first event for identity
    return map;
  }, new Map());

  // Build final payload
  const asOfLocal = refDt ? refDt.toISO() : DateTime.now().setZone('America/Denver').toISO();
  const asOfUTC = refDt ? refDt.toUTC().toISO() : new Date().toISOString();

  return {
    asOfLocal,
    asOfUTC,
    currentCount: finalList.length,
    floorBreakdown,
    personnelSummary: { employees, contractors },
    personnelBreakdown,
    totalVisitedToday: visited.total,
    visitedToday: {
      employees: visited.employees,
      contractors: visited.contractors,
      total: visited.total
    },
     visitedOccupants: Array.from(visitedOccupants.values()),  // üëà new full list
    swipeStats: { totalInSwipes, totalOutSwipes },
    floorInOutSummary
  };
}






// Live SSE endpoint with heartbeat + non-overlap + logging
exports.getDenverLiveOccupancy = async (req, res) => {
  try {
    // ensure poolPromise at least initialised (does not throw)
    const poolMaybe = await denver.poolPromise;
    if (!poolMaybe) {
      console.warn('‚ö†Ô∏è Denver poolPromise resolved to null ‚Äî DB likely unavailable');
    }
  } catch (err) {
    console.error('‚ùå Failed to initialize Denver pool in SSE endpoint:', err);
    // still continue but logs will show missing DB
  }

  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive'
  });
  res.write('\n');

  // heartbeat comment every 15s so clients do not time out
  const heartbeat = setInterval(() => {
    try {
      // SSE comment keeps connection alive but is ignored by EventSource data parser
      res.write(': heartbeat\n\n');
      if (typeof res.flush === 'function') res.flush();
    } catch (err) {
      console.warn('‚ö†Ô∏è Failed to send heartbeat (connection likely closed):', err);
    }
  }, 15_000);

  let lastSeen = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const events = [];
  let pushRunning = false;
  let consecutiveDbErrors = 0;

  const push = async () => {
    if (pushRunning) {
      // console.debug('[DENVER] push already running ‚Äî skipping this tick');
      return;
    }
    pushRunning = true;
    try {
      const fresh = await fetchNewEvents(lastSeen);

      if (fresh.length) {
        // update lastSeen to the latest event's LocaleMessageTime (string or Date)
        const lastEvt = fresh[fresh.length - 1];
        if (lastEvt && lastEvt.LocaleMessageTime) {
          lastSeen = new Date(lastEvt.LocaleMessageTime);
        } else {
          lastSeen = new Date();
        }
        events.push(...fresh);
        // console.log(`[DENVER] pushed ${fresh.length} new events ‚Äî events buffer now ${events.length}`);
      }

      // prune events not on today's Denver date (keep memory small)
      const todayDenver = DateTime.now().setZone('America/Denver').toISODate();
      for (let i = events.length - 1; i >= 0; i--) {
        const ts = events[i].Dateonly || (events[i].LocaleMessageTime ? DateTime.fromISO(events[i].LocaleMessageTime, { zone: 'utc' }).setZone('America/Denver').toISODate() : null);
        if (!ts || ts !== todayDenver) events.splice(i, 1);
      }

      // build payload
      let payload;
      try {
        payload = buildOccupancyForToday(events, fresh, null); // live mode (null => uses now)
      } catch (err) {
        console.error('[DENVER] Error building payload:', err);
        payload = {
          asOfLocal: DateTime.now().setZone('America/Denver').toISO(),
          asOfUTC: new Date().toISOString(),
          currentCount: 0,
          floorBreakdown: [],
          personnelSummary: { employees: 0, contractors: 0 },
          personnelBreakdown: [],
          totalVisitedToday: 0,
          visitedToday: { employees: 0, contractors: 0, total: 0 },
          swipeStats: { totalInSwipes: 0, totalOutSwipes: 0 },
          floorInOutSummary: []
        };
      }

      // write SSE event
      const sid = Date.now();
      try {
        res.write(`id: ${sid}\n`);
        res.write(`data: ${JSON.stringify(payload)}\n\n`);
        if (typeof res.flush === 'function') res.flush();
        // console.debug(`[DENVER] wrote payload id=${sid}`);
      } catch (err) {
        console.warn('[DENVER] Failed to write SSE payload (connection likely closed):', err);
      }

      consecutiveDbErrors = 0;
    } catch (err) {
      consecutiveDbErrors++;
      console.error('[DENVER] push top-level error:', err);
      // back off a bit if DB failing repeatedly
      if (consecutiveDbErrors > 3) {
        console.warn(`[DENVER] ${consecutiveDbErrors} consecutive DB errors ‚Äî sleeping 5s before next try`);
        await new Promise(r => setTimeout(r, 5000));
      }
    } finally {
      pushRunning = false;
    }
  };

  // run initial push, then interval
  await push();
  const timer = setInterval(push, 2000); // 2s interval and non-overlap guarded

  req.on('close', () => {
    clearInterval(timer);
    clearInterval(heartbeat);
    console.log('[DENVER] SSE client disconnected, cleared timers');
  });
};










// src/App.js
import React, { useEffect, useState, useMemo, lazy, Suspense } from 'react';
import { Container, Navbar, Nav, Form, Button, InputGroup } from 'react-bootstrap';
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';
import { FaSun } from 'react-icons/fa';
import OverlayTrigger from "react-bootstrap/OverlayTrigger";
import Tooltip from "react-bootstrap/Tooltip";
import './App.css';

// Lazy load pages
const DashboardHome = lazy(() => import('./pages/DashboardHome'));
const FloorDetailsPage = lazy(() => import('./pages/FloorDetailsPage'));
const DenverInOutInconsistencyPage = lazy(() => import('./pages/DenverInOutInconsistency'));

export default function App() {
  const [state, setState] = useState({
    floorData: [],
    personnelBreakdown: [],
    totalVisitedToday: 0,
    personnelSummary: { employees: 0, contractors: 0 },
    visitedToday: { employees: 0, contractors: 0, total: 0 },
    floorInOutSummary: [],
    liveVisitedOccupants: [],
    visitedOccupants: [],
    inOutData: null,
    loadingInOut: true,
    inOutError: null,
    snapshotMode: false,
    snapshotTime: '',
    snapshotDate: new Date().toLocaleDateString('en-CA', { timeZone: 'America/Denver' }),
    snapshotLoading: false,
    snapshotError: null,
    snapshotData: null
  });

  // SSE for live occupancy
  useEffect(() => {
    const es = new EventSource('http://10.199.22.57:3013/api/live-occupancy-denver');

    es.onmessage = e => {
      try {
        const p = JSON.parse(e.data);
        setState(prev => ({
          ...prev,
          floorData: p.floorBreakdown || [],
          personnelBreakdown: p.personnelBreakdown || [],
          totalVisitedToday: p.totalVisitedToday || 0,
          personnelSummary: p.personnelSummary || { employees: 0, contractors: 0 },
          visitedToday: p.visitedToday || { employees: 0, contractors: 0, total: 0 },
          floorInOutSummary: p.floorInOutSummary || [],
          liveVisitedOccupants: p.visitedOccupants || [],
          visitedOccupants: prev.snapshotMode ? prev.visitedOccupants : (p.visitedOccupants || [])
        }));
      } catch (err) {
        console.error('SSE parse error:', err);
      }
    };

    es.onerror = err => {
      console.error('SSE error:', err);
      es.close();
    };

    return () => es.close();
  }, []);

  // Fetch in/out inconsistency once
  useEffect(() => {
    fetch('http://10.199.22.57:3013/api/inout-inconsistency-denver')
      .then(res => res.ok ? res.json() : Promise.reject(`HTTP ${res.status} - ${res.statusText}`))
      .then(data => setState(prev => ({ ...prev, inOutData: data.floorInconsistency || [], loadingInOut: false })))
      .catch(err => setState(prev => ({ ...prev, inOutError: err.toString(), loadingInOut: false })));
  }, []);

  // Snapshot handlers
  const handleSnapshotTimeChange = e => setState(prev => ({ ...prev, snapshotTime: e.target.value, snapshotError: null }));
  const handleSnapshotDateChange = e => setState(prev => ({ ...prev, snapshotDate: e.target.value, snapshotError: null }));

  function getDenverNowIsoString() {
    const fmt = new Intl.DateTimeFormat('en-CA', {
      timeZone: 'America/Denver',
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
    });
    const parts = fmt.formatToParts(new Date());
    const m = {};
    parts.forEach(p => { if (p.type !== 'literal') m[p.type] = p.value; });
    return `${m.year}-${m.month}-${m.day}T${m.hour}:${m.minute}:${m.second}`;
  }

  const applySnapshot = async () => {
    const { snapshotTime, snapshotDate } = state;
    if (!snapshotTime || !snapshotDate) {
      setState(prev => ({ ...prev, snapshotError: 'Select date and time first.' }));
      return;
    }

    const timeForApi = snapshotTime.length === 5 ? `${snapshotTime}:00` : snapshotTime;
    const snapshotIso = `${snapshotDate}T${timeForApi}`;
    const nowDenverIso = getDenverNowIsoString();

    if (snapshotIso > nowDenverIso) {
      const msg = 'Snapshot cannot be in the future.';
      setState(prev => ({ ...prev, snapshotError: msg }));
      return;
    }

    setState(prev => ({ ...prev, snapshotLoading: true, snapshotError: null }));
    try {
      const resp = await fetch(`http://10.199.22.57:3013/api/occupancy-at-time-denver?date=${encodeURIComponent(snapshotDate)}&time=${encodeURIComponent(timeForApi)}`);
      if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
      const json = await resp.json();
      setState(prev => ({
        ...prev,
        snapshotData: json,
        visitedOccupants: json.visitedOccupants || [],
        snapshotMode: true
      }));
    } catch (err) {
      setState(prev => ({ ...prev, snapshotError: err.message || 'Failed to fetch snapshot', snapshotData: null, snapshotMode: false }));
    } finally {
      setState(prev => ({ ...prev, snapshotLoading: false }));
    }
  };

  const clearSnapshot = () => {
    setState(prev => ({
      ...prev,
      snapshotMode: false,
      snapshotData: null,
      snapshotTime: '',
      snapshotError: null,
      snapshotLoading: false,
      visitedOccupants: prev.liveVisitedOccupants
    }));
  };

  // Memoized active data
  const activeFloorData = useMemo(() => state.snapshotMode && state.snapshotData ? state.snapshotData.floorBreakdown || [] : state.floorData, [state.snapshotMode, state.snapshotData, state.floorData]);
  const activePersonnelBreakdown = useMemo(() => state.snapshotMode && state.snapshotData ? state.snapshotData.personnelBreakdown || [] : state.personnelBreakdown, [state.snapshotMode, state.snapshotData, state.personnelBreakdown]);
  const activeVisitedOccupants = useMemo(() => state.snapshotMode && state.snapshotData ? state.snapshotData.visitedOccupants || [] : state.visitedOccupants, [state.snapshotMode, state.snapshotData, state.visitedOccupants]);
  const activeTotalVisitedToday = useMemo(() => state.snapshotMode && state.snapshotData ? state.snapshotData.totalVisitedToday || 0 : state.totalVisitedToday, [state.snapshotMode, state.snapshotData, state.totalVisitedToday]);
  const activePersonnelSummary = useMemo(() => state.snapshotMode && state.snapshotData ? state.snapshotData.personnelSummary || { employees: 0, contractors: 0 } : state.personnelSummary, [state.snapshotMode, state.snapshotData, state.personnelSummary]);
  const activeVisitedToday = useMemo(() => state.snapshotMode && state.snapshotData ? state.snapshotData.visitedToday || { employees: 0, contractors: 0, total: 0 } : state.visitedToday, [state.snapshotMode, state.snapshotData, state.visitedToday]);
  const activeFloorInOutSummary = useMemo(() => state.snapshotMode && state.snapshotData ? state.snapshotData.floorInOutSummary || [] : state.floorInOutSummary, [state.snapshotMode, state.snapshotData, state.floorInOutSummary]);

  let snapshotLabel = null;
  if (state.snapshotMode && state.snapshotData) {
    const asOfLocal = state.snapshotData.asOfLocal || state.snapshotData.asOf || state.snapshotData.asOfUTC;
    const formatted = asOfLocal ? new Date(asOfLocal).toLocaleString('en-US', { timeZone: 'America/Denver' }) : `${state.snapshotDate} ${state.snapshotTime}`;
    snapshotLabel = <div style={{ background: '#363d37', color: '#FFF', padding: '8px 16px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', borderLeft: '4px solid rgb(11,248,3)', marginBottom: 8 }}> Snapshot: {formatted} (Denver) </div>;
  }

  return (
    <BrowserRouter>
      <div className="dark-theme">
        <Navbar bg="dark" variant="dark" expand="lg" className="px-4 navbar-infographic">
          <Navbar.Brand as={Link} to="/" className="wu-brand">Live Occupancy ‚Äî Western Union Denver</Navbar.Brand>
          <Nav className="ms-auto align-items-center">
            <OverlayTrigger placement="bottom" overlay={<Tooltip id="tooltip-dashboard">Dashboard</Tooltip>}>
              <Nav.Link as={Link} to="/" className="nav-item-infographic"><i className="bi bi-house"></i></Nav.Link>
            </OverlayTrigger>
            <OverlayTrigger placement="bottom" overlay={<Tooltip id="tooltip-history">History</Tooltip>}>
              <Nav.Link href="http://10.199.22.57:3002/partition/US.CO.OBS/history" className="nav-item-infographic"><i className="bi bi-clock-history"></i></Nav.Link>
            </OverlayTrigger>
            <OverlayTrigger placement="bottom" overlay={<Tooltip id="tooltip-details">Details</Tooltip>}>
              <Nav.Link as={Link} to="/floor-details" className="nav-item-infographic"><i className="fa-solid fa-calendar-day"></i></Nav.Link>
            </OverlayTrigger>
            <Form className="d-flex align-items-center ms-3" onSubmit={e => e.preventDefault()}>
              <InputGroup>
                <Form.Control type="date" value={state.snapshotDate} onChange={handleSnapshotDateChange} style={{ maxWidth: 150 }} />
                <Form.Control type="time" step="1" value={state.snapshotTime} onChange={handleSnapshotTimeChange} style={{ maxWidth: 120 }} />
                <Button variant="outline-light" onClick={applySnapshot} disabled={state.snapshotLoading}>{state.snapshotLoading ? 'Loading‚Ä¶' : 'Apply'}</Button>
                <Button variant="outline-secondary" onClick={clearSnapshot} className="ms-1">Clear</Button>
              </InputGroup>
            </Form>
            <Nav.Link className="theme-toggle-icon" title="Dark mode only"><FaSun color="#FFC72C" /></Nav.Link>
          </Nav>
        </Navbar>

        <Container fluid className="mt-4">
          {snapshotLabel}
          {state.snapshotError && <span style={{ color: 'salmon', marginLeft: 10 }}>{state.snapshotError}</span>}

          <Suspense fallback={<div>Loading dashboard...</div>}>
            <Routes>
              <Route path="/" element={
                <DashboardHome
                  personnelSummary={activePersonnelSummary}
                  totalVisitedToday={activeTotalVisitedToday}
                  visitedToday={activeVisitedToday}
                  visitedOccupants={activeVisitedOccupants}
                  floorData={activeFloorData}
                  personnelBreakdown={activePersonnelBreakdown}
                  floorInOutSummary={activeFloorInOutSummary}
                  rejectionSnapshot={state.snapshotMode && state.snapshotData ? state.snapshotData.rejections || state.snapshotData.rejectionAllDetailsToday || [] : null}
                />
              } />
              <Route path="/floor-details" element={<FloorDetailsPage floorData={activeFloorData} floorInOutSummary={activeFloorInOutSummary} visitedOccupants={activeVisitedOccupants} />} />
              <Route path="/inout-inconsistency-denver" element={<DenverInOutInconsistencyPage data={state.inOutData} loading={state.loadingInOut} error={state.inOutError} />} />
            </Routes>
          </Suspense> {/* <-- Fixed: Suspense properly closed */}
        </Container>
      </div>
    </BrowserRouter>
  );
}




