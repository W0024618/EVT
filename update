Please cross-validate the data and send me the comparison report.
Please highlight any employees with duration mismatches.




Please cross-validate the data and send me a comparison report, highlighting any employees with duration mismatches.






Subject: APAC Pune — September Duration Report — Please cross-validate

Hi Manisha,

Please find attached the APAC Pune duration report for September.
Could you cross-validate the data and send a comparison report to this same email?
Please highlight any employees with duration mismatches.

Thanks,
Swapnil










//C:\Users\W0024618\Desktop\global-page\backend\services\reportService.js

 import { getPool, sql } from '../config/dbConfig.js';


export async function listLocations(region) {
  if (!region) throw new Error('region required');
  const pool = await getPool(region);
  const req = pool.request();
  // get distinct PartitionName2 values
  const q = `SELECT DISTINCT PartitionName2 FROM ACVSUJournalLog WHERE PartitionName2 IS NOT NULL ORDER BY PartitionName2`;
  const { recordset } = await req.query(q);
  return (recordset || []).map(r => r.PartitionName2).filter(Boolean);
}

/**
 * Search employees by name or employee id fragment
 * q: search string (partial), region: region key for getPool
 */
export async function searchEmployees(region = 'emea', q = '') {
  const pool = await getPool(region);
  const req = pool.request();
  const like = `%${q}%`;
  req.input('q', sql.NVarChar(200), like);

  // search common personnel name field (Text1) and numeric EmployeeID (Int1) and Text12 (contractor id)
  const query = `
    SELECT TOP (200)
      CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR(50)) END AS EmployeeID,
      ISNULL(t2.Text1, '') AS Name
    FROM ACVSCore.Access.Personnel AS t2
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId = t3.ObjectID
    WHERE (t2.Text1 LIKE @q) OR (CAST(t2.Int1 AS NVARCHAR(50)) LIKE @q) OR (t2.Text12 LIKE @q)
    ORDER BY t2.Text1;
  `;
  const { recordset } = await req.query(query);
  return (recordset || []).map(r => ({ EmployeeID: r.EmployeeID, Name: r.Name }));
}



export async function rawReport(region, { startDate, endDate, location, admitFilter = 'all' }) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  // const pool = await getPool(region);
  // const req = pool.request();

  const pool = await getPool(region);
  const req = pool.request();
  // increase timeout for this request (ms) — set to 5 minutes
  req.timeout = 300000;


  // Accept NULL for location to mean "all partitions in this region DB"
  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;

  req.input('location', sql.NVarChar(200), locationParam);
  req.input('startDate', sql.Date, startDate);
  req.input('endDate', sql.Date, endDate);
  req.input('admitFilter', sql.NVarChar(20), String(admitFilter || 'all'));

  const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    -- message types we consider
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    -- location optional filter
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    -- admit/reject filter: 'all' | 'admit' | 'reject' (case-insensitive)
    AND (
      UPPER(ISNULL(@admitFilter,'all')) = 'ALL'
      OR (UPPER(@admitFilter) = 'ADMIT'  AND t1.MessageType = 'CardAdmitted')
      OR (UPPER(@admitFilter) = 'REJECT' AND t1.MessageType = 'CardRejected')
    )
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM CombinedQuery
ORDER BY LocaleMessageTime ASC;
`;

  const { recordset } = await req.query(query);
  return recordset;
}





export async function rejectionReport(region, { startDate, endDate, location } = {}) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  // const pool = await getPool(region);
  // const req = pool.request();

   const pool = await getPool(region);
  const req = pool.request();
  // increase timeout for this request (ms) — set to 5 minutes
  req.timeout = 300000;


  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;

  req.input('location', sql.NVarChar(200), locationParam);
  req.input('startDate', sql.Date, startDate);
  req.input('endDate', sql.Date, endDate);

  const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType = 'CardRejected'
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
),
Unified AS (
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Lost'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Clearance'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type IN ('CardDisabled','Disabled')
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Stolen'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Expired'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'PIN'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'UnknownCard'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'SiteCode'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'NotActivated'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'FacilityCode'
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM Unified
ORDER BY LocaleMessageTime DESC;
`;

  const { recordset } = await req.query(query);
  return recordset;
}

// // backend/services/reportService.js
export async function dailyAccessReportEMEA({ from, to, employees = '' }) {
  const pool = await getPool('emea');
  const req  = pool.request();

  req.input('fromDate', sql.Date, from);
  req.input('toDate',   sql.Date, to);
  const employeesParam = (employees && String(employees).trim()) ? String(employees).trim() : null;
  req.input('employees', sql.NVarChar(sql.MAX), employeesParam);

  const query = `

  -- expects parameters: @fromDate (DATE), @toDate (DATE), @employees (NVARCHAR(MAX) | NULL)
DECLARE @empCSV NVARCHAR(MAX) = @employees;

;WITH EmpList AS (
  SELECT LTRIM(RTRIM(value)) AS emp
  FROM STRING_SPLIT(ISNULL(@empCSV,''), ',')
  WHERE LTRIM(RTRIM(value)) <> ''
)

-- Raw rows: compute LocaleMessageTime once and use OUTER APPLY to avoid duplicate shreddes
, RawSwipes AS (
  SELECT
    t1.ObjectName1,
    t1.ObjectName2,
    t1.MessageType,
    t2.Text12       AS EmployeeID,
    CAST(t2.Int1 AS NVARCHAR(50)) AS NumericEmployeeID,
    t3.Name         AS PersonnelType,
    t1.PartitionName2 AS PartitionName2,

    -- compute local wall-clock once (DO NOT change sign here; using your -1 * MessageLocaleOffset)
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,

    -- direction/value picked by OUTER APPLY (single row)
    CASE
      WHEN dir.Value = 'InDirection'  THEN 'IN'
      WHEN dir.Value = 'OutDirection' THEN 'OUT'
      ELSE 'Unknown'
    END AS Swipe,

    card.Value AS CardNumber
  FROM ACVSUJournal_00011028.dbo.ACVSUJournalLog AS t1
  INNER JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  INNER JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID

  -- pick at most one direction shred row (InDirection/OutDirection)
  OUTER APPLY (
    SELECT TOP (1) s.Value
    FROM ACVSUJournal_00011028.dbo.ACVSUJournalLogxmlShred AS s
    WHERE s.GUID = t1.XmlGUID
      AND s.Value IN ('InDirection','OutDirection')
  ) AS dir

  -- pick at most one numeric card value (exclude direction values, ensure numeric)
  OUTER APPLY (
    SELECT TOP (1) s.Value
    FROM ACVSUJournal_00011028.dbo.ACVSUJournalLogxmlShred AS s
    WHERE s.GUID = t1.XmlGUID
      AND s.Value NOT IN ('InDirection','OutDirection')
      AND s.Value NOT LIKE '%[^0-9]%'
      AND s.Value IS NOT NULL
      AND LTRIM(RTRIM(s.Value)) <> ''
  ) AS card
)

-- Strict time window: >= 08:00 on @fromDate, and < 08:00 on @toDate
, Windowed AS (
  SELECT *
  FROM RawSwipes
  WHERE
    LocaleMessageTime >= DATEADD(HOUR, 8, CAST(@fromDate AS DATETIME))
    -- NOTE: removed extra DATEADD(DAY,1,...) — upper bound should be < toDate 08:00
    AND LocaleMessageTime <  DATEADD(HOUR, 8, CAST(@toDate AS DATETIME))
    AND Swipe IN ('IN','OUT') -- only real swipes
)

-- final projection + optional employee filter (supports CSV of names or IDs)
SELECT
  ObjectName1,
  ObjectName2,
  PersonnelType,
  EmployeeID,
  NumericEmployeeID,
  -- alias PartitionName2 -> location so frontend sees r.location
  PartitionName2 AS location,
  -- alias MessageType -> Messagetype so frontend sees r.Messagetype
  MessageType AS Messagetype,
  Swipe,
  CardNumber,
  LocaleMessageTime
FROM Windowed w
WHERE
  (
    @empCSV IS NULL
    OR LTRIM(RTRIM(@empCSV)) = ''
    OR EXISTS (
      SELECT 1
      FROM EmpList e
      WHERE
        e.emp = LTRIM(RTRIM(w.ObjectName1))
        OR e.emp = w.EmployeeID
        OR e.emp = w.NumericEmployeeID
    )
  )
ORDER BY LocaleMessageTime;

`;

  const { recordset } = await req.query(query);
  return recordset;
}










/**
 * In-vs-Out Report (parameterized) — groups by employee & month
 */
export async function inOutReport(region, { year, month, doors }) {
 // const pool = await getPool(region);
  // const req  = pool.request();

    const pool = await getPool(region);
  const req = pool.request();
  // increase timeout for this request (ms) — set to 5 minutes
  req.timeout = 300000;


  req.input('TargetYear',  sql.Int, year);
  req.input('TargetMonth', sql.Int, month);
  doors.forEach((d, i) => req.input(`door${i}`, sql.NVarChar, d));
  const doorList = doors.map((_, i) => `@door${i}`).join(',');

  const query = `
WITH CombinedQuery AS (
  SELECT
    DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
    t1.ObjectName1,
    t1.PartitionName2    AS location,
    t5_card.CardNumber,
    t5_dir.value         AS Direction,
    CASE
      WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
      ELSE CAST(t2.Int1 AS NVARCHAR)
    END                    AS EmployeeID,
    t3.Name               AS PersonnelType
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID
    AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml AS t_xml
    ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard
    ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  WHERE
    YEAR(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetYear
    AND MONTH(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetMonth
    AND t1.ObjectName2 IN (${doorList})
)
SELECT
  FORMAT(LocaleMessageTime,'yyyy-MM')    AS Month,
  ObjectName1                           AS EmployeeName,
  EmployeeID,
  PersonnelType,
  location,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)  AS In_Count,
  SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS Out_Count,
  COUNT(*)                                                 AS TotalSwipes,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)
  - SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS InOut_Difference
FROM CombinedQuery
GROUP BY FORMAT(LocaleMessageTime,'yyyy-MM'),
         ObjectName1, EmployeeID, PersonnelType, location
ORDER BY Month DESC, EmployeeName;
`;

  const { recordset } = await req.query(query);
  return recordset;
}



/**
 * Time Duration Report (parameterized by region, partition, startDate)
 */
export async function timeDurationReport(region, { partition = 'Default', startDate }) {
  // const pool = await getPool(region);
  // const req  = pool.request();

    const pool = await getPool(region);
 const req = pool.request();
 // increase timeout for this request (ms) — set to 5 minutes
  req.timeout = 300000;


  // bind inputs
  const fullPartition = `${region.toUpperCase()}.${partition}`;
  req.input('partition', sql.NVarChar, fullPartition);
  req.input('startDate', sql.Date, startDate);

  const query = `

SELECT 
    t1.[ObjectName1],
    t1.[ObjectName2],
    t1.[PartitionName2],
    CASE
        WHEN t2.[Int1] = 0 THEN t2.[Text12]
        ELSE CAST(t2.[Int1] AS NVARCHAR)
    END AS EmployeeID,
    t3.[Name] AS PersonnelType,
    t2.text5,
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    DATEADD(HOUR, -2, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) AS AdjustedMessageTime
INTO 
    #CombinedEmployeeData
FROM 
    [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] AS t1
INNER JOIN 
    [ACVSCore].[Access].[Personnel] AS t2
    ON t1.ObjectIdentity1 = t2.GUID
INNER JOIN 
    [ACVSCore].[Access].[PersonnelType] AS t3
    ON t2.[PersonnelTypeId] = t3.[ObjectID];

-- Step 2: Daily duration per employee
WITH DailyDurations AS (
    SELECT 
        [ObjectName1],
        PersonnelType,
        EmployeeID,
        [PartitionName2],
        text5,
        CONVERT(DATE, AdjustedMessageTime) AS ShiftedDate,
        DATEPART(WEEK, AdjustedMessageTime) AS WeekNumber,
        DATEPART(YEAR, AdjustedMessageTime) AS YearNumber,
        MIN(LocaleMessageTime) AS FirstSwipeTime,
        MAX(LocaleMessageTime) AS LastSwipeTime,
        DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) AS DurationMinutes,
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) / 60 AS NVARCHAR), 2)
        + ':' +
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) % 60 AS NVARCHAR), 2) AS DurationHHMM,
        CASE 
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 5 THEN '<5mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 10 THEN '<10mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 20 THEN '<20mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 30 THEN '<30mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 60 THEN '<1hr'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 120 THEN 'Less than <2hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 180 THEN 'Less than <3hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 240 THEN 'Less than <4hrs'
            ELSE '4+ hrs'
        END AS TimeDiffCategory
    FROM 
        #CombinedEmployeeData



  WHERE CONVERT(DATE, AdjustedMessageTime) >= @startDate

   AND [PartitionName2] = 'APAC.Default'
        AND PersonnelType IN ('Employee', 'Terminated Personnel')
    GROUP BY 
        [ObjectName1], EmployeeID, PersonnelType, text5, [PartitionName2],
        CONVERT(DATE, AdjustedMessageTime),
        DATEPART(WEEK, AdjustedMessageTime),
        DATEPART(YEAR, AdjustedMessageTime)
),

-- Step 3: Weekly summary
WeeklySummary AS (
    SELECT 
        EmployeeID,
        [ObjectName1],
        PersonnelType,
        text5,
        [PartitionName2],
        YearNumber,
        WeekNumber,
        COUNT(DISTINCT ShiftedDate) AS DaysPresentInWeek,
        SUM(CASE WHEN DurationMinutes < 240 THEN 1 ELSE 0 END) AS ViolationDaysInWeek
    FROM 
        DailyDurations
    GROUP BY 
        EmployeeID, [ObjectName1], PersonnelType, text5, [PartitionName2], YearNumber, WeekNumber
)

-- Step 4: Final output with daily duration, category, and defaulter flag
SELECT 
    dd.EmployeeID,
    dd.ObjectName1,
    dd.PersonnelType,
    dd.text5,
    dd.PartitionName2,
    dd.YearNumber,
    dd.WeekNumber,
    dd.ShiftedDate,
    dd.FirstSwipeTime,
    dd.LastSwipeTime,
    dd.DurationHHMM,
    dd.TimeDiffCategory,
    ws.DaysPresentInWeek,
    ws.ViolationDaysInWeek,
    (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) AS CleanDaysInWeek,
    CASE
        WHEN (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) < 3 THEN 'Yes'
        ELSE 'No'
    END AS Defaulter
FROM 
    DailyDurations dd
JOIN 
    WeeklySummary ws
    ON dd.EmployeeID = ws.EmployeeID
    AND dd.WeekNumber = ws.WeekNumber
    AND dd.YearNumber = ws.YearNumber
ORDER BY 
    dd.YearNumber DESC, dd.WeekNumber DESC, dd.EmployeeID, dd.ShiftedDate;
  `;

  const { recordset } = await req.query(query);
  return recordset;
}


//EUROC 




export async function eurocAdmitRejectionReport(region, { reportDate }) {
  // const pool = await getPool(region);
  // const req  = pool.request();

    const pool = await getPool(region);
  const req = pool.request();
  // increase timeout for this request (ms) — set to 5 minutes
  req.timeout = 300000;


  // enforce location LT.Vilnius (as requested)
  req.input('location', sql.NVarChar, 'LT.Vilnius');
  // reportDate should be YYYY-MM-DD or Date — bind as sql.Date
  req.input('reportDate', sql.Date, reportDate);

  const query = `
/*
  Approach:
  1) Build CombinedQuery as a CTE and SELECT INTO #Combined (materialize)
  2) Build #Admits (with ROW_NUMBER) and #Rejections from #Combined
  3) Return three resultsets: admits (rn=1), rejections (all), summary (counts)
*/

WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    AND t1.PartitionName2 = @location
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @reportDate
)

-- materialize CombinedQuery into a temp table
SELECT
  LocaleMessageTime,
  CONVERT(date, LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  MessageType
INTO #Combined
FROM CombinedQuery;

-- create admits with row number (first admit per employee)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  ROW_NUMBER() OVER (PARTITION BY ISNULL(EmployeeID, CardNumber) ORDER BY LocaleMessageTime ASC) AS rn
INTO #Admits
FROM #Combined
WHERE MessageType = 'CardAdmitted'
  AND PersonnelType = 'Employee';

-- create rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
INTO #Rejections
FROM #Combined
WHERE MessageType = 'CardRejected';

-- resultset 1: admits (only rn = 1)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Admits
WHERE rn = 1
ORDER BY LocaleMessageTime ASC;

-- resultset 2: rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Rejections
ORDER BY LocaleMessageTime ASC;

-- resultset 3: summary counts by Rejection_Type
SELECT
  ISNULL(Rejection_Type, 'Unknown') AS Rejection_Type,
  COUNT(*) AS CountVal
FROM #Rejections
GROUP BY ISNULL(Rejection_Type, 'Unknown')
ORDER BY CountVal DESC;

-- cleanup temp tables (optional — they scope to the session and will go away automatically,
-- but good practice to drop)
DROP TABLE IF EXISTS #Admits;
DROP TABLE IF EXISTS #Rejections;
DROP TABLE IF EXISTS #Combined;
`;

  const result = await req.query(query);
  // result.recordsets is an array of resultsets
  const recordsets = result.recordsets || [];
  const admitRows = (recordsets[0] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const rejectRows = (recordsets[1] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Rejection_Type: r.Rejection_Type,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const summaryRows = (recordsets[2] || []).map(r => ({ Rejection_Type: r.Rejection_Type, Count: r.CountVal }));

  return { admit: admitRows, rejection: rejectRows, summary: summaryRows };
}

















//2



// C:\Users\W0024618\Desktop\global-page\backend\routes\reports.js


 import express from 'express';
import {
  rawReport,
  rejectionReport,
  dailyAccessReportEMEA,
   inOutReport,
  timeDurationReport,
  eurocAdmitRejectionReport
} from '../services/reportService.js';
import { listLocations, searchEmployees } from '../services/reportService.js';

const router = express.Router();

// router.get('/raw', rawReportHandler);





router.get('/locations', async (req, res) => {
  try {
    const region = (req.query.region || 'emea').toString().toLowerCase();
    // for 'global' you could optionally return combined results by calling each region's pool,
    // but frontend already calls fetchLocationsForRegion per region when region==='global'.
    const locations = await listLocations(region);
    res.json({ data: locations });
  } catch (err) {
    console.error('GET /api/locations err', err);
    res.status(500).json({ error: err.message || 'failed' });
  }
});

router.get('/employees', async (req, res) => {
  try {
    const q = (req.query.q || '').toString();
    const region = (req.query.region || 'emea').toString().toLowerCase();
    if (!q || q.length < 2) return res.json({ data: [] });
    const rows = await searchEmployees(region, q);
    // return as array of objects
    res.json({ data: rows });
  } catch (err) {
    console.error('GET /api/employees err', err);
    res.status(500).json({ error: err.message || 'failed' });
  }
});




// Helper to unify GET/POST inputs
function getParam(req, name, defaultValue = undefined) {
  if (req.method === 'GET') {
    return req.query[name] ?? defaultValue;
  } else {
    return req.body[name] ?? defaultValue;
  }
}

// Middleware to ensure `region` is defined
function requireRegion(req, res, next) {
  const region = getParam(req, 'region');
  if (!region) {
    return res
      .status(400)
      .json({ error: "Missing required parameter: 'region'" });
  }
  next();
}



// RAW Report handler
// async function handleRaw(req, res, next) {
//   try {
//     const region    = getParam(req, 'region');
//     const startDate = getParam(req, 'startDate');
//     if (!startDate) {
//       return res
//         .status(400)
//         .json({ error: "Missing required parameter: 'startDate'" });
//     }
//     const data = await rawReport(region, { startDate });
//     res.json({ data });
//   } catch (err) {
//     next(err);
//   }
// }


async function handleRaw(req, res, next) {
  try {
    const region = getParam(req, 'region');
    const startDateParam = getParam(req, 'startDate');
    const endDateParam = getParam(req, 'endDate');
    const location = getParam(req, 'location', undefined);
    const admitFilter = getParam(req, 'admitFilter', 'all');

    if (!startDateParam || !endDateParam) {
      return res
        .status(400)
        .json({ error: "Missing required parameters: 'startDate' and/or 'endDate'" });
    }

    const startDate = new Date(startDateParam);
    const endDate = new Date(endDateParam);
    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      return res.status(400).json({ error: "Invalid date format for startDate/endDate" });
    }

    // call service with validated params (service expects startDate & endDate + optional location & admitFilter)
    const data = await rawReport(region, { startDate, endDate, location, admitFilter });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}



router.get ('/raw',  requireRegion, handleRaw);
router.post('/raw',  requireRegion, handleRaw);


// Rejection Report handler (supports region=global)
async function handleRejection(req, res, next) {
  try {
    const regionRaw = getParam(req, 'region');
    const region = (regionRaw || '').toString().toLowerCase();
    const startDateParam = getParam(req, 'startDate');
    const endDateParam = getParam(req, 'endDate');
    const location = getParam(req, 'location', undefined);

    if (!startDateParam || !endDateParam) {
      return res
        .status(400)
        .json({ error: "Missing required parameters: 'startDate' and/or 'endDate'" });
    }

    const startDate = new Date(startDateParam);
    const endDate = new Date(endDateParam);
    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      return res.status(400).json({ error: "Invalid date format for startDate/endDate" });
    }

    const ALL_REGIONS = ['apac', 'emea', 'laca', 'namer'];

    if (region === 'global') {
      const promises = ALL_REGIONS.map(r => rejectionReport(r, { startDate, endDate, location }));
      const results = await Promise.all(promises);
      const merged = results.flat();
      // sort by LocaleMessageTime desc (most recent first)
      merged.sort((a, b) => {
        const ta = a.LocaleMessageTime ? new Date(a.LocaleMessageTime).getTime() : 0;
        const tb = b.LocaleMessageTime ? new Date(b.LocaleMessageTime).getTime() : 0;
        return tb - ta;
      });
      return res.json({ data: merged });
    }

    // single-region
    const data = await rejectionReport(region, { startDate, endDate, location });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}

router.get('/rejection', requireRegion, handleRejection);
router.post('/rejection', requireRegion, handleRejection);





// Daily Access Report handler
async function handleDailyAccess(req, res, next) {
  try {
    const region    = getParam(req, 'region');
    const from      = getParam(req, 'from');
    const to        = getParam(req, 'to');
    if (!from || !to) {
      return res
        .status(400)
        .json({ error: "Missing required parameters: 'from' and/or 'to'" });
    }
    // employees: POST expects array, GET expects comma-separated string
    let employees = getParam(req, 'employees', []);
    if (typeof employees === 'string') {
      employees = employees.split(',').map(s => s.trim()).filter(Boolean);
    }
    if (!Array.isArray(employees) || employees.length === 0) {
      return res
        .status(400)
        .json({ error: "Missing or empty required parameter: 'employees'" });
    }
    const data = await dailyAccessReportEMEA({ from, to });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}
router.get ('/daily-access',  requireRegion, handleDailyAccess);
router.post('/daily-access',  requireRegion, handleDailyAccess);

// In vs Out Report handler
async function handleInOut(req, res, next) {
  try {
    const region = getParam(req, 'region');
    const year   = parseInt(getParam(req, 'year'),  10);
    const month  = parseInt(getParam(req, 'month'), 10);
    if (Number.isNaN(year) || Number.isNaN(month)) {
      return res
        .status(400)
        .json({ error: "Missing or invalid parameters: 'year' and/or 'month'" });
    }
    // doors: POST expects array, GET expects comma-separated string
    let doors = getParam(req, 'doors', []);
    if (typeof doors === 'string') {
      doors = doors.split(',').map(s => s.trim()).filter(Boolean);
    }
    if (!Array.isArray(doors) || doors.length === 0) {
      return res
        .status(400)
        .json({ error: "Missing or empty required parameter: 'doors'" });
    }
    const data = await inOutReport(region, { year, month, doors });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}
router.get ('/in-out',  requireRegion, handleInOut);
router.post('/in-out',  requireRegion, handleInOut);


// Time Duration Report handler
async function handleTimeDuration(req, res, next) {
  try {
    const region    = getParam(req, 'region');
    const startDate = getParam(req, 'startDate');
    const partition = getParam(req, 'partition', 'Default');

    if (!startDate) {
      return res
        .status(400)
        .json({ error: "Missing required parameter: 'startDate'" });
    }

    const data = await timeDurationReport(region, { partition, startDate });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}
router.get('/time-duration',  requireRegion, handleTimeDuration);
router.post('/time-duration', requireRegion, handleTimeDuration);





// EUROC Admit-Rejection handler
async function handleEuroc(req, res, next) {
  try {
    const region = getParam(req, 'region');
    const dateParam = getParam(req, 'date'); // expected YYYY-MM-DD or JS date string
    if (!region || region.toLowerCase() !== 'emea') {
      return res.status(400).json({ error: "EUROC report only supported for region 'emea'" });
    }
    if (!dateParam) {
      return res.status(400).json({ error: "Missing required parameter: 'date' (YYYY-MM-DD)" });
    }
    // normalize date (send only date part)
    const dt = new Date(dateParam);
    if (Number.isNaN(dt.getTime())) {
      return res.status(400).json({ error: "Invalid date parameter" });
    }
    const isoDate = dt.toISOString().slice(0, 10); // YYYY-MM-DD
    const data = await eurocAdmitRejectionReport(region, { reportDate: isoDate });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}
router.get('/euroc-admit-rejection', requireRegion, handleEuroc);
router.post('/euroc-admit-rejection', requireRegion, handleEuroc);



export default router;












//3





//C:\Users\W0024618\Desktop\global-page\backend\controllers\reportController.js
import { rawReport } from '../services/reportService.js';

const ALL_REGIONS = ['apac', 'emea', 'laca', 'namer'];

export async function rawReportHandler(req, res) {
  try {
    const regionRaw = (req.query.region || '').toString();
    const region = regionRaw.toLowerCase();
    const location = req.query.location ? req.query.location.toString().trim() : undefined;
    const startDateParam = req.query.startDate;
    const endDateParam = req.query.endDate;
    const admitFilter = req.query.admitFilter ? req.query.admitFilter.toString().toLowerCase() : 'all';

    if (!region) return res.status(400).json({ success: false, message: 'region required' });
    if (!startDateParam || !endDateParam) {
      return res.status(400).json({ success: false, message: 'startDate and endDate required' });
    }

    const startDate = new Date(startDateParam);
    const endDate = new Date(endDateParam);
    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      return res.status(400).json({ success: false, message: 'Invalid date format' });
    }

    // GLOBAL: query all regions and merge results
    if (region === 'global') {
      const promises = ALL_REGIONS.map(r => rawReport(r, { startDate, endDate, location, admitFilter }));
      const results = await Promise.all(promises);
      // results is array of recordsets -> flatten
      const merged = results.flat();
      // Optionally sort by LocaleMessageTime desc to keep consistent ordering
      merged.sort((a, b) => {
        const ta = a.LocaleMessageTime ? new Date(a.LocaleMessageTime).getTime() : 0;
        const tb = b.LocaleMessageTime ? new Date(b.LocaleMessageTime).getTime() : 0;
        return tb - ta;
      });
      return res.json({ success: true, data: merged });
    }

    // Normal single-region flow
    const rows = await rawReport(region, { startDate, endDate, location, admitFilter });
    return res.json({ success: true, data: rows });
  } catch (err) {
    console.error('rawReportHandler error', err);
    return res.status(500).json({ success: false, message: err.message || 'server error' });
  }
}
















//C:\Users\W0024618\Desktop\global-page\backend\config\dbConfig.js
import sql from 'mssql';

// shared options
const commonOpts = {
  options: {
    encrypt: true,
    trustServerCertificate: true
  },
  // increase timeouts (milliseconds)
  // requestTimeout: maximum time for a single request to complete
  requestTimeout: 300000,      // 5 minutes
  // connectionTimeout: time to wait while establishing connection
  connectionTimeout: 30000,    // 30 seconds
  // pool defaults
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  }
};

// lowercase keys only
const regions = {
  apac: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUPNQ0986V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  },
  emea: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUFRA0986V',
    database: 'ACVSUJournal_00011028',
    ...commonOpts
  },
  laca: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUSJO0986V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  },
  namer: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUDEN0891V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  }
};

const pools = {};

/**
 * @param {string} regionKey  one of the keys in `regions`, case-insensitive
 */
export async function getPool(regionKey) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) {
    throw new Error(`Unknown region: ${regionKey}`);
  }
  if (!pools[key]) {
    pools[key] = await new sql.ConnectionPool(cfg).connect();
  }
  return pools[key];
}

export { sql };




















//C:\Users\W0024618\Desktop\global-page\frontend\src\pages\ReportsPage.jsx
//import React, { useState } from 'react';
import React, { useState, useEffect, useRef } from 'react';
import {
  Box, FormControl, InputLabel, Select, OutlinedInput,
  Checkbox, ListItemText, MenuItem, Button,
  CircularProgress, Typography, TextField, Tabs, Tab, Grid, Paper, IconButton, Divider,Autocomplete
} from '@mui/material';

;

import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import axios from 'axios';
import ExcelJS from 'exceljs';
import * as XLSX from 'xlsx';
import { useAuth } from '../context/AuthContext';

import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import PlaceIcon from '@mui/icons-material/Place';
import PeopleIcon from '@mui/icons-material/People';
import DownloadIcon from '@mui/icons-material/CloudDownload';
import FilterListIcon from '@mui/icons-material/FilterList';
import Avatar from '@mui/material/Avatar';
import { generateDailyAccessExcelFromRows } from './DailyAccessReport';

// Static lists
const EMPLOYEE_OPTIONS = [
  'Vainilaitis, Valdas',
  'Tomasevic, Kazimez',
  'Sesickis, Janas',
  'Valiunas, Sigitas',
  'JANCUKOVIC, VACLAVA',
  'Kalpokiene, Alina',
  'Korkus, Vanda',
  'Kvaraciejiene, Maryte',
  'ZNAMEROVSKIS, DARIUS'
];

const REGION_OPTIONS = ['global', 'apac', 'emea', 'laca', 'namer'];
const LOCATION_MAP = {
  apac: ['APAC.Default', 'JP.Tokyo', 'PH.Manila', 'MY.Kuala Lumpur','IN.HYD'],
  emea: ['AUT.Vienna', 'DU.Abu Dhab', 'IE.Dublin', 'IT.Rome', 'LT.Vilnius', 'MA.Casablanca', 'RU.Moscow', 'UK.London', 'ES.Madrid'],
  laca: ['AR.Cordoba', 'CR.Costa Rica Partition', 'MX.Mexico City', 'PE.Lima', 'BR.Sao Paulo', 'PA.Panama City'],
  namer: ['US.NYC', 'US.FL.Miami', 'USA/Canada Default', 'US.CO.OBS'],
  global: []
};

function formatDisplayDate(date) {
  const d = new Date(date);
  const day = d.getDate();
  const suf = day % 10 === 1 && day !== 11 ? 'st'
    : day % 10 === 2 && day !== 12 ? 'nd'
      : day % 10 === 3 && day !== 13 ? 'rd' : 'th';
  const mon = d.toLocaleString('default', { month: 'long' });
  return `${day}${suf} ${mon} ${d.getFullYear()}`;
}

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');

// --- Helper: parse server "ISO like" / "YYYY-MM-DD[ T]HH:MM:SS(.mmm)[Z|+..]" as literal parts
function _extractServerDateTimeParts(iso) {
  if (!iso) return null;
  const s = String(iso);
  let datePart = '', timePart = '';
  if (s.includes('T')) {
    [datePart, timePart] = s.split('T');
  } else if (s.includes(' ')) {
    [datePart, timePart] = s.split(' ');
  } else {
    return null;
  }
  datePart = datePart.slice(0, 10);
  timePart = (timePart || '').replace(/Z|[+-]\d{2}:\d{2}$/, '').replace(/\.\d+$/, '');
  const dParts = datePart.split('-').map(p => parseInt(p, 10));
  const tParts = timePart.split(':').map(p => parseInt(p || '0', 10));
  return {
    year: dParts[0] || 0,
    month: dParts[1] || 0,
    day: dParts[2] || 0,
    hour: tParts[0] || 0,
    minute: tParts[1] || 0,
    second: tParts[2] || 0
  };
}



function formatDateFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  const y = dt.getUTCFullYear();
  const m = dt.getUTCMonth(); // 0..11
  const d = dt.getUTCDate();
  const yrShort = String(y).slice(-2);
  return `${pad2(d)}-${MONTH_ABBR[m]}-${yrShort}`;         // e.g. "12-Aug-25"
}



function formatTimeFromServerISO(iso) {
  if (!iso) return '';
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const hh = p.hour;
  const mm = p.minute || 0;
  const ss = p.second || 0;
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1;
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`; // e.g. "3:23:46 PM"
}



function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10);
  if (!swipeIso) {
    return `${datePart}T00:00:00.000`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000`;
  }
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000`;
}






// returns a server-wall-clock ISO for a row: prefer LocaleMessageTime, else DateOnly+Swipe_Time
const getServerISO = (r) => {
  if (!r) return '';
  if (r.LocaleMessageTime) return r.LocaleMessageTime;
  if (r.DateOnly) return buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  return '';
};

// returns YYYY-MM-DD for server wall-clock (used for filtering)
const getServerYMD = (r) => {
  const iso = getServerISO(r);
  if (!iso) return '';
  return iso.slice(0, 10);
};

// Helper — convert "YYYY-MM-DD..." (ISO) into a local midnight Date (avoids UTC shift)
const isoDateOnlyToLocalDate = (iso) => {
  if (!iso) return null;
  const s = iso.toString().slice(0, 10);
  const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
  return new Date(y, m - 1, d);
};

// Build a Date that preserves the server-provided wall-clock values.
// If swipeTime is an ISO (with Z), read UTC components and use them as local values.
const buildLocalDateFromDateOnlyAndSwipe = (dateOnly, swipeTime) => {
  if (!dateOnly) return null;
  const dateStr = dateOnly.toString().slice(0, 10);
  const [yy, mm, dd] = dateStr.split('-').map(n => parseInt(n, 10));

  let hh = 0, min = 0, ss = 0;
  if (swipeTime) {
    const parsed = new Date(swipeTime);
    if (!isNaN(parsed.getTime())) {
      hh = parsed.getUTCHours();
      min = parsed.getUTCMinutes();
      ss = parsed.getUTCSeconds();
    } else {
      const parts = swipeTime.split(':').map(p => parseInt(p, 10));
      if (parts.length >= 2) {
        hh = parts[0] || 0;
        min = parts[1] || 0;
        ss = parts[2] || 0;
      }
    }
  }
  return new Date(yy, mm - 1, dd, hh, min, ss);
};

export default function ReportsPage() {
  const auth = useAuth();

  // --- state ---
  const [tab, setTab] = useState(0);

  const [region, setRegion] = useState('emea');
  const [location, setLocation] = useState('');
  const [from, setFrom] = useState(null);
  const [to, setTo] = useState(null);
  const [showFromCal, setShowFromCal] = useState(false);
  const [showToCal, setShowToCal] = useState(false);
  const [selectedEmps, setSelectedEmps] = useState([]);
  const [loading, setLoading] = useState(false);

  const [rawSearch, setRawSearch] = useState('');
  const [rawAdmitFilter, setRawAdmitFilter] = useState('all');
  const [newEmployee, setNewEmployee] = useState(''); // text field for adding name or ID

  //new usestste

  // locations fetched from backend for current region (strings like "APAC.Default")
  const [availableLocations, setAvailableLocations] = useState([]);
  // selected locations for Raw (multiple)
  const [selectedLocations, setSelectedLocations] = useState([]);
   // employee-autocomplete state specifically for Raw tab
  const [rawEmpOptions, setRawEmpOptions] = useState([]); // suggestions from backend
  const [selectedRawEmps, setSelectedRawEmps] = useState([]); // array of strings (name or ID)
  const empQueryRef = useRef(null); // debounce timer




// // Helper: fetch locations for a single region key (backend endpoint assumed: /api/locations?region=apac)
//   const fetchLocationsForRegion = async (r) => {
//     try {
//       const resp = await axios.get('/api/locations', { params: { region: r } });
//       // expect resp.data.data to be array of strings like "APAC.Default" or ["IN.HYD", ...]
//       const list = (resp.data && (resp.data.data || resp.data)) || [];
//       // normalize to "REGION.Partition" where appropriate (we assume backend returns full partition names)
//       return Array.isArray(list) ? list : [];
//     } catch (e) {
//       console.warn('fetchLocationsForRegion error', r, e);
//       return [];
//     }
//   };


// Helper: fetch locations for a single region key (backend endpoint: GET /api/locations?region=apac)
const fetchLocationsForRegion = async (r) => {
  try {
    if (!r) return [];
    // pass region param exactly as frontend holds it (lowercase like 'apac','emea')
    const resp = await axios.get('/api/locations', { params: { region: r } });
    const listRaw = (resp.data && (resp.data.data || resp.data)) || [];

    // Accept multiple shapes:
    //  - array of strings: ["APAC.Default", "IN.HYD"]
    //  - array of objects: [{ PartitionName2: "APAC.Default" }, { partition: "IN.HYD" }]
    // Normalize to strings.
    const list = Array.isArray(listRaw)
      ? listRaw.map(item => {
          if (typeof item === 'string') return item;
          // common property names we might receive
          return item.PartitionName2 || item.partition || item.location || item.name || (item.label ? item.label : null);
        }).filter(Boolean)
      : [];

    // Fallback: if backend returned nothing, use static map (best-effort)
    if (!list.length) {
      const key = (r || '').toLowerCase();
      return (LOCATION_MAP[key] || []).slice();
    }

    // dedupe & sort
    return Array.from(new Set(list)).sort();
  } catch (e) {
    console.warn('fetchLocationsForRegion error', r, e);
    // fallback to static map
    const key = (r || '').toLowerCase();
    return (LOCATION_MAP[key] || []).slice();
  }
};




  // // When region changes and Raw tab is active — fetch locations.
  // useEffect(() => {
  //   let mounted = true;
  //   const load = async () => {
  //     if (tab !== 1) return; // only for Raw tab
  //     setAvailableLocations([]);
  //     if (!region) return;
  //     // if global, fetch for all four regions and combine
  //     const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];
  //     try {
  //       if (region === 'global') {
  //         const promises = MULTI_REGIONS.map(r => fetchLocationsForRegion(r));
  //         const results = await Promise.all(promises);
  //         const merged = results.flat();
  //         if (!mounted) return;
  //         setAvailableLocations(Array.from(new Set(merged)).sort());
  //       } else {
  //         const list = await fetchLocationsForRegion(region);
  //         if (!mounted) return;
  //         setAvailableLocations(Array.from(new Set(list)).sort());
  //       }
  //     } catch (err) {
  //       console.error('load locations error', err);
  //     }
  //   };
  //   load();
  //   return () => { mounted = false; };
  // }, [region, tab]);






// fetch availableLocations for the currently selected region (runs on region change)
useEffect(() => {
  let mounted = true;
  const load = async () => {
    setAvailableLocations([]);
    if (!region) return;

    const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];

    try {
      if (region === 'global') {
        const promises = MULTI_REGIONS.map(r => fetchLocationsForRegion(r));
        const results = await Promise.all(promises);
        const merged = results.flat();
        if (!mounted) return;
        setAvailableLocations(Array.from(new Set(merged)).sort());
      } else {
        const list = await fetchLocationsForRegion(region);
        if (!mounted) return;
        setAvailableLocations(Array.from(new Set(list)).sort());
      }
    } catch (err) {
      console.error('load locations error', err);
      // fallback to static map handled below when rendering
    }
  };

  load();
  return () => { mounted = false; };
}, [region]);





  // Handle tab switch (Daily / Raw / Rejection)
  const handleTabChange = (_, v) => {
    setTab(v);
    // reset filters
    setRegion('emea');
    setLocation('');
    setFrom(null);
    setTo(null);
    setSelectedEmps([]);
    setRawSearch('');
    setRawAdmitFilter('all');
  };

  /** Time Duration Excel generator */
  const generateTimeDurationExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Time Duration');

    ws.mergeCells('A1:M1');
    ws.getCell('A1').value =
      `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };

    const headers = [
      'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
      'Partition', 'Text5', 'Year', 'Week', 'Date',
      'First Swipe', 'Last Swipe', 'Duration', 'Category',
      'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'ptype', width: 18 },
      { key: 'part', width: 15 },
      { key: 'txt5', width: 20 },
      { key: 'year', width: 8 },
      { key: 'week', width: 6 },
      { key: 'date', width: 12 },
      { key: 'first', width: 16 },
      { key: 'last', width: 16 },
      { key: 'dur', width: 10 },
      { key: 'cat', width: 12 },
      { key: 'dpw', width: 12 },
      { key: 'vdw', width: 14 },
      { key: 'cdw', width: 12 },
      { key: 'def', width: 10 }
    ];

    data.forEach((r, idx) => {
      const first = new Date(r.FirstSwipeTime);
      const last = new Date(r.LastSwipeTime);
      const date = new Date(r.ShiftedDate);
      const row = ws.addRow([
        idx + 1,
        r.ObjectName1,
        r.EmployeeID,
        r.PersonnelType,
        r.PartitionName2,
        r.text5,
        r.YearNumber,
        r.WeekNumber,
        date,
        first,
        last,
        r.DurationHHMM,
        r.TimeDiffCategory,
        r.DaysPresentInWeek,
        r.ViolationDaysInWeek,
        r.CleanDaysInWeek,
        r.Defaulter
      ]);

      row.getCell(9).numFmt = 'dd-mmm-yy';
      row.getCell(10).numFmt = 'h:mm:ss AM/PM';
      row.getCell(11).numFmt = 'h:mm:ss AM/PM';

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    ws.autoFilter = 'A2:Q2';

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    const filename =
      `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;

    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  // Rejection Excel
  const generateRejectionExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Rejection');

    const title = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}`;
    ws.mergeCells('A1:J1');
    ws.getCell('A1').value = title;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };

    const headers = [
      'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
      'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'date', width: 12 },
      { key: 'time', width: 12 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'card', width: 15 },
      { key: 'type', width: 15 },
      { key: 'door', width: 40 },
      { key: 'loc', width: 15 },
      { key: 'swipe', width: 10 }
    ];

    data.forEach((r, idx) => {
      const iso = getServerISO(r);
      const dateStr = iso ? formatDateFromServerISO(iso) : '';
      const timeStr = iso ? formatTimeFromServerISO(iso) : '';

      const row = ws.addRow([
        idx + 1,
        dateStr,
        timeStr,
        r.ObjectName1 || '',
        r.EmployeeID || '',
        r.CardNumber || '',
        r.Rejection_Type || '',
        r.Door || r.ObjectName2 || '',
        r.location || '',
        r.Direction || r.Swipe || ''
      ]);

      row.getCell(2).alignment = { horizontal: 'left' };
      row.getCell(3).alignment = { horizontal: 'left' };

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    const counts = data.reduce((a, r) => {
      const k = r.Rejection_Type || 'Unknown';
      a[k] = (a[k] || 0) + 1; return a;
    }, {});
    let rowIdx = 3;
    ws.getCell(rowIdx, 11).value = 'Rejection';
    ws.getCell(rowIdx, 12).value = 'Count';
    [11, 12].forEach(c => {
      const cell = ws.getCell(rowIdx, c);
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'center' };
      cell.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });
    rowIdx++;
    Object.entries(counts).forEach(([type, cnt]) => {
      ws.getCell(rowIdx, 11).value = type;
      ws.getCell(rowIdx, 12).value = cnt;
      [11, 12].forEach(c => {
        const cell = ws.getCell(rowIdx, c);
        cell.alignment = { horizontal: 'left' };
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });
      rowIdx++;
    });
    ws.getCell(rowIdx, 11).value = 'Total';
    ws.getCell(rowIdx, 12).value = data.length;
    [11, 12].forEach(c => {
      const cell = ws.getCell(rowIdx, c);
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'left' };
      cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
    });

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const filename = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}.xlsx`;
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };



// helper: safe filename builder used by generateRawExcel (prevents ReferenceError)
function buildRawFileName(opts = {}) {
  const safe = s => (s === undefined || s === null) ? '' : String(s).replace(/[\/\\:?<>|"]/g, '_').trim();
  const regionPart = opts.region ? safe(opts.region).toUpperCase() : 'RAW';
  const locationPart = opts.location ? `_${safe(opts.location).replace('.', '_')}` : '';
  const admitPart = opts.rawAdmitFilter ? `_${safe(opts.rawAdmitFilter)}` : '';
  const searchPart = opts.rawSearch ? `_${safe(opts.rawSearch).replace(/\s+/g, '_')}` : '';

  // from/to might be Date objects (frontend passes Date), or strings — handle both
  const formatDateForName = d => {
    if (!d) return '';
    try {
      if (d instanceof Date) return `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}`;
      const dt = new Date(d);
      if (!isNaN(dt.getTime())) return `${dt.getFullYear()}${pad2(dt.getMonth()+1)}${pad2(dt.getDate())}`;
    } catch (e) { /* ignore */ }
    return safe(d).slice(0,10).replace(/[-\s:]/g,'');
  };

  const fromPart = opts.from ? `_from_${formatDateForName(opts.from)}` : '';
  const toPart   = opts.to   ? `_to_${formatDateForName(opts.to)}` : '';

  const filename = `Raw_${regionPart}${locationPart}${fromPart}${toPart}${admitPart}${searchPart}.xlsx`;
  return filename;
}


  // generateRawExcel
  const generateRawExcel = async (rows, opts = {}) => {
    const formatTimeFromSwipe = (swipeIso) => {
      if (!swipeIso) return '';
      const dt = new Date(swipeIso);
      if (!isNaN(dt.getTime())) {
        return formatTimeFromServerISO(swipeIso);
      }
      const parts = ('' + swipeIso).split(':').map(p => parseInt(p || 0, 10));
      const hh = parts[0] || 0;
      const mm = parts[1] || 0;
      const ss = parts[2] || 0;
      const ampm = hh >= 12 ? 'PM' : 'AM';
      const hh12 = ((hh + 11) % 12) + 1;
      return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
    };

    const admitFilter = (opts.rawAdmitFilter || 'all').toString().toLowerCase();

    const baseHeaders = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber'];
    const admitCol = 'AdmitCode';
    const rejCol = 'Rejection_Type';
    const tailCols = ['Direction','Door'];

    let headers = [...baseHeaders];
    if (admitFilter === 'all') {
      headers.push(admitCol);
      headers.push(...tailCols);
      headers.push(rejCol);
    } else if (admitFilter === 'admit') {
      headers.push(admitCol);
      headers.push(...tailCols);
    } else if (admitFilter === 'reject') {
      headers.push(...tailCols);
      headers.push(rejCol);
    } else {
      headers.push(admitCol);
      headers.push(...tailCols);
      headers.push(rejCol);
    }

    if (!rows || !rows.length) {
      const wbEmpty = XLSX.utils.book_new();
      const wsEmpty = XLSX.utils.aoa_to_sheet([headers]);
      XLSX.utils.book_append_sheet(wbEmpty, wsEmpty, 'Raw');
      const fileNameEmpty = buildRawFileName(opts);
      XLSX.writeFile(wbEmpty, fileNameEmpty);
      return;
    }

    const rowsForSheet = rows.map(r => {
      const iso = getServerISO(r);
      const dateStr = iso ? formatDateFromServerISO(iso) : '';
      const timeStr = iso ? formatTimeFromServerISO(iso) : '';
      const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');
      const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';
      const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

      const fullObj = {
        LocaleMessageTime: localeMsgFormatted,
        DateOnly: dateOnlyFormatted,
        Swipe_Time: swipeTimeFormatted,
        EmployeeID: r.EmployeeID || '',
        ObjectName1: r.ObjectName1 || '',
        PersonnelType: r.PersonnelType || '',
        location: r.location || '',
        CardNumber: r.CardNumber || '',
        AdmitCode: r.AdmitCode || r.Messagetype || '',
        Direction: r.Direction || r.Swipe || '',
        Door: r.Door || r.ObjectName2 || '',
        Rejection_Type: r.Rejection_Type || ''
      };

      const picked = {};
      headers.forEach(h => {
        picked[h] = (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '';
      });
      return picked;
    });

    const ws = XLSX.utils.json_to_sheet(rowsForSheet, { header: headers });
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Raw');

    const filename = buildRawFileName(opts);
    XLSX.writeFile(wb, filename);
  };

  // --- Permission helpers ---
  const exportPermsForTab = () => {
    if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
    if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
    if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
    if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
    if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
    if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
    return ['gsoc_reports'];
  };

  // disabled conditions - UI-level validations (permission gating done separately)
  // const disabled = loading
  //   || !region
  //   || (tab === 0 && (!from || !to || selectedEmps.length === 0))
  //   || (tab === 1 && (!from || !to))
  //   || (tab === 2 && (!from || !to))
  //   || (tab === 3 && !from)
  //   || (tab === 4 && (!from || !to));


  const disabled = loading
    || !region
    || (tab === 0 && (!from || !to || selectedEmps.length === 0))
    || (tab === 1 && (!from || !to))
    || (tab === 2 && (!from || !to))
    || (tab === 3 && !from)
    || (tab === 4 && (!from || !to));



  const navDisabled = !region || loading;

  const exportAllowed = auth.hasPermission(exportPermsForTab());

  // --- Generate handler with permission check up-front ---
  const handleGenerate = async () => {
    // Permission gating: determine required permission for each tab
    const requirePermissionForTab = () => {
      if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
      if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
      if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
      if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
      if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
      if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
      return ['gsoc_reports'];
    };

    if (!auth.hasPermission(requirePermissionForTab())) {
      alert('You do not have permission to generate this report.');
      return;
    }

    setLoading(true);
    try {
      const baseParams = { region, location: location || undefined };

      // Helper: format dates in local time without timezone conversion for API parameters
      const formatLocalDate = (date, endOfDay = false) => {
        const d = new Date(date);
        if (endOfDay) d.setHours(23, 59, 59, 999);
        else d.setHours(0, 0, 0, 0);
        const pad = n => n.toString().padStart(2, '0');
        return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}` +
               `T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      };

      const toLocalYMD = date => `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`;

      // ----- 0: Daily Access -----
      if (tab === 0) {
        // IMPORTANT: backend daily access expects DATE (no time) for from/to.
        // Send YYYY-MM-DD (date-only) to avoid SQL server timezone/cast issues.
        const fromDateOnly = `${from.getFullYear()}-${pad2(from.getMonth() + 1)}-${pad2(from.getDate())}`;
        const toDateOnly = `${to.getFullYear()}-${pad2(to.getMonth() + 1)}-${pad2(to.getDate())}`;

        const params = {
          ...baseParams,
          from: fromDateOnly,
          to: toDateOnly,
          employees: selectedEmps.join(',')
        };
        const resp = await axios.get('/api/reports/daily-access', { params });

        // rows as returned by backend (backend now returns LocaleMessageTime as text)
        const rows = (resp.data && resp.data.data) || [];

        // pass rows and current options; the new module writes Excel using server wall-clock text
        await generateDailyAccessExcelFromRows(rows, { from: fromDateOnly, to: toDateOnly, selectedEmps, region });
        return;
      }



  // // ----- 1: Raw -----
  //     if (tab === 1) {
  //       const startISO = formatLocalDate(from);
  //       const endISO = formatLocalDate(to, true);

  //       const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];

  //       let rowsSrcCombined = [];
  //       if (region === 'global') {
  //         const promises = MULTI_REGIONS.map(r => {
  //           const params = {
  //             ...baseParams,
  //             region: r,
  //             startDate: startISO,
  //             endDate: endISO,
  //             admitFilter: rawAdmitFilter
  //           };
  //           return axios.get('/api/reports/raw', { params });
  //         });
  //         const responses = await Promise.all(promises);
  //         rowsSrcCombined = responses.flatMap(resp => (resp.data && resp.data.data) || []);
  //       } else {
  //         const params = {
  //           ...baseParams,
  //           startDate: startISO,
  //           endDate: endISO,
  //           admitFilter: rawAdmitFilter
  //         };
  //         const resp = await axios.get('/api/reports/raw', { params });
  //         rowsSrcCombined = (resp.data && resp.data.data) || [];
  //       }

  //       const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
  //       const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

  //       const rows = rowsSrcCombined.filter(r => {
  //         const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
  //         return date >= startDate && date <= endDate;
  //       });

  //       let filtered = rows;
  //       if (rawSearch && rawSearch.trim() !== '') {
  //         const s = rawSearch.trim().toLowerCase();
  //         filtered = rows.filter(r => {
  //           const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
  //           const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
  //           return id.includes(s) || name.includes(s);
  //         });
  //       }

  //       await generateRawExcel(filtered, { region, location, rawSearch, from, to, rawAdmitFilter });
  //       return;
  //     }



 // ----- 1: Raw -----
      if (tab === 1) {
        const startISO = formatLocalDate(from);
        const endISO = formatLocalDate(to, true);
        const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];

        // Build a list of requests to perform (region + optional location)
        const requests = [];

        // Helper: push a request for given region and optional location
        const pushReq = (r, locationParam = undefined) => {
          const params = {
            startDate: startISO,
            endDate: endISO,
            admitFilter: rawAdmitFilter
          };
          // only include region if not global per-call (we will explicitly call per-region)
          if (r) params.region = r;
          if (locationParam) params.location = locationParam;
          requests.push(axios.get('/api/reports/raw', { params }));
        };

        if (region === 'global') {
          // if user selected specific locations, group them by their region prefix (e.g. "APAC.Default")
          if (selectedLocations && selectedLocations.length) {
            // map: regionKey -> [loc, loc, ...]
            const regionMap = {};
            selectedLocations.forEach(loc => {
              // loc might be "APAC.Default" or just "IN.HYD" or "LT.Vilnius".
              // derive region key as lowercased prefix before first dot, fallback to 'unknown'
              const parts = String(loc).split('.');
              const rKey = (parts[0] || '').toString().toLowerCase();
              regionMap[rKey] = regionMap[rKey] || [];
              regionMap[rKey].push(loc);
            });
            // for each region group add per-location requests
            Object.entries(regionMap).forEach(([rKey, locs]) => {
              // if rKey is not one of MULTI_REGIONS, treat these locations by calling without region
              const isKnown = MULTI_REGIONS.includes(rKey);
              if (isKnown) {
                locs.forEach(loc => pushReq(rKey, loc));
              } else {
                // unknown prefix: send requests without region but with the location param
                locs.forEach(loc => pushReq(undefined, loc));
              }
            });
          } else {
            // no specific locations -> call backend once per sub-region (broad request)
            MULTI_REGIONS.forEach(r => pushReq(r));
          }
        } else {
          // single region chosen
          if (selectedLocations && selectedLocations.length) {
            // user selected multiple locations within this region -> request per location
            selectedLocations.forEach(loc => pushReq(region, loc));
          } else {
            // no locations selected -> single call for the region (all partitions)
            pushReq(region);
          }
        }

        // perform requests in parallel (bounded by number of calls we generated)
        let rowsSrcCombined = [];
        try {
          // rate-limit: if no requests created (should not happen), make a single request for region
          if (!requests.length) {
            pushReq(region === 'global' ? MULTI_REGIONS[0] : region);
          }
          const responses = await Promise.all(requests);
          rowsSrcCombined = responses.flatMap(r => (r.data && (r.data.data || r.data)) || []);
        } catch (err) {
          console.error('raw fetch error', err);
          throw err; // handled by outer catch which shows message
        }

        // client-side date window filter — ensure row dates are inside selected date range
        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

        const rows = rowsSrcCombined.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          // defensive: if date is null, skip
          if (!date) return false;
          return (date >= startDate && date <= endDate);
        });

        // apply free-text search (rawSearch) if present
        let filtered = rows;
        if (rawSearch && rawSearch.trim() !== '') {
          const s = rawSearch.trim().toLowerCase();
          filtered = filtered.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            return id.includes(s) || name.includes(s);
          });
        }

        // apply selected employees filter (selectedRawEmps) if present
        if (selectedRawEmps && selectedRawEmps.length) {
          const setSel = new Set(selectedRawEmps.map(x => String(x).toLowerCase()));
          filtered = filtered.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            // support numeric or name matches
            return setSel.has(id) || setSel.has(name) || selectedRawEmps.some(sel => id.includes(String(sel).toLowerCase()) || name.includes(String(sel).toLowerCase()));
          });
        }

        // optional: remove duplicates (same LocaleMessageTime+EmployeeID+Door) to avoid duplicates from multi-requests
        const keySet = new Set();
        const deduped = [];
        filtered.forEach(r => {
          const key = `${getServerISO(r)}|${r.EmployeeID}|${r.Door}|${r.CardNumber}`;
          if (!keySet.has(key)) {
            keySet.add(key);
            deduped.push(r);
          }
        });

        await generateRawExcel(deduped, { region, location: selectedLocations && selectedLocations.join(',') || location, rawSearch, from, to, rawAdmitFilter });
        return;
      }










      // ----- 2: Rejection -----
      if (tab === 2) {
        const params = { ...baseParams, startDate: formatLocalDate(from), endDate: formatLocalDate(to, true) };
        const resp = await axios.get('/api/reports/rejection', { params });

        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

        const rowsSrc = (resp.data && resp.data.data) || [];
        const rows = rowsSrc.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          return date >= startDate && date <= endDate;
        });

        await generateRejectionExcel(rows);
        return;
      }

      // ----- 3: EUROC Admit-Reject (single day) -----
      if (tab === 3) {
        if (region.toLowerCase() !== 'emea') {
          alert('EUROC report is only available for region EMEA. Please select EMEA.');
          return;
        }
        if (!from) {
          alert('Please select a date (From) for EUROC report.');
          return;
        }

        const dateParam = toLocalYMD(new Date(from));
        const params = { region: 'emea', date: dateParam };
        const resp = await axios.get('/api/reports/euroc-admit-rejection', { params });
        const { data } = resp.data || {};

        const wb = new ExcelJS.Workbook();

        // Admit sheet
        const admitTitle = `EUROC Admit Report - ${formatDisplayDate(from)}`;
        const ws1 = wb.addWorksheet('EUROC Admit');
        ws1.mergeCells('A1:I1');
        ws1.getCell('A1').value = admitTitle;
        ws1.getCell('A1').font = { bold: true, size: 14 };
        ws1.getCell('A1').alignment = { horizontal: 'center' };

        const admitHeaders = [
          'Sr. No.', 'Date', 'Time', 'Employee Name',
          'Access Card No.', 'Personnel Type', 'Door Name', 'Location', 'Swipe'
        ];
        const hdrRow1 = ws1.addRow(admitHeaders);
        hdrRow1.font = { bold: true };
        hdrRow1.alignment = { vertical: 'middle', horizontal: 'center' };
        hdrRow1.eachCell(c => {
          c.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
        });

        ws1.columns = [
          { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
          { key:'name', width:30 }, { key:'card', width:15 }, { key:'ptype', width:20 },
          { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
        ];

        (data.admit || []).forEach((r, idx) => {
          let iso;
          if (r.LocaleMessageTime) {
            iso = r.LocaleMessageTime;
          } else if (r.DateOnly) {
            iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
          } else {
            iso = '';
          }

          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws1.addRow([
            idx + 1,
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.CardNumber || '',
            r.PersonnelType || '',
            r.Door || r.ObjectName2 || '',
            r.location || '',
            r.Direction || ''
          ]);

          row.getCell(2).alignment = { horizontal: 'left' };
          row.getCell(3).alignment = { horizontal: 'left' };
          row.eachCell(c => {
            c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        // Rejection sheet
        const ws2 = wb.addWorksheet('EUROC Rejection');
        ws2.mergeCells('A1:J1');
        ws2.getCell('A1').value = `EUROC Rejection Report - ${formatDisplayDate(from)}`;
        ws2.getCell('A1').font = { bold: true, size: 14 };
        ws2.getCell('A1').alignment = { horizontal: 'center' };

        const headerRow2 = ws2.addRow(['Sr. No.', 'Date', 'Time', 'Employee Name', 'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe']);
        headerRow2.font = { bold: true };
        headerRow2.alignment = { vertical: 'middle', horizontal: 'center' };
        headerRow2.eachCell(c => {
          c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });

        ws2.columns = [
          { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
          { key:'name', width:30 }, { key:'card', width:15 }, { key:'type', width:15 },
          { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
        ];

        (data.rejection || []).forEach((r, idx) => {
          let iso;
          if (r.LocaleMessageTime) {
            iso = r.LocaleMessageTime;
          } else if (r.DateOnly) {
            iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
          } else {
            iso = '';
          }

          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws2.addRow([
            idx + 1,
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.CardNumber || '',
            r.Rejection_Type || '',
            r.Door || '',
            r.location || '',
            r.Direction || ''
          ]);

          row.getCell(2).alignment = { horizontal: 'left' };
          row.getCell(3).alignment = { horizontal: 'left' };
          row.eachCell(c => {
            c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        // Summary block
        const counts = data.summary || [];
        let startRow = 3;
        ws2.getCell(startRow, 11).value = 'Rejection';
        ws2.getCell(startRow, 12).value = 'Count';
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.font = { bold: true };
          cell.alignment = { horizontal: 'center' };
          cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });
        startRow++;
        counts.forEach(c => {
          ws2.getCell(startRow, 11).value = c.Rejection_Type || 'Unknown';
          ws2.getCell(startRow, 12).value = c.Count || 0;
          [11, 12].forEach(col => {
            const cell = ws2.getCell(startRow, col);
            cell.alignment = { horizontal: 'left' };
            cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
          });
          startRow++;
        });
        ws2.getCell(startRow, 11).value = 'Grand Total';
        ws2.getCell(startRow, 12).value = (data.rejection || []).length;
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.font = { bold: true };
          cell.alignment = { horizontal: 'left' };
          cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });

        const buf = await wb.xlsx.writeBuffer();
        const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const filename = `EUROC_Admit_Rejection_${dateParam}.xlsx`;
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        return;
      }

      // ----- 4: Time Duration -----
      if (tab === 4) {
        if (!from || !to) {
          alert('Please select both Start Date and End Date for Time Duration report.');
          return;
        }
        const startParam = toLocalYMD(new Date(from));
        const endParam = toLocalYMD(new Date(to));
        const params = {
          region,
          startDate: startParam,
          endDate: endParam,
          partition: location ? location.split('.').pop() : 'Default'
        };
        const resp = await axios.get('/api/reports/time-duration', { params });
        await generateTimeDurationExcel(resp.data.data || []);
        return;
      }

      // ----- 5: HeadCount / External navigation -----
      if (tab === 5) {
        // final permission check (region specific)
        const permCandidates = [`headcount.${region}`, 'headcount', 'global_access'];
        if (!auth.hasPermission(permCandidates)) {
          alert(`You do not have permission to view HeadCount for ${region.toUpperCase()}.`);
          setLoading(false);
          return;
        }

        let url = '';

        if (region === 'laca') {
          if (!location) url = 'http://10.199.22.57:3003/history';
          else {
            const LACA_URLS = {
              'CR.Costa Rica Partition': 'http://10.199.22.57:3003/partition/CR.Costa%20Rica%20Partition/history',
              'MX.Mexico City': 'http://10.199.22.57:3003/partition/MX.Mexico%20City/history',
              'AR.Cordoba': 'http://10.199.22.57:3003/partition/AR.Cordoba/history',
              'PA.Panama City': 'http://10.199.22.57:3003/partition/PA.Panama%20City/history',
              'PE.Lima': 'http://10.199.22.57:3003/partition/PE.Lima/history',
              'BR.Sao Paulo': 'http://10.199.22.57:3003/partition/BR.Sao%20Paulo/history'
            };
            url = LACA_URLS[location] || 'http://10.199.22.57:3003/history';
          }
        } else if (region === 'namer') {
          if (!location) url = 'http://10.199.22.57:3002/history';
          else {
            const NAMER_URLS = {
              'US.Denver': 'http://10.199.22.57:3002/partition/US.CO.OBS/history',
              'US.Miami': 'http://10.199.22.57:3002/partition/US.FL.Miami/history',
              'US.NYC': 'http://10.199.22.57:3002/partition/US.NYC/history',
              'US.Austin': 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default/history'
            };
            url = NAMER_URLS[location] || 'http://10.199.22.57:3002/history';
          }
        } else if (region === 'apac') {
          if (!location) url = 'http://10.199.22.57:3000/history';
          else {
            const APAC_URLS = {
              'APAC.Default': 'http://10.199.22.57:3000/partition/Pune/history',
              'IN.HYD':'http://10.199.22.57:3000/partition/IN.HYD/history',
              'MY.Kuala Lumpur': 'http://10.199.22.57:3000/partition/MY.Kuala Lumpur/history',
              'PH.Manila': 'http://10.199.22.57:3000/partition/PH.Manila/history',
              'JP.Tokyo': 'http://10.199.22.57:3000/history',
              'CN.Beijing': 'http://10.199.22.57:3000/history'
            };
            url = APAC_URLS[location] || 'http://10.199.22.57:3000/history';
          }
        } else if (region === 'emea') {
          if (!location) url = 'http://10.199.22.57:3001/history';
          else {
            const EMEA_URLS = {
              'AUT.Vienna': 'http://10.199.22.57:3001/history',
              'DU.Abu Dhabi': 'http://10.199.22.57:3001/history',
              'IE.Dublin': 'http://10.199.22.57:3001/history',
              'IT.Rome': 'http://10.199.22.57:3001/history',
              'LT.Vilnius': 'http://10.199.22.57:3001/history',
              'MA.Casablanca': 'http://10.199.22.57:3001/history',
              'RU.Moscow': 'http://10.199.22.57:3001/history',
              'UK.London': 'http://10.199.22.57:3001/history',
              'ES.Madrid': 'http://10.199.22.57:3001/history'
            };
            url = EMEA_URLS[location] || 'http://10.199.22.57:3001/history';
          }
        }

        if (url) window.location.href = url;
        else alert('Invalid region or location selected.');
        return;
      }



} catch (err) {
      console.error('handleGenerate error:', err);
      // Show backend message when available (axios)
      let msg = 'Failed to generate report';
      if (err?.response?.data) {
        // backend may returned { error: "..." } or full HTML — try to extract
        const d = err.response.data;
        const serverMsg = (typeof d === 'string') ? d
                          : (d.error || d.message || JSON.stringify(d));
        msg += `: ${serverMsg}`;
      } else if (err?.message) {
        msg += `: ${err.message}`;
      }
      // small friendly alert for the UI
      alert(msg);
    } finally {
      setLoading(false);
    }
  };


  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
        {/* Topbar / Header */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            px: 3,
            py: 2,
            borderBottom: '1px solid rgba(255,204,0,0.08)',
            background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
          }}
        >
          <Avatar sx={{ bgcolor: '#000', border: '3px solid #FFCC00', width: 56, height: 56 }}>
            <Typography sx={{ color: '#FFCC00', fontWeight: 900 }}>WU</Typography>
          </Avatar>

          <Box sx={{ flex: 1 }}>
            <Typography variant="h5" sx={{ fontWeight: 900, letterSpacing: 0.6 }}>
              Global Security Operation Center
            </Typography>
            <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
              Reports & Exports — Secure access, fast insights
            </Typography>
          </Box>

          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
            <Button
              startIcon={<DownloadIcon />}
              onClick={handleGenerate}
              disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
              sx={{
                bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                color: '#000',
                fontWeight: 800,
                px: 3,
                py: 1,
                borderRadius: 3,
                boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
                transformOrigin: 'center',
                '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-2px)' : 'none' }
              }}
            >
              {loading ? 'Loading…'
                : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
            </Button>
          </Box>
        </Box>

        {/* Main content: Sidebar + Content */}
        <Grid container sx={{ px: 3, py: 4 }} spacing={3}>
          {/* Sidebar */}
          <Grid item xs={12} md={3}>
            <Paper
              elevation={8}
              sx={{
                p: 2.5,
                borderRadius: 3,
                height: { xs: 'auto', md: 'calc(100vh - 150px)' },
                overflow: 'auto',
                background: 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015))',
                border: '1px solid rgba(255,204,0,0.06)'
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
                <Box>
                  <Typography variant="subtitle1" sx={{ fontWeight: 800, color: '#FFCC00' }}>Filters</Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Narrow down by region, date and employees
                  </Typography>
                </Box>
                <IconButton size="small" sx={{ color: '#FFCC00' }}>
                  <FilterListIcon />
                </IconButton>
              </Box>

              <Divider sx={{ my: 1, borderColor: 'rgba(255,204,0,0.06)' }} />

              {/* Region */}
              <Box sx={{ mt: 1 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Region</InputLabel>
                  <Select
                    value={region}
                    onChange={e => { setRegion(e.target.value); setLocation(''); }}
                    input={<OutlinedInput label="Region" />}
                    sx={{
                      color: '#fff',
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.24)' }
                    }}
                  >
                    {REGION_OPTIONS.map(r => <MenuItem key={r} value={r}>{r.toUpperCase()}</MenuItem>)}
                  </Select>
                </FormControl>
              </Box>



           
 <Box sx={{ mt: 2 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Location</InputLabel>

                  {/* If Raw tab, show multi-select Autocomplete populated from backend.
                      For other tabs, keep previous single-select behavior. */}
                  {tab === 1 ? (
                    <Autocomplete
                      multiple
                      freeSolo={false}
                      options={availableLocations}
                      value={selectedLocations}
                      onChange={(e, v) => setSelectedLocations(v)}
                      renderInput={(params) => (
                        <TextField
                          {...params}
                           //label="Location(s)"
                          placeholder="Choose 0..n locations (leave empty = all)"
                           InputLabelProps={{ style: { color: '#FFCC00' } }}
                          sx={{
                            '& .MuiInputBase-input': { color: '#fff' },
                            '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                          }}
                        />
                      )}
                      getOptionLabel={(opt) => String(opt)}
                      isOptionEqualToValue={(opt, val) => opt === val}
                      disabled={!region}
                    />
                  ) : (


                    // <Select
                    //   value={location}
                    //   onChange={e => setLocation(e.target.value)}
                    //   input={<OutlinedInput label="Location" />}
                    //   disabled={!region}
                    //   sx={{
                    //     color: '#fff',
                    //     '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                    //   }}
                    // >
                    //   {(LOCATION_MAP[region] || []).map(loc => <MenuItem key={loc} value={loc}>{loc.split('.').pop()}</MenuItem>)}
                    // </Select>


<Select
  value={location}
  onChange={e => setLocation(e.target.value)}
  input={<OutlinedInput label="Location" />}
  disabled={!region}
  sx={{
    color: '#fff',
    '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
  }}
>
  {(
    (availableLocations && availableLocations.length) 
      ? availableLocations 
      : (LOCATION_MAP[region] || [])
  ).map(loc => (
    <MenuItem key={loc} value={loc}>
      {String(loc).split('.').pop()}
    </MenuItem>
  ))}
</Select>
            
                  )}
                </FormControl>
              </Box>





              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />


  {tab === 1 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employee (name or ID) — multiple
                  </Typography>

                  <Autocomplete
                    multiple
                    freeSolo
                    filterSelectedOptions
                    options={rawEmpOptions}
                    value={selectedRawEmps}
                    onChange={(e, v) => setSelectedRawEmps(v)}

onInputChange={async (e, value, reason) => {
  if (empQueryRef.current) clearTimeout(empQueryRef.current);

  // only query for 2+ chars
  if (!value || value.length < 2) {
    empQueryRef.current = setTimeout(() => setRawEmpOptions([]), 150);
    return;
  }

  empQueryRef.current = setTimeout(async () => {
    try {
      // pass region so backend can search right DB; if region === 'global' send nothing (server can choose default)
      const params = { q: value };
      if (region && region !== 'global') params.region = region;

      const resp = await axios.get('/api/employees', { params });

      // resp.data.data || resp.data may be:
      //  - array of strings like ["W00246", "W00247"]
      //  - array of objects like [{ EmployeeID: "W00246", Name: "Lloyd, John" }, ...]
      const raw = (resp.data && (resp.data.data || resp.data)) || [];

      const normalized = Array.isArray(raw) ? raw.map(item => {
        if (typeof item === 'string') return item;
        // object shape normalization
        const id = item.EmployeeID || item.id || item.NumericEmployeeID || item.Employee || '';
        const name = item.Name || item.name || item.ObjectName1 || '';
        if (name && id) return `${name} (${id})`;
        if (id) return String(id);
        if (name) return String(name);
        // fallback stringify small object to avoid empty option
        return JSON.stringify(item);
      }) : [];

      setRawEmpOptions(Array.from(new Set(normalized)));
    } catch (err) {
      console.warn('employee suggestions error', err);
      setRawEmpOptions([]);
    }
  }, 300); // 300ms debounce
}}



                    renderInput={(params) => (
                      <TextField
                        {...params}
                        placeholder="Type name or ID (2+ chars) — select multiple"
                        InputLabelProps={{ style: { color: '#FFCC00' } }}
                        sx={{
                          '& .MuiInputBase-input': { color: '#fff' },
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                        }}
                      />
                    )}
                    // renderOption={(props, option) => <li {...props}>{String(option)}</li>}
                    // getOptionLabel={(opt) => String(opt)}

getOptionLabel={(opt) => (typeof opt === 'string' ? opt : (opt.label || opt.name || String(opt)))}
renderOption={(props, option) => <li {...props}>{typeof option === 'string' ? option : (option.label || option.name || String(option))}</li>}




                    ListboxProps={{ style: { maxHeight: 240 } }}
                  />

                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                    Leave empty to export all raw rows for the date range. Type 2+ chars to get suggestions for employee names or IDs.
                  </Typography>

                  <Box sx={{ mt: 2 }}>
                    <FormControl fullWidth>
                      <InputLabel sx={{ color: '#FFCC00' }}>Admit / Reject</InputLabel>
                      <Select
                        value={rawAdmitFilter}
                        onChange={(e) => setRawAdmitFilter(e.target.value)}
                        input={<OutlinedInput label="Admit / Reject" />}
                        sx={{
                          color: '#fff',
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                        }}
                      >
                        <MenuItem value="all">All (Admitted + Rejected)</MenuItem>
                        <MenuItem value="admit">Admitted only</MenuItem>
                        <MenuItem value="reject">Rejected only</MenuItem>
                      </Select>
                    </FormControl>
                    <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                      Default = All.
                    </Typography>
                  </Box>
                </Box>
              )}




              {/* Dates */}
              {tab !== 5 && (
                <Box>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Date Range
                  </Typography>
                  <Box sx={{ display: 'grid', gap: 1.25 }}>
                    <TextField
                      label={tab === 0 ? 'From Date' : 'Start Date'}
                      value={from ? from.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowFromCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                    <TextField
                      label={tab === 0 ? 'To Date' : 'End Date'}
                      value={to ? to.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowToCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                  </Box>

                  {showFromCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={from}
                        onChange={(newValue) => setFrom(newValue)}
                        onAccept={() => setShowFromCal(false)}
                        onClose={() => setShowFromCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                  {showToCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={to}
                        onChange={(newValue) => setTo(newValue)}
                        onAccept={() => setShowToCal(false)}
                        onClose={() => setShowToCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                </Box>
              )}

{tab === 0 && (
  <Box>
    <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
      Employees
    </Typography>

    {/* Add employee by name or ID */}
    <Box sx={{ display: 'flex', gap: 1, mb: 1 }}>
      <TextField
        fullWidth
        placeholder="Add name or ID (e.g. 'Vainilaitis, Valdas' or '323471')"
        value={newEmployee}
        onChange={(e) => setNewEmployee(e.target.value)}
        sx={{
          '& .MuiInputBase-input': { color: '#fff' },
          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
        }}
        InputLabelProps={{ style: { color: '#FFCC00' } }}
      />
      <Button
        variant="contained"
        onClick={() => {
          const v = (newEmployee || '').toString().trim();
          if (!v) return;
          if (!selectedEmps.includes(v)) {
            setSelectedEmps(prev => [...prev, v]);
          }
          setNewEmployee('');
        }}
        sx={{
          bgcolor: '#FFCC00',
          color: '#000',
          fontWeight: 800,
          px: 2,
          '&:hover': { bgcolor: '#ffd84d' }
        }}
      >
        Add
      </Button>
    </Box>

    <FormControl fullWidth>
      <InputLabel sx={{ color: '#FFCC00' }}>Employees</InputLabel>

      <Select
        multiple
        value={selectedEmps}
        onChange={e => setSelectedEmps(e.target.value)}
        input={<OutlinedInput label="Employees" />}
        renderValue={vals => vals.join(', ')}
        sx={{
          color: '#fff',
          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
        }}
      >
        {[
          ...EMPLOYEE_OPTIONS,
          ...selectedEmps.filter(s => !EMPLOYEE_OPTIONS.includes(s))
        ].map(n => (
          <MenuItem key={n} value={n}>
            <Checkbox checked={selectedEmps.includes(n)} />
            <ListItemText primary={n} />
          </MenuItem>
        ))}
      </Select>
    </FormControl>
  </Box>
)}

              <Box sx={{ mt: 3, p: 2, borderRadius: 2, background: 'rgba(255,255,255,0.02)' }}>
                <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                  Tip: For daily exports pick employees & a single day range. For Time Duration choose the required partition via Location.
                </Typography>
              </Box>
            </Paper>
          </Grid>

          {/* Main panel */}
          <Grid item xs={12} md={9}>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              <Paper
                elevation={3}
                sx={{
                  px: 2,
                  py: 1,
                  borderRadius: 2,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  gap: 2,
                  border: '1px solid rgba(255,204,0,0.04)'
                }}
              >
                <Tabs
                  value={tab}
                  onChange={handleTabChange}
                  sx={{
                    '& .MuiTab-root': {
                      textTransform: 'none',
                      minWidth: 120,
                      fontWeight: 700,
                      color: 'rgba(255,255,255,0.8)'
                    },
                    '& .Mui-selected': { color: '#FFCC00' }
                  }}
                >
                  <Tab icon={<CalendarTodayIcon />} label="Daily Access" />
                  <Tab icon={<PeopleIcon />} label="Raw" />
                  <Tab icon={<PlaceIcon />} label="Rejection" />
                  <Tab icon={<PeopleIcon />} label="EUROC Admit-Reject" />
                  <Tab icon={<CalendarTodayIcon />} label="Time Duration" />
                  <Tab icon={<PeopleIcon />} label="HeadCount" />
                </Tabs>

                <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                  <Button
                    variant="text"
                    startIcon={<FilterListIcon />}
                    sx={{ color: 'rgba(255,255,255,0.65)', textTransform: 'none' }}
                    onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}
                  >
                    Reset View
                  </Button>
                </Box>
              </Paper>

              <Paper elevation={6} sx={{ p: 3, borderRadius: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 2 }}>
                <Box>
                  <Typography variant="h6" sx={{ fontWeight: 900 }}>Export Center</Typography>
                  <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                    Selected Region: <strong style={{ color: '#FFCC00' }}>{region.toUpperCase()}</strong> {location ? `• ${location.split('.').pop()}` : ''}
                  </Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Choose tab, select filters and export reports in Excel.
                  </Typography>
                </Box>

                <Box>
                  <Button
                    startIcon={loading ? <CircularProgress size={20} /> : <DownloadIcon />}
                    disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
                    onClick={handleGenerate}
                    sx={{
                      bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                      color: '#000',
                      fontWeight: 900,
                      px: 4,
                      py: 1,
                      borderRadius: 3,
                      boxShadow: '0 8px 30px rgba(255,204,0,0.22)',
                      '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-3px)' : 'none' }
                    }}
                  >
                    {loading
                      ? 'Loading…'
                      : (tab === 5
                          ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`)
                          : 'Export to Excel')}
                  </Button>
                </Box>
              </Paper>

            </Box>
          </Grid>

        </Grid>
      </Box>
    </LocalizationProvider>
  );
}






//C:\Users\W0024618\Desktop\global-page\frontend\src\components\MapChart.jsx
import React, { useState, useEffect } from 'react';
import {
  ComposableMap,
  Geographies,
  Geography,
  Marker,
  ZoomableGroup,
} from 'react-simple-maps';
import { useTheme } from '@mui/material/styles';
import Box from '@mui/material/Box';
import IconButton from '@mui/material/IconButton';
import AddIcon from '@mui/icons-material/Add';
import RemoveIcon from '@mui/icons-material/Remove';
import theme, { brandColors } from '../theme.js';

const geoUrl = '/world-110m.json';

const apacList = [
  { name: 'Pune, India', coords: [73.8567, 18.5204], url: 'http://10.199.22.57:3011' },
  { name: 'Hyderabad, India', coords: [80.8500, 11.5204], url: 'http://10.199.22.57:3000/partition/IN.HYD' },
  { name: 'Quezon City, Philippines', coords: [121.0509, 14.6760], url: 'http://10.199.22.57:3000/partition/Quezon%20City' },
  { name: 'Tokyo, Japan', coords: [139.6917, 35.6895], url: 'http://10.199.22.57:3000/partition/JP.Tokyo' },
  { name: 'Taguig City, Philippines', coords: [121.0437, 14.5547], url: 'http://10.199.22.57:3000/partition/Taguig%20City' },
  { name: 'Kuala Lumpur, Malaysia', coords: [101.6869, 3.1390], url: 'http://10.199.22.57:3000/partition/MY.Kuala%20Lumpur' },
];

const lacaList = [
  { name: 'San José, Costa Rica', coords: [-84.0907, 9.9281], url: 'http://10.199.22.57:3003/partition/CR.Costa%20Rica%20Partition' },
  { name: 'Mexico City, Mexico', coords: [-99.1332, 19.4326], url: 'http://10.199.22.57:3003/partition/MX.Mexico%20City' },
  { name: 'Buenos Aires, Argentina', coords: [-58.3816, -34.6037], url: 'http://10.199.22.57:3003/partition/AR.Cordoba' },
  { name: 'Panama City, Panama', coords: [-79.5167, 8.9833], url: 'http://10.199.22.57:3003/partition/PA.Panama%20City' },
  { name: 'Lima, Peru', coords: [-77.0428, -12.0464], url: 'http://10.199.22.57:3003/partition/PE.Lima' },
  { name: 'Brasília, Brazil', coords: [-47.8825, -15.7942], url: 'http://10.199.22.57:3003/partition/BR.Sao%20Paulo' },
];

const emeaList = [
  { name: 'Dubai, UAE', coords: [55.2708, 25.2048], url: 'http://10.199.22.57:3001/partition/DU.Abu%20Dhab' },
  { name: 'London, UK', coords: [-0.1278, 51.5074], url: 'http://10.199.22.57:3001/partition/UK.London' },
  { name: 'Dublin, Ireland', coords: [-6.2603, 53.3498], url: 'http://10.199.22.57:3001/partition/IE.Dublin' },
  { name: 'Moscow, Russia', coords: [37.6173, 55.7558], url: 'http://10.199.22.57:3001/partition/RU.Moscow' },
  { name: 'Casablanca, Morocco', coords: [-7.5898, 33.5731], url: 'http://10.199.22.57:3001/partition/MA.Casablanca' },
  { name: 'Vilnius, Lithuania', coords: [25.2797, 54.6872], url: 'http://10.199.22.57:3001/partition/LT.Vilnius' },
];

const namerList = [
  { name: 'Denver, USA', coords: [-104.9903, 39.7392], url: 'http://10.199.22.57:3012'},
  { name: 'New York, USA', coords: [-74.0060, 40.7128], url: 'http://10.199.22.57:3002/partition/US.NYC' },
  { name: 'Miami, USA', coords: [-80.1918, 25.7617], url: 'http://10.199.22.57:3002/partition/US.FL.Miami' },
  { name: 'Austin, USA', coords: [-97.7431, 30.2672], url: 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default' },
];

const REGION_COUNTRIES = {
  global: [...apacList, ...emeaList, ...lacaList, ...namerList],
  apac: apacList,
  emea: emeaList,
  laca: lacaList,
  namer: namerList,
};

const regionOrder = ['global', 'apac', 'emea', 'laca', 'namer'];
function getColor(region, palette) {
  return palette[regionOrder.indexOf(region) % palette.length];
}



// Instead of hiding label, we'll only offset their positions
const CITY_OFFSETS = {
  'Taguig City, Philippines': [5.5, -8], // slightly to the right & down
  'Panama City, Panama': [5.5, -8],
  'Dublin, Ireland': [9.9, -10],
  'Moscow, Russia': [7.5, -0.5],
};



// export default function MapChart({ selected = 'global', onClickSite, initialZoom = 5, }) {
//   const theme = useTheme();
//   const brands = theme.palette.brand.colors;

export default function MapChart({ selected = 'global', onClickSite, initialZoom = 5, }) {
  const theme = useTheme();
  // pull colors array directly instead of theme.palette.brand
  const brands = brandColors;



  // Zoom & center
  // const [zoom, setZoom] = useState();

  // Zoom & center
  // Use a ref to know if we’re mounting for the first time
  const firstMount = React.useRef(true);
  const [zoom, setZoom] = useState(initialZoom);


  const [center, setCenter] = useState([0, 20]);
  useEffect(() => {


    // recenter every time region changes
    if (selected === 'global') {
      setCenter([0, 13]);
      // only reset zoom on first mount if you want; otherwise keep whatever zoom is
      if (firstMount.current) {
        setZoom(initialZoom);
        firstMount.current = false;
      }
    } else {

      const list = REGION_COUNTRIES[selected] || [];
      if (list.length) {
        setCenter(list[0].coords);
        setZoom(selected === 'apac' || selected === 'emea' ? 2 : 3);
      }
    }
  }, [selected]);

  const handleZoomIn = () => setZoom(z => Math.min(z * 1.9, 10));
  const handleZoomOut = () => setZoom(z => Math.max(z / 1.5, 1));

  // Build markers with label / tooltip behavior
  const markers = REGION_COUNTRIES[selected].map((m, idx) => {
    const [city] = m.name.split(',');




const offset = CITY_OFFSETS[m.name] || [0, 0];
const coords = [m.coords[0] + offset[0], m.coords[1] + offset[1]];

return {
  name: city.trim(),
  coords,
  color: brands[idx % brands.length],
  showLabel: true, // ✅ Show label for all cities
  tooltip: null,    // Optional: keep tooltip if needed
  url: m.url,
};


  });




  return (
    <Box sx={{ position: 'relative', width: '100%', height: '100%' }}>
      {/* Zoom Controls */}
      <Box
        sx={{
          position: 'absolute',
          top: 8,
          right: 8,
          display: 'flex',
          flexDirection: 'column',
          zIndex: 10,
        }}
      >
        <IconButton size="small" onClick={handleZoomIn}>
          <AddIcon fontSize="small" />
        </IconButton>
        <IconButton size="small" onClick={handleZoomOut}>
          <RemoveIcon fontSize="small" />
        </IconButton>
      </Box>

      <ComposableMap
        projectionConfig={{ rotate: [-10, 0, 0], scale: 150 }}
        style={{
          width: '100%',
          height: '100%',

          // border: '1px solid #d0d0d0', // professional border
          borderRadius: '12px',
          boxShadow: '0 4px 20px rgba(0, 0, 0, 0.1)',
        }}
      >
        <ZoomableGroup center={center} zoom={zoom}>
          {/* Countries */}
          <Geographies geography={geoUrl}>
            {({ geographies }) =>
              geographies.map(geo => {
                const name = geo.properties.NAME;
                const inRegion = REGION_COUNTRIES[selected].some(
                  c => c.name.split(',').pop().trim() === name
                );
                return (
                  <Geography
                    key={geo.rsmKey}
                    geography={geo}
                    fill={
                      inRegion
                        ? getColor(selected, brands)
                        : theme.palette.grey[900]
                    }
                    stroke={theme.palette.grey[700]}
                    strokeWidth={0.5}
                    style={{ default: { outline: 'none' } }}
                  />
                );
              })
            }
          </Geographies>

         
{/* 
          {markers.map((m, i) => {
            const r = 1 * zoom;
            return (
              <Marker
                key={i}
                coordinates={m.coords}
                onClick={() => {
                  if (m.url) {
                    window.location.href=m.url; // ✅ Use URL from data
                  }
                }}
                style={{ cursor: 'pointer' }} */}
              {/* > */}

          {markers.map((m, i) => {
            const r = 1 * zoom;
            return (
              <Marker
                key={i}
                coordinates={m.coords}
                onClick={() => {
                  // delegate navigation/permission-check to parent
                  if (typeof onClickSite === 'function') {
                    onClickSite({ ...m, region: selected });
                    return;
                  }
                 // fallback (preserve previous behaviour if no handler passed)
                  if (m.url) window.location.href = m.url;
                }}
                style={{ cursor: 'pointer' }}
              >

                <svg
                  width={5 * zoom}
                  height={5 * zoom}
                  viewBox="0 0 16 16"
                  fill={m.color}
                  xmlns="http://www.w3.org/2000/svg"
                  style={{ transform: 'translate(-8px, -16px)', cursor: 'pointer' }}
                >
                  <path d="M8 0a5 5 0 0 0-5 5c0 4.25 5 11 5 11s5-6.75 5-11a5 5 0 0 0-5-5zm0 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4z" />
                  {m.tooltip && <title>{m.tooltip}</title>}
                </svg>

                {m.showLabel && (
                  <text
                    textAnchor="middle"
                    y={-12 * zoom}
                    fill={m.color}
                    fontSize={5 * zoom}
                    fontWeight="bold"
                    style={{
                      paintOrder: 'stroke',
                      strokeWidth: 1,
                      strokeLinejoin: 'round',
                      cursor: 'pointer', // Ensure text also shows pointer
                    }}
                  >
                    {m.name}
                  </text>
                )}
              </Marker>
            );
          })}


        </ZoomableGroup>
      </ComposableMap>
    </Box>
  );
}












































