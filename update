Check each file line by line and fix the issue carefully and share me fully updated file so i can easily swap file each other


//C:\Users\W0024618\Desktop\global-page\backend\controllers\reportController.js
import { rawReport } from '../services/reportService.js';

const ALL_REGIONS = ['apac', 'emea', 'laca', 'namer'];

export async function rawReportHandler(req, res) {
  try {
    const regionRaw = (req.query.region || '').toString();
    const region = regionRaw.toLowerCase();
    const location = req.query.location ? req.query.location.toString().trim() : undefined;
    const startDateParam = req.query.startDate;
    const endDateParam = req.query.endDate;
    const admitFilter = req.query.admitFilter ? req.query.admitFilter.toString().toLowerCase() : 'all';

    if (!region) return res.status(400).json({ success: false, message: 'region required' });
    if (!startDateParam || !endDateParam) {
      return res.status(400).json({ success: false, message: 'startDate and endDate required' });
    }

    const startDate = new Date(startDateParam);
    const endDate = new Date(endDateParam);
    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      return res.status(400).json({ success: false, message: 'Invalid date format' });
    }

    // GLOBAL: query all regions and merge results
    if (region === 'global') {
      const promises = ALL_REGIONS.map(r => rawReport(r, { startDate, endDate, location, admitFilter }));
      const results = await Promise.all(promises);
      // results is array of recordsets -> flatten
      const merged = results.flat();
      // Optionally sort by LocaleMessageTime desc to keep consistent ordering
      merged.sort((a, b) => {
        const ta = a.LocaleMessageTime ? new Date(a.LocaleMessageTime).getTime() : 0;
        const tb = b.LocaleMessageTime ? new Date(b.LocaleMessageTime).getTime() : 0;
        return tb - ta;
      });
      return res.json({ success: true, data: merged });
    }

    // Normal single-region flow
    const rows = await rawReport(region, { startDate, endDate, location, admitFilter });
    return res.json({ success: true, data: rows });
  } catch (err) {
    console.error('rawReportHandler error', err);
    return res.status(500).json({ success: false, message: err.message || 'server error' });
  }
}











// C:\Users\W0024618\Desktop\global-page\backend\routes\reports.js
import express from 'express';
import {
  rawReport,
  rejectionReport,
  dailyAccessReportEMEA, inOutReport,
   timeDurationReport,
   eurocAdmitRejectionReport 
} from '../services/reportService.js';

import { rawReportHandler } from '../controllers/reportController.js';

const router = express.Router();

router.get('/raw', rawReportHandler);

// Helper to unify GET/POST inputs
function getParam(req, name, defaultValue = undefined) {
  if (req.method === 'GET') {
    return req.query[name] ?? defaultValue;
  } else {
    return req.body[name] ?? defaultValue;
  }
}

// Middleware to ensure `region` is defined
function requireRegion(req, res, next) {
  const region = getParam(req, 'region');
  if (!region) {
    return res
      .status(400)
      .json({ error: "Missing required parameter: 'region'" });
  }
  next();
}

// RAW Report handler
async function handleRaw(req, res, next) {
  try {
    const region    = getParam(req, 'region');
    const startDate = getParam(req, 'startDate');
    if (!startDate) {
      return res
        .status(400)
        .json({ error: "Missing required parameter: 'startDate'" });
    }
    const data = await rawReport(region, { startDate });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}
router.get ('/raw',  requireRegion, handleRaw);
router.post('/raw',  requireRegion, handleRaw);


// Rejection Report handler (supports region=global)
async function handleRejection(req, res, next) {
  try {
    const regionRaw = getParam(req, 'region');
    const region = (regionRaw || '').toString().toLowerCase();
    const startDateParam = getParam(req, 'startDate');
    const endDateParam = getParam(req, 'endDate');
    const location = getParam(req, 'location', undefined);

    if (!startDateParam || !endDateParam) {
      return res
        .status(400)
        .json({ error: "Missing required parameters: 'startDate' and/or 'endDate'" });
    }

    const startDate = new Date(startDateParam);
    const endDate = new Date(endDateParam);
    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      return res.status(400).json({ error: "Invalid date format for startDate/endDate" });
    }

    const ALL_REGIONS = ['apac', 'emea', 'laca', 'namer'];

    if (region === 'global') {
      const promises = ALL_REGIONS.map(r => rejectionReport(r, { startDate, endDate, location }));
      const results = await Promise.all(promises);
      const merged = results.flat();
      // sort by LocaleMessageTime desc (most recent first)
      merged.sort((a, b) => {
        const ta = a.LocaleMessageTime ? new Date(a.LocaleMessageTime).getTime() : 0;
        const tb = b.LocaleMessageTime ? new Date(b.LocaleMessageTime).getTime() : 0;
        return tb - ta;
      });
      return res.json({ data: merged });
    }

    // single-region
    const data = await rejectionReport(region, { startDate, endDate, location });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}

router.get('/rejection', requireRegion, handleRejection);
router.post('/rejection', requireRegion, handleRejection);





// Daily Access Report handler
async function handleDailyAccess(req, res, next) {
  try {
    const region    = getParam(req, 'region');
    const from      = getParam(req, 'from');
    const to        = getParam(req, 'to');
    if (!from || !to) {
      return res
        .status(400)
        .json({ error: "Missing required parameters: 'from' and/or 'to'" });
    }
    // employees: POST expects array, GET expects comma-separated string
    let employees = getParam(req, 'employees', []);
    if (typeof employees === 'string') {
      employees = employees.split(',').map(s => s.trim()).filter(Boolean);
    }
    if (!Array.isArray(employees) || employees.length === 0) {
      return res
        .status(400)
        .json({ error: "Missing or empty required parameter: 'employees'" });
    }
    const data = await dailyAccessReportEMEA({ from, to });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}
router.get ('/daily-access',  requireRegion, handleDailyAccess);
router.post('/daily-access',  requireRegion, handleDailyAccess);

// In vs Out Report handler
async function handleInOut(req, res, next) {
  try {
    const region = getParam(req, 'region');
    const year   = parseInt(getParam(req, 'year'),  10);
    const month  = parseInt(getParam(req, 'month'), 10);
    if (Number.isNaN(year) || Number.isNaN(month)) {
      return res
        .status(400)
        .json({ error: "Missing or invalid parameters: 'year' and/or 'month'" });
    }
    // doors: POST expects array, GET expects comma-separated string
    let doors = getParam(req, 'doors', []);
    if (typeof doors === 'string') {
      doors = doors.split(',').map(s => s.trim()).filter(Boolean);
    }
    if (!Array.isArray(doors) || doors.length === 0) {
      return res
        .status(400)
        .json({ error: "Missing or empty required parameter: 'doors'" });
    }
    const data = await inOutReport(region, { year, month, doors });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}
router.get ('/in-out',  requireRegion, handleInOut);
router.post('/in-out',  requireRegion, handleInOut);


// Time Duration Report handler
async function handleTimeDuration(req, res, next) {
  try {
    const region    = getParam(req, 'region');
    const startDate = getParam(req, 'startDate');
    const partition = getParam(req, 'partition', 'Default');

    if (!startDate) {
      return res
        .status(400)
        .json({ error: "Missing required parameter: 'startDate'" });
    }

    const data = await timeDurationReport(region, { partition, startDate });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}
router.get('/time-duration',  requireRegion, handleTimeDuration);
router.post('/time-duration', requireRegion, handleTimeDuration);





// EUROC Admit-Rejection handler
async function handleEuroc(req, res, next) {
  try {
    const region = getParam(req, 'region');
    const dateParam = getParam(req, 'date'); // expected YYYY-MM-DD or JS date string
    if (!region || region.toLowerCase() !== 'emea') {
      return res.status(400).json({ error: "EUROC report only supported for region 'emea'" });
    }
    if (!dateParam) {
      return res.status(400).json({ error: "Missing required parameter: 'date' (YYYY-MM-DD)" });
    }
    // normalize date (send only date part)
    const dt = new Date(dateParam);
    if (Number.isNaN(dt.getTime())) {
      return res.status(400).json({ error: "Invalid date parameter" });
    }
    const isoDate = dt.toISOString().slice(0, 10); // YYYY-MM-DD
    const data = await eurocAdmitRejectionReport(region, { reportDate: isoDate });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}
router.get('/euroc-admit-rejection', requireRegion, handleEuroc);
router.post('/euroc-admit-rejection', requireRegion, handleEuroc);



export default router;






//C:\Users\W0024618\Desktop\global-page\backend\services\reportService.js

 import { getPool, sql } from '../config/dbConfig.js';

export async function rawReport(region, { startDate, endDate, location, admitFilter = 'all' }) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const pool = await getPool(region);
  const req = pool.request();

  // Accept NULL for location to mean "all partitions in this region DB"
  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;

  req.input('location', sql.NVarChar(200), locationParam);
  req.input('startDate', sql.Date, startDate);
  req.input('endDate', sql.Date, endDate);
  req.input('admitFilter', sql.NVarChar(20), String(admitFilter || 'all'));

  const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    -- message types we consider
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    -- location optional filter
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    -- admit/reject filter: 'all' | 'admit' | 'reject' (case-insensitive)
    AND (
      UPPER(ISNULL(@admitFilter,'all')) = 'ALL'
      OR (UPPER(@admitFilter) = 'ADMIT'  AND t1.MessageType = 'CardAdmitted')
      OR (UPPER(@admitFilter) = 'REJECT' AND t1.MessageType = 'CardRejected')
    )
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM CombinedQuery
ORDER BY LocaleMessageTime ASC;
`;

  const { recordset } = await req.query(query);
  return recordset;
}





export async function rejectionReport(region, { startDate, endDate, location } = {}) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const pool = await getPool(region);
  const req = pool.request();

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;

  req.input('location', sql.NVarChar(200), locationParam);
  req.input('startDate', sql.Date, startDate);
  req.input('endDate', sql.Date, endDate);

  const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType = 'CardRejected'
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
),
Unified AS (
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Lost'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Clearance'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type IN ('CardDisabled','Disabled')
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Stolen'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Expired'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'PIN'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'UnknownCard'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'SiteCode'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'NotActivated'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'FacilityCode'
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM Unified
ORDER BY LocaleMessageTime DESC;
`;

  const { recordset } = await req.query(query);
  return recordset;
}




// backend/services/reportService.js
export async function dailyAccessReportEMEA({ from, to, employees = '' }) {
  const pool = await getPool('emea');
  const req  = pool.request();

  req.input('fromDate', sql.Date, from);
  req.input('toDate',   sql.Date, to);
  const employeesParam = (employees && String(employees).trim()) ? String(employees).trim() : null;
  req.input('employees', sql.NVarChar(sql.MAX), employeesParam);

  const query = `

  -- expects parameters: @fromDate (DATE), @toDate (DATE), @employees (NVARCHAR(MAX) | NULL)
DECLARE @empCSV NVARCHAR(MAX) = @employees;

;WITH EmpList AS (
  SELECT LTRIM(RTRIM(value)) AS emp
  FROM STRING_SPLIT(ISNULL(@empCSV,''), ',')
  WHERE LTRIM(RTRIM(value)) <> ''
)

-- Raw rows: compute LocaleMessageTime once and use OUTER APPLY to avoid duplicate shreddes
, RawSwipes AS (
  SELECT
    t1.ObjectName1,
    t1.ObjectName2,
    t1.MessageType,
    t2.Text12       AS EmployeeID,
    CAST(t2.Int1 AS NVARCHAR(50)) AS NumericEmployeeID,
    t3.Name         AS PersonnelType,
    t1.PartitionName2 AS PartitionName2,

    -- compute local wall-clock once (DO NOT change sign here; using your -1 * MessageLocaleOffset)
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,

    -- direction/value picked by OUTER APPLY (single row)
    CASE
      WHEN dir.Value = 'InDirection'  THEN 'IN'
      WHEN dir.Value = 'OutDirection' THEN 'OUT'
      ELSE 'Unknown'
    END AS Swipe,

    card.Value AS CardNumber
  FROM ACVSUJournal_00011028.dbo.ACVSUJournalLog AS t1
  INNER JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  INNER JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID

  -- pick at most one direction shred row (InDirection/OutDirection)
  OUTER APPLY (
    SELECT TOP (1) s.Value
    FROM ACVSUJournal_00011028.dbo.ACVSUJournalLogxmlShred AS s
    WHERE s.GUID = t1.XmlGUID
      AND s.Value IN ('InDirection','OutDirection')
  ) AS dir

  -- pick at most one numeric card value (exclude direction values, ensure numeric)
  OUTER APPLY (
    SELECT TOP (1) s.Value
    FROM ACVSUJournal_00011028.dbo.ACVSUJournalLogxmlShred AS s
    WHERE s.GUID = t1.XmlGUID
      AND s.Value NOT IN ('InDirection','OutDirection')
      AND s.Value NOT LIKE '%[^0-9]%'
      AND s.Value IS NOT NULL
      AND LTRIM(RTRIM(s.Value)) <> ''
  ) AS card
)

-- Strict time window: >= 08:00 on @fromDate, and < 08:00 on @toDate
, Windowed AS (
  SELECT *
  FROM RawSwipes
  WHERE
    LocaleMessageTime >= DATEADD(HOUR, 8, CAST(@fromDate AS DATETIME))
    -- NOTE: removed extra DATEADD(DAY,1,...) ‚Äî upper bound should be < toDate 08:00
    AND LocaleMessageTime <  DATEADD(HOUR, 8, CAST(@toDate AS DATETIME))
    AND Swipe IN ('IN','OUT') -- only real swipes
)

-- final projection + optional employee filter (supports CSV of names or IDs)
SELECT
  ObjectName1,
  ObjectName2,
  PersonnelType,
  EmployeeID,
  NumericEmployeeID,
  -- alias PartitionName2 -> location so frontend sees r.location
  PartitionName2 AS location,
  -- alias MessageType -> Messagetype so frontend sees r.Messagetype
  MessageType AS Messagetype,
  Swipe,
  CardNumber,
  LocaleMessageTime
FROM Windowed w
WHERE
  (
    @empCSV IS NULL
    OR LTRIM(RTRIM(@empCSV)) = ''
    OR EXISTS (
      SELECT 1
      FROM EmpList e
      WHERE
        e.emp = LTRIM(RTRIM(w.ObjectName1))
        OR e.emp = w.EmployeeID
        OR e.emp = w.NumericEmployeeID
    )
  )
ORDER BY LocaleMessageTime;

`;

  const { recordset } = await req.query(query);
  return recordset;
}












/**
 * In-vs-Out Report (parameterized) ‚Äî groups by employee & month
 */
export async function inOutReport(region, { year, month, doors }) {
  const pool = await getPool(region);
  const req  = pool.request();

  req.input('TargetYear',  sql.Int, year);
  req.input('TargetMonth', sql.Int, month);
  doors.forEach((d, i) => req.input(`door${i}`, sql.NVarChar, d));
  const doorList = doors.map((_, i) => `@door${i}`).join(',');

  const query = `
WITH CombinedQuery AS (
  SELECT
    DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
    t1.ObjectName1,
    t1.PartitionName2    AS location,
    t5_card.CardNumber,
    t5_dir.value         AS Direction,
    CASE
      WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
      ELSE CAST(t2.Int1 AS NVARCHAR)
    END                    AS EmployeeID,
    t3.Name               AS PersonnelType
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID
    AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml AS t_xml
    ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard
    ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  WHERE
    YEAR(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetYear
    AND MONTH(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetMonth
    AND t1.ObjectName2 IN (${doorList})
)
SELECT
  FORMAT(LocaleMessageTime,'yyyy-MM')    AS Month,
  ObjectName1                           AS EmployeeName,
  EmployeeID,
  PersonnelType,
  location,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)  AS In_Count,
  SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS Out_Count,
  COUNT(*)                                                 AS TotalSwipes,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)
  - SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS InOut_Difference
FROM CombinedQuery
GROUP BY FORMAT(LocaleMessageTime,'yyyy-MM'),
         ObjectName1, EmployeeID, PersonnelType, location
ORDER BY Month DESC, EmployeeName;
`;

  const { recordset } = await req.query(query);
  return recordset;
}



/**
 * Time Duration Report (parameterized by region, partition, startDate)
 */
export async function timeDurationReport(region, { partition = 'Default', startDate }) {
  const pool = await getPool(region);
  const req  = pool.request();

  // bind inputs
  const fullPartition = `${region.toUpperCase()}.${partition}`;
  req.input('partition', sql.NVarChar, fullPartition);
  req.input('startDate', sql.Date, startDate);

  const query = `

SELECT 
    t1.[ObjectName1],
    t1.[ObjectName2],
    t1.[PartitionName2],
    CASE
        WHEN t2.[Int1] = 0 THEN t2.[Text12]
        ELSE CAST(t2.[Int1] AS NVARCHAR)
    END AS EmployeeID,
    t3.[Name] AS PersonnelType,
    t2.text5,
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    DATEADD(HOUR, -2, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) AS AdjustedMessageTime
INTO 
    #CombinedEmployeeData
FROM 
    [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] AS t1
INNER JOIN 
    [ACVSCore].[Access].[Personnel] AS t2
    ON t1.ObjectIdentity1 = t2.GUID
INNER JOIN 
    [ACVSCore].[Access].[PersonnelType] AS t3
    ON t2.[PersonnelTypeId] = t3.[ObjectID];

-- Step 2: Daily duration per employee
WITH DailyDurations AS (
    SELECT 
        [ObjectName1],
        PersonnelType,
        EmployeeID,
        [PartitionName2],
        text5,
        CONVERT(DATE, AdjustedMessageTime) AS ShiftedDate,
        DATEPART(WEEK, AdjustedMessageTime) AS WeekNumber,
        DATEPART(YEAR, AdjustedMessageTime) AS YearNumber,
        MIN(LocaleMessageTime) AS FirstSwipeTime,
        MAX(LocaleMessageTime) AS LastSwipeTime,
        DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) AS DurationMinutes,
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) / 60 AS NVARCHAR), 2)
        + ':' +
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) % 60 AS NVARCHAR), 2) AS DurationHHMM,
        CASE 
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 5 THEN '<5mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 10 THEN '<10mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 20 THEN '<20mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 30 THEN '<30mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 60 THEN '<1hr'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 120 THEN 'Less than <2hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 180 THEN 'Less than <3hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 240 THEN 'Less than <4hrs'
            ELSE '4+ hrs'
        END AS TimeDiffCategory
    FROM 
        #CombinedEmployeeData



  WHERE CONVERT(DATE, AdjustedMessageTime) >= @startDate

   AND [PartitionName2] = 'APAC.Default'
        AND PersonnelType IN ('Employee', 'Terminated Personnel')
    GROUP BY 
        [ObjectName1], EmployeeID, PersonnelType, text5, [PartitionName2],
        CONVERT(DATE, AdjustedMessageTime),
        DATEPART(WEEK, AdjustedMessageTime),
        DATEPART(YEAR, AdjustedMessageTime)
),

-- Step 3: Weekly summary
WeeklySummary AS (
    SELECT 
        EmployeeID,
        [ObjectName1],
        PersonnelType,
        text5,
        [PartitionName2],
        YearNumber,
        WeekNumber,
        COUNT(DISTINCT ShiftedDate) AS DaysPresentInWeek,
        SUM(CASE WHEN DurationMinutes < 240 THEN 1 ELSE 0 END) AS ViolationDaysInWeek
    FROM 
        DailyDurations
    GROUP BY 
        EmployeeID, [ObjectName1], PersonnelType, text5, [PartitionName2], YearNumber, WeekNumber
)

-- Step 4: Final output with daily duration, category, and defaulter flag
SELECT 
    dd.EmployeeID,
    dd.ObjectName1,
    dd.PersonnelType,
    dd.text5,
    dd.PartitionName2,
    dd.YearNumber,
    dd.WeekNumber,
    dd.ShiftedDate,
    dd.FirstSwipeTime,
    dd.LastSwipeTime,
    dd.DurationHHMM,
    dd.TimeDiffCategory,
    ws.DaysPresentInWeek,
    ws.ViolationDaysInWeek,
    (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) AS CleanDaysInWeek,
    CASE
        WHEN (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) < 3 THEN 'Yes'
        ELSE 'No'
    END AS Defaulter
FROM 
    DailyDurations dd
JOIN 
    WeeklySummary ws
    ON dd.EmployeeID = ws.EmployeeID
    AND dd.WeekNumber = ws.WeekNumber
    AND dd.YearNumber = ws.YearNumber
ORDER BY 
    dd.YearNumber DESC, dd.WeekNumber DESC, dd.EmployeeID, dd.ShiftedDate;
  `;

  const { recordset } = await req.query(query);
  return recordset;
}


//EUROC 




export async function eurocAdmitRejectionReport(region, { reportDate }) {
  const pool = await getPool(region);
  const req  = pool.request();

  // enforce location LT.Vilnius (as requested)
  req.input('location', sql.NVarChar, 'LT.Vilnius');
  // reportDate should be YYYY-MM-DD or Date ‚Äî bind as sql.Date
  req.input('reportDate', sql.Date, reportDate);

  const query = `
/*
  Approach:
  1) Build CombinedQuery as a CTE and SELECT INTO #Combined (materialize)
  2) Build #Admits (with ROW_NUMBER) and #Rejections from #Combined
  3) Return three resultsets: admits (rn=1), rejections (all), summary (counts)
*/

WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    AND t1.PartitionName2 = @location
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @reportDate
)

-- materialize CombinedQuery into a temp table
SELECT
  LocaleMessageTime,
  CONVERT(date, LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  MessageType
INTO #Combined
FROM CombinedQuery;

-- create admits with row number (first admit per employee)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  ROW_NUMBER() OVER (PARTITION BY ISNULL(EmployeeID, CardNumber) ORDER BY LocaleMessageTime ASC) AS rn
INTO #Admits
FROM #Combined
WHERE MessageType = 'CardAdmitted'
  AND PersonnelType = 'Employee';

-- create rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
INTO #Rejections
FROM #Combined
WHERE MessageType = 'CardRejected';

-- resultset 1: admits (only rn = 1)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Admits
WHERE rn = 1
ORDER BY LocaleMessageTime ASC;

-- resultset 2: rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Rejections
ORDER BY LocaleMessageTime ASC;

-- resultset 3: summary counts by Rejection_Type
SELECT
  ISNULL(Rejection_Type, 'Unknown') AS Rejection_Type,
  COUNT(*) AS CountVal
FROM #Rejections
GROUP BY ISNULL(Rejection_Type, 'Unknown')
ORDER BY CountVal DESC;

-- cleanup temp tables (optional ‚Äî they scope to the session and will go away automatically,
-- but good practice to drop)
DROP TABLE IF EXISTS #Admits;
DROP TABLE IF EXISTS #Rejections;
DROP TABLE IF EXISTS #Combined;
`;

  const result = await req.query(query);
  // result.recordsets is an array of resultsets
  const recordsets = result.recordsets || [];
  const admitRows = (recordsets[0] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const rejectRows = (recordsets[1] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Rejection_Type: r.Rejection_Type,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const summaryRows = (recordsets[2] || []).map(r => ({ Rejection_Type: r.Rejection_Type, Count: r.CountVal }));

  return { admit: admitRows, rejection: rejectRows, summary: summaryRows };
}








// C:\Users\W0024618\Desktop\global-page\backend\index.js
import express from 'express';
import cors from 'cors';
import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';
import reportsRouter from './routes/reports.js';
import headcountRouter from './routes/headcount.js';
import vipRouter       from './routes/vip.js';
import authRouter      from './routes/auth.js';   // <-- NEW

const __filename = fileURLToPath(import.meta.url);
const __dirname  = dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3008;

// 1) Middleware
app.use(cors());              // enable CORS for all origins
app.use(express.json());      // parse JSON payloads

// 2) Static Assets (if you have any in ../public)
app.use(express.static(resolve(__dirname, '../public')));

// 3) API Routes
app.use('/api/headcount', headcountRouter);
app.use('/api/vip',       vipRouter);
app.use('/api/reports',   reportsRouter);
app.use('/api/auth',      authRouter);   // <-- NEW

// 4) Health-check endpoint (optional)
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok', uptime: process.uptime() });
});

// 5) Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res
    .status(err.status || 500)
    .json({ error: err.message || 'Internal Server Error' });
});

// 6) Start server
app.listen(PORT, () => {
  console.log(`üåç Global-backend listening on http://localhost:${PORT}`);
});




































