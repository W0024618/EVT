function lookupFloor(partition, door, direction, unmapped) {
  const normPart = String(partition || '').trim().toUpperCase();
  const normDoor = normalizeDoor(door || '');

  // helper to wrap entry -> return shape
  const wrap = (entry) => ({
    floor: direction === 'InDirection' ? entry.inDirectionFloor : entry.outDirectionFloor,
    mappedPartition: entry.partition
  });

  // 1) exact partition+door match
  let entry = doorMap.find(d =>
    d.partition.trim().toUpperCase() === normPart &&
    d.door === normDoor
  );
  if (entry) return wrap(entry);

  // 1b) fallback for OBS doors mapped under Default
  if (normPart === 'US.CO.OBS') {
    entry = doorMap.find(d =>
      d.partition.trim().toUpperCase() === 'USA/CANADA DEFAULT' &&
      d.door === normDoor
    );
    if (entry) return wrap(entry);
  }

  // 2) general OBS wildcard (‘*’) under Default (existing behavior)
  if (normPart === 'US.CO.OBS') {
    entry = doorMap.find(d =>
      d.partition.trim().toUpperCase() === 'USA/CANADA DEFAULT' &&
      d.door === '*'
    );
    if (entry) return wrap(entry);
  }

  // 2b) heuristic: catch any “15” or “1” in the door name for OBS (existing behavior)
  if (normPart === 'US.CO.OBS') {
    if (/\b15\b/.test(normDoor)) {
      return { floor: direction === 'InDirection' ? 'Floor 15' : 'Out of office', mappedPartition: 'US.CO.OBS' };
    }
    if (/\b1\b/.test(normDoor)) {
      return { floor: direction === 'InDirection' ? 'Floor 01' : 'Out of office', mappedPartition: 'US.CO.OBS' };
    }
  }

  // ---- NEW FALLBACKS START ----
  // Try to find the door mapping across partitions (prefer US.CO.*)
  entry = doorMap.find(d =>
    d.door === normDoor &&
    d.partition.trim().toUpperCase().includes('US.CO')
  );
  if (entry) return wrap(entry);

  // Accept any partition that has the same door
  entry = doorMap.find(d => d.door === normDoor);
  if (entry) return wrap(entry);

  // Heuristic for Default bucket: if partition is the generic bucket but door contains floor numbers,
  // assume same mapping as US.CO.OBS (safe for HQ doors)
  if (normPart === 'USA/CANADA DEFAULT') {
    if (/\b15\b/.test(normDoor)) {
      return { floor: direction === 'InDirection' ? 'Floor 15' : 'Out of office', mappedPartition: 'US.CO.OBS' };
    }
    if (/\b14\b/.test(normDoor)) {
      return { floor: direction === 'InDirection' ? 'Floor 14' : 'Out of office', mappedPartition: 'US.CO.OBS' };
    }
    if (/\b13\b/.test(normDoor)) {
      return { floor: direction === 'InDirection' ? 'Floor 13' : 'Out of office', mappedPartition: 'US.CO.OBS' };
    }
  }
  // ---- NEW FALLBACKS END ----

  // still no mapping? record and bail
  unmapped.add(`${partition}|${door}`);
  return { floor: null, mappedPartition: null };
}








const floorName = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmapped) || 'Unknown';
if (floorName === 'Out of office') return;

// tally realtime
const p = r.PartitionName2;
realtime[p] = realtime[p] || { total:0, Employee:0, Contractor:0, floors:{} };
realtime[p].total++;
if (isEmp) realtime[p].Employee++; else realtime[p].Contractor++;
realtime[p].floors[floorName] = (realtime[p].floors[floorName]||0) + 1;






const map = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmapped) || { floor: null, mappedPartition: null };
const floorName = map.floor || 'Unknown';
if (floorName === 'Out of office') return;

// choose mappedPartition when available, otherwise use the record's partition
const p = map.mappedPartition || r.PartitionName2;

realtime[p] = realtime[p] || { total:0, Employee:0, Contractor:0, floors:{} };
realtime[p].total++;
if (isEmp) realtime[p].Employee++; else realtime[p].Contractor++;
realtime[p].floors[floorName] = (realtime[p].floors[floorName]||0) + 1;







// floor
const floorName = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmapped) || 'Unknown';
if (floorName === 'Out of office') return;

// tally
const p = r.PartitionName2;
realtime[p] = realtime[p] || { total:0, Employee:0, Contractor:0, floors:{} };
realtime[p].total++;
isEmployeeType(r.PersonnelType)
  ? realtime[p].Employee++
  : realtime[p].Contractor++;
realtime[p].floors[floorName] = (realtime[p].floors[floorName]||0) + 1;






const map = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmapped) || { floor: null, mappedPartition: null };
const floorName = map.floor || 'Unknown';
if (floorName === 'Out of office') return;

// choose mappedPartition when available, otherwise use the record's partition
const p = map.mappedPartition || r.PartitionName2;

realtime[p] = realtime[p] || { total:0, Employee:0, Contractor:0, floors:{} };
realtime[p].total++;
isEmployeeType(r.PersonnelType)
  ? realtime[p].Employee++
  : realtime[p].Contractor++;
realtime[p].floors[floorName] = (realtime[p].floors[floorName]||0) + 1;










Initailly solve this issue only then will solve New York issue 

When Update Above Snippets with replacing current floorLookup 

http://localhost:3007/api/occupancy/live-summary

{
  "success": true,
  "today": {
    "total": 805,
    "Employee": 741,
    "Contractor": 64
  },
  "realtime": {
    "US.CO.OBS": {
      "total": 32,
      "Employee": 17,
      "Contractor": 15,
      "floors": {
        "Floor 11": 9,
        "Floor 12": 5,
        "Floor 06": 5,
        "Floor 13": 2,
        "Floor 14": 4,
        "Floor 15": 2,   ... expected is here need to add 1 more count 
        "Floor 01": 4,
        "Floor 09": 1
      }
    },
    "USA/Canada Default": {
      "total": 5,
      "Employee": 1,
      "Contractor": 4,
      "floors": {
        "Texas": 4,
        "Floor 15": 1 ---------In Austin Texas there is no 15 th floor 
      }
    },
    "US.NYC": {
      "total": 4,
      "Employee": 4,
      "Contractor": 0,
      "floors": {
        "New York": 4
      }
    }
  },
  "details": [


fix this issue 


