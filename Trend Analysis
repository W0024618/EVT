<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Trend Analysis — Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- React + ReactDOM + Babel (quick prototyping) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- Flatpickr (high-quality calendar) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <style>
    /* (use your existing CSS — kept minimal additions here) */
    html,body { height:100%; margin:0; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#f7fafc; color:#0b1221; }
    .container { padding:18px; max-width:1300px; margin:0 auto; }
    .topbar { display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:16px; }
    .wu-brand { display:flex; align-items:center; gap:12px; }
    .wu-logo { width:46px; height:46px; background:#0b1221; color:#fff; display:flex; align-items:center; justify-content:center; border-radius:8px; font-weight:800; }
    .title-block h1 { margin:0; font-size:20px; }
    .header-actions { display:flex; gap:8px; align-items:end; }
    .date-input { padding:8px 10px; border-radius:6px; border:1px solid #e6edf3; min-width:110px; }
    .btn-primary { background:#0b1221; color:#fff; padding:8px 12px; border-radius:6px; border:none; cursor:pointer; }
    .btn-ghost { background:transparent; border:1px solid #d1d5db; padding:8px 10px; border-radius:6px; cursor:pointer; }
    .card-shell { display:block; }
    .cards { display:flex; gap:12px; margin-bottom:12px; }
    .card { background:#fff; padding:12px; border-radius:10px; box-shadow:0 4px 16px rgba(11,18,33,0.04); width:220px; position:relative; }
    .card-content { display:flex; gap:12px; align-items:center; }
    .card-icon { font-size:22px; color:#0b1221; }
    .main { display:flex; gap:12px; }
    .left { flex:1; }
    .right { width:320px; }
    .chart-wrap { height:180px; background:#fff; border-radius:8px; padding:12px; box-shadow:0 4px 12px rgba(11,18,33,0.04); margin-bottom:8px; position:relative; }
    .chart-wrap canvas { width:100% !important; height:100% !important; cursor:pointer; }
    .muted { color:#6b7280; }
    .table-scroll { background:#fff; border-radius:8px; padding:6px; margin-top:10px; box-shadow:0 4px 12px rgba(11,18,33,0.04); }
    table { width:100%; border-collapse:collapse; }
    th, td { text-align:left; padding:8px 10px; border-bottom:1px solid #f1f5f9; font-size:13px; }
    .pill { display:inline-block; padding:4px 8px; border-radius:999px; background:#eef2ff; margin-right:6px; font-size:12px; }
    .chip { padding:8px 10px; border-radius:6px; background:#f8fafc; border:1px solid #e6edf3; cursor:pointer; }
    .chip.active { background:#0b1221; color:#fff; border-color:#0b1221; }
    .evidence-btn { background:#0b1221; color:#fff; border:none; padding:6px 8px; border-radius:6px; cursor:pointer; }
    .risk-badge { display:inline-block; padding:6px 10px; border-radius:999px; font-weight:800; color:#fff; font-size:13px; box-shadow:0 4px 10px rgba(0,0,0,0.08); }
    .risk-small { font-size:12px; font-weight:700; }
    .sidebar-section { background:#fff; padding:12px; border-radius:8px; box-shadow:0 4px 12px rgba(11,18,33,0.04); margin-bottom:12px; }
    .risk-filter-list { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
    .risk-chip { padding:8px 10px; border-radius:999px; border:1px solid #e6edf3; cursor:pointer; display:flex; gap:8px; align-items:center; }
    .risk-chip.active { background:#0b1221; color:#fff; border-color:#0b1221; }
    .small-button { padding:6px 8px; border-radius:6px; border:1px solid #e6edf3; background:transparent; cursor:pointer; }
    /* modal and other classes retained from original file — omitted for brevity */
    .modal { position:fixed; inset:0; background:rgba(11,18,33,0.6); display:flex; align-items:center; justify-content:center; z-index:999; }
    .modal-inner { width:1000px; max-width:98%; max-height:92vh; overflow:auto; background:#fff; border-radius:10px; padding:12px; }
    /* accessibility focus */
    :focus { outline:3px solid rgba(59,130,246,0.3); outline-offset:2px; }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    (function () {
      const { useState, useEffect, useRef } = React;

      // CHANGE THIS IF YOUR API HOST DIFFERS
      const API_BASE = "http://localhost:8002";

      // Colour mapping requested by user
      const RISK_COLORS = {
        "Low": "#10b981",          // Green
        "Low Medium": "#86efac",   // Light green
        "Medium": "#facc15",       // Yellow
        "Medium High": "#fb923c",  // Orange
        "High": "#ef4444"          // Red
      };

      const RISK_LABELS = ["Low", "Low Medium", "Medium", "Medium High", "High"];

      const SCENARIO_EXPLANATIONS = {
        "long_gap_>=90min": "Long gap between swipes (>= 90 minutes) — could indicate long out-of-office break.",
        "short_duration_<4h": "Short total duration in office (< 4 hours).",
        "coffee_badging": "Frequent short badge cycles (>=4) with short duration — possible 'coffee badging'.",
        "low_swipe_count_<=2": "Low swipe count (<=2) for the day.",
        "single_door": "All swipes used the same door — single-door behavior.",
        "only_in": "Only IN swipe(s) recorded for the day.",
        "only_out": "Only OUT swipe(s) recorded for the day.",
        "overtime_>=10h": "Long duration (>=10 hours) — overtime.",
        "very_long_duration_>=16h": "Very long duration (>=16 hours) — suspiciously long presence.",
        "zero_swipes": "No swipes recorded.",
        "unusually_high_swipes": "Unusually high number of swipes versus historical median.",
        "repeated_short_breaks": "Multiple short breaks within the day.",
        "multiple_location_same_day": "Swipes recorded at multiple locations same day.",
        "weekend_activity": "Activity recorded on weekend.",
        "repeated_rejection_count": "Several card rejections.",
        "badge_sharing_suspected": "Badge sharing suspected (same card used by multiple persons on same day).",
        "early_arrival_before_06": "First swipe before 06:00.",
        "late_exit_after_22": "Last swipe after 22:00.",
        "shift_inconsistency": "Duration inconsistent with historical shift patterns.",
        "trending_decline": "Historical trending decline flagged.",
        "consecutive_absent_days": "Marked absent for consecutive days historically.",
        "high_variance_duration": "High variance in durations historically.",
        "short_duration_on_high_presence_days": "Short duration even though employee usually attends many days.",
        "swipe_overlap": "Simultaneous swipe(s) near the same time with other uid(s) (possible tailgating or collusion).",
        "shortstay_longout_repeat": "Pattern: short stay, long out-of-office, short return (repeat)."
      };

      function pad(n) { return n.toString().padStart(2, '0'); }
      function formatDateISO(d) {
        if (!d) return "";
        const dt = (d instanceof Date) ? d : new Date(d);
        return dt.getFullYear() + "-" + pad(dt.getMonth() + 1) + "-" + pad(dt.getDate());
      }
      function datesBetween(start, end) {
        var out = [];
        var cur = new Date(start);
        while (cur <= end) {
          out.push(new Date(cur));
          cur.setDate(cur.getDate() + 1);
        }
        return out;
      }
      function safeDateDisplay(val) {
        if (!val && val !== 0) return "";
        try {
          var d = (val instanceof Date) ? val : new Date(val);
          if (isNaN(d.getTime())) return String(val);
          return d.toLocaleString();
        } catch (e) {
          return String(val);
        }
      }
      function sanitizeName(row) {
        return row.EmployeeName || row.EmployeeName_x || row.EmployeeName_y || row.person_uid || "";
      }
      function downloadCSV(rows, filename) {
        if (!rows || !rows.length) { alert("No rows to export"); return; }
        var cols = Object.keys(rows[0]);
        var lines = [cols.join(",")];
        rows.forEach(function (r) {
          var row = cols.map(function (c) {
            var v = (r[c] === undefined || r[c] === null) ? "" : String(r[c]).replace(/\n/g, ' ');
            return JSON.stringify(v);
          }).join(",");
          lines.push(row);
        });
        var blob = new Blob([lines.join("\n")], { type: 'text/csv' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a'); a.href = url; a.download = filename || 'export.csv'; a.click(); URL.revokeObjectURL(url);
      }

      // convert seconds -> "HH:mm:ss"
      function formatSecondsToHmsJS(seconds) {
        if (seconds === null || seconds === undefined || seconds === '') return "-";
        const n = Number(seconds);
        if (isNaN(n) || !isFinite(n)) return "-";
        const s = Math.max(0, Math.floor(n));
        const hh = Math.floor(s / 3600);
        const mm = Math.floor((s % 3600) / 60);
        const ss = s % 60;
        return pad(hh) + ":" + pad(mm) + ":" + pad(ss);
      }

      function App() {
        var yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);

        const [dateFrom, setDateFrom] = useState(formatDateISO(yesterday));
        const [dateTo, setDateTo] = useState(formatDateISO(new Date()));
        const [loading, setLoading] = useState(false);
        const [summary, setSummary] = useState({ rows: 0, flagged_rows: 0, files: [], end_date: null });
        const [rows, setRows] = useState([]);
        const [reasonsCount, setReasonsCount] = useState({});
        const [riskCounts, setRiskCounts] = useState({ "Low":0, "Low Medium":0, "Medium":0, "Medium High":0, "High":0 });
        const [filterText, setFilterText] = useState("");
        const [page, setPage] = useState(1);
        const [selectedReason, setSelectedReason] = useState("");
        const [reasonFilterText, setReasonFilterText] = useState("");
        const [modalRow, setModalRow] = useState(null);
        const [modalDetails, setModalDetails] = useState(null);
        const [modalLoading, setModalLoading] = useState(false);
        const [selectedRiskFilter, setSelectedRiskFilter] = useState(""); // NEW
        const pageSize = 25;
        const chartRef = useRef(null);
        const chartInst = useRef(null);

        // flatpickr refs
        const fromRef = useRef(null);
        const toRef = useRef(null);
        const fromFp = useRef(null);
        const toFp = useRef(null);

        useEffect(function () {
          if (window.flatpickr && fromRef.current && toRef.current) {
            try { if (fromFp.current) fromFp.current.destroy(); } catch (e) { }
            try { if (toFp.current) toFp.current.destroy(); } catch (e) { }
            fromFp.current = window.flatpickr(fromRef.current, {
              dateFormat: "Y-m-d",
              defaultDate: dateFrom,
              allowInput: true,
              onChange: function (selectedDates, str) {
                if (selectedDates && selectedDates.length) {
                  const iso = formatDateISO(selectedDates[0]);
                  setDateFrom(iso);
                  try { if (toFp.current) toFp.current.set('minDate', iso); } catch (e) { }
                  if (dateTo && new Date(iso) > new Date(dateTo)) {
                    setDateTo(iso);
                    try { if (toFp.current) toFp.current.setDate(iso, true); } catch (e) { }
                  }
                }
              }
            });
            toFp.current = window.flatpickr(toRef.current, {
              dateFormat: "Y-m-d",
              defaultDate: dateTo,
              allowInput: true,
              onChange: function (selectedDates, str) {
                if (selectedDates && selectedDates.length) {
                  const iso = formatDateISO(selectedDates[0]);
                  setDateTo(iso);
                  try { if (fromFp.current) fromFp.current.set('maxDate', iso); } catch (e) { }
                  if (dateFrom && new Date(iso) < new Date(dateFrom)) {
                    setDateFrom(iso);
                    try { if (fromFp.current) fromFp.current.setDate(iso, true); } catch (e) { }
                  }
                }
              }
            });
            try { if (fromFp.current) fromFp.current.set('maxDate', dateTo); if (toFp.current) toFp.current.set('minDate', dateFrom); } catch (e) { }
          }
          loadLatest();
          return function () { try { if (fromFp.current) fromFp.current.destroy(); } catch (e) { } try { if (toFp.current) toFp.current.destroy(); } catch (e) { } };
          // eslint-disable-next-line
        }, []);

        useEffect(function () {
          try { if (fromFp.current && dateFrom) fromFp.current.setDate(dateFrom, false); } catch (e) { }
          try { if (toFp.current && dateTo) toFp.current.setDate(dateTo, false); } catch (e) { }
          try { if (fromFp.current) fromFp.current.set('maxDate', dateTo); } catch (e) { }
          try { if (toFp.current) toFp.current.set('minDate', dateFrom); } catch (e) { }
        }, [dateFrom, dateTo]);

        async function runForRange() {
          setLoading(true);
          setRows([]); setSummary({ rows: 0, flagged_rows: 0, files: [], end_date: null }); setReasonsCount({}); setRiskCounts({ "Low":0, "Low Medium":0, "Medium":0, "Medium High":0, "High":0 });
          try {
            var start = new Date(dateFrom);
            var end = new Date(dateTo);
            var dateList = datesBetween(start, end).map(d => formatDateISO(d));
            var accRows = []; var totalRows = 0, totalFlagged = 0, files = [];
            for (var i = 0; i < dateList.length; i++) {
              var d = dateList[i];
              var url = API_BASE + "/run?date=" + d;
              var r = await fetch(url, { method: 'GET' });
              if (!r.ok) { var txt = await r.text(); throw new Error("API returned " + r.status + ": " + txt); }
              var js = await r.json();
              var sample = js.sample || [];
              if (Array.isArray(sample) && sample.length) accRows = accRows.concat(sample);
              if (typeof js.rows === 'number') totalRows += js.rows; else totalRows += (Array.isArray(sample) ? sample.length : 0);
              totalFlagged += (js.flagged_rows || 0);
              if (js.files) files = files.concat(js.files);
            }
            setRows(accRows);
            setSummary({ rows: totalRows, flagged_rows: totalFlagged, files: files, end_date: formatDateISO(new Date(dateTo)) });
            computeReasonsAndRisks(accRows);
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message);
            console.error(err);
          } finally { setLoading(false); }
        }

        async function loadLatest() {
          setLoading(true);
          try {
            var r = await fetch(API_BASE + "/latest");
            if (!r.ok) throw new Error("latest failed: " + r.status);
            var js = await r.json();
            var sample = js.sample || [];
            if (!Array.isArray(sample)) sample = [];
            setRows(sample);
            setSummary({ rows: (js.rows || sample.length || 0), flagged_rows: (sample.filter(function (x) { return !!x.Reasons; }).length || 0), files: [js.file] });
            computeReasonsAndRisks(sample);
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message + (err.message === 'latest failed: 0' ? " (check backend/CORS)" : ""));
            console.error(err);
          } finally { setLoading(false); }
        }

        // Helper: get risk label for a row (fallback to RiskScore numeric -> label)
        function getRiskLabelForRow(r) {
          if (!r) return null;
          var rl = r.RiskLevel || r.Risk || null;
          if (rl) return String(rl);
          if (r.RiskScore !== undefined && r.RiskScore !== null) {
            const mapNum = {1:"Low",2:"Low Medium",3:"Medium",4:"Medium High",5:"High"};
            return mapNum[String(r.RiskScore)] || null;
          }
          return null;
        }

        // compute both reasons distribution and risk-level distribution and draw the risk graph
        function computeReasonsAndRisks(dataRows) {
          var counts = {};
          var rcounts = { "Low":0, "Low Medium":0, "Medium":0, "Medium High":0, "High":0 };
          (dataRows || []).forEach(function (r) {
            if (r.Reasons) {
              var parts = String(r.Reasons).split(";").map(function (s) { return s.trim(); }).filter(Boolean);
              parts.forEach(function (p) { counts[p] = (counts[p] || 0) + 1; });
            }
            var rl = getRiskLabelForRow(r);
            if (rl && rcounts[rl] !== undefined) {
              rcounts[rl] += 1;
            } else if (rl && rcounts[rl] === undefined) {
              // unexpected label, add it
              rcounts[rl] = (rcounts[rl] || 0) + 1;
            } else {
              // if missing, increment Low as fallback
              rcounts["Low"] += 1;
            }
          });
          setReasonsCount(counts);
          setRiskCounts(rcounts);
          // buildChart will be called by useEffect when riskCounts / selectedRiskFilter changes
        }

        // chart build function uses selectedRiskFilter to adjust colors
        function buildChart(rcounts) {
          var labels = RISK_LABELS;
          var values = labels.map(l => rcounts && rcounts[l] ? rcounts[l] : 0);
          var colors = labels.map(l => {
            if (selectedRiskFilter) {
              return (l === selectedRiskFilter) ? RISK_COLORS[l] : '#e6edf3';
            } else {
              return RISK_COLORS[l] || '#cccccc';
            }
          });

          var ctx = chartRef.current && chartRef.current.getContext ? chartRef.current.getContext('2d') : null;
          if (!ctx) return;
          try { if (chartInst.current) chartInst.current.destroy(); } catch (e) { }
          chartInst.current = new Chart(ctx, {
            type: 'bar',
            data: { labels: labels, datasets: [{ label: 'Flagged by Risk Level', data: values, backgroundColor: colors, borderRadius:6 }] },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      return context.parsed.y + ' cases';
                    }
                  }
                }
              },
              onClick: function (evt, elements) {
                if (elements && elements.length > 0) {
                  var idx = elements[0].index;
                  var label = this.data.labels[idx];
                  handleRiskBarClick(label);
                }
              },
              scales: {
                y: { beginAtZero: true, ticks: { precision:0 } }
              }
            }
          });
        }

        // Rebuild chart when riskCounts or selectedRiskFilter changes
        useEffect(function () {
          buildChart(riskCounts);
          // eslint-disable-next-line
        }, [riskCounts, selectedRiskFilter]);

        // filtering & pagination helpers (now includes risk filter)
        var filtered = (rows || []).filter(function (r) {
          var hay = (sanitizeName(r) + " " + (r.EmployeeID || "") + " " + (r.CardNumber || "") + " " + (r.Reasons || "")).toLowerCase();
          var textOk = !filterText || hay.indexOf(filterText.toLowerCase()) !== -1;
          var reasonOk = !selectedReason || (r.Reasons && ((";" + String(r.Reasons) + ";").indexOf(selectedReason) !== -1));
          var riskOk = true;
          if (selectedRiskFilter) {
            var rl = getRiskLabelForRow(r);
            if (!rl) { riskOk = false; }
            else riskOk = (String(rl) === String(selectedRiskFilter));
          }
          return textOk && reasonOk && riskOk;
        });
        var totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
        var pageRows = filtered.slice((page - 1) * pageSize, page * pageSize);

        function exportFiltered() { downloadCSV(filtered, "trend_filtered_export.csv"); }

        function onReasonClick(reason) {
          if (!reason) { setSelectedReason(""); return; }
          if (selectedReason === reason) setSelectedReason(""); else setSelectedReason(reason);
          setPage(1);
        }

        // open evidence modal (explicit Evidence button)
        async function openEvidence(row) {
          setModalRow(row);
          setModalDetails(null);
          setModalLoading(true);
          try {
            // Query API for aggregated and raw swipe details. Backend endpoint is /record?employee_id=...
            const q = encodeURIComponent(row.EmployeeID || row.person_uid || "");
            const resp = await fetch(API_BASE + "/record?employee_id=" + q);
            if (!resp.ok) { const txt = await resp.text(); throw new Error("record failed: " + resp.status + " - " + txt); }
            const js = await resp.json();
            const details = { aggregated_rows: js.aggregated_rows || [], raw_swipe_files: js.raw_swipe_files || [], raw_swipes: js.raw_swipes || [] };
            setModalDetails(details);
          } catch (e) {
            alert("Failed loading details: " + e.message);
            console.error(e);
          } finally { setModalLoading(false); }
        }

        function closeModal() { setModalRow(null); setModalDetails(null); }

        var rowsCount = (summary && typeof summary.rows === 'number') ? summary.rows : (rows ? rows.length : 0);
        var flaggedCount = (summary && typeof summary.flagged_rows === 'number') ? summary.flagged_rows : (rows ? rows.filter(function (r) { return !!r.Reasons; }).length : 0);
        var flaggedPct = rowsCount ? Math.round((flaggedCount * 100) / (rowsCount || 1)) : 0;

        function renderOverlapCell(r) {
          var ov = r.OverlapWith || r.swipe_overlap || r.overlap_with || null;
          if (ov && typeof ov === 'string') {
            var parts = ov.split(";").map(function (s) { return s.trim(); }).filter(Boolean);
            if (parts.length === 0) return <span className="muted">—</span>;
            return <span className="pill" title={ov}>{parts.length} overlap</span>;
          }
          return <span className="muted">—</span>;
        }

        function renderReasonChips(reasonText) {
          if (!reasonText) return <span className="muted">—</span>;
          const parts = String(reasonText).split(";").map(s => s.trim()).filter(Boolean);
          return parts.map((p, idx) => (<span key={idx} className="pill" title={SCENARIO_EXPLANATIONS[p] || p}>{p}</span>));
        }

        function renderReasonExplanations(reasonText) {
          if (!reasonText) return <div className="muted">No flags</div>;
          const parts = String(reasonText).split(";").map(s => s.trim()).filter(Boolean);
          return (
            <div>
              {parts.map((p, idx) => (
                <div key={idx} className="why-item" style={{ marginBottom: 8 }}>
                  <b>{p}</b>
                  <div className="small">{SCENARIO_EXPLANATIONS[p] || "No explanation available."}</div>
                </div>
              ))}
            </div>
          );
        }

        // render timeline with requested highlights:
        function renderSwipeTimeline(details, modalRow) {
          if (!details || !details.raw_swipes || details.raw_swipes.length === 0) {
            return <div className="muted">No raw swipe evidence available (person not flagged or raw file missing).</div>;
          }
          const all = details.raw_swipes.slice().map(r => {
            const obj = Object.assign({}, r);
            try {
              if (obj.Date && obj.Time) { obj.__ts = new Date(obj.Date + "T" + obj.Time); }
              else if (obj.Date && obj.Time === undefined && obj.LocaleMessageTime) { obj.__ts = new Date(obj.LocaleMessageTime); }
              else if (obj.LocaleMessageTime) { obj.__ts = new Date(obj.LocaleMessageTime); }
              else { obj.__ts = null; }
            } catch (e) { obj.__ts = null; }
            let gap = null;
            if (obj.SwipeGapSeconds !== undefined && obj.SwipeGapSeconds !== null) { gap = Number(obj.SwipeGapSeconds); if (isNaN(gap)) gap = null; }
            else if (obj.SwipeGap) {
              try { const parts = String(obj.SwipeGap).split(':').map(p => Number(p)); if (parts.length === 3) gap = parts[0] * 3600 + parts[1] * 60 + parts[2]; } catch (e) { gap = null; }
            }
            obj.__gap = gap;
            obj.__zone_l = String((obj.Zone || '')).toLowerCase();
            return obj;
          }).sort((a, b) => {
            if (a.__ts && b.__ts) return a.__ts - b.__ts;
            if (a.__ts) return -1;
            if (b.__ts) return 1;
            return 0;
          });

          const flags = new Array(all.length).fill({}).map(() => ({ dayStart: false, outReturn: false }));
          for (let i = 0; i < all.length; i++) {
            const cur = all[i]; const prev = all[i - 1];
            try {
              const curDate = cur.Date ? cur.Date.slice(0, 10) : (cur.__ts ? cur.__ts.toISOString().slice(0, 10) : null);
              const prevDate = prev ? (prev.Date ? prev.Date.slice(0, 10) : (prev.__ts ? prev.__ts.toISOString().slice(0, 10) : null)) : null;
              if (!prev || prevDate !== curDate) { flags[i].dayStart = true; }
            } catch (e) { }
          }
          const OUT_RETURN_GAP_SECONDS = 60 * 60;
          for (let i = 0; i < all.length - 1; i++) {
            const a = all[i], b = all[i + 1];
            const aZone = a.__zone_l || ''; const bZone = b.__zone_l || ''; const bGap = b.__gap || 0;
            if (aZone.includes('out of office') || aZone.includes('out_of_office') || aZone.includes('out of')) {
              if (!bZone.includes('out of office') && (bGap >= OUT_RETURN_GAP_SECONDS || bGap === null && aZone.includes('out'))) {
                flags[i].outReturn = true; flags[i + 1].outReturn = true;
              }
            }
          }

          return (
            <div className="table-scroll">
              <table className="evidence-table" role="table" aria-label="Swipe timeline">
                <thead>
                  <tr>
                    <th>Employee Name</th>
                    <th>Employee ID</th>
                    <th>Card</th>
                    <th>Date</th>
                    <th>Time</th>
                    <th>SwipeGap</th>
                    <th>Door</th>
                    <th>Direction</th>
                    <th>Zone</th>
                    <th>Note</th>
                  </tr>
                </thead>
                <tbody>
                  {all.map((rObj, idx) => {
                    const r = rObj || {};
                    const g = r.__gap;
                    const gapFormatted = (r.SwipeGap && String(r.SwipeGap).trim()) ? String(r.SwipeGap) : (g !== null && g !== undefined) ? formatSecondsToHmsJS(g) : "-";
                    const cls = [];
                    if (flags[idx].dayStart) cls.push('row-day-start');
                    if (flags[idx].outReturn) cls.push('row-out-return');
                    if (g && g >= OUT_RETURN_GAP_SECONDS) cls.push('highlight-long-duration');
                    return (
                      <tr key={idx} className={cls.join(' ')}>
                        <td className="small">{r.EmployeeName || '-'}</td>
                        <td className="small">{r.EmployeeID || '-'}</td>
                        <td className="small">{r.CardNumber || r.Card || '-'}</td>
                        <td className="small">{r.Date || '-'}</td>
                        <td className="small">{r.Time || (r.__ts ? r.__ts.toTimeString().slice(0, 8) : '-')}</td>
                        <td className="small">{gapFormatted}</td>
                        <td className="small" style={{ minWidth: 160 }}>{r.Door || '-'}</td>
                        <td className="small">{r.Direction || '-'}</td>
                        <td className="small">{r.Zone || '-'}</td>
                        <td className="small">{r.Note || '-'}{r._source ? <span className="muted"> ({r._source})</span> : null}</td>
                      </tr>
                    );
                  })
                  }
                </tbody>
              </table>
            </div>
          );
        }

        // handle click on a risk bar
        function handleRiskBarClick(label) {
          if (!label) return;
          if (selectedRiskFilter === label) {
            setSelectedRiskFilter("");
          } else {
            setSelectedRiskFilter(label);
          }
          setPage(1);
        }

        function clearRiskFilter() {
          setSelectedRiskFilter("");
        }

        return (
          <div className="container" aria-live="polite">
            {loading && (
              <div className="spinner-overlay" role="status" aria-label="Loading">
                <div className="spinner-box">
                  <div className="spinner" />
                  <div style={{ fontWeight: 700 }}>Loading…</div>
                </div>
              </div>
            )}

            <div className="topbar" role="banner">
              <div className="wu-brand" aria-hidden={false}>
                <div className="wu-logo">WU</div>
                <div className="title-block">
                  <h1>Western Union — Trend Analysis</h1>
                  <p>Pune</p>
                </div>
              </div>

              <div className="header-actions" role="region" aria-label="controls">
                <div className="control">
                  <label className="small" htmlFor="fromDate">From</label>
                  <input id="fromDate" ref={fromRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                </div>

                <div className="control">
                  <label className="small" htmlFor="toDate">To</label>
                  <input id="toDate" ref={toRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                </div>

                <button className="btn-primary" onClick={runForRange} disabled={loading}>Run</button>
                <button className="btn-ghost" onClick={loadLatest} disabled={loading}>Load latest</button>
              </div>
            </div>

            <div className="card-shell">
              <div className="cards" aria-hidden={loading}>
                <div className="card" title="Rows analysed">
                  <div className="card-content">
                    <div className="card-icon">
                      <i className="bi bi-table"></i>
                    </div>
                    <div className="card-text">
                      <h3>{(rowsCount !== undefined && rowsCount !== null) ? rowsCount.toLocaleString() : 0}</h3>
                      <p>Rows analysed</p>
                    </div>
                  </div>
                  <div className="card-gradient"></div>
                </div>

                <div className="card card-flagged" title="Flagged rows">
                  <div className="card-content">
                    <div className="card-icon">
                      <i className="bi bi-flag-fill"></i>
                    </div>
                    <div className="card-text">
                      <h3>{(flaggedCount !== undefined && flaggedCount !== null) ? flaggedCount.toLocaleString() : 0}</h3>
                      <p>Flagged rows</p>
                    </div>
                  </div>
                  <div className="card-gradient"></div>
                </div>

                <div className="card card-rate" title="Flagged rate">
                  <div className="card-content">
                    <div className="card-icon">
                      <i className="bi bi-graph-up-arrow"></i>
                    </div>
                    <div className="card-text">
                      <h3>{flaggedPct}%</h3>
                      <p>Flagged rate</p>
                    </div>
                  </div>
                  <div className="card-gradient"></div>
                </div>
              </div>

              <div className="main">
                <div className="left">
                  <div className="chart-wrap" aria-label="Risk level chart">
                    <canvas ref={chartRef}></canvas>
                    <div style={{ position:'absolute', right:12, top:12, fontSize:12, color:'#6b7280' }}>
                      <span>Click a bar to filter</span>
                    </div>
                  </div>

                  <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginTop: 6 }}>
                    <input placeholder="Search name, employee id, card or reason..." value={filterText} onChange={function (e) { setFilterText(e.target.value); setPage(1); }} style={{ flex: 1, padding: 10, borderRadius: 6, border: '1px solid #e6edf3' }} />
                    <div className="muted">Showing {filtered.length} / {rows.length} rows</div>
                    <button className="small-button" onClick={exportFiltered}>Export filtered</button>
                    {selectedRiskFilter ? <button className="small-button" onClick={clearRiskFilter}>Clear risk filter</button> : null}
                  </div>

                  <div style={{ marginTop: 10 }} className="table-scroll" role="region" aria-label="results table">
                    <table>
                      <thead>
                        <tr>
                          <th>Employee</th>
                          <th className="small">ID</th>
                          <th className="small">Card</th>
                          <th className="small">Date</th>
                          <th className="small">Duration</th>
                          <th className="small">Reasons</th>
                          <th className="small">Overlap</th>
                          <th className="small">Evidence</th>
                        </tr>
                      </thead>
                      <tbody>
                        {pageRows.map(function (r, idx) {
                          var empName = sanitizeName(r);
                          var displayDate = safeDateDisplay(r.Date || r.FirstSwipe || r.LastSwipe);
                          var durText = r.Duration || (r.DurationMinutes ? Math.round(r.DurationMinutes) + " min" : "");
                          var flagged = r.Reasons && String(r.Reasons).trim();
                          return (
                            <tr key={idx} className={flagged ? "flagged-row" : ""}>
                              <td className="row-click" onClick={function () { openEvidence(r); }}>{empName || <span className="muted">—</span>}</td>
                              <td className="small">{r.EmployeeID || ""}</td>
                              <td className="small">{r.CardNumber || ""}</td>
                              <td className="small">{displayDate}</td>
                              <td className="small">{durText}</td>
                              <td className="small">{renderReasonChips(r.Reasons)}</td>
                              <td className="small">{renderOverlapCell(r)}</td>
                              <td className="small">
                                <button className="evidence-btn" onClick={function () { openEvidence(r); }}>Evidence</button>
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>

                  <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginTop: 10 }}>
                    <button onClick={function () { setPage(function (p) { return Math.max(1, p - 1); }); }} disabled={page <= 1}>Prev</button>
                    <div className="muted">Page {page} / {totalPages}</div>
                    <button onClick={function () { setPage(function (p) { return Math.min(totalPages, p + 1); }); }} disabled={page >= totalPages}>Next</button>
                  </div>
                </div>

                <aside className="right" aria-label="side panel">
                  <div className="sidebar-section">
                    <strong>Risk filters</strong>
                    <div className="small muted" style={{ marginTop:6 }}>Click a risk to filter. Chart click also toggles filter.</div>

                    <div className="risk-filter-list" style={{ marginTop:8 }}>
                      {RISK_LABELS.map((lab) => {
                        const cnt = (riskCounts && riskCounts[lab]) ? riskCounts[lab] : 0;
                        const active = selectedRiskFilter === lab;
                        return (
                          <div key={lab} role="button" tabIndex={0} aria-pressed={active} className={"risk-chip " + (active ? "active" : "")} onClick={function () { handleRiskBarClick(lab); }} onKeyDown={function(e){ if(e.key==='Enter' || e.key===' ') { handleRiskBarClick(lab); } }}>
                            <div style={{ width:10, height:10, borderRadius:999, background: RISK_COLORS[lab], boxShadow:'0 2px 6px rgba(0,0,0,0.08)' }}></div>
                            <div style={{ fontSize:13 }}>{lab} <span className="muted" style={{ marginLeft:6 }}>({cnt})</span></div>
                          </div>
                        );
                      })}
                    </div>

                    <div style={{ marginTop:8 }}>
                      <button className="small-button" onClick={clearRiskFilter}>Clear risk filter</button>
                    </div>
                  </div>

                  <div className="sidebar-section" style={{ marginTop:12 }}>
                    <strong>Top reasons summary</strong>
                    <div className="small muted" style={{ marginTop: 6 }}>Click a reason to filter the table by that reason. Click again to clear.</div>

                    <div style={{ marginTop: 8, display: 'flex', gap: 8 }}>
                      <input placeholder="Filter reason list..." value={reasonFilterText} onChange={function (e) { setReasonFilterText(e.target.value); }} style={{ flex: 1, padding: '6px 8px', borderRadius: 6, border: '1px solid #e2e8f0' }} />
                      <button className="small-button" onClick={function () { setSelectedReason(''); setReasonFilterText(''); }}>Clear</button>
                    </div>

                    <div style={{ marginTop: 8, maxHeight: 320, overflow: 'auto' }}>
                      {Object.keys(reasonsCount).length === 0 && <div className="muted">No flags found</div>}
                      {Object.entries(reasonsCount).sort(function (a, b) { return b[1] - a[1]; }).filter(function (kv) {
                        var name = kv[0];
                        if (!reasonFilterText) return true;
                        return name.toLowerCase().indexOf(reasonFilterText.toLowerCase()) !== -1;
                      }).slice(0, 50).map(function (kv) {
                        var name = kv[0], count = kv[1];
                        var active = selectedReason === name;
                        return (
                          <div key={name} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 8, marginBottom: 6 }}>
                            <button className={"chip " + (active ? "active" : "")} style={{ textAlign: 'left', flex: 1 }} onClick={function () { onReasonClick(name); }}>
                              {name}
                            </button>
                            <div style={{ minWidth: 48, textAlign: 'right' }} className="small"><b>{count}</b></div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </aside>
              </div>
            </div>

            {modalRow &&
              <div className="modal" onClick={closeModal}>
                <div className="modal-inner" onClick={function (e) { e.stopPropagation(); }}>
                  {/* Enhanced Header */}
                  <div className="modal-header">
                    <div className="header-content">
                      <div className="header-icon">
                        <i className="bi bi-clipboard2-data-fill"></i>
                      </div>
                      <div className="header-text">
                        <h3>Details — Evidence</h3>
                        <div className="header-subtitle small">Evidence & explanation for selected row</div>
                      </div>
                    </div>
                    <button className="close-btn" onClick={closeModal}>
                      <i className="bi bi-x-lg"></i>
                      Close
                    </button>
                  </div>

                  <div className="modal-body">
                    {modalLoading && (
                      <div className="loading-state">
                        <div className="loading-spinner"></div>
                        <span>Loading evidence…</span>
                      </div>
                    )}

                    {/* Enhanced Top Section */}
                    <div className="modal-top" role="region" aria-label="evidence summary" style={{ display:'flex', gap:12 }}>
                      {/* Column 1 - Image */}
                      <div style={{ width:160 }}>
                        <div style={{ width:140, height:140, borderRadius:8, background:'#f3f4f6', display:'flex', alignItems:'center', justifyContent:'center' }}>
                          {(modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows.length > 0 && modalDetails.aggregated_rows[0].imageUrl) ? (
                            <img src={API_BASE + modalDetails.aggregated_rows[0].imageUrl} alt="Employee" style={{ maxWidth:'100%', maxHeight:'100%', borderRadius:6 }} />
                          ) : (<div className="muted">No image</div>)}
                        </div>
                      </div>

                      {/* Column 2 - Details */}
                      <div style={{ flex:1 }}>
                        <div style={{ display:'flex', justifyContent:'space-between', alignItems:'start' }}>
                          <div>
                            <div style={{ fontSize:18, fontWeight:700 }}>{sanitizeName(modalRow) || "—"}</div>
                            <div className="emp-badge muted" style={{ marginTop:6 }}>ID: {modalRow.EmployeeID || "—"}</div>
                          </div>
                          <div>
                            <div style={{ display:'flex', gap:8, alignItems:'center' }}>
                              <div className="risk-badge" style={{ background: RISK_COLORS[modalRow.RiskLevel] || RISK_COLORS[getRiskLabelForRow(modalRow)] || RISK_COLORS["Low"] }}>
                                {modalRow.RiskLevel || (modalRow.RiskScore ? ("Score " + modalRow.RiskScore) : "Low")}
                              </div>
                            </div>
                            <div style={{ marginTop:8, textAlign:'right' }}>
                              <div className="muted">Violation days (90d)</div>
                              <div style={{ fontWeight:700 }}>{(modalRow.ViolationDaysLast90 !== undefined && modalRow.ViolationDaysLast90 !== null) ? modalRow.ViolationDaysLast90 : 0}</div>
                            </div>
                          </div>
                        </div>

                        <div style={{ marginTop:10, display:'grid', gridTemplateColumns:'1fr 1fr', gap:8 }}>
                          <div style={{ background:'#f8fafc', padding:8, borderRadius:6 }}>
                            <div className="muted">Card</div>
                            <div style={{ fontWeight:700 }}>{modalRow.CardNumber || "—"}</div>
                          </div>
                          <div style={{ background:'#f8fafc', padding:8, borderRadius:6 }}>
                            <div className="muted">Date</div>
                            <div style={{ fontWeight:700 }}>{safeDateDisplay(modalRow.Date || modalRow.FirstSwipe)}</div>
                          </div>
                          <div style={{ background:'#f8fafc', padding:8, borderRadius:6 }}>
                            <div className="muted">Duration</div>
                            <div style={{ fontWeight:700 }}>{modalRow.Duration || (modalRow.DurationMinutes ? Math.round(modalRow.DurationMinutes) + " min" : "—")}</div>
                          </div>
                          <div style={{ background:'#f8fafc', padding:8, borderRadius:6 }}>
                            <div className="muted">Reasons</div>
                            <div>{renderReasonChips(modalRow.Reasons)}</div>
                          </div>
                        </div>
                      </div>

                      {/* Column 3 - Explanation */}
                      <div style={{ width:280 }}>
                        <div style={{ fontWeight:700 }}>Explanation</div>
                        <div style={{ marginTop:8, maxHeight:160, overflow:'auto', background:'#fff', border:'1px solid #eef2f7', padding:8, borderRadius:6 }}>
                          {modalRow.Explanation ? <div style={{ whiteSpace: 'pre-wrap' }}>{modalRow.Explanation}</div> : <div className="muted">No explanation provided.</div>}
                        </div>
                      </div>
                    </div>

                    <div style={{ marginTop:12 }}>
                      <div style={{ fontWeight:700, marginBottom:8 }}>Available Evidence Files</div>
                      <div>
                        {modalDetails && modalDetails.raw_swipe_files && modalDetails.raw_swipe_files.length > 0 ? (
                          modalDetails.raw_swipe_files.map((f, i) => (
                            <div key={i} style={{ display:'flex', gap:8, alignItems:'center', marginBottom:6 }}>
                              <i className="bi bi-file-earmark-text"></i>
                              <div style={{ flex:1 }}>{f}</div>
                              <button className="small-button" onClick={function(){ window.location = API_BASE + "/swipes/" + encodeURIComponent(f); }}>Download</button>
                            </div>
                          ))
                        ) : (<div className="muted">No raw swipe files found for this person/date.</div>)}
                      </div>
                    </div>

                    <div style={{ marginTop:12 }}>
                      <div style={{ fontWeight:700, marginBottom:8 }}>Swipe Timeline</div>
                      <div>
                        {modalDetails ? renderSwipeTimeline(modalDetails, modalRow) : <div className="muted">Evidence not loaded yet.</div>}
                      </div>
                    </div>

                    <div style={{ marginTop:12 }}>
                      <label style={{ display:'flex', gap:8, alignItems:'center' }}>
                        <input type="checkbox" id="showraw" onChange={function (e) {
                          const el = document.getElementById('rawpayload');
                          if (el) el.style.display = e.target.checked ? 'block' : 'none';
                        }} />
                        <span className="muted">Show raw aggregated JSON</span>
                      </label>
                      <div id="rawpayload" style={{ display:'none', marginTop:8 }}>
                        <pre style={{ background:'#0b1221', color:'#fff', padding:8, borderRadius:6 }}>{JSON.stringify(modalRow, null, 2)}</pre>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            }

          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(App));
    })();
  </script>
</body>

</html>





















<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Trend Analysis — Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- React + ReactDOM + Babel (quick prototyping) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- Flatpickr -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <style>
    /* keep your existing styles (omitted here). Add a couple of small extras: */
    .risk-badge {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 800;
      color: #fff;
      font-size: 13px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.08);
    }
    .risk-small { font-size: 12px; font-weight:700; }
    .risk-chip { padding: 6px 8px; border-radius: 6px; cursor: pointer; border: 1px solid #e6edf3; display:inline-flex; align-items:center; gap:8px; }
    .risk-chip.active { box-shadow: 0 2px 8px rgba(0,0,0,0.08); font-weight:700; }
    .risk-chips { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:8px; }
    .chart-legend { display:flex; gap:12px; align-items:center; margin-top:6px; }
    .clear-filter { background:transparent; border: none; color:#0366d6; cursor:pointer; text-decoration:underline; }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    (function () {
      const { useState, useEffect, useRef } = React;

      const API_BASE = "http://localhost:8002";

      const RISK_COLORS = {
        "Low": "#10b981",
        "Low Medium": "#86efac",
        "Medium": "#facc15",
        "Medium High": "#fb923c",
        "High": "#ef4444"
      };

      const SCENARIO_EXPLANATIONS = {
        "long_gap_>=90min": "Long gap between swipes (>= 90 minutes) — could indicate long out-of-office break.",
        "short_duration_<4h": "Short total duration in office (< 4 hours).",
        "coffee_badging": "Frequent short badge cycles (>=4) with short duration — possible 'coffee badging'.",
        "low_swipe_count_<=2": "Low swipe count (<=2) for the day.",
        "single_door": "All swipes used the same door — single-door behavior.",
        "only_in": "Only IN swipe(s) recorded for the day.",
        "only_out": "Only OUT swipe(s) recorded for the day.",
        "overtime_>=10h": "Long duration (>=10 hours) — overtime.",
        "very_long_duration_>=16h": "Very long duration (>=16 hours) — suspiciously long presence.",
        "zero_swipes": "No swipes recorded.",
        "unusually_high_swipes": "Unusually high number of swipes versus historical median.",
        "repeated_short_breaks": "Multiple short breaks within the day.",
        "multiple_location_same_day": "Swipes recorded at multiple locations same day.",
        "weekend_activity": "Activity recorded on weekend.",
        "repeated_rejection_count": "Several card rejections.",
        "badge_sharing_suspected": "Badge sharing suspected (same card used by multiple persons on same day).",
        "early_arrival_before_06": "First swipe before 06:00.",
        "late_exit_after_22": "Last swipe after 22:00.",
        "shift_inconsistency": "Duration inconsistent with historical shift patterns.",
        "trending_decline": "Historical trending decline flagged.",
        "consecutive_absent_days": "Marked absent for consecutive days historically.",
        "high_variance_duration": "High variance in durations historically.",
        "short_duration_on_high_presence_days": "Short duration even though employee usually attends many days.",
        "swipe_overlap": "Simultaneous swipe(s) near the same time with other uid(s) (possible tailgating or collusion).",
        "shortstay_longout_repeat": "Pattern: short stay, long out-of-office, short return (repeat)."
      };

      function pad(n) { return n.toString().padStart(2, '0'); }
      function formatDateISO(d) {
        if (!d) return "";
        const dt = (d instanceof Date) ? d : new Date(d);
        return dt.getFullYear() + "-" + pad(dt.getMonth() + 1) + "-" + pad(dt.getDate());
      }
      function datesBetween(start, end) {
        var out = [];
        var cur = new Date(start);
        while (cur <= end) {
          out.push(new Date(cur));
          cur.setDate(cur.getDate() + 1);
        }
        return out;
      }
      function safeDateDisplay(val) {
        if (!val && val !== 0) return "";
        try {
          var d = (val instanceof Date) ? val : new Date(val);
          if (isNaN(d.getTime())) return String(val);
          return d.toLocaleString();
        } catch (e) {
          return String(val);
        }
      }
      function sanitizeName(row) {
        return row.EmployeeName || row.EmployeeName_x || row.EmployeeName_y || row.person_uid || "";
      }
      function downloadCSV(rows, filename) {
        if (!rows || !rows.length) { alert("No rows to export"); return; }
        var cols = Object.keys(rows[0]);
        var lines = [cols.join(",")];
        rows.forEach(function (r) {
          var row = cols.map(function (c) {
            var v = (r[c] === undefined || r[c] === null) ? "" : String(r[c]).replace(/\n/g, ' ');
            return JSON.stringify(v);
          }).join(",");
          lines.push(row);
        });
        var blob = new Blob([lines.join("\n")], { type: 'text/csv' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a'); a.href = url; a.download = filename || 'export.csv'; a.click(); URL.revokeObjectURL(url);
      }

      function formatSecondsToHmsJS(seconds) {
        if (seconds === null || seconds === undefined || seconds === '') return "-";
        const n = Number(seconds);
        if (isNaN(n) || !isFinite(n)) return "-";
        const s = Math.max(0, Math.floor(n));
        const hh = Math.floor(s / 3600);
        const mm = Math.floor((s % 3600) / 60);
        const ss = s % 60;
        return pad(hh) + ":" + pad(mm) + ":" + pad(ss);
      }

      function App() {
        var yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1);

        const [dateFrom, setDateFrom] = useState(formatDateISO(yesterday));
        const [dateTo, setDateTo] = useState(formatDateISO(new Date()));
        const [loading, setLoading] = useState(false);
        const [summary, setSummary] = useState({ rows: 0, flagged_rows: 0, files: [], end_date: null });
        const [rows, setRows] = useState([]);
        const [reasonsCount, setReasonsCount] = useState({});
        const [riskCounts, setRiskCounts] = useState({});
        const [filterText, setFilterText] = useState("");
        const [page, setPage] = useState(1);
        const [selectedReason, setSelectedReason] = useState("");
        const [reasonFilterText, setReasonFilterText] = useState("");
        const [modalRow, setModalRow] = useState(null);
        const [modalDetails, setModalDetails] = useState(null);
        const [modalLoading, setModalLoading] = useState(false);
        const [selectedRisk, setSelectedRisk] = useState(""); // NEW: risk filter state

        const pageSize = 25;
        const chartRef = useRef(null);
        const chartInst = useRef(null);

        // flatpickr refs
        const fromRef = useRef(null);
        const toRef = useRef(null);
        const fromFp = useRef(null);
        const toFp = useRef(null);

        useEffect(function () {
          if (window.flatpickr && fromRef.current && toRef.current) {
            try { if (fromFp.current) fromFp.current.destroy(); } catch (e) { }
            try { if (toFp.current) toFp.current.destroy(); } catch (e) { }
            fromFp.current = window.flatpickr(fromRef.current, {
              dateFormat: "Y-m-d",
              defaultDate: dateFrom,
              allowInput: true,
              onChange: function (selectedDates) {
                if (selectedDates && selectedDates.length) {
                  const iso = formatDateISO(selectedDates[0]);
                  setDateFrom(iso);
                  try { if (toFp.current) toFp.current.set('minDate', iso); } catch (e) { }
                  if (dateTo && new Date(iso) > new Date(dateTo)) {
                    setDateTo(iso);
                    try { if (toFp.current) toFp.current.setDate(iso, true); } catch (e) { }
                  }
                }
              }
            });
            toFp.current = window.flatpickr(toRef.current, {
              dateFormat: "Y-m-d",
              defaultDate: dateTo,
              allowInput: true,
              onChange: function (selectedDates) {
                if (selectedDates && selectedDates.length) {
                  const iso = formatDateISO(selectedDates[0]);
                  setDateTo(iso);
                  try { if (fromFp.current) fromFp.current.set('maxDate', iso); } catch (e) { }
                  if (dateFrom && new Date(iso) < new Date(dateFrom)) {
                    setDateFrom(iso);
                    try { if (fromFp.current) fromFp.current.setDate(iso, true); } catch (e) { }
                  }
                }
              }
            });
            try { if (fromFp.current) fromFp.current.set('maxDate', dateTo); if (toFp.current) toFp.current.set('minDate', dateFrom); } catch (e) { }
          }
          loadLatest();
          return function () { try { if (fromFp.current) fromFp.current.destroy(); } catch (e) { } try { if (toFp.current) toFp.current.destroy(); } catch (e) { } };
          // eslint-disable-next-line
        }, []);

        useEffect(function () {
          try { if (fromFp.current && dateFrom) fromFp.current.setDate(dateFrom, false); } catch (e) { }
          try { if (toFp.current && dateTo) toFp.current.setDate(dateTo, false); } catch (e) { }
          try { if (fromFp.current) fromFp.current.set('maxDate', dateTo); } catch (e) { }
          try { if (toFp.current) toFp.current.set('minDate', dateFrom); } catch (e) { }
        }, [dateFrom, dateTo]);

        // Helper: resolve risk label for a row
        function getRiskLabel(row) {
          if (!row) return null;
          let rl = row.RiskLevel || row.Risk || null;
          if (!rl && row.RiskScore) {
            const mapNum = {1:"Low",2:"Low Medium",3:"Medium",4:"Medium High",5:"High"};
            rl = mapNum[String(row.RiskScore)] || null;
          }
          return rl || "Low";
        }

        async function runForRange() {
          setLoading(true);
          setRows([]); setSummary({ rows: 0, flagged_rows: 0, files: [], end_date: null }); setReasonsCount({}); setRiskCounts({});
          try {
            var start = new Date(dateFrom);
            var end = new Date(dateTo);
            var dateList = datesBetween(start, end).map(d => formatDateISO(d));
            var accRows = []; var totalRows = 0, totalFlagged = 0, files = [];
            for (var i = 0; i < dateList.length; i++) {
              var d = dateList[i];
              var url = API_BASE + "/run?date=" + d;
              var r = await fetch(url, { method: 'GET' });
              if (!r.ok) { var txt = await r.text(); throw new Error("API returned " + r.status + ": " + txt); }
              var js = await r.json();
              var sample = js.sample || [];
              if (Array.isArray(sample) && sample.length) accRows = accRows.concat(sample);
              if (typeof js.rows === 'number') totalRows += js.rows; else totalRows += (Array.isArray(sample) ? sample.length : 0);
              totalFlagged += (js.flagged_rows || 0);
              if (js.files) files = files.concat(js.files);
            }
            setRows(accRows);
            setSummary({ rows: totalRows, flagged_rows: totalFlagged, files: files, end_date: formatDateISO(new Date(dateTo)) });
            computeReasonsAndRisks(accRows);
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message);
            console.error(err);
          } finally { setLoading(false); }
        }

        async function loadLatest() {
          setLoading(true);
          try {
            var r = await fetch(API_BASE + "/latest");
            if (!r.ok) throw new Error("latest failed: " + r.status);
            var js = await r.json();
            var sample = js.sample || [];
            if (!Array.isArray(sample)) sample = [];
            setRows(sample);
            setSummary({ rows: (js.rows || sample.length || 0), flagged_rows: (sample.filter(function (x) { return !!x.Reasons; }).length || 0), files: [js.file] });
            computeReasonsAndRisks(sample);
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message + (err.message === 'latest failed: 0' ? " (check backend/CORS)" : ""));
            console.error(err);
          } finally { setLoading(false); }
        }

        function computeReasonsAndRisks(dataRows) {
          var counts = {};
          var rcounts = { "Low":0, "Low Medium":0, "Medium":0, "Medium High":0, "High":0 };
          (dataRows || []).forEach(function (r) {
            if (r.Reasons) {
              var parts = String(r.Reasons).split(";").map(function (s) { return s.trim(); }).filter(Boolean);
              parts.forEach(function (p) { counts[p] = (counts[p] || 0) + 1; });
            }
            var rl = getRiskLabel(r);
            if (rl) {
              if (!rcounts[rl]) rcounts[rl] = 0;
              rcounts[rl] += 1;
            } else {
              rcounts["Low"] += 1;
            }
          });
          setReasonsCount(counts);
          setRiskCounts(rcounts);
          buildChart(rcounts);
        }

        function buildChart(rcounts) {
          var labels = ["Low", "Low Medium", "Medium", "Medium High", "High"];
          var values = labels.map(l => rcounts && rcounts[l] ? rcounts[l] : 0);
          var colors = labels.map(l => RISK_COLORS[l] || '#cccccc');

          var ctx = chartRef.current && chartRef.current.getContext ? chartRef.current.getContext('2d') : null;
          if (!ctx) return;
          try { if (chartInst.current) { chartInst.current.destroy(); chartInst.current = null; } } catch (e) { }
          chartInst.current = new Chart(ctx, {
            type: 'bar',
            data: { labels: labels, datasets: [{ label: 'Flagged by Risk Level', data: values, backgroundColor: colors }] },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: function(context) { return context.parsed.y + ' cases'; }
                  }
                }
              },
              scales: { y: { beginAtZero: true, ticks: { precision:0 } } }
            }
          });

          // clickable bars -> set selectedRisk (toggle)
          // remove previous handler if any
          try { chartRef.current.onclick = null; } catch (e) { }
          chartRef.current.onclick = function (evt) {
            try {
              const points = chartInst.current.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
              if (points && points.length) {
                const idx = points[0].index;
                const label = chartInst.current.data.labels[idx];
                setSelectedRisk(prev => {
                  const next = (prev === label) ? "" : label;
                  setPage(1);
                  return next;
                });
              }
            } catch (err) { console.error("chart click error", err); }
          };
        }

        // filtering & pagination helpers — include selectedRisk filter
        var filtered = (rows || []).filter(function (r) {
          var hay = (sanitizeName(r) + " " + (r.EmployeeID || "") + " " + (r.CardNumber || "") + " " + (r.Reasons || "")).toLowerCase();
          var textOk = !filterText || hay.indexOf(filterText.toLowerCase()) !== -1;
          var reasonOk = !selectedReason || (r.Reasons && ((";" + String(r.Reasons) + ";").indexOf(selectedReason) !== -1));
          var riskLabel = getRiskLabel(r);
          var riskOk = !selectedRisk || (riskLabel === selectedRisk);
          return textOk && reasonOk && riskOk;
        });

        var totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
        var pageRows = filtered.slice((page - 1) * pageSize, page * pageSize);

        function exportFiltered() { downloadCSV(filtered, "trend_filtered_export.csv"); }

        function onReasonClick(reason) {
          if (!reason) { setSelectedReason(""); return; }
          if (selectedReason === reason) setSelectedReason(""); else setSelectedReason(reason);
          setPage(1);
        }

        async function openEvidence(row) {
          setModalRow(row);
          setModalDetails(null);
          setModalLoading(true);
          try {
            const q = encodeURIComponent(row.EmployeeID || row.person_uid || "");
            const resp = await fetch(API_BASE + "/record?employee_id=" + q);
            if (!resp.ok) { const txt = await resp.text(); throw new Error("record failed: " + resp.status + " - " + txt); }
            const js = await resp.json();
            const details = { aggregated_rows: js.aggregated_rows || [], raw_swipe_files: js.raw_swipe_files || [], raw_swipes: js.raw_swipes || [] };
            setModalDetails(details);
          } catch (e) {
            alert("Failed loading details: " + e.message);
            console.error(e);
          } finally { setModalLoading(false); }
        }

        function closeModal() { setModalRow(null); setModalDetails(null); }

        var rowsCount = (summary && typeof summary.rows === 'number') ? summary.rows : (rows ? rows.length : 0);
        var flaggedCount = (summary && typeof summary.flagged_rows === 'number') ? summary.flagged_rows : (rows ? rows.filter(function (r) { return !!r.Reasons; }).length : 0);
        var flaggedPct = rowsCount ? Math.round((flaggedCount * 100) / (rowsCount || 1)) : 0;

        function renderOverlapCell(r) {
          var ov = r.OverlapWith || r.swipe_overlap || r.overlap_with || null;
          if (ov && typeof ov === 'string') {
            var parts = ov.split(";").map(function (s) { return s.trim(); }).filter(Boolean);
            if (parts.length === 0) return <span className="muted">—</span>;
            return <span className="pill" title={ov}>{parts.length} overlap</span>;
          }
          return <span className="muted">—</span>;
        }

        function renderReasonChips(reasonText) {
          if (!reasonText) return <span className="muted">—</span>;
          const parts = String(reasonText).split(";").map(s => s.trim()).filter(Boolean);
          return parts.map((p, idx) => (<span key={idx} className="pill" title={SCENARIO_EXPLANATIONS[p] || p}>{p}</span>));
        }

        function renderReasonExplanations(reasonText) {
          if (!reasonText) return <div className="muted">No flags</div>;
          const parts = String(reasonText).split(";").map(s => s.trim()).filter(Boolean);
          return (
            <div>
              {parts.map((p, idx) => (
                <div key={idx} className="why-item" style={{ marginBottom: 8 }}>
                  <b>{p}</b>
                  <div className="small">{SCENARIO_EXPLANATIONS[p] || "No explanation available."}</div>
                </div>
              ))}
            </div>
          );
        }

        function renderSwipeTimeline(details, modalRow) {
          if (!details || !details.raw_swipes || details.raw_swipes.length === 0) {
            return <div className="muted">No raw swipe evidence available (person not flagged or raw file missing).</div>;
          }
          const all = details.raw_swipes.slice().map(r => {
            const obj = Object.assign({}, r);
            try {
              if (obj.Date && obj.Time) { obj.__ts = new Date(obj.Date + "T" + obj.Time); }
              else if (obj.Date && obj.Time === undefined && obj.LocaleMessageTime) { obj.__ts = new Date(obj.LocaleMessageTime); }
              else if (obj.LocaleMessageTime) { obj.__ts = new Date(obj.LocaleMessageTime); }
              else { obj.__ts = null; }
            } catch (e) { obj.__ts = null; }
            let gap = null;
            if (obj.SwipeGapSeconds !== undefined && obj.SwipeGapSeconds !== null) { gap = Number(obj.SwipeGapSeconds); if (isNaN(gap)) gap = null; }
            else if (obj.SwipeGap) {
              try { const parts = String(obj.SwipeGap).split(':').map(p => Number(p)); if (parts.length === 3) gap = parts[0] * 3600 + parts[1] * 60 + parts[2]; } catch (e) { gap = null; }
            }
            obj.__gap = gap;
            obj.__zone_l = String((obj.Zone || '')).toLowerCase();
            return obj;
          }).sort((a, b) => {
            if (a.__ts && b.__ts) return a.__ts - b.__ts;
            if (a.__ts) return -1;
            if (b.__ts) return 1;
            return 0;
          });

          const flags = new Array(all.length).fill({}).map(() => ({ dayStart: false, outReturn: false }));
          for (let i = 0; i < all.length; i++) {
            const cur = all[i]; const prev = all[i - 1];
            try {
              const curDate = cur.Date ? cur.Date.slice(0, 10) : (cur.__ts ? cur.__ts.toISOString().slice(0, 10) : null);
              const prevDate = prev ? (prev.Date ? prev.Date.slice(0, 10) : (prev.__ts ? prev.__ts.toISOString().slice(0, 10) : null)) : null;
              if (!prev || prevDate !== curDate) { flags[i].dayStart = true; }
            } catch (e) { }
          }
          const OUT_RETURN_GAP_SECONDS = 60 * 60;
          for (let i = 0; i < all.length - 1; i++) {
            const a = all[i], b = all[i + 1];
            const aZone = a.__zone_l || ''; const bZone = b.__zone_l || ''; const bGap = b.__gap || 0;
            if (aZone.includes('out of office') || aZone.includes('out_of_office') || aZone.includes('out of')) {
              if (!bZone.includes('out of office') && (bGap >= OUT_RETURN_GAP_SECONDS || bGap === null && aZone.includes('out'))) {
                flags[i].outReturn = true; flags[i + 1].outReturn = true;
              }
            }
          }

          return (
            <div className="table-scroll">
              <table className="evidence-table" role="table" aria-label="Swipe timeline">
                <thead>
                  <tr>
                    <th>Employee Name</th>
                    <th>Employee ID</th>
                    <th>Card</th>
                    <th>Date</th>
                    <th>Time</th>
                    <th>SwipeGap</th>
                    <th>Door</th>
                    <th>Direction</th>
                    <th>Zone</th>
                    <th>Note</th>
                  </tr>
                </thead>
                <tbody>
                  {all.map((rObj, idx) => {
                    const r = rObj || {};
                    const g = r.__gap;
                    const gapFormatted = (r.SwipeGap && String(r.SwipeGap).trim()) ? String(r.SwipeGap) : (g !== null && g !== undefined) ? formatSecondsToHmsJS(g) : "-";
                    const cls = [];
                    if (flags[idx].dayStart) cls.push('row-day-start');
                    if (flags[idx].outReturn) cls.push('row-out-return');
                    if (g && g >= OUT_RETURN_GAP_SECONDS) cls.push('highlight-long-duration');
                    return (
                      <tr key={idx} className={cls.join(' ')}>
                        <td className="small">{r.EmployeeName || '-'}</td>
                        <td className="small">{r.EmployeeID || '-'}</td>
                        <td className="small">{r.CardNumber || r.Card || '-'}</td>
                        <td className="small">{r.Date || '-'}</td>
                        <td className="small">{r.Time || (r.__ts ? r.__ts.toTimeString().slice(0, 8) : '-')}</td>
                        <td className="small">{gapFormatted}</td>
                        <td className="small" style={{ minWidth: 160 }}>{r.Door || '-'}</td>
                        <td className="small">{r.Direction || '-'}</td>
                        <td className="small">{r.Zone || '-'}</td>
                        <td className="small">{r.Note || '-'}{r._source ? <span className="muted"> ({r._source})</span> : null}</td>
                      </tr>
                    );
                  })
                  }
                </tbody>
              </table>
            </div>
          );
        }

        return (
          <div className="container" aria-live="polite">
            {loading && (
              <div className="spinner-overlay" role="status" aria-label="Loading">
                <div className="spinner-box">
                  <div className="spinner" />
                  <div style={{ fontWeight: 700 }}>Loading…</div>
                </div>
              </div>
            )}

            <div className="topbar" role="banner">
              <div className="wu-brand" aria-hidden={false}>
                <div className="wu-logo">WU</div>
                <div className="title-block">
                  <h1>Western Union — Trend Analysis</h1>
                  <p>Pune</p>
                </div>
              </div>

              <div className="header-actions" role="region" aria-label="controls">
                <div className="control">
                  <label className="small" htmlFor="fromDate">From</label>
                  <input id="fromDate" ref={fromRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                </div>

                <div className="control">
                  <label className="small" htmlFor="toDate">To</label>
                  <input id="toDate" ref={toRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                </div>

                <button className="btn-primary" onClick={runForRange} disabled={loading}>Run</button>
                <button className="btn-ghost" onClick={loadLatest} disabled={loading}>Load latest</button>
              </div>
            </div>

            <div className="card-shell">
              <div className="cards" aria-hidden={loading}>
                <div className="card" title="Rows analysed">
                  <div className="card-content">
                    <div className="card-icon"><i className="bi bi-table"></i></div>
                    <div className="card-text"><h3>{(rowsCount !== undefined && rowsCount !== null) ? rowsCount.toLocaleString() : 0}</h3><p>Rows analysed</p></div>
                  </div>
                </div>

                <div className="card card-flagged" title="Flagged rows">
                  <div className="card-content">
                    <div className="card-icon"><i className="bi bi-flag-fill"></i></div>
                    <div className="card-text"><h3>{(flaggedCount !== undefined && flaggedCount !== null) ? flaggedCount.toLocaleString() : 0}</h3><p>Flagged rows</p></div>
                  </div>
                </div>

                <div className="card card-rate" title="Flagged rate">
                  <div className="card-content">
                    <div className="card-icon"><i className="bi bi-graph-up-arrow"></i></div>
                    <div className="card-text"><h3>{flaggedPct}%</h3><p>Flagged rate</p></div>
                  </div>
                </div>
              </div>

              <div className="main">
                <div className="left">
                  <div style={{ display:'flex', alignItems:'flex-start', gap:16 }}>
                    <div style={{ flex:1, minHeight:220 }} className="chart-wrap" aria-label="Risk level chart">
                      <canvas ref={chartRef}></canvas>
                    </div>

                    {/* Risk chips + clear control */}
                    <div style={{ width:220 }}>
                      <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center' }}>
                        <strong>Risk filter</strong>
                        {selectedRisk ? <button className="clear-filter" onClick={() => { setSelectedRisk(""); setPage(1); }}>Clear</button> : null}
                      </div>

                      <div className="risk-chips" role="list" aria-label="risk chips">
                        {["Low","Low Medium","Medium","Medium High","High"].map(key => {
                          const count = (riskCounts && riskCounts[key]) ? riskCounts[key] : 0;
                          const active = selectedRisk === key;
                          return (
                            <div key={key} role="listitem"
                              className={"risk-chip " + (active ? "active" : "")}
                              onClick={() => { setSelectedRisk(prev => prev === key ? "" : key); setPage(1); }}
                              title={`Show only ${key} (${count})`}
                              style={{ borderColor: active ? '#cbd5e1' : '#eee', background: active ? '#ffffff' : 'transparent' }}>
                              <div style={{ width:12, height:12, borderRadius:6, background: RISK_COLORS[key] }}></div>
                              <div style={{ fontSize:13 }}>{key}</div>
                              <div style={{ marginLeft:6, fontWeight:700 }}>{count}</div>
                            </div>
                          );
                        })}
                      </div>

                      <div style={{ marginTop:12 }} className="chart-legend">
                        <small className="muted">Tip: click a bar to apply the filter.</small>
                      </div>
                    </div>
                  </div>

                  <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginTop: 12 }}>
                    <input placeholder="Search name, employee id, card or reason..." value={filterText} onChange={function (e) { setFilterText(e.target.value); setPage(1); }} style={{ flex: 1, padding: 10, borderRadius: 6, border: '1px solid #e6edf3' }} />
                    <div className="muted">Showing {filtered.length} / {rows.length} rows</div>
                    <button className="small-button" onClick={exportFiltered}>Export filtered</button>
                  </div>

                  <div style={{ marginTop: 10 }} className="table-scroll" role="region" aria-label="results table">
                    <table>
                      <thead>
                        <tr>
                          <th>Employee</th>
                          <th className="small">ID</th>
                          <th className="small">Card</th>
                          <th className="small">Date</th>
                          <th className="small">Duration</th>
                          <th className="small">Reasons</th>
                          <th className="small">Overlap</th>
                          <th className="small">Evidence</th>
                        </tr>
                      </thead>
                      <tbody>
                        {pageRows.map(function (r, idx) {
                          var empName = sanitizeName(r);
                          var displayDate = safeDateDisplay(r.Date || r.FirstSwipe || r.LastSwipe);
                          var durText = r.Duration || (r.DurationMinutes ? Math.round(r.DurationMinutes) + " min" : "");
                          var flagged = r.Reasons && String(r.Reasons).trim();
                          return (
                            <tr key={idx} className={flagged ? "flagged-row" : ""}>
                              <td className="row-click" onClick={function () { openEvidence(r); }}>{empName || <span className="muted">—</span>}</td>
                              <td className="small">{r.EmployeeID || ""}</td>
                              <td className="small">{r.CardNumber || ""}</td>
                              <td className="small">{displayDate}</td>
                              <td className="small">{durText}</td>
                              <td className="small">{renderReasonChips(r.Reasons)}</td>
                              <td className="small">{renderOverlapCell(r)}</td>
                              <td className="small">
                                <button className="evidence-btn" onClick={function () { openEvidence(r); }}>Evidence</button>
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>

                  <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginTop: 10 }}>
                    <button onClick={function () { setPage(function (p) { return Math.max(1, p - 1); }); }} disabled={page <= 1}>Prev</button>
                    <div className="muted">Page {page} / {totalPages}</div>
                    <button onClick={function () { setPage(function (p) { return Math.min(totalPages, p + 1); }); }} disabled={page >= totalPages}>Next</button>
                  </div>
                </div>

                <aside className="right" aria-label="side panel">
                  <div style={{ marginBottom: 12 }}>
                    <strong>Files:</strong>
                    <div className="muted" style={{ marginTop: 6 }}>{(summary.files || []).join(", ")}</div>
                  </div>

                  <div style={{ marginBottom: 12 }}>
                    <strong>Top reasons summary</strong>
                    <div className="small muted" style={{ marginTop: 6 }}>Click a reason to filter the table by that reason. Click again to clear.</div>

                    <div style={{ marginTop: 8, display: 'flex', gap: 8 }}>
                      <input placeholder="Filter reason list..." value={reasonFilterText} onChange={function (e) { setReasonFilterText(e.target.value); }} style={{ flex: 1, padding: '6px 8px', borderRadius: 6, border: '1px solid #e2e8f0' }} />
                      <button className="small-button" onClick={function () { setSelectedReason(''); setReasonFilterText(''); }}>Clear</button>
                    </div>

                    <div style={{ marginTop: 8, maxHeight: 320, overflow: 'auto' }}>
                      {Object.keys(reasonsCount).length === 0 && <div className="muted">No flags found</div>}
                      {Object.entries(reasonsCount).sort(function (a, b) { return b[1] - a[1]; }).filter(function (kv) {
                        var name = kv[0];
                        if (!reasonFilterText) return true;
                        return name.toLowerCase().indexOf(reasonFilterText.toLowerCase()) !== -1;
                      }).slice(0, 50).map(function (kv) {
                        var name = kv[0], count = kv[1];
                        var active = selectedReason === name;
                        return (
                          <div key={name} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 8, marginBottom: 6 }}>
                            <button className={"chip " + (active ? "active" : "")} style={{ textAlign: 'left', flex: 1 }} onClick={function () { onReasonClick(name); }}>
                              {name}
                            </button>
                            <div style={{ minWidth: 48, textAlign: 'right' }} className="small"><b>{count}</b></div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </aside>
              </div>
            </div>

            {/* Modal (unchanged) */}
            {modalRow &&
              <div className="modal" onClick={closeModal}>
                <div className="modal-inner" onClick={function (e) { e.stopPropagation(); }}>
                  <div className="modal-header">
                    <div className="header-content">
                      <div className="header-icon"><i className="bi bi-clipboard2-data-fill"></i></div>
                      <div className="header-text">
                        <h3>Details — Evidence</h3>
                        <div className="header-subtitle small">Evidence & explanation for selected row</div>
                      </div>
                    </div>
                    <button className="close-btn" onClick={closeModal}><i className="bi bi-x-lg"></i> Close</button>
                  </div>

                  <div className="modal-body">
                    {modalLoading && (
                      <div className="loading-state">
                        <div className="loading-spinner"></div>
                        <span>Loading evidence…</span>
                      </div>
                    )}

                    <div className="modal-top" role="region" aria-label="evidence summary">
                      <div className="image-section">
                        <div className="image-container">
                          <div className="multi-color-border">
                            <div className="image-content">
                              {(modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows.length > 0) ? (
                                (() => {
                                  const md = modalDetails.aggregated_rows[0];
                                  if (md && md.imageUrl) {
                                    return (
                                      <img className="modal-image" src={API_BASE + md.imageUrl} alt="Employee" onError={(e) => { e.target.style.display = 'none'; e.target.nextSibling.style.display = 'flex'; }} />
                                    );
                                  } else {
                                    return <div className="modal-image-placeholder">No image</div>;
                                  }
                                })()
                              ) : (
                                <div className="modal-image-placeholder"><i className="bi bi-person-square"></i><span>No image</span></div>
                              )}
                            </div>
                          </div>
                        </div>
                      </div>

                      <div className="modal-details">
                        <div className="details-header">
                          <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
                            <div className="emp-name">{sanitizeName(modalRow) || "—"}</div>
                            <div style={{ display: 'flex', gap: 8, alignItems:'center' }}>
                              <div className="risk-badge" style={{ background: RISK_COLORS[modalRow.RiskLevel] || RISK_COLORS[getRiskLabel(modalRow)] }}>
                                {modalRow.RiskLevel || (modalRow.RiskScore ? ("Score " + modalRow.RiskScore) : "Low")}
                              </div>
                              <div style={{ fontSize: 13, color: '#fff', fontWeight:700 }}>
                                <span className="risk-small" style={{ color: '#0b1221', marginLeft: 6 }}>{modalRow.RiskScore ? ("(" + modalRow.RiskScore + ")") : ""}</span>
                              </div>
                            </div>
                          </div>

                          <div style={{ marginTop: 8 }}>
                            <div className="emp-badge"><i className="bi bi-person-badge"></i> ID: {modalRow.EmployeeID || "—"}</div>
                          </div>
                        </div>

                        <div className="details-grid" style={{ marginTop: 10 }}>
                          <div className="detail-item"><div className="detail-icon"><i className="bi bi-credit-card"></i></div><div className="detail-content"><label>Card Number</label><span>{modalRow.CardNumber || "—"}</span></div></div>
                          <div className="detail-item"><div className="detail-icon"><i className="bi bi-calendar-date"></i></div><div className="detail-content"><label>Date</label><span>{safeDateDisplay(modalRow.Date || modalRow.FirstSwipe)}</span></div></div>
                          <div className="detail-item"><div className="detail-icon"><i className="bi bi-clock"></i></div><div className="detail-content"><label>Duration</label><span className="duration-badge">{modalRow.Duration || (modalRow.DurationMinutes ? Math.round(modalRow.DurationMinutes) + " min" : "—")}</span></div></div>
                          <div className="detail-item"><div className="detail-icon"><i className="bi bi-exclamation-triangle"></i></div><div className="detail-content"><label>Violation days (90d)</label><span>{(modalRow.ViolationDaysLast90 !== undefined && modalRow.ViolationDaysLast90 !== null) ? modalRow.ViolationDaysLast90 : 0}</span></div></div>
                        </div>
                      </div>

                      <div className="modal-reasons">
                        <div className="reasons-section">
                          <div className="section-title"><i className="bi bi-list-check"></i> Explanation</div>
                          <div className="why-box" style={{ maxHeight: 140, overflow: 'auto' }}>{modalRow.Explanation ? <div style={{ whiteSpace: 'pre-wrap' }}>{modalRow.Explanation}</div> : <div className="muted">No explanation provided.</div>}</div>
                        </div>

                        <div className="why-section">
                          <div className="section-title"><i className="bi bi-badge-ad"></i> Reasons (codes)</div>
                          <div className="reasons-list">{renderReasonChips(modalRow.Reasons)}</div>
                        </div>
                      </div>
                    </div>

                    <div className="evidence-section">
                      <div className="section-header"><i className="bi bi-folder2-open"></i><h4>Available Evidence Files</h4></div>
                      <div className="files-container">
                        {modalDetails && modalDetails.raw_swipe_files && modalDetails.raw_swipe_files.length > 0 ? (
                          <div className="files-list">{modalDetails.raw_swipe_files.map((f, i) => (
                            <div key={i} className="file-item"><i className="bi bi-file-earmark-text"></i><span className="file-name">{f}</span>
                              <button className="download-btn" onClick={function () { window.location = API_BASE + "/swipes/" + encodeURIComponent(f); }}><i className="bi bi-download"></i> Download</button>
                            </div>
                          ))}</div>
                        ) : (
                          <div className="no-files"><i className="bi bi-folder-x"></i><span>No raw swipe files found for this person/date.</span></div>
                        )}
                      </div>
                    </div>

                    <div className="timeline-section">
                      <div className="section-header"><i className="bi bi-clock-history"></i><h4>Swipe Timeline</h4><span className="subtitle">Filtered for this person/date</span></div>
                      <div className="timeline-content">{modalDetails ? renderSwipeTimeline(modalDetails, modalRow) : (<div className="loading-timeline"><i className="bi bi-hourglass-split"></i><span>Evidence not loaded yet.</span></div>)}</div>
                    </div>

                    <div className="raw-json-section">
                      <label className="toggle-label">
                        <input type="checkbox" id="showraw" onChange={function (e) { const el = document.getElementById('rawpayload'); if (el) el.style.display = e.target.checked ? 'block' : 'none'; }} />
                        <span className="toggle-slider"></span>
                        <span className="toggle-text"><i className="bi bi-code-slash"></i> Show raw aggregated JSON</span>
                      </label>
                      <div id="rawpayload" className="raw-json"><pre>{JSON.stringify(modalRow, null, 2)}</pre></div>
                    </div>
                  </div>
                </div>
              </div>
            }
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(App));
    })();
  </script>
</body>

</html>


























<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Trend Analysis — Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- React + ReactDOM + Babel (quick prototyping) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- Flatpickr (high-quality calendar) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <!-- (styles omitted here for brevity — use your existing styles) -->
  <style>
    /* Paste your existing CSS here (kept unchanged from your file).
       For brevity in this reply I preserved the full style block in your original file. */
    /* ... (use same CSS as provided in your original file) ... */
    /* For demo, a little extra for Risk badge */
    .risk-badge {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 800;
      color: #fff;
      font-size: 13px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.08);
    }
    .risk-small { font-size: 12px; font-weight:700; }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    (function () {
      const { useState, useEffect, useRef } = React;

      // CHANGE THIS IF YOUR API HOST DIFFERS
      const API_BASE = "http://localhost:8002";

      // Colour mapping requested by user
      const RISK_COLORS = {
        "Low": "#10b981",          // Green
        "Low Medium": "#86efac",   // Light green
        "Medium": "#facc15",       // Yellow
        "Medium High": "#fb923c",  // Orange
        "High": "#ef4444"          // Red
      };

      const SCENARIO_EXPLANATIONS = {
        "long_gap_>=90min": "Long gap between swipes (>= 90 minutes) — could indicate long out-of-office break.",
        "short_duration_<4h": "Short total duration in office (< 4 hours).",
        "coffee_badging": "Frequent short badge cycles (>=4) with short duration — possible 'coffee badging'.",
        "low_swipe_count_<=2": "Low swipe count (<=2) for the day.",
        "single_door": "All swipes used the same door — single-door behavior.",
        "only_in": "Only IN swipe(s) recorded for the day.",
        "only_out": "Only OUT swipe(s) recorded for the day.",
        "overtime_>=10h": "Long duration (>=10 hours) — overtime.",
        "very_long_duration_>=16h": "Very long duration (>=16 hours) — suspiciously long presence.",
        "zero_swipes": "No swipes recorded.",
        "unusually_high_swipes": "Unusually high number of swipes versus historical median.",
        "repeated_short_breaks": "Multiple short breaks within the day.",
        "multiple_location_same_day": "Swipes recorded at multiple locations same day.",
        "weekend_activity": "Activity recorded on weekend.",
        "repeated_rejection_count": "Several card rejections.",
        "badge_sharing_suspected": "Badge sharing suspected (same card used by multiple persons on same day).",
        "early_arrival_before_06": "First swipe before 06:00.",
        "late_exit_after_22": "Last swipe after 22:00.",
        "shift_inconsistency": "Duration inconsistent with historical shift patterns.",
        "trending_decline": "Historical trending decline flagged.",
        "consecutive_absent_days": "Marked absent for consecutive days historically.",
        "high_variance_duration": "High variance in durations historically.",
        "short_duration_on_high_presence_days": "Short duration even though employee usually attends many days.",
        "swipe_overlap": "Simultaneous swipe(s) near the same time with other uid(s) (possible tailgating or collusion).",
        "shortstay_longout_repeat": "Pattern: short stay, long out-of-office, short return (repeat)."
      };

      function pad(n) { return n.toString().padStart(2, '0'); }
      function formatDateISO(d) {
        if (!d) return "";
        const dt = (d instanceof Date) ? d : new Date(d);
        return dt.getFullYear() + "-" + pad(dt.getMonth() + 1) + "-" + pad(dt.getDate());
      }
      function datesBetween(start, end) {
        var out = [];
        var cur = new Date(start);
        while (cur <= end) {
          out.push(new Date(cur));
          cur.setDate(cur.getDate() + 1);
        }
        return out;
      }
      function safeDateDisplay(val) {
        if (!val && val !== 0) return "";
        try {
          var d = (val instanceof Date) ? val : new Date(val);
          if (isNaN(d.getTime())) return String(val);
          return d.toLocaleString();
        } catch (e) {
          return String(val);
        }
      }
      function sanitizeName(row) {
        return row.EmployeeName || row.EmployeeName_x || row.EmployeeName_y || row.person_uid || "";
      }
      function downloadCSV(rows, filename) {
        if (!rows || !rows.length) { alert("No rows to export"); return; }
        var cols = Object.keys(rows[0]);
        var lines = [cols.join(",")];
        rows.forEach(function (r) {
          var row = cols.map(function (c) {
            var v = (r[c] === undefined || r[c] === null) ? "" : String(r[c]).replace(/\n/g, ' ');
            return JSON.stringify(v);
          }).join(",");
          lines.push(row);
        });
        var blob = new Blob([lines.join("\n")], { type: 'text/csv' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a'); a.href = url; a.download = filename || 'export.csv'; a.click(); URL.revokeObjectURL(url);
      }

      // convert seconds -> "HH:mm:ss"
      function formatSecondsToHmsJS(seconds) {
        if (seconds === null || seconds === undefined || seconds === '') return "-";
        const n = Number(seconds);
        if (isNaN(n) || !isFinite(n)) return "-";
        const s = Math.max(0, Math.floor(n));
        const hh = Math.floor(s / 3600);
        const mm = Math.floor((s % 3600) / 60);
        const ss = s % 60;
        return pad(hh) + ":" + pad(mm) + ":" + pad(ss);
      }

      function App() {
        var yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);

        const [dateFrom, setDateFrom] = useState(formatDateISO(yesterday));
        const [dateTo, setDateTo] = useState(formatDateISO(new Date()));
        const [loading, setLoading] = useState(false);
        const [summary, setSummary] = useState({ rows: 0, flagged_rows: 0, files: [], end_date: null });
        const [rows, setRows] = useState([]);
        const [reasonsCount, setReasonsCount] = useState({});
        const [riskCounts, setRiskCounts] = useState({});
        const [filterText, setFilterText] = useState("");
        const [page, setPage] = useState(1);
        const [selectedReason, setSelectedReason] = useState("");
        const [reasonFilterText, setReasonFilterText] = useState("");
        const [modalRow, setModalRow] = useState(null);
        const [modalDetails, setModalDetails] = useState(null);
        const [modalLoading, setModalLoading] = useState(false);
        const pageSize = 25;
        const chartRef = useRef(null);
        const chartInst = useRef(null);

        // flatpickr refs
        const fromRef = useRef(null);
        const toRef = useRef(null);
        const fromFp = useRef(null);
        const toFp = useRef(null);

        useEffect(function () {
          if (window.flatpickr && fromRef.current && toRef.current) {
            try { if (fromFp.current) fromFp.current.destroy(); } catch (e) { }
            try { if (toFp.current) toFp.current.destroy(); } catch (e) { }
            fromFp.current = window.flatpickr(fromRef.current, {
              dateFormat: "Y-m-d",
              defaultDate: dateFrom,
              allowInput: true,
              onChange: function (selectedDates, str) {
                if (selectedDates && selectedDates.length) {
                  const iso = formatDateISO(selectedDates[0]);
                  setDateFrom(iso);
                  try { if (toFp.current) toFp.current.set('minDate', iso); } catch (e) { }
                  if (dateTo && new Date(iso) > new Date(dateTo)) {
                    setDateTo(iso);
                    try { if (toFp.current) toFp.current.setDate(iso, true); } catch (e) { }
                  }
                }
              }
            });
            toFp.current = window.flatpickr(toRef.current, {
              dateFormat: "Y-m-d",
              defaultDate: dateTo,
              allowInput: true,
              onChange: function (selectedDates, str) {
                if (selectedDates && selectedDates.length) {
                  const iso = formatDateISO(selectedDates[0]);
                  setDateTo(iso);
                  try { if (fromFp.current) fromFp.current.set('maxDate', iso); } catch (e) { }
                  if (dateFrom && new Date(iso) < new Date(dateFrom)) {
                    setDateFrom(iso);
                    try { if (fromFp.current) fromFp.current.setDate(iso, true); } catch (e) { }
                  }
                }
              }
            });
            try { if (fromFp.current) fromFp.current.set('maxDate', dateTo); if (toFp.current) toFp.current.set('minDate', dateFrom); } catch (e) { }
          }
          loadLatest();
          return function () { try { if (fromFp.current) fromFp.current.destroy(); } catch (e) { } try { if (toFp.current) toFp.current.destroy(); } catch (e) { } };
          // eslint-disable-next-line
        }, []);

        useEffect(function () {
          try { if (fromFp.current && dateFrom) fromFp.current.setDate(dateFrom, false); } catch (e) { }
          try { if (toFp.current && dateTo) toFp.current.setDate(dateTo, false); } catch (e) { }
          try { if (fromFp.current) fromFp.current.set('maxDate', dateTo); } catch (e) { }
          try { if (toFp.current) toFp.current.set('minDate', dateFrom); } catch (e) { }
        }, [dateFrom, dateTo]);

        async function runForRange() {
          setLoading(true);
          setRows([]); setSummary({ rows: 0, flagged_rows: 0, files: [], end_date: null }); setReasonsCount({}); setRiskCounts({});
          try {
            var start = new Date(dateFrom);
            var end = new Date(dateTo);
            var dateList = datesBetween(start, end).map(d => formatDateISO(d));
            var accRows = []; var totalRows = 0, totalFlagged = 0, files = [];
            for (var i = 0; i < dateList.length; i++) {
              var d = dateList[i];
              var url = API_BASE + "/run?date=" + d;
              var r = await fetch(url, { method: 'GET' });
              if (!r.ok) { var txt = await r.text(); throw new Error("API returned " + r.status + ": " + txt); }
              var js = await r.json();
              var sample = js.sample || [];
              if (Array.isArray(sample) && sample.length) accRows = accRows.concat(sample);
              if (typeof js.rows === 'number') totalRows += js.rows; else totalRows += (Array.isArray(sample) ? sample.length : 0);
              totalFlagged += (js.flagged_rows || 0);
              if (js.files) files = files.concat(js.files);
            }
            setRows(accRows);
            setSummary({ rows: totalRows, flagged_rows: totalFlagged, files: files, end_date: formatDateISO(new Date(dateTo)) });
            computeReasonsAndRisks(accRows);
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message);
            console.error(err);
          } finally { setLoading(false); }
        }

        async function loadLatest() {
          setLoading(true);
          try {
            var r = await fetch(API_BASE + "/latest");
            if (!r.ok) throw new Error("latest failed: " + r.status);
            var js = await r.json();
            var sample = js.sample || [];
            if (!Array.isArray(sample)) sample = [];
            setRows(sample);
            setSummary({ rows: (js.rows || sample.length || 0), flagged_rows: (sample.filter(function (x) { return !!x.Reasons; }).length || 0), files: [js.file] });
            computeReasonsAndRisks(sample);
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message + (err.message === 'latest failed: 0' ? " (check backend/CORS)" : ""));
            console.error(err);
          } finally { setLoading(false); }
        }

        // NEW: compute both reasons distribution and risk-level distribution and draw the risk graph
        function computeReasonsAndRisks(dataRows) {
          var counts = {};
          var rcounts = { "Low":0, "Low Medium":0, "Medium":0, "Medium High":0, "High":0 };
          (dataRows || []).forEach(function (r) {
            if (r.Reasons) {
              var parts = String(r.Reasons).split(";").map(function (s) { return s.trim(); }).filter(Boolean);
              parts.forEach(function (p) { counts[p] = (counts[p] || 0) + 1; });
            }
            // RiskLevel -- backend may provide RiskLevel (string) or RiskScore (1..5)
            var rl = r.RiskLevel || r.Risk || null;
            if (!rl && r.RiskScore) {
              // map from numeric to string per your backend thresholds (fallback)
              const mapNum = {1:"Low",2:"Low Medium",3:"Medium",4:"Medium High",5:"High"};
              rl = mapNum[String(r.RiskScore)] || null;
            }
            if (rl) {
              if (!rcounts[rl]) rcounts[rl] = 0;
              rcounts[rl] += 1;
            } else {
              // If missing, assume Low
              rcounts["Low"] += 1;
            }
          });
          setReasonsCount(counts);
          setRiskCounts(rcounts);
          buildChart(rcounts);
        }

        // Build the Risk-level chart (colour-coded exactly per user request)
        function buildChart(rcounts) {
          // labels in desired order
          var labels = ["Low", "Low Medium", "Medium", "Medium High", "High"];
          var values = labels.map(l => rcounts && rcounts[l] ? rcounts[l] : 0);
          var colors = labels.map(l => RISK_COLORS[l] || '#cccccc');

          var ctx = chartRef.current && chartRef.current.getContext ? chartRef.current.getContext('2d') : null;
          if (!ctx) return;
          try { if (chartInst.current) chartInst.current.destroy(); } catch (e) { }
          chartInst.current = new Chart(ctx, {
            type: 'bar',
            data: { labels: labels, datasets: [{ label: 'Flagged by Risk Level', data: values, backgroundColor: colors }] },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      return context.parsed.y + ' cases';
                    }
                  }
                }
              },
              scales: {
                y: { beginAtZero: true, ticks: { precision:0 } }
              }
            }
          });
        }

        // filtering & pagination helpers
        var filtered = (rows || []).filter(function (r) {
          var hay = (sanitizeName(r) + " " + (r.EmployeeID || "") + " " + (r.CardNumber || "") + " " + (r.Reasons || "")).toLowerCase();
          var textOk = !filterText || hay.indexOf(filterText.toLowerCase()) !== -1;
          var reasonOk = !selectedReason || (r.Reasons && ((";" + String(r.Reasons) + ";").indexOf(selectedReason) !== -1));
          return textOk && reasonOk;
        });
        var totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
        var pageRows = filtered.slice((page - 1) * pageSize, page * pageSize);

        function exportFiltered() { downloadCSV(filtered, "trend_filtered_export.csv"); }

        function onReasonClick(reason) {
          if (!reason) { setSelectedReason(""); return; }
          if (selectedReason === reason) setSelectedReason(""); else setSelectedReason(reason);
          setPage(1);
        }

        // open evidence modal (explicit Evidence button)
        async function openEvidence(row) {
          setModalRow(row);
          setModalDetails(null);
          setModalLoading(true);
          try {
            // Query API for aggregated and raw swipe details. Backend endpoint is /record?employee_id=...
            const q = encodeURIComponent(row.EmployeeID || row.person_uid || "");
            const resp = await fetch(API_BASE + "/record?employee_id=" + q);
            if (!resp.ok) { const txt = await resp.text(); throw new Error("record failed: " + resp.status + " - " + txt); }
            const js = await resp.json();
            const details = { aggregated_rows: js.aggregated_rows || [], raw_swipe_files: js.raw_swipe_files || [], raw_swipes: js.raw_swipes || [] };
            setModalDetails(details);
          } catch (e) {
            alert("Failed loading details: " + e.message);
            console.error(e);
          } finally { setModalLoading(false); }
        }

        function closeModal() { setModalRow(null); setModalDetails(null); }

        var rowsCount = (summary && typeof summary.rows === 'number') ? summary.rows : (rows ? rows.length : 0);
        var flaggedCount = (summary && typeof summary.flagged_rows === 'number') ? summary.flagged_rows : (rows ? rows.filter(function (r) { return !!r.Reasons; }).length : 0);
        var flaggedPct = rowsCount ? Math.round((flaggedCount * 100) / (rowsCount || 1)) : 0;

        function renderOverlapCell(r) {
          var ov = r.OverlapWith || r.swipe_overlap || r.overlap_with || null;
          if (ov && typeof ov === 'string') {
            var parts = ov.split(";").map(function (s) { return s.trim(); }).filter(Boolean);
            if (parts.length === 0) return <span className="muted">—</span>;
            return <span className="pill" title={ov}>{parts.length} overlap</span>;
          }
          return <span className="muted">—</span>;
        }

        function renderReasonChips(reasonText) {
          if (!reasonText) return <span className="muted">—</span>;
          const parts = String(reasonText).split(";").map(s => s.trim()).filter(Boolean);
          return parts.map((p, idx) => (<span key={idx} className="pill" title={SCENARIO_EXPLANATIONS[p] || p}>{p}</span>));
        }

        function renderReasonExplanations(reasonText) {
          if (!reasonText) return <div className="muted">No flags</div>;
          const parts = String(reasonText).split(";").map(s => s.trim()).filter(Boolean);
          return (
            <div>
              {parts.map((p, idx) => (
                <div key={idx} className="why-item" style={{ marginBottom: 8 }}>
                  <b>{p}</b>
                  <div className="small">{SCENARIO_EXPLANATIONS[p] || "No explanation available."}</div>
                </div>
              ))}
            </div>
          );
        }

        // render timeline with requested highlights:
        function renderSwipeTimeline(details, modalRow) {
          if (!details || !details.raw_swipes || details.raw_swipes.length === 0) {
            return <div className="muted">No raw swipe evidence available (person not flagged or raw file missing).</div>;
          }
          const all = details.raw_swipes.slice().map(r => {
            const obj = Object.assign({}, r);
            try {
              if (obj.Date && obj.Time) { obj.__ts = new Date(obj.Date + "T" + obj.Time); }
              else if (obj.Date && obj.Time === undefined && obj.LocaleMessageTime) { obj.__ts = new Date(obj.LocaleMessageTime); }
              else if (obj.LocaleMessageTime) { obj.__ts = new Date(obj.LocaleMessageTime); }
              else { obj.__ts = null; }
            } catch (e) { obj.__ts = null; }
            let gap = null;
            if (obj.SwipeGapSeconds !== undefined && obj.SwipeGapSeconds !== null) { gap = Number(obj.SwipeGapSeconds); if (isNaN(gap)) gap = null; }
            else if (obj.SwipeGap) {
              try { const parts = String(obj.SwipeGap).split(':').map(p => Number(p)); if (parts.length === 3) gap = parts[0] * 3600 + parts[1] * 60 + parts[2]; } catch (e) { gap = null; }
            }
            obj.__gap = gap;
            obj.__zone_l = String((obj.Zone || '')).toLowerCase();
            return obj;
          }).sort((a, b) => {
            if (a.__ts && b.__ts) return a.__ts - b.__ts;
            if (a.__ts) return -1;
            if (b.__ts) return 1;
            return 0;
          });

          const flags = new Array(all.length).fill({}).map(() => ({ dayStart: false, outReturn: false }));
          for (let i = 0; i < all.length; i++) {
            const cur = all[i]; const prev = all[i - 1];
            try {
              const curDate = cur.Date ? cur.Date.slice(0, 10) : (cur.__ts ? cur.__ts.toISOString().slice(0, 10) : null);
              const prevDate = prev ? (prev.Date ? prev.Date.slice(0, 10) : (prev.__ts ? prev.__ts.toISOString().slice(0, 10) : null)) : null;
              if (!prev || prevDate !== curDate) { flags[i].dayStart = true; }
            } catch (e) { }
          }
          const OUT_RETURN_GAP_SECONDS = 60 * 60;
          for (let i = 0; i < all.length - 1; i++) {
            const a = all[i], b = all[i + 1];
            const aZone = a.__zone_l || ''; const bZone = b.__zone_l || ''; const bGap = b.__gap || 0;
            if (aZone.includes('out of office') || aZone.includes('out_of_office') || aZone.includes('out of')) {
              if (!bZone.includes('out of office') && (bGap >= OUT_RETURN_GAP_SECONDS || bGap === null && aZone.includes('out'))) {
                flags[i].outReturn = true; flags[i + 1].outReturn = true;
              }
            }
          }

          return (
            <div className="table-scroll">
              <table className="evidence-table" role="table" aria-label="Swipe timeline">
                <thead>
                  <tr>
                    <th>Employee Name</th>
                    <th>Employee ID</th>
                    <th>Card</th>
                    <th>Date</th>
                    <th>Time</th>
                    <th>SwipeGap</th>
                    <th>Door</th>
                    <th>Direction</th>
                    <th>Zone</th>
                    <th>Note</th>
                  </tr>
                </thead>
                <tbody>
                  {all.map((rObj, idx) => {
                    const r = rObj || {};
                    const g = r.__gap;
                    const gapFormatted = (r.SwipeGap && String(r.SwipeGap).trim()) ? String(r.SwipeGap) : (g !== null && g !== undefined) ? formatSecondsToHmsJS(g) : "-";
                    const cls = [];
                    if (flags[idx].dayStart) cls.push('row-day-start');
                    if (flags[idx].outReturn) cls.push('row-out-return');
                    if (g && g >= OUT_RETURN_GAP_SECONDS) cls.push('highlight-long-duration');
                    return (
                      <tr key={idx} className={cls.join(' ')}>
                        <td className="small">{r.EmployeeName || '-'}</td>
                        <td className="small">{r.EmployeeID || '-'}</td>
                        <td className="small">{r.CardNumber || r.Card || '-'}</td>
                        <td className="small">{r.Date || '-'}</td>
                        <td className="small">{r.Time || (r.__ts ? r.__ts.toTimeString().slice(0, 8) : '-')}</td>
                        <td className="small">{gapFormatted}</td>
                        <td className="small" style={{ minWidth: 160 }}>{r.Door || '-'}</td>
                        <td className="small">{r.Direction || '-'}</td>
                        <td className="small">{r.Zone || '-'}</td>
                        <td className="small">{r.Note || '-'}{r._source ? <span className="muted"> ({r._source})</span> : null}</td>
                      </tr>
                    );
                  })
                  }
                </tbody>
              </table>
            </div>
          );
        }

        return (
          <div className="container" aria-live="polite">
            {loading && (
              <div className="spinner-overlay" role="status" aria-label="Loading">
                <div className="spinner-box">
                  <div className="spinner" />
                  <div style={{ fontWeight: 700 }}>Loading…</div>
                </div>
              </div>
            )}

            <div className="topbar" role="banner">
              <div className="wu-brand" aria-hidden={false}>
                <div className="wu-logo">WU</div>
                <div className="title-block">
                  <h1>Western Union — Trend Analysis</h1>
                  <p>Pune</p>
                </div>
              </div>

              <div className="header-actions" role="region" aria-label="controls">
                <div className="control">
                  <label className="small" htmlFor="fromDate">From</label>
                  <input id="fromDate" ref={fromRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                </div>

                <div className="control">
                  <label className="small" htmlFor="toDate">To</label>
                  <input id="toDate" ref={toRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                </div>

                <button className="btn-primary" onClick={runForRange} disabled={loading}>Run</button>
                <button className="btn-ghost" onClick={loadLatest} disabled={loading}>Load latest</button>
              </div>
            </div>

            <div className="card-shell">
              <div className="cards" aria-hidden={loading}>
                <div className="card" title="Rows analysed">
                  <div className="card-content">
                    <div className="card-icon">
                      <i className="bi bi-table"></i>
                    </div>
                    <div className="card-text">
                      <h3>{(rowsCount !== undefined && rowsCount !== null) ? rowsCount.toLocaleString() : 0}</h3>
                      <p>Rows analysed</p>
                    </div>
                  </div>
                  <div className="card-gradient"></div>
                </div>

                <div className="card card-flagged" title="Flagged rows">
                  <div className="card-content">
                    <div className="card-icon">
                      <i className="bi bi-flag-fill"></i>
                    </div>
                    <div className="card-text">
                      <h3>{(flaggedCount !== undefined && flaggedCount !== null) ? flaggedCount.toLocaleString() : 0}</h3>
                      <p>Flagged rows</p>
                    </div>
                  </div>
                  <div className="card-gradient"></div>
                </div>

                <div className="card card-rate" title="Flagged rate">
                  <div className="card-content">
                    <div className="card-icon">
                      <i className="bi bi-graph-up-arrow"></i>
                    </div>
                    <div className="card-text">
                      <h3>{flaggedPct}%</h3>
                      <p>Flagged rate</p>
                    </div>
                  </div>
                  <div className="card-gradient"></div>
                </div>
              </div>

              <div className="main">
                <div className="left">
                  <div className="chart-wrap" aria-label="Risk level chart">
                    <canvas ref={chartRef}></canvas>
                  </div>

                  <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginTop: 6 }}>
                    <input placeholder="Search name, employee id, card or reason..." value={filterText} onChange={function (e) { setFilterText(e.target.value); setPage(1); }} style={{ flex: 1, padding: 10, borderRadius: 6, border: '1px solid #e6edf3' }} />
                    <div className="muted">Showing {filtered.length} / {rows.length} rows</div>
                    <button className="small-button" onClick={exportFiltered}>Export filtered</button>
                  </div>

                  <div style={{ marginTop: 10 }} className="table-scroll" role="region" aria-label="results table">
                    <table>
                      <thead>
                        <tr>
                          <th>Employee</th>
                          <th className="small">ID</th>
                          <th className="small">Card</th>
                          <th className="small">Date</th>
                          <th className="small">Duration</th>
                          <th className="small">Reasons</th>
                          <th className="small">Overlap</th>
                          <th className="small">Evidence</th>
                        </tr>
                      </thead>
                      <tbody>
                        {pageRows.map(function (r, idx) {
                          var empName = sanitizeName(r);
                          var displayDate = safeDateDisplay(r.Date || r.FirstSwipe || r.LastSwipe);
                          var durText = r.Duration || (r.DurationMinutes ? Math.round(r.DurationMinutes) + " min" : "");
                          var flagged = r.Reasons && String(r.Reasons).trim();
                          return (
                            <tr key={idx} className={flagged ? "flagged-row" : ""}>
                              <td className="row-click" onClick={function () { openEvidence(r); }}>{empName || <span className="muted">—</span>}</td>
                              <td className="small">{r.EmployeeID || ""}</td>
                              <td className="small">{r.CardNumber || ""}</td>
                              <td className="small">{displayDate}</td>
                              <td className="small">{durText}</td>
                              <td className="small">{renderReasonChips(r.Reasons)}</td>
                              <td className="small">{renderOverlapCell(r)}</td>
                              <td className="small">
                                <button className="evidence-btn" onClick={function () { openEvidence(r); }}>Evidence</button>
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>

                  <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginTop: 10 }}>
                    <button onClick={function () { setPage(function (p) { return Math.max(1, p - 1); }); }} disabled={page <= 1}>Prev</button>
                    <div className="muted">Page {page} / {totalPages}</div>
                    <button onClick={function () { setPage(function (p) { return Math.min(totalPages, p + 1); }); }} disabled={page >= totalPages}>Next</button>
                  </div>
                </div>

                <aside className="right" aria-label="side panel">
                  <div style={{ marginBottom: 12 }}>
                    <strong>Files:</strong>
                    <div className="muted" style={{ marginTop: 6 }}>{(summary.files || []).join(", ")}</div>
                  </div>

                  <div style={{ marginBottom: 12 }}>
                    <strong>Top reasons summary</strong>
                    <div className="small muted" style={{ marginTop: 6 }}>Click a reason to filter the table by that reason. Click again to clear.</div>

                    <div style={{ marginTop: 8, display: 'flex', gap: 8 }}>
                      <input placeholder="Filter reason list..." value={reasonFilterText} onChange={function (e) { setReasonFilterText(e.target.value); }} style={{ flex: 1, padding: '6px 8px', borderRadius: 6, border: '1px solid #e2e8f0' }} />
                      <button className="small-button" onClick={function () { setSelectedReason(''); setReasonFilterText(''); }}>Clear</button>
                    </div>

                    <div style={{ marginTop: 8, maxHeight: 320, overflow: 'auto' }}>
                      {Object.keys(reasonsCount).length === 0 && <div className="muted">No flags found</div>}
                      {Object.entries(reasonsCount).sort(function (a, b) { return b[1] - a[1]; }).filter(function (kv) {
                        var name = kv[0];
                        if (!reasonFilterText) return true;
                        return name.toLowerCase().indexOf(reasonFilterText.toLowerCase()) !== -1;
                      }).slice(0, 50).map(function (kv) {
                        var name = kv[0], count = kv[1];
                        var active = selectedReason === name;
                        return (
                          <div key={name} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 8, marginBottom: 6 }}>
                            <button className={"chip " + (active ? "active" : "")} style={{ textAlign: 'left', flex: 1 }} onClick={function () { onReasonClick(name); }}>
                              {name}
                            </button>
                            <div style={{ minWidth: 48, textAlign: 'right' }} className="small"><b>{count}</b></div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </aside>
              </div>
            </div>

            {modalRow &&
              <div className="modal" onClick={closeModal}>
                <div className="modal-inner" onClick={function (e) { e.stopPropagation(); }}>
                  {/* Enhanced Header */}
                  <div className="modal-header">
                    <div className="header-content">
                      <div className="header-icon">
                        <i className="bi bi-clipboard2-data-fill"></i>
                      </div>
                      <div className="header-text">
                        <h3>Details — Evidence</h3>
                        <div className="header-subtitle small">Evidence & explanation for selected row</div>
                      </div>
                    </div>
                    <button className="close-btn" onClick={closeModal}>
                      <i className="bi bi-x-lg"></i>
                      Close
                    </button>
                  </div>

                  <div className="modal-body">
                    {modalLoading && (
                      <div className="loading-state">
                        <div className="loading-spinner"></div>
                        <span>Loading evidence…</span>
                      </div>
                    )}

                    {/* Enhanced Top Section */}
                    <div className="modal-top" role="region" aria-label="evidence summary">
                      {/* Column 1 - Enhanced Image with Multi-color Border */}
                      <div className="image-section">
                        <div className="image-container">
                          <div className="multi-color-border">
                            <div className="color-ring color-1"></div>
                            <div className="color-ring color-2"></div>
                            <div className="color-ring color-3"></div>
                            <div className="color-ring color-4"></div>
                            <div className="image-content">
                              {(modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows.length > 0) ? (
                                (() => {
                                  const md = modalDetails.aggregated_rows[0];
                                  if (md && md.imageUrl) {
                                    return (
                                      <img
                                        className="modal-image"
                                        src={API_BASE + md.imageUrl}
                                        alt="Employee"
                                        onError={(e) => {
                                          e.target.style.display = 'none';
                                          e.target.nextSibling.style.display = 'flex';
                                        }}
                                      />
                                    );
                                  } else {
                                    return <div className="modal-image-placeholder">No image</div>;
                                  }
                                })()
                              ) : (
                                <div className="modal-image-placeholder">
                                  <i className="bi bi-person-square"></i>
                                  <span>No image</span>
                                </div>
                              )}
                            </div>
                          </div>
                        </div>
                      </div>

                      {/* Column 2 - Enhanced Employee Details */}
                      <div className="modal-details">
                        <div className="details-header">
                          <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
                            <div className="emp-name">{sanitizeName(modalRow) || "—"}</div>
                            {/* Risk badge */}
                            <div style={{ display: 'flex', gap: 8, alignItems:'center' }}>
                              <div className="risk-badge" style={{ background: RISK_COLORS[modalRow.RiskLevel] || RISK_COLORS[(modalRow.RiskScore && modalRow.RiskScore>=1)? (modalRow.RiskScore==5?'High': modalRow.RiskScore==4?'Medium High': modalRow.RiskScore==3?'Medium': modalRow.RiskScore==2?'Low Medium':'Low'): 'Low'] }}>
                                {modalRow.RiskLevel || (modalRow.RiskScore ? ("Score " + modalRow.RiskScore) : "Low")}
                              </div>
                              <div style={{ fontSize: 13, color: '#fff', fontWeight:700 }}>
                                <span className="risk-small" style={{ color: '#0b1221', marginLeft: 6 }}>{modalRow.RiskScore ? ("(" + modalRow.RiskScore + ")") : ""}</span>
                              </div>
                            </div>
                          </div>

                          <div style={{ marginTop: 8 }}>
                            <div className="emp-badge">
                              <i className="bi bi-person-badge"></i>
                              ID: {modalRow.EmployeeID || "—"}
                            </div>
                          </div>
                        </div>

                        <div className="details-grid" style={{ marginTop: 10 }}>
                          <div className="detail-item">
                            <div className="detail-icon">
                              <i className="bi bi-credit-card"></i>
                            </div>
                            <div className="detail-content">
                              <label>Card Number</label>
                              <span>{modalRow.CardNumber || "—"}</span>
                            </div>
                          </div>

                          <div className="detail-item">
                            <div className="detail-icon">
                              <i className="bi bi-calendar-date"></i>
                            </div>
                            <div className="detail-content">
                              <label>Date</label>
                              <span>{safeDateDisplay(modalRow.Date || modalRow.FirstSwipe)}</span>
                            </div>
                          </div>

                          <div className="detail-item">
                            <div className="detail-icon">
                              <i className="bi bi-clock"></i>
                            </div>
                            <div className="detail-content">
                              <label>Duration</label>
                              <span className="duration-badge">
                                {modalRow.Duration || (modalRow.DurationMinutes ? Math.round(modalRow.DurationMinutes) + " min" : "—")}
                              </span>
                            </div>
                          </div>

                          <div className="detail-item">
                            <div className="detail-icon">
                              <i className="bi bi-exclamation-triangle"></i>
                            </div>
                            <div className="detail-content">
                              <label>Violation days (90d)</label>
                              <span>{(modalRow.ViolationDaysLast90 !== undefined && modalRow.ViolationDaysLast90 !== null) ? modalRow.ViolationDaysLast90 : 0}</span>
                            </div>
                          </div>
                        </div>
                      </div>

                      {/* Column 3 - Explanation & Reasons */}
                      <div className="modal-reasons">
                        <div className="reasons-section">
                          <div className="section-title">
                            <i className="bi bi-list-check"></i>
                            Explanation
                          </div>
                          <div className="why-box" style={{ maxHeight: 140, overflow: 'auto' }}>
                            {modalRow.Explanation ? <div style={{ whiteSpace: 'pre-wrap' }}>{modalRow.Explanation}</div> : <div className="muted">No explanation provided.</div>}
                          </div>
                        </div>

                        <div className="why-section">
                          <div className="section-title">
                            <i className="bi bi-badge-ad"></i>
                            Reasons (codes)
                          </div>
                          <div className="reasons-list">
                            {renderReasonChips(modalRow.Reasons)}
                          </div>
                        </div>
                      </div>
                    </div>

                    {/* Enhanced Evidence Files Section */}
                    <div className="evidence-section">
                      <div className="section-header">
                        <i className="bi bi-folder2-open"></i>
                        <h4>Available Evidence Files</h4>
                      </div>
                      <div className="files-container">
                        {modalDetails && modalDetails.raw_swipe_files && modalDetails.raw_swipe_files.length > 0 ? (
                          <div className="files-list">
                            {modalDetails.raw_swipe_files.map((f, i) => (
                              <div key={i} className="file-item">
                                <i className="bi bi-file-earmark-text"></i>
                                <span className="file-name">{f}</span>
                                <button
                                  className="download-btn"
                                  onClick={function () { window.location = API_BASE + "/swipes/" + encodeURIComponent(f); }}
                                >
                                  <i className="bi bi-download"></i>
                                  Download
                                </button>
                              </div>
                            ))}
                          </div>
                        ) : (
                          <div className="no-files">
                            <i className="bi bi-folder-x"></i>
                            <span>No raw swipe files found for this person/date.</span>
                          </div>
                        )}
                      </div>
                    </div>

                    {/* Enhanced Timeline Section */}
                    <div className="timeline-section">
                      <div className="section-header">
                        <i className="bi bi-clock-history"></i>
                        <h4>Swipe Timeline</h4>
                        <span className="subtitle">Filtered for this person/date</span>
                      </div>
                      <div className="timeline-content">
                        {modalDetails ? renderSwipeTimeline(modalDetails, modalRow) : (
                          <div className="loading-timeline">
                            <i className="bi bi-hourglass-split"></i>
                            <span>Evidence not loaded yet.</span>
                          </div>
                        )}
                      </div>
                    </div>

                    {/* Raw JSON Toggle */}
                    <div className="raw-json-section">
                      <label className="toggle-label">
                        <input
                          type="checkbox"
                          id="showraw"
                          onChange={function (e) {
                            const el = document.getElementById('rawpayload');
                            if (el) el.style.display = e.target.checked ? 'block' : 'none';
                          }}
                        />
                        <span className="toggle-slider"></span>
                        <span className="toggle-text">
                          <i className="bi bi-code-slash"></i>
                          Show raw aggregated JSON
                        </span>
                      </label>
                      <div id="rawpayload" className="raw-json">
                        <pre>{JSON.stringify(modalRow, null, 2)}</pre>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            }

          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(App));
    })();
  </script>
</body>

</html>




























Ok Good Now Help me to Integrate Frontend 

http://localhost:8002/run?date=2025-10-30

  {
      "AnomalyScore": 1.75,
      "BreakCount": 0,
      "CardNumber": "619980",
      "CompanyName": "WU Srvcs India Private Ltd",
      "CountSwipes": 2,
      "Date": "2025-10-30",
      "DetectedScenarios": "short_duration_<4h; low_swipe_count_<=2; single_door",
      "Duration": "2:56:38",
      "DurationMinutes": 176.63333333333333,
      "DurationSeconds": 10598.0,
      "EmpHistoryPresent": false,
      "EmployeeID": "328464",
      "EmployeeIdentity": "208681F9-C3CC-47BA-B59A-7B19DD6E1B54",
      "EmployeeName": "Narang, Sachin",
      "Explanation": "Narang, Sachin -  Short total presence (177 min) \u2014 less than 4 hours; may indicate short stay or partial-day attendance. Very few swipes on day \u2014 unusually low activity. Only a single door used during the day \u2014 possible badge-sharing or single-entry behavior.",
      "FirstDirection": "InDirection",
      "FirstDoor": "APAC_IN_PUN_TOWER B_LIFT LOBBY DOOR",
      "FirstSwipe": "2025-10-30T14:38:14",
      "InCount": 1,
      "IsFlagged": true,
      "LastDirection": "OutDirection",
      "LastDoor": "APAC_IN_PUN_TOWER B_LIFT LOBBY DOOR",
      "LastSwipe": "2025-10-30T17:34:52",
      "LongBreakCount": 0,
      "MaxSwipeGapSeconds": 10598,
      "OnlyIn": 0,
      "OnlyOut": 0,
      "OutCount": 1,
      "OverlapWith": null,
      "PartitionName2": "APAC.Default",
      "PatternSequence": null,
      "PatternSequenceReadable": null,
      "PatternShortLongRepeat": false,
      "PersonnelType": "Employee",
      "PersonnelTypeName": "Employee",
      "PrimaryLocation": "Pune - Business Bay",
      "Reasons": "short_duration_<4h; low_swipe_count_<=2; single_door",
      "RejectionCount": 0,
      "RiskLevel": "High",
      "RiskScore": 5,
      "ShortGapCount": 0,
      "SingleDoor": 1,
      "TotalBreakMinutes": 0.0,
      "UniqueDoors": 1,
      "UniqueLocations": 1,
      "ViolationDaysLast90": 4,
      "badge_sharing_suspected": false,
      "coffee_badging": false,
      "consecutive_absent_days": false,
      "early_arrival_before_06": false,
      "high_variance_duration": false,
      "late_exit_after_22": false,
      "long_gap_>=90min": false,
      "low_swipe_count_<=2": true,
      "multiple_location_same_day": false,
      "only_in": false,
      "only_out": false,
      "overtime_>=10h": false,
      "person_uid": "208681F9-C3CC-47BA-B59A-7B19DD6E1B54",
      "repeated_rejection_count": false,
      "repeated_short_breaks": false,
      "shift_inconsistency": false,
      "short_duration_<4h": true,
      "short_duration_on_high_presence_days": false,
      "shortstay_longout_repeat": false,
      "single_door": true,
      "swipe_overlap": false,
      "trending_decline": false,
      "unusually_high_swipes": false,
      "very_long_duration_>=16h": false,
      "weekend_activity": false,
      "zero_swipes": false
    },



Now In Frontend Build Graph as per Risk Assestment table 

For graph use exact same colour coding ..
Low - use Green 
Low medium - Light green .
Medium - Yellow .
Medium high - Orange 
High -Red..


Employee	ID	Card	Date	Duration	Reasons	Overlap	Evidence

Sawarkar, Sneha	311119	410966	30/10/2025, 05:30:00	8:13:24	repeated_short_breaksshortstay_longout_repeat	—	Evidence
Nair, Saurabh Siddharth	315179	413981	30/10/2025, 05:30:00	3:46:05	short_duration_<4hrepeated_short_breaks	—	Evidence
Marothe, Manisha	318542	608470	30/10/2025, 05:30:00	3:00:29	short_duration_<4hrepeated_short_breaks	—	Evidence




 Update This Section like 
 "EmployeeName": "Narang, Sachin",
 Employee :ID
Evidance tab
"RiskLevel": "High",
ViolationDaysLast90
Explanation

make this Section like Attached image Format same icon and format..
also 

In Evidance tab there is 
Reasons Flagged

Why Highlighted
Replace With 
Explanation


Refer backend file alos as well API resonce carefully and integrate logic in frontend strickly.....
Dont make unnecessary changes here ....






#above is Working file 

# backend/trend_runner.py
from datetime import date, datetime, time, timedelta
from pathlib import Path
import pandas as pd
import numpy as np
import logging
import hashlib
import math
import re
import os

# IMPORTANT: duration_report must exist and expose run_for_date(date, regions, outdir, city)
from duration_report import run_for_date
from config.door_zone import map_door_to_zone, BREAK_ZONES, OUT_OF_OFFICE_ZONE

# HIST_PATH: try a few likely locations (project config, repository root, absolute path)
CANDIDATE_HISTORY = [
    Path(__file__).parent / "config" / "current_analysis.csv",
    Path(__file__).parent.parent / "config" / "current_analysis.csv",
    Path.cwd() / "current_analysis.csv",
    Path(__file__).parent / "current_analysis.csv"
]
HIST_PATH = None
for p in CANDIDATE_HISTORY:
    if p.exists():
        HIST_PATH = p
        break

if HIST_PATH is None:
    logging.warning("Historical profile file current_analysis.csv not found in candidate locations.")
    HIST_DF = pd.DataFrame()
else:
    try:
        HIST_DF = pd.read_csv(HIST_PATH)
        logging.info("Loaded historical profile from %s (rows=%d)", HIST_PATH, len(HIST_DF))
    except Exception as e:
        logging.warning("Failed to load historical profile: %s", e)
        HIST_DF = pd.DataFrame()

OUTDIR = Path("./outputs")
OUTDIR.mkdir(parents=True, exist_ok=True)
MODELS_DIR = Path("./models")
MODELS_DIR.mkdir(parents=True, exist_ok=True)
logging.basicConfig(level=logging.INFO)

# ----- small shared helpers: treat empty/placeholder tokens as None -----
_PLACEHOLDER_STRS = set(['', 'nan', 'na', 'n/a', '-', '—', '–', 'none', 'null'])

def _is_placeholder_str(s: object) -> bool:
    try:
        if s is None:
            return True
        st = str(s).strip().lower()
        return st in _PLACEHOLDER_STRS
    except Exception:
        return False


def _normalize_id_val(v):
    """
    Normalize an id-like value: strip, convert floats like '320172.0' -> '320172'
    Return None for NaN/empty/placeholder.
    """
    try:
        if pd.isna(v):
            return None
    except Exception:
        pass
    if v is None:
        return None
    s = str(v).strip()
    if s == "" or s.lower() == "nan" or _is_placeholder_str(s):
        return None
    # strip .0 if integer-like
    try:
        if '.' in s:
            f = float(s)
            if math.isfinite(f) and f.is_integer():
                return str(int(f))
    except Exception:
        pass
    return s


# prefer to avoid emp:<GUID> person_uids — only treat emp: if value looks like a human id (not GUID)
_GUID_RE = re.compile(r'^[0-9A-Fa-f]{8}-(?:[0-9A-Fa-f]{4}-){3}[0-9A-Fa-f]{12}$')

def _looks_like_guid(s: object) -> bool:
    """Return True if s looks like a GUID/UUID string."""
    if s is None:
        return False
    try:
        st = str(s).strip()
        if not st:
            return False
        return bool(_GUID_RE.match(st))
    except Exception:
        return False

def _looks_like_name(s: object) -> bool:
    """Heuristic: treat as a plausible human name if it contains letters and not a GUID."""
    if s is None:
        return False
    try:
        st = str(s).strip()
        if not st:
            return False
        # reject GUIDs and obviously numeric ids
        if _looks_like_guid(st):
            return False
        # require at least one alphabetic character
        return bool(re.search(r'[A-Za-z]', st))
    except Exception:
        return False

def _pick_first_non_guid_value(series):
    """Pick the first non-null, non-GUID, non-placeholder value from a pandas Series (as str) or None."""
    for v in series:
        if v is None:
            continue
        try:
            s = str(v).strip()
            if not s:
                continue
            if _is_placeholder_str(s):
                continue
            if _looks_like_guid(s):
                continue
            return s
        except Exception:
            continue
    return None

def _canonical_person_uid(row):
    """
    Create canonical person uid:
      - prefer EmployeeID (normalized) -> 'emp:<id>' only if it is not a GUID
      - else EmployeeIdentity -> 'uid:<val>' (GUID allowed)
      - else EmployeeName -> hash-based 'name:<shorthash>'
    """
    empid = row.get('EmployeeID', None)
    empident = row.get('EmployeeIdentity', None)
    name = row.get('EmployeeName', None)
    empid_n = _normalize_id_val(empid)
    if empid_n and not _looks_like_guid(empid_n):
        return f"emp:{empid_n}"
    empident_n = _normalize_id_val(empident)
    if empident_n:
        return f"uid:{empident_n}"
    if name and str(name).strip():
        # stable short hash of name
        h = hashlib.sha1(str(name).strip().lower().encode('utf8')).hexdigest()[:10]
        return f"name:{h}"
    return None


# small helper to extract Card from XML-like strings
_CARD_XML_RE = re.compile(r'<Card>([^<]+)</Card>', re.IGNORECASE | re.DOTALL)
def _extract_card_from_xml(txt):
    try:
        if not txt or not isinstance(txt, str):
            return None
        m = _CARD_XML_RE.search(txt)
        if m:
            return m.group(1).strip()
        # fallback: look for CHUID ... Card: pattern or Card: 12345
        m2 = re.search(r'CHUID.*?Card.*?[:=]\s*([0-9A-Za-z\-\_]+)', txt, re.IGNORECASE | re.DOTALL)
        if m2:
            return m2.group(1).strip()
    except Exception:
        pass
    return None


# explicit list of zones considered breaks (fallback local; config.door_zone imported earlier)
# If config.door_zone defines BREAK_ZONES it's used. Keep a fallback here for safety.
try:
    _BREAK_ZONES = BREAK_ZONES
    _OUT_OF_OFFICE_ZONE = OUT_OF_OFFICE_ZONE
except Exception:
    _BREAK_ZONES = set(["East Outdoor Area", "West Outdoor Area", "Assembly Area"])
    _OUT_OF_OFFICE_ZONE = "Out of office"

def map_door_to_zone(door: object, direction: object = None) -> str:
    """
    Local wrapper that delegates to config's map_door_to_zone, with defensive fallback.
    """
    try:
        return map_door_to_zone(door, direction)
    except Exception:
        # original simple fallback
        try:
            if door is None:
                return None
            s = str(door).strip()
            if not s:
                return None
            s_l = s.lower()
            if direction and isinstance(direction, str):
                d = direction.strip().lower()
                if "out" in d:
                    return _OUT_OF_OFFICE_ZONE
                if "in" in d:
                    return "Reception Area"
            if "out" in s_l or "exit" in s_l or ("turnstile" in s_l and "out" in s_l):
                return _OUT_OF_OFFICE_ZONE
            return "Working Area"
        except Exception:
            return None

# --- CONFIG for violation window and risk thresholds ---
VIOLATION_WINDOW_DAYS = 90  # look-back window to count violation days (adjustable)
# risk thresholds (numeric ranges) -> labels
RISK_THRESHOLDS = [
    (0.5, "Low"),
    (1.5, "Low Medium"),
    (2.5, "Medium"),
    (4.0, "Medium High"),
    (float("inf"), "High"),
]

def map_score_to_label(score: float) -> (int, str):
    """
    Map a numeric score to RiskScore (1..5) and RiskLevel label.
    Returns (risk_bucket, label)
    """
    try:
        if score is None:
            score = 0.0
        s = float(score)
    except Exception:
        s = 0.0
    bucket = 1
    label = "Low"
    for i, (threshold, lbl) in enumerate(RISK_THRESHOLDS, start=1):
        if s <= threshold:
            bucket = i
            label = lbl
            break
    return bucket, label

# ---------------- SCENARIOS (boolean functions) ----------------
def scenario_long_gap(row):
    # treat long gap only when gap >= 5 hours
    return (row.get('MaxSwipeGapSeconds') or 0) >= 5 * 3600

def scenario_short_duration(row):
    return (row.get('DurationMinutes') or 0) < 240

def scenario_coffee_badging(row):
    return (row.get('CountSwipes') or 0) >= 4 and (row.get('DurationMinutes') or 0) < 60

def scenario_low_swipe_count(row):
    return 0 < (row.get('CountSwipes') or 0) <= 2

def scenario_single_door(row):
    return (row.get('UniqueDoors') or 0) <= 1

def scenario_only_in(row):
    return int(row.get('OnlyIn', 0)) == 1

def scenario_only_out(row):
    return int(row.get('OnlyOut', 0)) == 1

def scenario_overtime(row):
    return (row.get('DurationMinutes') or 0) >= 10 * 60

def scenario_very_long_duration(row):
    return (row.get('DurationMinutes') or 0) >= 16 * 60

def scenario_zero_swipes(row):
    return int(row.get('CountSwipes', 0)) == 0

def scenario_unusually_high_swipes(row):
    cur = row.get('CountSwipes') or 0
    empid = row.get('EmployeeID')
    try:
        if not HIST_DF.empty and empid is not None and empid in HIST_DF['EmployeeID'].values:
            rec = HIST_DF[HIST_DF['EmployeeID'] == empid].iloc[0]
            median = float(rec.get('TotalSwipes_median', np.nan))
            if np.isfinite(median) and median > 0:
                return cur > 3 * median
    except Exception:
        pass
    if not HIST_DF.empty and 'TotalSwipes_median' in HIST_DF.columns:
        global_med = HIST_DF['TotalSwipes_median'].median()
        if pd.notna(global_med) and global_med > 0:
            return cur > 3 * global_med
    return cur > 50

def scenario_repeated_short_breaks(row):
    return (row.get('ShortGapCount') or 0) >= 3

def scenario_multiple_location_same_day(row):
    return (row.get('UniqueLocations') or 0) > 1

def scenario_weekend_activity(row):
    try:
        d = pd.to_datetime(row['Date'])
        return d.weekday() >= 5
    except Exception:
        return False

def scenario_repeated_rejection_count(row):
    return (row.get('RejectionCount') or 0) >= 2

def scenario_badge_sharing_suspected(row, badge_map=None):
    card = row.get('CardNumber')
    d = row.get('Date')
    if card is None or pd.isna(card) or d is None:
        return False
    if badge_map is None:
        return False
    return badge_map.get((d, card), 0) > 1

def scenario_early_arrival_before_06(row):
    fs = row.get('FirstSwipe')
    if pd.isna(fs) or fs is None:
        return False
    try:
        t = pd.to_datetime(fs).time()
        return t < time(hour=6)
    except Exception:
        return False

def scenario_late_exit_after_22(row):
    ls = row.get('LastSwipe')
    if pd.isna(ls) or ls is None:
        return False
    try:
        t = pd.to_datetime(ls).time()
        return t >= time(hour=22)
    except Exception:
        return False

def scenario_shift_inconsistency(row):
    empid = row.get('EmployeeID')
    dur = row.get('DurationMinutes') or 0
    if HIST_DF is not None and not HIST_DF.empty and empid in HIST_DF['EmployeeID'].values:
        rec = HIST_DF[HIST_DF['EmployeeID'] == empid].iloc[0]
        med = rec.get('AvgDurationMins_median', np.nan)
        std = rec.get('AvgDurationMins_std', np.nan)
        if pd.notna(med) and pd.notna(std):
            return (dur < med - 2.5 * std) or (dur > med + 2.5 * std)
    return False

def scenario_trending_decline(row):
    empid = row.get('EmployeeID')
    if HIST_DF is None or HIST_DF.empty:
        return False
    if 'TrendingDecline' in HIST_DF.columns:
        rec = HIST_DF[HIST_DF['EmployeeID'] == empid]
        if not rec.empty:
            val = rec.iloc[0].get('TrendingDecline')
            return str(val).strip().lower() == 'yes' if pd.notna(val) else False
    return False

def scenario_consecutive_absent_days(row):
    if row.get('CountSwipes') == 0:
        empid = row.get('EmployeeID')
        if HIST_DF is not None and not HIST_DF.empty and 'ConsecAbsent3Plus' in HIST_DF.columns:
            rec = HIST_DF[HIST_DF['EmployeeID'] == empid]
            if not rec.empty:
                v = rec.iloc[0].get('ConsecAbsent3Plus')
                return str(v).strip().lower() in ('yes', 'true', '1')
        return False
    return False

def scenario_high_variance_duration(row):
    empid = row.get('EmployeeID')
    if HIST_DF is not None and not HIST_DF.empty and empid in HIST_DF['EmployeeID'].values:
        rec = HIST_DF[HIST_DF['EmployeeID'] == empid].iloc[0]
        med = rec.get('AvgDurationMins_median', np.nan)
        std = rec.get('AvgDurationMins_std', np.nan)
        if pd.notna(med) and pd.notna(std) and med > 0:
            return (std / med) > 1.0
    return False

def scenario_short_duration_on_high_presence_days(row):
    days_present = row.get('DaysPresentInWeek') or 0
    dur = row.get('DurationMinutes') or 0
    return (days_present >= 4) and (dur < 240)

def scenario_swipe_overlap(row, swipe_overlap_map=None):
    d = row.get('Date')
    uid = row.get('person_uid')
    if swipe_overlap_map is None or d is None or uid is None:
        return False
    return (d, uid) in swipe_overlap_map

# NEW scenario: the pattern described by the user
def scenario_shortstay_longout_repeat(row):
    # Uses the feature computed in compute_features: PatternShortLongRepeat
    return bool(row.get('PatternShortLongRepeat', False))


# scenario list (name, fn)
SCENARIOS = [
    ("long_gap_>=90min", scenario_long_gap),
    ("short_duration_<4h", scenario_short_duration),
    ("coffee_badging", scenario_coffee_badging),
    ("low_swipe_count_<=2", scenario_low_swipe_count),
    ("single_door", scenario_single_door),
    ("only_in", scenario_only_in),
    ("only_out", scenario_only_out),
    ("overtime_>=10h", scenario_overtime),
    ("very_long_duration_>=16h", scenario_very_long_duration),
    ("zero_swipes", scenario_zero_swipes),
    ("unusually_high_swipes", scenario_unusually_high_swipes),
    ("repeated_short_breaks", scenario_repeated_short_breaks),
    ("multiple_location_same_day", scenario_multiple_location_same_day),
    ("weekend_activity", scenario_weekend_activity),
    ("repeated_rejection_count", scenario_repeated_rejection_count),
    ("badge_sharing_suspected", scenario_badge_sharing_suspected),
    ("early_arrival_before_06", scenario_early_arrival_before_06),
    ("late_exit_after_22", scenario_late_exit_after_22),
    ("shift_inconsistency", scenario_shift_inconsistency),
    ("trending_decline", scenario_trending_decline),
    ("consecutive_absent_days", scenario_consecutive_absent_days),
    ("high_variance_duration", scenario_high_variance_duration),
    ("short_duration_on_high_presence_days", scenario_short_duration_on_high_presence_days),
    ("swipe_overlap", scenario_swipe_overlap),
    # new pattern scenario
    ("shortstay_longout_repeat", scenario_shortstay_longout_repeat)
]

# --- Human readable explanations per scenario (short and neutral) ---
def _fmt_minutes(seconds):
    try:
        m = int(round((seconds or 0) / 60.0))
        return f"{m} min" if m < 60 else f"{m//60} hr {m%60} min"
    except Exception:
        return None

SCENARIO_EXPLANATIONS = {
    "long_gap_>=90min": lambda r: f"Long gap between swipes (~{_fmt_minutes(r.get('MaxSwipeGapSeconds'))}). This may indicate an extended out-of-office absence.",
    "short_duration_<4h": lambda r: f"Short total presence ({int(round(r.get('DurationMinutes',0)))} min) — less than 4 hours; may indicate short stay or partial-day attendance.",
    "coffee_badging": lambda r: "Multiple quick swipes in short time (possible 'coffee' or proxy badge use).",
    "low_swipe_count_<=2": lambda r: "Very few swipes on day — unusually low activity.",
    "single_door": lambda r: "Only a single door used during the day — possible badge-sharing or single-entry behavior.",
    "only_in": lambda r: "Only 'IN' events recorded without corresponding 'OUT'.",
    "only_out": lambda r: "Only 'OUT' events recorded without prior 'IN'.",
    "overtime_>=10h": lambda r: "Overtime detected (>=10 hours).",
    "very_long_duration_>=16h": lambda r: "Very long presence (>=16 hours).",
    "zero_swipes": lambda r: "No swipes recorded on this day.",
    "unusually_high_swipes": lambda r: "Unusually high number of swipes compared to peers/history.",
    "repeated_short_breaks": lambda r: "Many short gaps between swipes — repeated short breaks pattern.",
    "multiple_location_same_day": lambda r: "Multiple locations/partitions used in same day.",
    "weekend_activity": lambda r: "Activity recorded on weekend day.",
    "repeated_rejection_count": lambda r: "Multiple rejection events recorded.",
    "badge_sharing_suspected": lambda r: "Same card used by multiple users on same day — possible badge sharing.",
    "early_arrival_before_06": lambda r: "First swipe earlier than 06:00.",
    "late_exit_after_22": lambda r: f"Last swipe after 22:00 ({(pd.to_datetime(r.get('LastSwipe')).time() if pd.notna(r.get('LastSwipe')) else 'time unknown')}).",
    "shift_inconsistency": lambda r: "Duration deviates from historical shift patterns.",
    "trending_decline": lambda r: "Employee shows trending decline in presence.",
    "consecutive_absent_days": lambda r: "Consecutive absent days observed historically.",
    "high_variance_duration": lambda r: "High variance in daily durations historically.",
    "short_duration_on_high_presence_days": lambda r: "Short duration despite normally high presence days.",
    "swipe_overlap": lambda r: "Overlap in swipe times with other persons on same door — suspicious co-located events.",
    "shortstay_longout_repeat": lambda r: "Repeated pattern: short in → long out-of-office → short return — may indicate leaving site for extended period between brief visits."
}

def _explain_scenarios_detected(row, detected_list):
    pieces = []
    name = row.get('EmployeeName') or row.get('EmployeeID') or row.get('person_uid') or "Employee"
    prefix = f"{name} - "
    for sc in detected_list:
        sc = sc.strip()
        fn = SCENARIO_EXPLANATIONS.get(sc)
        try:
            if fn:
                # let each lambda produce a sentence
                pieces.append(fn(row))
            else:
                pieces.append(sc.replace("_", " ").replace(">=", "≥"))
        except Exception:
            pieces.append(sc)
    if not pieces:
        return None
    # Join as sentences for clarity.
    explanation = " ".join([p if p.endswith('.') else p + '.' for p in pieces])
    return prefix + " " + explanation

# --- compute_features (replaced/updated) ---
def compute_features(swipes: pd.DataFrame, durations: pd.DataFrame) -> pd.DataFrame:
    """
    Compute per person-per-date features used by scenarios.
    Returns DataFrame per (person_uid, Date) with feature columns and normalized IDs/names.
    """
    if swipes is None or swipes.empty:
        return pd.DataFrame()

    sw = swipes.copy()

    # Build lowercase->actual column map for flexible column detection
    cols_lower = {c.lower(): c for c in sw.columns}

    # detect time column
    time_candidates = ['localemessagetime', 'messagetime', 'timestamp', 'time', 'localemessagetimestamp']
    found_time_col = next((cols_lower[c] for c in time_candidates if c in cols_lower), None)
    if found_time_col:
        sw['LocaleMessageTime'] = pd.to_datetime(sw[found_time_col], errors='coerce')
        sw['Date'] = sw['LocaleMessageTime'].dt.date
    else:
        if 'Date' in sw.columns:
            sw['Date'] = pd.to_datetime(sw['Date'], errors='coerce').dt.date
        else:
            sw['Date'] = None

    # find these earlier in compute_features — prefer Int1/Text12 for EmployeeID and CHUID/Card for CardNumber
    name_candidates = ['employeename', 'objectname1', 'objectname', 'employee_name', 'name', 'object_name']
    employeeid_candidates = ['int1', 'text12', 'employeeid', 'employee_id', 'empid', 'id']
    card_candidates = ['cardnumber', 'chuid', 'card', 'card_no', 'cardnum', 'value']
    door_candidates = ['door', 'doorname', 'door_name']
    direction_candidates = ['direction', 'directionname', 'direction_name']

    name_col = next((cols_lower[c] for c in name_candidates if c in cols_lower), None)
    empid_col = next((cols_lower[c] for c in employeeid_candidates if c in cols_lower), None)
    card_col = next((cols_lower[c] for c in card_candidates if c in cols_lower), None)
    door_col = next((cols_lower[c] for c in door_candidates if c in cols_lower), None)
    dir_col = next((cols_lower[c] for c in direction_candidates if c in cols_lower), None)

    # Filter personnel types: prefer PersonnelTypeName, fallback to PersonnelType
    if 'PersonnelTypeName' in sw.columns:
        sw = sw[sw['PersonnelTypeName'].isin(['Employee', 'Terminated Personnel'])]
    elif 'PersonnelType' in sw.columns:
        sw = sw[sw['PersonnelType'].isin(['Employee', 'Terminated Personnel'])]
    # else keep everything

    if sw.empty:
        logging.info("compute_features: no rows after PersonnelType filter")
        return pd.DataFrame()

    # ensure stable person_uid (canonical)
    if 'person_uid' not in sw.columns:
        def make_person_uid_local(r):
            # prefer canonical EmployeeID (normalized, non-GUID) then EmployeeIdentity then EmployeeName
            empid_val = None
            if empid_col and empid_col in r and pd.notna(r.get(empid_col)):
                empid_val = r.get(empid_col)
            elif 'EmployeeID' in r and pd.notna(r.get('EmployeeID')):
                empid_val = r.get('EmployeeID')

            empident_val = r.get('EmployeeIdentity') if 'EmployeeIdentity' in r else None
            name_val = None
            if name_col and name_col in r:
                name_val = r.get(name_col)
            elif 'EmployeeName' in r:
                name_val = r.get('EmployeeName')
            elif 'ObjectName1' in r:
                name_val = r.get('ObjectName1')

            return _canonical_person_uid({
                'EmployeeID': empid_val,
                'EmployeeIdentity': empident_val,
                'EmployeeName': name_val
            })
        sw['person_uid'] = sw.apply(make_person_uid_local, axis=1)

    # selection columns for aggregation: include discovered columns
    sel_cols = set(['LocaleMessageTime', 'Direction', 'Door', 'PartitionName2', 'Rejection_Type',
                    'CardNumber', 'EmployeeID', 'EmployeeName', 'ObjectName1', 'PersonnelType', 'PersonnelTypeName',
                    'EmployeeIdentity'])
    if name_col:
        sel_cols.add(name_col)
    if empid_col:
        sel_cols.add(empid_col)
    if card_col:
        sel_cols.add(card_col)
    if door_col:
        sel_cols.add(door_col)
    if dir_col:
        sel_cols.add(dir_col)
    sel_cols = [c for c in sel_cols if c in sw.columns]

    def agg_swipe_group(g):
        # g is a DataFrame for one person_uid + date
        times = sorted(g['LocaleMessageTime'].dropna().tolist()) if 'LocaleMessageTime' in g else []
        gaps = []
        short_gap_count = 0
        for i in range(1, len(times)):
            s = (times[i] - times[i-1]).total_seconds()
            gaps.append(s)
            if s <= 5*60:
                short_gap_count += 1
        max_gap = int(max(gaps)) if gaps else 0

        # Direction counts (default to column names present)
        in_count = int((g['Direction'] == 'InDirection').sum()) if 'Direction' in g.columns else 0
        out_count = int((g['Direction'] == 'OutDirection').sum()) if 'Direction' in g.columns else 0
        unique_doors = int(g['Door'].nunique()) if 'Door' in g.columns else 0
        unique_locations = int(g['PartitionName2'].nunique()) if 'PartitionName2' in g.columns else 0
        rejection_count = int(g['Rejection_Type'].notna().sum()) if 'Rejection_Type' in g.columns else 0

        # pick first non-placeholder, non-guid card number if present (prefer cardnumber/chuid)
        card_numbers = []
        # 1) direct known column
        if card_col and card_col in g.columns:
            card_numbers = list(pd.unique(g[card_col].dropna()))
        # 2) explicit 'CardNumber' output column (from SQL COALESCE)
        if not card_numbers and 'CardNumber' in g.columns:
            card_numbers = list(pd.unique(g['CardNumber'].dropna()))
        # 3) some XML-shred columns may appear as 'value' or other column names
        if not card_numbers:
            for c in g.columns:
                cl = c.lower()
                if 'value' == cl or 'xml' in cl or 'msg' in cl or 'shred' in cl:
                    try:
                        vals = list(pd.unique(g[c].dropna()))
                        if vals:
                            card_numbers.extend(vals)
                    except Exception:
                        continue
        # 4) lastly try to extract from XmlMessage fields
        if not card_numbers:
            for c in g.columns:
                cl = c.lower()
                if 'xml' in cl or 'xmlmessage' in cl or 'xml_msg' in cl or 'xmlmessage' in cl:
                    for raw in g[c].dropna().astype(str):
                        extracted = _extract_card_from_xml(raw)
                        if extracted:
                            card_numbers.append(extracted)
        # 5) final unique
        card_numbers = list(dict.fromkeys(card_numbers))  # preserve order, unique

        card_number = None
        for c in card_numbers:
            n = _normalize_id_val(c)
            # explicitly reject GUIDs as card numbers
            if n and not _looks_like_guid(n):
                card_number = n
                break

        # stable id/name from the group using discovered columns first
        employee_id = None
        employee_name = None
        employee_identity = None
        personnel_type = None

        # Employee ID: prefer Int1/Text12 then EmployeeID; DO NOT use EmployeeIdentity as EmployeeID
        # use _pick_first_non_guid_value to skip GUIDs automatically
        if empid_col and empid_col in g.columns:
            vals = g[empid_col].dropna().astype(str).map(lambda x: x.strip())
            employee_id = _pick_first_non_guid_value(vals)
            if employee_id is None and not vals.empty:
                # final trial: numeric normalization (strip .0) but still reject GUIDs
                v0 = vals.iloc[0]
                normalized = _normalize_id_val(v0)
                if normalized and not _looks_like_guid(normalized):
                    employee_id = normalized
        elif 'EmployeeID' in g.columns:
            vals = g['EmployeeID'].dropna().astype(str).map(lambda x: x.strip())
            employee_id = _pick_first_non_guid_value(vals)
            if employee_id is None and not vals.empty:
                v0 = vals.iloc[0]
                normalized = _normalize_id_val(v0)
                if normalized and not _looks_like_guid(normalized):
                    employee_id = normalized

        # If still no employee_id and PersonnelType indicates contractor -> prefer Text12 explicitly
        if (not employee_id) and 'PersonnelType' in g.columns:
            try:
                pvals = g['PersonnelType'].dropna().astype(str)
                if not pvals.empty:
                    p0 = pvals.iloc[0]
                    if str(p0).strip().lower() in ('contractor', 'terminated contractor', 'contractor '):
                        # look for text12 explicitly (case-insensitive)
                        for c in g.columns:
                            if c.lower() == 'text12':
                                vals = g[c].dropna().astype(str).map(lambda x: x.strip())
                                employee_id = _pick_first_non_guid_value(vals)
                                if employee_id:
                                    break
            except Exception:
                pass

        # Employee identity (GUID) — keep but do not promote to EmployeeID
        if 'EmployeeIdentity' in g.columns:
            vals = g['EmployeeIdentity'].dropna().astype(str).map(lambda x: x.strip())
            if not vals.empty:
                employee_identity = vals.iloc[0]

        # Employee name: pick non-GUID candidate
        candidate_name_vals = None
        if name_col and name_col in g.columns:
            candidate_name_vals = g[name_col].dropna().astype(str).map(lambda x: x.strip())
        elif 'EmployeeName' in g.columns:
            candidate_name_vals = g['EmployeeName'].dropna().astype(str).map(lambda x: x.strip())
        elif 'ObjectName1' in g.columns:
            candidate_name_vals = g['ObjectName1'].dropna().astype(str).map(lambda x: x.strip())

        if candidate_name_vals is not None and not candidate_name_vals.empty:
            employee_name = _pick_first_non_guid_value(candidate_name_vals)
            if employee_name is None:
                # accept any value that looks like a name
                for v in candidate_name_vals:
                    if _looks_like_name(v) and not _is_placeholder_str(v):
                        employee_name = str(v).strip()
                        break

        # personnel type
        if 'PersonnelTypeName' in g.columns:
            vals = g['PersonnelTypeName'].dropna()
            if not vals.empty:
                personnel_type = vals.iloc[0]
        elif 'PersonnelType' in g.columns:
            vals = g['PersonnelType'].dropna()
            if not vals.empty:
                personnel_type = vals.iloc[0]

        # First/Last swipe times
        first_swipe = None
        last_swipe = None
        if times:
            first_swipe = times[0]
            last_swipe = times[-1]

        # ----------------- NEW: break/out-of-office sequence analysis -----------------
        # Build a timeline of (time, door, direction, zone)
        timeline = []
        for _, row in g.sort_values('LocaleMessageTime').iterrows():
            t = row.get('LocaleMessageTime')
            dname = None
            if door_col and door_col in row and pd.notna(row.get(door_col)):
                dname = row.get(door_col)
            elif 'Door' in row and pd.notna(row.get('Door')):
                dname = row.get('Door')
            direction = None
            if dir_col and dir_col in row and pd.notna(row.get(dir_col)):
                direction = row.get(dir_col)
            elif 'Direction' in row and pd.notna(row.get('Direction')):
                direction = row.get('Direction')
            zone = map_door_to_zone(dname, direction)
            timeline.append((t, dname, direction, zone))

        # compress timeline into segments with labels: 'work', 'break', 'out_of_office'
        segments = []
        if timeline:
            cur_zone = None
            seg_start = timeline[0][0]
            seg_label = None
            for (t, dname, direction, zone) in timeline:
                # determine label
                if zone in _BREAK_ZONES:
                    lbl = 'break'
                elif zone == _OUT_OF_OFFICE_ZONE:
                    lbl = 'out_of_office'
                else:
                    lbl = 'work'
                if cur_zone is None:
                    cur_zone = zone
                    seg_label = lbl
                    seg_start = t
                else:
                    # if label changes, close previous segment
                    if lbl != seg_label:
                        segments.append({
                            'label': seg_label,
                            'start': seg_start,
                            'end': t,
                            'start_zone': cur_zone
                        })
                        seg_start = t
                        seg_label = lbl
                        cur_zone = zone
                    else:
                        # keep current segment (extend)
                        cur_zone = cur_zone or zone
            # close last
            if seg_label is not None:
                segments.append({
                    'label': seg_label,
                    'start': seg_start,
                    'end': timeline[-1][0],
                    'start_zone': cur_zone
                })

        # Compute break metrics: only count "real" breaks (and only if long enough)
        break_count = 0
        long_break_count = 0
        total_break_minutes = 0.0

        # thresholds (minutes)
        # Updated: count break segments only if >= 1 hour (60 min)
        BREAK_MINUTES_THRESHOLD = 60    # user: now treat breaks >= 1 hour as real break
        # Updated: long break flag used for 'shortstay_longout_repeat' pattern:
        # use ~170 minutes (2:50) to avoid flagging shorter OOO segments inadvertently.
        LONG_BREAK_FLAG_MINUTES = 170    # for special pattern / long-break flag (~2:50 hours)

        for i, s in enumerate(segments):
            lbl = s.get('label')
            start = s.get('start')
            end = s.get('end')
            dur_mins = ((end - start).total_seconds() / 60.0) if (start and end) else 0.0

            if lbl == 'break':
                # only count break segments that are actually long enough (>= BREAK_MINUTES_THRESHOLD)
                if dur_mins >= BREAK_MINUTES_THRESHOLD:
                    break_count += 1
                    total_break_minutes += dur_mins
                    if dur_mins >= LONG_BREAK_FLAG_MINUTES:
                        long_break_count += 1

            elif lbl == 'out_of_office':
                # for out_of_office: require it's a real long out between work segments
                prev_lbl = segments[i-1]['label'] if i > 0 else None
                next_lbl = segments[i+1]['label'] if i < len(segments)-1 else None
                # Only treat as break if it's between work segments and long enough
                if prev_lbl == 'work' and next_lbl == 'work' and dur_mins >= BREAK_MINUTES_THRESHOLD:
                    break_count += 1
                    total_break_minutes += dur_mins
                    if dur_mins >= LONG_BREAK_FLAG_MINUTES:
                        long_break_count += 1

        # Detect the specific pattern:
        pattern_flag = False
        pattern_sequence_readable = None
        try:
            # create simplified label list with durations
            seq = []
            for s in segments:
                dur_mins = (s['end'] - s['start']).total_seconds() / 60.0 if (s['end'] and s['start']) else 0
                seq.append((s['label'], int(round(dur_mins))))
            # look for the pattern anywhere in sequence (triplet: short work -> long out -> short work)
            for i in range(len(seq)-2):
                a = seq[i]     # first work
                b = seq[i+1]   # long out
                c = seq[i+2]   # short work
                # short work: < 60 min; long out: >= LONG_BREAK_FLAG_MINUTES; short return: < 60 min
                if a[0] == 'work' and a[1] < 60 and \
                   b[0] in ('out_of_office','break') and b[1] >= LONG_BREAK_FLAG_MINUTES and \
                   c[0] == 'work' and c[1] < 60:
                    pattern_flag = True
                    # build readable snippet for the 3-segment window
                    seq_fragment = [a, b, c]
                    pattern_sequence_readable = " -> ".join([f"{lbl} ({mins}m)" for lbl, mins in seq_fragment])
                    break
        except Exception:
            pattern_flag = False
            pattern_sequence_readable = None



            

        # ----------------- return aggregated metrics (including new ones) -----------------
        return pd.Series({
            'CountSwipes': int(len(g)),
            'MaxSwipeGapSeconds': max_gap,
            'ShortGapCount': int(short_gap_count),
            'InCount': in_count,
            'OutCount': out_count,
            'UniqueDoors': unique_doors,
            'UniqueLocations': unique_locations,
            'RejectionCount': rejection_count,
            'CardNumber': card_number,
            'EmployeeID': employee_id,
            'EmployeeIdentity': employee_identity,
            'EmployeeName': employee_name,
            'PersonnelType': personnel_type,
            'FirstSwipe': first_swipe,
            'LastSwipe': last_swipe,
            # new break features
            'BreakCount': int(break_count),
            'LongBreakCount': int(long_break_count),
            'TotalBreakMinutes': float(round(total_break_minutes,1)),
            'PatternShortLongRepeat': bool(pattern_flag),
            'PatternSequenceReadable': pattern_sequence_readable,
            'PatternSequence': None  # keep old field empty for compatibility
        })

    grouped = sw[['person_uid', 'Date'] + sel_cols].groupby(['person_uid', 'Date'])
    grouped = grouped.apply(agg_swipe_group).reset_index()

    dur = pd.DataFrame() if durations is None else durations.copy()
    if not dur.empty and 'Date' in dur.columns:
        dur['Date'] = pd.to_datetime(dur['Date'], errors='coerce').dt.date

    merged = pd.merge(grouped, dur, how='left', on=['person_uid', 'Date'])

    # --- START PATCH: coalesce duplicate columns produced by merge ---
    def _coalesce_merge_columns(df, bases):
        for base in bases:
            x = base + "_x"
            y = base + "_y"
            try:
                has_base = base in df.columns
                base_all_null = False
                if has_base:
                    base_all_null = df[base].isnull().all()
            except Exception:
                has_base = base in df.columns
                base_all_null = True

            if (not has_base) or base_all_null:
                if x in df.columns and y in df.columns:
                    try:
                        df[base] = df[x].combine_first(df[y])
                    except Exception:
                        try:
                            df[base] = df[x].where(df[x].notna(), df[y] if y in df.columns else None)
                        except Exception:
                            if x in df.columns:
                                df[base] = df[x]
                            elif y in df.columns:
                                df[base] = df[y]
                elif x in df.columns:
                    df[base] = df[x]
                elif y in df.columns:
                    df[base] = df[y]
    _coalesce_merge_columns(merged, [
        "EmployeeID", "Int1", "Text12", "CardNumber", "EmployeeName", "EmployeeIdentity"
    ])
    drop_cols = [c for c in merged.columns if c.endswith("_x") or c.endswith("_y")]
    if drop_cols:
        try:
            merged.drop(columns=drop_cols, inplace=True)
        except Exception:
            for c in drop_cols:
                if c in merged.columns:
                    try:
                        merged.drop(columns=[c], inplace=True)
                    except Exception:
                        pass
    # --- END PATCH ---

    # coalesce helpers (ensure column existence)
    def ensure_col(df, col, default=None):
        if col not in df.columns:
            df[col] = default

    ensure_col(merged, 'DurationSeconds', 0)
    ensure_col(merged, 'FirstSwipe', pd.NaT)
    ensure_col(merged, 'LastSwipe', pd.NaT)
    ensure_col(merged, 'CountSwipes', 0)
    ensure_col(merged, 'MaxSwipeGapSeconds', 0)
    ensure_col(merged, 'ShortGapCount', 0)
    ensure_col(merged, 'RejectionCount', 0)
    ensure_col(merged, 'UniqueLocations', 0)
    ensure_col(merged, 'UniqueDoors', 0)
    ensure_col(merged, 'CardNumber', None)
    ensure_col(merged, 'EmployeeID', None)
    ensure_col(merged, 'EmployeeName', None)
    ensure_col(merged, 'EmployeeIdentity', None)
    ensure_col(merged, 'PersonnelType', None)
    ensure_col(merged, 'BreakCount', 0)
    ensure_col(merged, 'LongBreakCount', 0)
    ensure_col(merged, 'TotalBreakMinutes', 0.0)
    ensure_col(merged, 'PatternShortLongRepeat', False)
    ensure_col(merged, 'PatternSequenceReadable', None)
    ensure_col(merged, 'PatternSequence', None)

    # If EmployeeName is missing or a GUID, try to get a better name from durations (durations typically has EmployeeName)
    if 'EmployeeName' in merged.columns:
        def choose_best_name(row):
            gname = row.get('EmployeeName')
            dname = None
            for cand in ('EmployeeName', 'employee_name', 'objectname1', 'ObjectName1'):
                if cand in row and row.get(cand) is not None:
                    dname = row.get(cand)
                    break
            if _looks_like_name(gname):
                return str(gname).strip()
            if _looks_like_name(dname):
                return str(dname).strip()
            if gname and not _looks_like_guid(gname) and not _is_placeholder_str(gname):
                return str(gname).strip()
            if dname and not _is_placeholder_str(dname):
                return str(dname).strip()
            return None
        merged['EmployeeName'] = merged.apply(choose_best_name, axis=1)
    else:
        if not dur.empty:
            def fill_name_from_dur(row):
                gname = row.get('EmployeeName')
                if _looks_like_name(gname) and not _is_placeholder_str(gname):
                    return gname
                for cand in ('EmployeeName', 'EmployeeName_y', 'EmployeeName_x'):
                    if cand in row and _looks_like_name(row[cand]) and not _is_placeholder_str(row[cand]):
                        return row[cand]
                return None
            merged['EmployeeName'] = merged.apply(fill_name_from_dur, axis=1)

    # numeric normalization for EmployeeID: ensure not GUIDs/placeholder, convert floats like '320172.0' -> '320172'
    def normalize_empid(v):
        if v is None:
            return None
        try:
            s = str(v).strip()
            if s == '' or s.lower() == 'nan' or _is_placeholder_str(s):
                return None
            if _looks_like_guid(s):
                return None
            try:
                if '.' in s:
                    f = float(s)
                    if math.isfinite(f) and f.is_integer():
                        return str(int(f))
            except Exception:
                pass
            return s
        except Exception:
            return None

    merged['EmployeeID'] = merged['EmployeeID'].apply(normalize_empid)

    # normalize card numbers: reject GUIDs and placeholder tokens
    def normalize_card(v):
        if v is None:
            return None
        try:
            s = str(v).strip()
            if s == '' or s.lower() == 'nan' or _is_placeholder_str(s):
                return None
            if _looks_like_guid(s):
                return None
            return s
        except Exception:
            return None

    merged['CardNumber'] = merged['CardNumber'].apply(normalize_card)

    # numeric normalization
    # If durations DataFrame provided DurationSeconds, use that; else fall back to computed (LastSwipe-FirstSwipe)
    if 'DurationSeconds' not in merged.columns or merged['DurationSeconds'].isnull().all():
        try:
            merged['DurationSeconds'] = (pd.to_datetime(merged['LastSwipe']) - pd.to_datetime(merged['FirstSwipe'])).dt.total_seconds().clip(lower=0).fillna(0)
        except Exception:
            merged['DurationSeconds'] = merged.get('DurationSeconds', 0)

    merged['DurationSeconds'] = pd.to_numeric(merged['DurationSeconds'], errors='coerce').fillna(0).astype(float)
    merged['DurationMinutes'] = (merged['DurationSeconds'] / 60.0).astype(float)
    merged['CountSwipes'] = merged['CountSwipes'].fillna(0).astype(int)
    merged['MaxSwipeGapSeconds'] = merged['MaxSwipeGapSeconds'].fillna(0).astype(int)
    merged['ShortGapCount'] = merged['ShortGapCount'].fillna(0).astype(int)
    merged['RejectionCount'] = merged['RejectionCount'].fillna(0).astype(int)
    merged['UniqueLocations'] = merged['UniqueLocations'].fillna(0).astype(int)
    merged['UniqueDoors'] = merged['UniqueDoors'].fillna(0).astype(int)
    merged['BreakCount'] = merged['BreakCount'].fillna(0).astype(int)
    merged['LongBreakCount'] = merged['LongBreakCount'].fillna(0).astype(int)
    merged['TotalBreakMinutes'] = merged['TotalBreakMinutes'].fillna(0.0).astype(float)
    merged['PatternShortLongRepeat'] = merged['PatternShortLongRepeat'].fillna(False).astype(bool)

    # ensure FirstSwipe/LastSwipe are datetimes
    for col in ['FirstSwipe', 'LastSwipe']:
        try:
            merged[col] = pd.to_datetime(merged[col], errors='coerce')
        except Exception:
            merged[col] = pd.NaT

    merged['OnlyIn'] = ((merged.get('InCount', 0) > 0) & (merged.get('OutCount', 0) == 0)).astype(int)
    merged['OnlyOut'] = ((merged.get('OutCount', 0) > 0) & (merged.get('InCount', 0) == 0)).astype(int)
    merged['SingleDoor'] = (merged.get('UniqueDoors', 0) <= 1).astype(int)

    # EmpHistoryPresent
    hist_map = {}
    if not HIST_DF.empty and 'EmployeeID' in HIST_DF.columns:
        hist_map = HIST_DF.set_index('EmployeeID').to_dict(orient='index')
    merged['EmpHistoryPresent'] = merged['EmployeeID'].apply(lambda x: _normalize_id_val(x) in hist_map if pd.notna(x) else False)

    # normalize string columns for safe downstream use; EmployeeName keep as readable-only
    for c in ['EmployeeID', 'CardNumber', 'EmployeeIdentity', 'PersonnelType']:
        if c in merged.columns:
            def _clean_str_val(v):
                if v is None:
                    return None
                try:
                    s = str(v).strip()
                    if s == '' or s.lower() == 'nan' or _is_placeholder_str(s):
                        return None
                    return s
                except Exception:
                    return None
            merged[c] = merged[c].apply(_clean_str_val)

    # EmployeeName: keep None if empty or GUID/placeholder; otherwise string.
    if 'EmployeeName' in merged.columns:
        merged['EmployeeName'] = merged['EmployeeName'].apply(lambda v: None if (v is None or (isinstance(v, float) and np.isnan(v)) or _looks_like_guid(v) or _is_placeholder_str(v)) else str(v).strip())

    return merged


# ---------------- SCENARIO WEIGHTS (for anomaly scoring) ----------------
WEIGHTS = {
    "long_gap_>=90min": 0.3,
    "short_duration_<4h": 1.0,
    "coffee_badging": 1.0,
    "low_swipe_count_<=2": 0.5,
    "single_door": 0.25,
    "only_in": 0.8,
    "only_out": 0.8,
    "overtime_>=10h": 0.2,
    "very_long_duration_>=16h": 1.5,
    "zero_swipes": 0.4,
    "unusually_high_swipes": 1.5,
    "repeated_short_breaks": 0.5,
    "multiple_location_same_day": 0.6,
    "weekend_activity": 0.6,
    "repeated_rejection_count": 0.8,
    "badge_sharing_suspected": 2.0,
    "early_arrival_before_06": 0.4,
    "late_exit_after_22": 0.4,
    "shift_inconsistency": 1.2,
    "trending_decline": 0.7,
    "consecutive_absent_days": 1.2,
    "high_variance_duration": 0.8,
    "short_duration_on_high_presence_days": 1.1,
    "swipe_overlap": 2.0,
    # weight for new scenario
    "shortstay_longout_repeat": 2.0
}
ANOMALY_THRESHOLD = 1.5


def _read_past_trend_csvs(outdir: str, window_days: int, target_date: date):
    """
    Read existing trend_pune_*.csv in outdir and return a single DataFrame filtered to the
    window (target_date - window_days .. target_date-1).
    """
    p = Path(outdir)
    csvs = sorted(p.glob("trend_pune_*.csv"), reverse=True)
    if not csvs:
        return pd.DataFrame()
    dfs = []
    cutoff = target_date - timedelta(days=window_days)
    for fp in csvs:
        try:
            df = pd.read_csv(fp, parse_dates=['Date'])
            # keep only rows with date in (cutoff .. target_date-1)
            if 'Date' in df.columns:
                try:
                    df['Date'] = pd.to_datetime(df['Date'], errors='coerce').dt.date
                except Exception:
                    pass
                df = df[df['Date'].apply(lambda d: d is not None and d >= cutoff and d < target_date)]
            dfs.append(df)
        except Exception:
            try:
                df = pd.read_csv(fp, dtype=str)
                if 'Date' in df.columns:
                    try:
                        df['Date'] = pd.to_datetime(df['Date'], errors='coerce').dt.date
                        df = df[df['Date'].apply(lambda d: d is not None and d >= cutoff and d < target_date)]
                    except Exception:
                        pass
                dfs.append(df)
            except Exception:
                continue
    if not dfs:
        return pd.DataFrame()
    try:
        out = pd.concat(dfs, ignore_index=True)
        return out
    except Exception:
        return pd.DataFrame()


def compute_violation_days_map(outdir: str, window_days: int, target_date: date):
    """
    Return dict: person_uid -> count of days flagged as IsFlagged True in last window_days (excluding target_date).
    """
    df = _read_past_trend_csvs(outdir, window_days, target_date)
    if df is None or df.empty:
        return {}
    # Normalize person_uid column if present, else fallback to EmployeeID
    if 'person_uid' in df.columns:
        key_col = 'person_uid'
    elif 'EmployeeID' in df.columns:
        key_col = 'EmployeeID'
    else:
        return {}
    # consider IsFlagged column
    if 'IsFlagged' not in df.columns:
        # try to infer by AnomalyScore >= threshold
        if 'AnomalyScore' in df.columns:
            df['IsFlagged'] = df['AnomalyScore'].apply(lambda s: float(s) >= ANOMALY_THRESHOLD if not pd.isna(s) else False)
        else:
            df['IsFlagged'] = False
    # count unique dates per person_uid where IsFlagged
    try:
        df_clean = df[[key_col, 'Date', 'IsFlagged']].dropna(subset=[key_col, 'Date'])
        df_clean = df_clean[df_clean['IsFlagged'] == True]
        grouped = df_clean.groupby(key_col)['Date'].nunique().to_dict()
        return grouped
    except Exception:
        return {}


def run_trend_for_date(target_date: date, outdir: str = "./outputs", city='Pune'):
    logging.info("run_trend_for_date: date=%s (city=%s)", target_date, city)
    results = run_for_date(target_date, regions=['apac'], outdir=outdir, city=city)
    apac = results.get('apac', {})
    swipes = apac.get('swipes', pd.DataFrame())
    durations = apac.get('durations', pd.DataFrame())

    # save raw swipes for evidence (full raw)
    try:
        if swipes is not None and not swipes.empty:
            sw_out = Path(outdir) / f"swipes_{city.lower().replace(' ','_')}_{target_date.strftime('%Y%m%d')}.csv"
            swipes.to_csv(sw_out, index=False)
            logging.info("Saved raw swipes to %s", sw_out)
    except Exception as e:
        logging.warning("Failed to save raw swipes: %s", e)

    # compute features
    features = compute_features(swipes, durations)
    if features.empty:
        logging.warning("run_trend_for_date: no features computed")
        return pd.DataFrame()

    # ===== START FIX: reconcile zero CountSwipes with raw swipe files =====
    try:
        if swipes is not None and not swipes.empty and 'person_uid' in swipes.columns:
            tsw = swipes.copy()
            if 'LocaleMessageTime' in tsw.columns:
                tsw['LocaleMessageTime'] = pd.to_datetime(tsw['LocaleMessageTime'], errors='coerce')
            else:
                for cand in ('MessageUTC','MessageTime','Timestamp','timestamp'):
                    if cand in tsw.columns:
                        tsw['LocaleMessageTime'] = pd.to_datetime(tsw[cand], errors='coerce')
                        break
            if 'Date' not in tsw.columns:
                if 'LocaleMessageTime' in tsw.columns:
                    tsw['Date'] = tsw['LocaleMessageTime'].dt.date
                else:
                    for cand in ('date','Date'):
                        if cand in tsw.columns:
                            try:
                                tsw['Date'] = pd.to_datetime(tsw[cand], errors='coerce').dt.date
                            except Exception:
                                tsw['Date'] = None
                            break

            try:
                grp = tsw.dropna(subset=['person_uid', 'Date']).groupby(['person_uid', 'Date'])
                counts = grp.size().to_dict()
                firsts = grp['LocaleMessageTime'].min().to_dict()
                lasts = grp['LocaleMessageTime'].max().to_dict()
            except Exception:
                counts = {}
                firsts = {}
                lasts = {}

            def _fix_row_by_raw(idx, row):
                key = (row.get('person_uid'), row.get('Date'))
                if key in counts and (row.get('CountSwipes', 0) == 0 or pd.isna(row.get('CountSwipes'))):
                    try:
                        c = int(counts.get(key, 0))
                        features.at[idx, 'CountSwipes'] = c
                        f = firsts.get(key)
                        l = lasts.get(key)
                        if pd.notna(f) and (pd.isna(row.get('FirstSwipe')) or row.get('FirstSwipe') is None):
                            features.at[idx, 'FirstSwipe'] = pd.to_datetime(f)
                        if pd.notna(l) and (pd.isna(row.get('LastSwipe')) or row.get('LastSwipe') is None):
                            features.at[idx, 'LastSwipe'] = pd.to_datetime(l)
                        try:
                            fs = features.at[idx, 'FirstSwipe']
                            ls = features.at[idx, 'LastSwipe']
                            if pd.notna(fs) and pd.notna(ls):
                                dursec = (pd.to_datetime(ls) - pd.to_datetime(fs)).total_seconds()
                                dursec = max(0, dursec)
                                features.at[idx, 'DurationSeconds'] = float(dursec)
                                features.at[idx, 'DurationMinutes'] = float(dursec / 60.0)
                        except Exception:
                            pass
                    except Exception:
                        pass

            for ix, r in features[features['CountSwipes'].fillna(0).astype(int) == 0].iterrows():
                try:
                    _fix_row_by_raw(ix, r)
                except Exception:
                    logging.debug("Failed to reconcile row %s with raw swipes", ix)
    except Exception:
        logging.exception("Error while reconciling aggregated features with raw swipes (zero-swipe fix).")
    # ===== END FIX =====

    # Build badge map and swipe overlap maps for higher-severity scenarios
    badge_map = {}
    if 'CardNumber' in swipes.columns and 'person_uid' in swipes.columns and 'Date' in swipes.columns:
        tmp = swipes[['CardNumber', 'person_uid', 'Date']].dropna(subset=['CardNumber'])
        if not tmp.empty:
            grouped_card = tmp.groupby(['Date', 'CardNumber'])['person_uid'].nunique().reset_index(name='distinct_users')
            badge_map = {(row.Date, row.CardNumber): int(row.distinct_users) for row in grouped_card.itertuples(index=False)}

    swipe_overlap_map = {}
    overlap_window_seconds = 2
    if {'Door', 'LocaleMessageTime', 'person_uid', 'Date'}.issubset(swipes.columns):
        tmp = swipes[['Door', 'LocaleMessageTime', 'person_uid', 'Date']].dropna()
        if not tmp.empty:
            tmp = tmp.sort_values(['Door', 'LocaleMessageTime'])
            for (d, door), g in tmp.groupby(['Date', 'Door']):
                items = list(g[['LocaleMessageTime', 'person_uid']].itertuples(index=False, name=None))
                n = len(items)
                for i in range(n):
                    t_i, uid_i = items[i]
                    j = i+1
                    while j < n and (items[j][0] - t_i).total_seconds() <= overlap_window_seconds:
                        uid_j = items[j][1]
                        if uid_i != uid_j:
                            swipe_overlap_map.setdefault((d, uid_i), set()).add(uid_j)
                            swipe_overlap_map.setdefault((d, uid_j), set()).add(uid_i)
                        j += 1

    # Evaluate scenarios (use weighting to compute anomaly score)
    for name, fn in SCENARIOS:
        if name == "badge_sharing_suspected":
            features[name] = features.apply(lambda r: scenario_badge_sharing_suspected(r, badge_map=badge_map), axis=1)
        elif name == "swipe_overlap":
            features[name] = features.apply(lambda r: scenario_swipe_overlap(r, swipe_overlap_map), axis=1)
        else:
            features[name] = features.apply(lambda r, f=fn: bool(f(r)), axis=1)

    def compute_score(r):
        score = 0.0
        detected = []
        for name, _ in SCENARIOS:
            val = bool(r.get(name))
            w = WEIGHTS.get(name, 0.0)
            if val and w > 0:
                score += float(w)
                detected.append(name)
        return score, detected

    scores = features.apply(lambda r: pd.Series(compute_score(r), index=['AnomalyScore', 'DetectedScenarios']), axis=1)
    features['AnomalyScore'] = scores['AnomalyScore'].astype(float)
    features['DetectedScenarios'] = scores['DetectedScenarios'].apply(lambda x: "; ".join(x) if (isinstance(x, (list, tuple)) and len(x)>0) else None)
    features['IsFlagged'] = features['AnomalyScore'].apply(lambda s: bool(s >= ANOMALY_THRESHOLD))

    def reasons_for_row(r):
        if not bool(r.get('IsFlagged')):
            return None
        ds_raw = r.get('DetectedScenarios')
        if ds_raw:
            ds = [s.strip() for s in ds_raw.split(";") if s and s.strip()]
            # Build natural explanation sentences for the detected scenarios
            explanation = _explain_scenarios_detected(r, ds)
            # Also produce compact reasons list (code-style) in Reasons for backwards compatibility
            reasons_codes = "; ".join(ds) if ds else None
            return reasons_codes, explanation
        return None, None

    # Apply reasons_for_row to populate Reasons (codes) and Explanation (natural text)
    reason_tuples = features.apply(lambda r: pd.Series(reasons_for_row(r), index=['Reasons', 'Explanation']), axis=1)
    features['Reasons'] = reason_tuples['Reasons']
    features['Explanation'] = reason_tuples['Explanation']

    if 'OverlapWith' not in features.columns:
        def overlap_with_fn(r):
            d = r.get('Date')
            uid = r.get('person_uid')
            if (d, uid) in swipe_overlap_map:
                return ";".join(sorted(str(x) for x in swipe_overlap_map[(d, uid)]))
            return None
        features['OverlapWith'] = features.apply(overlap_with_fn, axis=1)

    # compute ViolationDays in past window (person_uid -> count) using existing trend CSVs in outdir
    try:
        violation_map = compute_violation_days_map(outdir, VIOLATION_WINDOW_DAYS, target_date)
        def map_violation_days(r):
            key = r.get('person_uid')
            if key in violation_map:
                return int(violation_map[key])
            # fallback: try EmployeeID
            eid = r.get('EmployeeID')
            if eid in violation_map:
                return int(violation_map[eid])
            return 0
        features['ViolationDaysLast90'] = features.apply(map_violation_days, axis=1)
    except Exception:
        features['ViolationDaysLast90'] = 0

    # compute RiskScore (bucket) and RiskLevel label
    try:
        def map_risk(r):
            score = r.get('AnomalyScore') or 0.0
            bucket, label = map_score_to_label(score)
            return int(bucket), label
        rs = features.apply(lambda r: pd.Series(map_risk(r), index=['RiskScore', 'RiskLevel']), axis=1)
        features['RiskScore'] = rs['RiskScore']
        features['RiskLevel'] = rs['RiskLevel']
    except Exception:
        features['RiskScore'] = 1
        features['RiskLevel'] = 'Low'

    # ---- OVERRIDE: force High risk when ViolationDaysLast90 >= 4 ----
    try:
        features['ViolationDaysLast90'] = features['ViolationDaysLast90'].fillna(0).astype(int)
        high_violation_mask = features['ViolationDaysLast90'] >= 4
        if high_violation_mask.any():
            features.loc[high_violation_mask, 'RiskScore'] = 5
            features.loc[high_violation_mask, 'RiskLevel'] = 'High'
    except Exception:
        pass
    # ---------------------------------------------------------------

    # Remove suffix columns and fix duplicates
    cols_to_drop = [c for c in features.columns if c.endswith("_x") or c.endswith("_y")]
    if cols_to_drop:
        for c in cols_to_drop:
            base = c[:-2]
            if base in features.columns:
                try:
                    features.drop(columns=[c], inplace=True)
                except Exception:
                    pass
            else:
                try:
                    features.rename(columns={c: base}, inplace=True)
                except Exception:
                    pass
    features = features.loc[:, ~features.columns.duplicated()]

    # ensure booleans are native Python (avoid numpy.bool_)
    for col in [name for name, _ in SCENARIOS] + ['IsFlagged']:
        if col in features.columns:
            features[col] = features[col].astype(bool)

    # write CSV with native types
    out_csv = Path(outdir) / f"trend_pune_{target_date.strftime('%Y%m%d')}.csv"
    try:
        write_df = features.copy()
        # FirstSwipe/LastSwipe -> ISO strings
        for dtcol in ('FirstSwipe', 'LastSwipe'):
            if dtcol in write_df.columns:
                write_df[dtcol] = pd.to_datetime(write_df[dtcol], errors='coerce').dt.strftime('%Y-%m-%dT%H:%M:%S')
        # Date -> ISO date
        if 'Date' in write_df.columns:
            try:
                write_df['Date'] = pd.to_datetime(write_df['Date'], errors='coerce').dt.date
                write_df['Date'] = write_df['Date'].apply(lambda d: d.isoformat() if pd.notna(d) else None)
            except Exception:
                pass
        write_df = write_df.where(pd.notnull(write_df), None)
        write_df.to_csv(out_csv, index=False)
        logging.info("run_trend_for_date: wrote %s (rows=%d)", out_csv, len(write_df))
    except Exception as e:
        logging.exception("Failed to write trend CSV: %s", e)

    return features


# ---------------- training dataset builder (restored) ----------------
def build_monthly_training(end_date: date = None, months: int = 3, min_unique_employees: int = 1000,
                           outdir: str = "./outputs", city: str = "Pune"):
    if end_date is None:
        end_date = datetime.now().date()
    logging.info("build_monthly_training: end_date=%s months=%d min_unique=%d", end_date, months, min_unique_employees)
    outdir = Path(outdir)
    month_windows = []
    cur = end_date.replace(day=1)
    for _ in range(months):
        start = cur
        next_month = (cur.replace(day=28) + timedelta(days=4)).replace(day=1)
        last = next_month - timedelta(days=1)
        month_windows.append((start, last))
        cur = (start - timedelta(days=1)).replace(day=1)

    person_month_rows = []
    unique_persons = set()

    for start, last in month_windows:
        d = start
        month_dfs = []
        while d <= last:
            csv_path = outdir / f"trend_pune_{d.strftime('%Y%m%d')}.csv"
            if csv_path.exists():
                try:
                    df = pd.read_csv(csv_path)
                    month_dfs.append(df)
                except Exception:
                    try:
                        df = pd.read_csv(csv_path, dtype=str)
                        month_dfs.append(df)
                    except Exception as e:
                        logging.warning("Failed reading %s: %s", csv_path, e)
            else:
                # generate the daily trend if missing
                logging.info("Monthly builder: trend CSV missing for %s — generating by running run_trend_for_date", d.isoformat())
                try:
                    run_trend_for_date(d, outdir=str(outdir), city=city)
                    # attempt to read after generating
                    if csv_path.exists():
                        try:
                            df = pd.read_csv(csv_path)
                            month_dfs.append(df)
                        except Exception:
                            try:
                                df = pd.read_csv(csv_path, dtype=str)
                                month_dfs.append(df)
                            except Exception as e:
                                logging.warning("Failed reading %s after generation: %s", csv_path, e)
                except Exception as e:
                    logging.warning("Failed to generate trend for %s: %s", d, e)
            d = d + timedelta(days=1)

        if not month_dfs:
            logging.info("No daily trend CSVs found for month %s - %s", start.isoformat(), last.isoformat())
            continue

        month_df = pd.concat(month_dfs, ignore_index=True)
        # ensure person_uid exists
        if 'person_uid' not in month_df.columns:
            def make_person_uid(row):
                parts = []
                for c in ('EmployeeIdentity', 'EmployeeID', 'EmployeeName'):
                    v = row.get(c)
                    if pd.notna(v) and str(v).strip():
                        parts.append(str(v).strip())
                return "|".join(parts) if parts else None
            month_df['person_uid'] = month_df.apply(make_person_uid, axis=1)

        # convert boolean columns to int for aggregation if necessary
        for name, _ in SCENARIOS:
            if name in month_df.columns:
                month_df[name] = month_df[name].astype(int)

        agg_funcs = {
            'CountSwipes': ['median', 'mean', 'sum'],
            'DurationMinutes': ['median', 'mean', 'sum'],
            'MaxSwipeGapSeconds': ['max', 'median'],
            'ShortGapCount': ['sum'],
            'UniqueDoors': ['median'],
            'UniqueLocations': ['median'],
            'RejectionCount': ['sum']
        }
        scenario_cols = [name for name,_ in SCENARIOS if name in month_df.columns]
        group_cols = ['person_uid']
        grp = month_df.groupby(group_cols)

        for person, g in grp:
            row = {}
            row['person_uid'] = person
            row['EmployeeID'] = next((v for v in g.get('EmployeeID', []) if pd.notna(v) and not _is_placeholder_str(v)), None)
            row['EmployeeName'] = next((v for v in g.get('EmployeeName', []) if pd.notna(v) and not _is_placeholder_str(v)), None)
            row['MonthStart'] = start.isoformat()
            row['MonthEnd'] = last.isoformat()
            for col, funcs in agg_funcs.items():
                if col in g.columns:
                    for f in funcs:
                        key = f"{col}_{f}"
                        try:
                            val = getattr(g[col], f)()
                            row[key] = float(val) if pd.notna(val) else None
                        except Exception:
                            row[key] = None
                else:
                    for f in funcs:
                        row[f"{col}_{f}"] = None
            for s in scenario_cols:
                row[f"{s}_days"] = int(g[s].sum())
                row[f"{s}_label"] = int(g[s].sum() > 0)
            row['days_present'] = int(g.shape[0])
            person_month_rows.append(row)
            unique_persons.add(person)

        if len(unique_persons) >= min_unique_employees:
            logging.info("Reached min unique employees=%d, stopping aggregation early", min_unique_employees)
            break

    if not person_month_rows:
        logging.warning("No person-month rows created (no data).")
        return None

    training_df = pd.DataFrame(person_month_rows)
    train_out = outdir / "training_person_month.csv"
    training_df.to_csv(train_out, index=False)
    logging.info("Saved training CSV to %s (rows=%d unique_persons=%d)", train_out, len(training_df), len(unique_persons))
    return train_out


if __name__ == "__main__":
    today = datetime.now().date()
    df = run_trend_for_date(today)
    print("Completed; rows:", len(df) if df is not None else 0)













<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Trend Analysis — Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- React + ReactDOM + Babel (quick prototyping) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- Flatpickr (high-quality calendar) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <!-- ................ -->

  <style>
    /* ---------- Global ---------- */
    :root {
      --wu-yellow: #ffd400;
      --wu-black: #0a0a0a;
      --card-bg: #ffffff;
      --muted: #64748b;
      --accent: #2563eb;
      --panel: #f7fafc;
      --pill-bg: #eef6ff;
      --pill-text: #0b4f7a;
    }

    html,
    body {
      height: 100%;
    }

    body {
      font-family: Inter, Roboto, Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #f6f7fb;
      color: #1f2937;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .container {
      max-width: 1250px;
      margin: 12px auto;
      padding: 0;
    }

    /* ---------- Header (Western Union look) ---------- */
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(90deg, #111 0%, #000 30%);
      color: var(--wu-yellow);
      padding: 12px 16px;
      /* border-radius: 8px 8px 0 0; */
      box-shadow: 0 8px 24px rgba(2, 6, 23, 0.18);
      gap: 12px;
      flex-wrap: wrap;
    }

    .wu-brand {
      display: flex;
      gap: 12px;
      align-items: center;
      min-width: 0;
    }

    .wu-logo {
      width: 54px;
      height: 34px;
      background: var(--wu-yellow);
      color: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      border-radius: 4px;
      box-shadow: inset 0 -2px 0 rgba(0, 0, 0, 0.08);
      font-family: "Helvetica Neue", Arial, sans-serif;
      flex-shrink: 0;
    }

    .title-block {
      line-height: 1;
      min-width: 0;
    }

    .title-block h1 {
      margin: 0;
      font-size: 18px;
      color: var(--wu-yellow);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 260px;
    }

    .title-block p {
      margin: 0;
      color: #e6e6e6;
      font-size: 13px;
    }

    .header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-left: auto;
      flex-wrap: wrap;
    }

    .header-actions .control {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .header-actions .control label {
      color: #e7e7e7;
      font-size: 13px;
      margin-right: 4px;
      white-space: nowrap;
    }

    .date-input {
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: transparent;
      color: #fff;
      min-width: 130px;
    }

    .header-actions button {
      padding: 8px 12px;
      border-radius: 6px;
      border: 0;
      font-weight: 600;
      cursor: pointer;
    }

    .btn-primary {
      background: var(--wu-yellow);
      color: var(--wu-black);
    }

    .btn-ghost {
      background: transparent;
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    /* ---------- Main card area ---------- */
    /* .card-shell {
      background: var(--card-bg);
      padding: 10px 14px 14px 14px;
      border-radius: 0 0 8px 8px;
      box-shadow: 0 6px 18px rgba(16, 24, 40, 0.04);
      margin-top: 4px;
    } */


    /* .card-shell {
  background: var(--card-bg);
  padding: 16px 20px 20px 20px;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(16, 24, 40, 0.08);
  margin-top: 6px;
}

    .cards {
      display: flex;
      gap: 10px;
      margin: 6px 0 10px 0;
      padding: 6px 0;
      align-items: stretch;
    }

    .card {
      flex: 1;
      background: linear-gradient(180deg, #fff, #fbfdff);
      padding: 12px 12px;
      border-radius: 8px;
      text-align: center;
      border: 2px solid rgba(28, 121, 196, 0.904);
      box-shadow: 0 6px 18px rgba(16, 24, 40, 0.04);
      min-width: 120px;
    }

    .card h3 {
      margin: 4px 0;
      font-size: 20px;
      color: #0f172a;
    }

    .card p {
      margin: 0;
      color: var(--muted);
      font-weight: 600;
    } */

    .cards {
      display: flex;
      gap: 16px;
      margin: 8px 0 12px 0;
      padding: 8px 0;
      align-items: stretch;
    }

    .card {
      flex: 1;
      background: linear-gradient(135deg, #ffffff 0%, #f8fbff 100%);
      padding: 20px;
      border-radius: 12px;
      border: 1.5px solid rgba(255, 212, 66, 0.15);
      box-shadow:
        0 4px 12px rgba(16, 24, 40, 0.05),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
      min-width: 200px;
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow:
        0 8px 24px rgba(16, 24, 40, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
      border-color: rgba(255, 212, 66, 0.3);
    }

    .card-content {
      display: flex;
      align-items: center;
      gap: 16px;
      height: 100%;
    }

    .card-icon {
      width: 56px;
      height: 56px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
      flex-shrink: 0;
    }

    .card-icon i {
      font-size: 24px;
    }

    .card-flagged .card-icon {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      box-shadow: 0 4px 12px rgba(245, 87, 108, 0.3);
    }

    .card-rate .card-icon {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      box-shadow: 0 4px 12px rgba(79, 172, 254, 0.3);
    }

    .card-text {
      text-align: left;
      flex: 1;
    }

    .card h3 {
      margin: 0 0 4px 0;
      font-size: 28px;
      font-weight: 700;
      color: #0f172a;
      letter-spacing: -0.5px;
      line-height: 1.2;
    }

    .card p {
      margin: 0;
      color: #64748b;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.2px;
    }

    .card-gradient {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #667eea, #764ba2);
      opacity: 0.8;
      transition: all 0.3s ease;
    }

    .card-flagged .card-gradient {
      background: linear-gradient(90deg, #f093fb, #f5576c);
    }

    .card-rate .card-gradient {
      background: linear-gradient(90deg, #4facfe, #00f2fe);
    }

    .card:hover .card-gradient {
      height: 6px;
      opacity: 1;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .cards {
        flex-direction: column;
        gap: 12px;
      }

      .card {
        min-width: auto;
      }

      .card-content {
        gap: 12px;
      }

      .card-icon {
        width: 48px;
        height: 48px;
      }

      .card-icon i {
        font-size: 20px;
      }

      .card h3 {
        font-size: 24px;
      }
    }

    .main {
      display: flex;
      gap: 14px;
      margin-top: 6px;
      padding-bottom: 18px;
    }

    .left {
      flex: 2;
      background: transparent;
      padding-right: 6px;
    }

    .right {
      flex: 1;
      min-width: 260px;
    }

    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .date-input::-webkit-calendar-picker-indicator {
      display: none;
    }

    /* ---------- Chart ---------- */
    .chart-wrap {
      background: #fff;
      padding: 10px;
      border-radius: 8px;
      box-shadow: inset 0 0 0 1px #f1f5f9;
      height: 260px;
      margin-bottom: 10px;
    }

    /* ---------- Table ---------- */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      background: #fff;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(2, 6, 23, 0.03);
    }

    thead th {
      padding: 10px 8px;
      font-weight: 700;
      font-size: 13px;
      background: linear-gradient(90deg, #fff, #fbfbfb);
      border-bottom: 3px solid #e2e8f0;
      text-align: left;
    }

    tbody td {
      padding: 8px;
      border-bottom: 1px solid #f1f5f9;
      font-size: 13px;
      color: #0f172a;
      vertical-align: middle;
    }

    .small {
      font-size: 12px;
      color: var(--muted);
    }

    .row-click {
      cursor: pointer;
      color: #0f172a;
    }

    .flagged-row {
      background: linear-gradient(90deg, #fff8f0, #fff);
    }









    /* ---------- Chips & reasons ---------- */
    .pill {
      display: inline-block;
      padding: 4px 6px;
      border-radius: 999px;
      background: var(--pill-bg);
      color: var(--pill-text);
      font-size: 11px;
      cursor: pointer;
      margin: 3px 6px 3px 0;
      border: 1px solid rgba(2, 80, 160, 0.06);
      box-shadow: 0 1px 6px rgba(2, 80, 160, 0.03);
    }

    .chip {
      display: inline-block;
      padding: 5px 8px;
      border-radius: 999px;
      background: #eef2ff;
      color: #034f84;
      font-size: 12px;
      cursor: pointer;
      margin: 3px;
      border: 1px solid transparent;
    }

    .chip.active {
      background: #ffd;
      border-color: #f7c948;
      box-shadow: 0 2px 6px rgba(39, 39, 56, 0.06);
    }

    /* 👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇 */
    
/* ---------- Enhanced Evidence Modal Styles ---------- */
.modal {
  position: fixed;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  background: rgba(3, 6, 23, 0.65);
  backdrop-filter: blur(8px);
}

.modal-inner {
  width: 1000px;
  height: 640px;
  max-width: 96%;
  max-height: 92%;
  overflow: hidden;
  background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
  border-radius: 16px;
  padding: 0;
  box-shadow: 
    0 32px 64px rgba(2, 6, 23, 0.4),
    0 0 0 1px rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  display: flex;
  flex-direction: column;
}

/* Enhanced Header */
.modal-header {
  display: flex;
  align-items: center;  
  justify-content: space-between; 
  padding: 8px 12px;
  border-radius: 16px 16px 0 0;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  position: relative;
  overflow: hidden;
}

.modal-header::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
  animation: shimmer 3s infinite;
}

@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.header-content {
  display: flex;
  align-items: center;
  gap: 12px;
}

.header-icon {
  width: 40px;
  height: 40px;
  background: rgba(255, 255, 255, 0.2);
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(10px);
}

.header-icon i {
  font-size: 20px;
}

.header-text h3 {
  margin: 0;
  font-size: 20px;
  font-weight: 700;
  color: white;
}

.header-subtitle {
  margin: 2px 0 0 0;
  font-size: 13px;
  opacity: 0.9;
  font-weight: 500;
}

.close-btn {
  background: rgba(255, 255, 255, 0.2);
  color: white;
  border-radius: 10px;
  padding: 10px 16px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  cursor: pointer;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 6px;
  backdrop-filter: blur(10px);
  transition: all 0.3s ease;
}

.close-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: translateY(-1px);
}

/* Enhanced Modal Body */
.modal-body {
  padding: 10px;
  overflow: auto;
  flex: 1;
  background: #f8fafc;
}

/* Loading State */
.loading-state {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2px;
  padding: 10px;
  color: #64748b;
  font-weight: 600;
}

.loading-spinner {
  width: 20px;
  height: 20px;
  border: 2px solid #e2e8f0;
  border-top: 2px solid #667eea;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Enhanced Top Section */
.modal-top {
  display: grid;
  grid-template-columns: 280px 1fr 360px;
  gap: 5px;
  align-items: start;
  background: white;
  padding: 10px;
  border-radius: 16px;
  box-shadow: 
    0 8px 32px rgba(2, 6, 23, 0.08),
    0 2px 4px rgba(2, 6, 23, 0.02);
  border: 1px solid #f1f5f9;
  margin-bottom: 24px;
}

/* Multi-color Image Border */
.image-section {
  display: flex;
  justify-content: center;
}

.image-container {
  position: relative;
}

.multi-color-border {
  position: relative;
  padding: 8px;
  border-radius: 16px;
  background: linear-gradient(135deg, #667eea, #f093fb, #f5576c, #4facfe);
  animation: rotateColors 4s linear infinite;
}

@keyframes rotateColors {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

.color-ring {
  position: absolute;
  border-radius: 12px;
  animation: pulse 2s infinite;
}

.color-1 { top: 2px; left: 2px; right: 2px; bottom: 2px; background: linear-gradient(45deg, #667eea, transparent); animation-delay: 0s; }
.color-2 { top: 4px; left: 4px; right: 4px; bottom: 4px; background: linear-gradient(135deg, #f093fb, transparent); animation-delay: 0.5s; }
.color-3 { top: 6px; left: 6px; right: 6px; bottom: 6px; background: linear-gradient(225deg, #f5576c, transparent); animation-delay: 1s; }
.color-4 { top: 8px; left: 8px; right: 8px; bottom: 8px; background: linear-gradient(315deg, #4facfe, transparent); animation-delay: 1.5s; }

@keyframes pulse {
  0%, 100% { opacity: 0.7; }
  50% { opacity: 1; }
}

.image-content {
  position: relative;
  z-index: 2;
  border-radius: 12px;
  overflow: hidden;
  background: white;
}

.modal-image {
  width: 100%;
  height: 250px;
  object-fit: cover;
  display: block;
}

.modal-image-placeholder {
  width: 100%;
  height: 250px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #64748b;
  background: linear-gradient(135deg, #f8fafc, #e2e8f0);
  border-radius: 12px;
  font-weight: 600;
  gap: 8px;
}

.modal-image-placeholder i {
  font-size: 48px;
  opacity: 0.5;
}

/* Enhanced Details Section */
.modal-details {
  padding: 0;
}

.details-header {
  margin-bottom: 5px;
  padding-bottom: 10px;
  border-bottom: 2px solid #f1f5f9;
}

.emp-name {
  font-size: 24px;
  font-weight: 800;
  color: #0f172a;
  margin-bottom: 8px;
  background: linear-gradient(135deg, #0f172a, #334155);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.emp-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: #f1f5f9;
  padding: 6px 12px;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 600;
  color: #475569;
}

.details-grid {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.detail-item {
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 5px;
  background: #f8fafc;
  border-radius: 12px;
  border: 1px solid #f1f5f9;
  transition: all 0.3s ease;
}

.detail-item:hover {
  background: white;
  box-shadow: 0 4px 12px rgba(2, 6, 23, 0.05);
  transform: translateY(-1px);
}

.detail-icon {
  width: 30px;
  height: 30px;
  background: linear-gradient(135deg, #667eea, #764ba2);
  border-radius: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: rgb(254, 254, 254);
  flex-shrink: 0;
}

.detail-icon i {
  font-size: 16px;
}

.detail-content {
  display: flex;
  flex-direction: column;
  flex: 1;
}

.detail-content label {
  font-size: 12px;
  font-weight: 600;
  color: #64748b;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 2px;
}

.detail-content span {
  font-size: 14px;
  font-weight: 700;
  color: #0f172a;
}

.duration-badge {
  /* background: linear-gradient(135deg, #10b981, #059669); */
  color: white;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 700;
}

/* Enhanced Reasons Section */
.modal-reasons {
  padding: 20px;
  border-radius: 16px;
  background: linear-gradient(135deg, #ffffff, #f8fafc);
  border: 1px solid #f1f5f9;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.reasons-header {
  display: flex;
  align-items: center;
  gap: 2px;
  font-size: 16px;
  font-weight: 700;
  color: #0f172a;
  padding-bottom: 12px;
  border-bottom: 2px solid #f1f5f9;
}

.reasons-header i {
  color: #ef4444;
}

.section-title {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  font-weight: 700;
  color: #374151;
  margin-bottom: 12px;
}

.section-title i {
  color: #667eea;
}

.reasons-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  max-height: 80px;
  overflow: auto;
  padding-right: 4px;
}

.why-box {
  background: white;
  padding: 16px;
  border-radius: 12px;
  border-left: 4px solid #667eea;
  box-shadow: 0 4px 12px rgba(2, 6, 23, 0.03);
  max-height: 140px;
  overflow: auto;
  font-size: 13px;
  line-height: 1.4;
}

/* Enhanced Evidence Files */
.evidence-section {
  background: white;
  padding: 20px;
  border-radius: 16px;
  box-shadow: 0 4px 12px rgba(2, 6, 23, 0.03);
  border: 1px solid #f1f5f9;
  margin-bottom: 20px;
}

.section-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 16px;
}

.section-header h4 {
  margin: 0;
  color: #0f172a;
  font-size: 16px;
  font-weight: 700;
}

.section-header i {
  color: #667eea;
}

.files-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.file-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: #f8fafc;
  border-radius: 8px;
  border: 1px solid #e2e8f0;
}

.file-name {
  flex: 1;
  font-size: 13px;
  font-weight: 600;
  color: #374151;
}

.download-btn {
  background: linear-gradient(135deg, #667eea, #764ba2);
  color: white;
  border: none;
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 4px;
  transition: all 0.3s ease;
}

.download-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

.no-files {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 20px;
  justify-content: center;
  color: #64748b;
  font-weight: 600;
}

/* Enhanced Timeline Section */
.timeline-section {
  background: white;
  padding: 20px;
  border-radius: 16px;
  box-shadow: 0 4px 12px rgba(2, 6, 23, 0.03);
  border: 1px solid #f1f5f9;
  margin-bottom: 20px;
}

.timeline-content {
  margin-top: 12px;
}

.loading-timeline {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 20px;
  justify-content: center;
  color: #64748b;
  font-weight: 600;
}

.subtitle {
  font-size: 12px;
  color: #64748b;
  font-weight: 500;
  margin-left: 8px;
}

/* Enhanced Raw JSON Section */
.raw-json-section {
  background: white;
  padding: 20px;
  border-radius: 16px;
  box-shadow: 0 4px 12px rgba(2, 6, 23, 0.03);
  border: 1px solid #f1f5f9;
}

.toggle-label {
  display: flex;
  align-items: center;
  gap: 12px;
  cursor: pointer;
  font-weight: 600;
  color: #374151;
}

.toggle-slider {
  width: 44px;
  height: 24px;
  background: #e2e8f0;
  border-radius: 12px;
  position: relative;
  transition: all 0.3s ease;
}

.toggle-slider::before {
  content: '';
  position: absolute;
  width: 18px;
  height: 18px;
  background: white;
  border-radius: 50%;
  top: 3px;
  left: 3px;
  transition: all 0.3s ease;
}

input[type="checkbox"] {
  display: none;
}

input[type="checkbox"]:checked + .toggle-slider {
  background: linear-gradient(135deg, #667eea, #764ba2);
}

input[type="checkbox"]:checked + .toggle-slider::before {
  transform: translateX(20px);
}

.toggle-text {
  display: flex;
  align-items: center;
  gap: 6px;
}

.raw-json {
  display: none;
  margin-top: 16px;
  background: #1e293b;
  color: #e2e8f0;
  padding: 16px;
  border-radius: 8px;
  overflow: auto;
  max-height: 200px;
}

.raw-json pre {
  margin: 0;
  font-size: 12px;
  font-family: 'Courier New', monospace;
}

/* Hide scrollbars */
.reasons-list,
.why-box,
.raw-json {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

.reasons-list::-webkit-scrollbar,
.why-box::-webkit-scrollbar,
.raw-json::-webkit-scrollbar {
  display: none;
  width: 0;
  height: 0;
}

/* Responsive adjustments */
@media (max-width: 1100px) {
  .modal-top {
    grid-template-columns: 240px 1fr 320px;
  }
  
  .modal-image,
  .modal-image-placeholder {
    height: 220px;
  }
}

@media (max-width: 860px) {
  .modal-inner {
    width: 92%;
    height: 82vh;
  }
  
  .modal-top {
    grid-template-columns: 1fr;
    gap: 20px;
  }
  
  .image-section {
    justify-content: center;
  }
}



    /* evidence table styles & highlight classes */
    .evidence-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
    }

    .evidence-table th,
    .evidence-table td {
      padding: 8px 10px;
      border: 1px solid #e6edf3;
      font-size: 13px;
      text-align: left;
      vertical-align: middle;
    }

    .gap-flag {
      background: #fff5f0;
      color: #9a3412;
      padding: 4px 6px;
      border-radius: 6px;
      display: inline-block;
      margin-left: 8px;
      font-weight: 600;
    }

    /* Highlights requested by user */
    .row-day-start {
      background: linear-gradient(90deg, #eefbe8, #f7ffef);
    }

    .row-out-return {
      background: linear-gradient(90deg, #fff0f0, #fff6f6);
    }

    .row-out {
      background: linear-gradient(90deg, #fff7ed, #fffdf8);
    }

    .highlight-long-duration {
      outline: 2px solid rgba(239, 68, 68, 0.12);
    }

    /* Loading overlay */
    .spinner-overlay {
      position: fixed;
      inset: 0;
      background: rgba(255, 255, 255, 0.65);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(2px);
    }

    .spinner-box {
      display: flex;
      gap: 12px;
      align-items: center;
      background: #fff;
      padding: 14px 18px;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(2, 6, 23, 0.15);
      border: 1px solid #e6edf3;
    }

    .spinner {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 4px solid #e6e6e6;
      border-top-color: var(--accent);
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      100% {
        transform: rotate(360deg);
      }
    }

    .evidence-btn {
      padding: 7px 10px;
      background: #0ea5a4;
      color: #fff;
      border-radius: 6px;
      border: 0;
      cursor: pointer;
    }

    .small-button {
      padding: 6px 8px;
      font-size: 12px;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
      background: transparent;
      cursor: pointer;
    }

    .table-scroll {
      overflow: auto;
      max-width: 100%;
    }

    /* ---------- Responsive ---------- */
    @media (max-width: 1100px) {
      .modal-top {
        grid-template-columns: 180px 1fr 300px;
      }

      .image-wrap {
        width: 196px;
        height: 196px;
      }

      .modal-image {
        width: 188px;
        height: 188px;
      }
    }

    @media (max-width: 860px) {
      .modal-inner {
        width: 92%;
        height: 82vh;
      }

      .modal-top {
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .image-wrap {
        justify-content: flex-start;
      }
    }


/* 👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆 */
    /* calendar input tweaks */
    .date-input {
      padding: 4px 6px;
      font-size: 12px;
      border-radius: 4px;
      min-width: 110px;
      background: #ffd700;
      color: #000;
      border: 1px solid #b89f00;
    }

    .flatpickr-calendar {
      font-size: 12px;
      transform: scale(0.9);
      transform-origin: top left;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    (function () {
      const { useState, useEffect, useRef } = React;

      // CHANGE THIS IF YOUR API HOST DIFFERS
      const API_BASE = "http://localhost:8002";

      // Threshold used to detect "long out then return" pattern (seconds)
      const OUT_RETURN_GAP_SECONDS = 60 * 60; // 1 hour (tweak if you want)

      const SCENARIO_EXPLANATIONS = {
        "long_gap_>=90min": "Long gap between swipes (>= 90 minutes) — could indicate long out-of-office break.",
        "short_duration_<4h": "Short total duration in office (< 4 hours).",
        "coffee_badging": "Frequent short badge cycles (>=4) with short duration — possible 'coffee badging'.",
        "low_swipe_count_<=2": "Low swipe count (<=2) for the day.",
        "single_door": "All swipes used the same door — single-door behavior.",
        "only_in": "Only IN swipe(s) recorded for the day.",
        "only_out": "Only OUT swipe(s) recorded for the day.",
        "overtime_>=10h": "Long duration (>=10 hours) — overtime.",
        "very_long_duration_>=16h": "Very long duration (>=16 hours) — suspiciously long presence.",
        "zero_swipes": "No swipes recorded.",
        "unusually_high_swipes": "Unusually high number of swipes versus historical median.",
        "repeated_short_breaks": "Multiple short breaks within the day.",
        "multiple_location_same_day": "Swipes recorded at multiple locations same day.",
        "weekend_activity": "Activity recorded on weekend.",
        "repeated_rejection_count": "Several card rejections.",
        "badge_sharing_suspected": "Badge sharing suspected (same card used by multiple persons on same day).",
        "early_arrival_before_06": "First swipe before 06:00.",
        "late_exit_after_22": "Last swipe after 22:00.",
        "shift_inconsistency": "Duration inconsistent with historical shift patterns.",
        "trending_decline": "Historical trending decline flagged.",
        "consecutive_absent_days": "Marked absent for consecutive days historically.",
        "high_variance_duration": "High variance in durations historically.",
        "short_duration_on_high_presence_days": "Short duration even though employee usually attends many days.",
        "swipe_overlap": "Simultaneous swipe(s) near the same time with other uid(s) (possible tailgating or collusion).",
        "shortstay_longout_repeat": "Pattern: short stay, long out-of-office, short return (repeat)."
      };

      function pad(n) { return n.toString().padStart(2, '0'); }
      function formatDateISO(d) {
        if (!d) return "";
        const dt = (d instanceof Date) ? d : new Date(d);
        return dt.getFullYear() + "-" + pad(dt.getMonth() + 1) + "-" + pad(dt.getDate());
      }
      function datesBetween(start, end) {
        var out = [];
        var cur = new Date(start);
        while (cur <= end) {
          out.push(new Date(cur));
          cur.setDate(cur.getDate() + 1);
        }
        return out;
      }
      function safeDateDisplay(val) {
        if (!val && val !== 0) return "";
        try {
          var d = (val instanceof Date) ? val : new Date(val);
          if (isNaN(d.getTime())) return String(val);
          return d.toLocaleString();
        } catch (e) {
          return String(val);
        }
      }
      function sanitizeName(row) {
        return row.EmployeeName || row.EmployeeName_x || row.EmployeeName_y || row.person_uid || "";
      }
      function downloadCSV(rows, filename) {
        if (!rows || !rows.length) { alert("No rows to export"); return; }
        var cols = Object.keys(rows[0]);
        var lines = [cols.join(",")];
        rows.forEach(function (r) {
          var row = cols.map(function (c) {
            var v = (r[c] === undefined || r[c] === null) ? "" : String(r[c]).replace(/\n/g, ' ');
            return JSON.stringify(v);
          }).join(",");
          lines.push(row);
        });
        var blob = new Blob([lines.join("\n")], { type: 'text/csv' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a'); a.href = url; a.download = filename || 'export.csv'; a.click(); URL.revokeObjectURL(url);
      }

      // convert seconds -> "HH:mm:ss"
      function formatSecondsToHmsJS(seconds) {
        if (seconds === null || seconds === undefined || seconds === '') return "-";
        const n = Number(seconds);
        if (isNaN(n) || !isFinite(n)) return "-";
        const s = Math.max(0, Math.floor(n));
        const hh = Math.floor(s / 3600);
        const mm = Math.floor((s % 3600) / 60);
        const ss = s % 60;
        return pad(hh) + ":" + pad(mm) + ":" + pad(ss);
      }

      function App() {
        var yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);

        const [dateFrom, setDateFrom] = useState(formatDateISO(yesterday));
        const [dateTo, setDateTo] = useState(formatDateISO(new Date()));
        const [loading, setLoading] = useState(false);
        const [summary, setSummary] = useState({ rows: 0, flagged_rows: 0, files: [], end_date: null });
        const [rows, setRows] = useState([]);
        const [reasonsCount, setReasonsCount] = useState({});
        const [filterText, setFilterText] = useState("");
        const [page, setPage] = useState(1);
        const [selectedReason, setSelectedReason] = useState("");
        const [reasonFilterText, setReasonFilterText] = useState("");
        const [modalRow, setModalRow] = useState(null);
        const [modalDetails, setModalDetails] = useState(null); // {aggregated_rows, raw_swipes, raw_swipe_files}
        const [modalLoading, setModalLoading] = useState(false);
        const pageSize = 25;
        const chartRef = useRef(null);
        const chartInst = useRef(null);

        // flatpickr refs
        const fromRef = useRef(null);
        const toRef = useRef(null);
        const fromFp = useRef(null);
        const toFp = useRef(null);

        useEffect(function () {
          if (window.flatpickr && fromRef.current && toRef.current) {
            try { if (fromFp.current) fromFp.current.destroy(); } catch (e) { }
            try { if (toFp.current) toFp.current.destroy(); } catch (e) { }
            fromFp.current = window.flatpickr(fromRef.current, {
              dateFormat: "Y-m-d",
              defaultDate: dateFrom,
              allowInput: true,
              onChange: function (selectedDates, str) {
                if (selectedDates && selectedDates.length) {
                  const iso = formatDateISO(selectedDates[0]);
                  setDateFrom(iso);
                  try { if (toFp.current) toFp.current.set('minDate', iso); } catch (e) { }
                  if (dateTo && new Date(iso) > new Date(dateTo)) {
                    setDateTo(iso);
                    try { if (toFp.current) toFp.current.setDate(iso, true); } catch (e) { }
                  }
                }
              }
            });
            toFp.current = window.flatpickr(toRef.current, {
              dateFormat: "Y-m-d",
              defaultDate: dateTo,
              allowInput: true,
              onChange: function (selectedDates, str) {
                if (selectedDates && selectedDates.length) {
                  const iso = formatDateISO(selectedDates[0]);
                  setDateTo(iso);
                  try { if (fromFp.current) fromFp.current.set('maxDate', iso); } catch (e) { }
                  if (dateFrom && new Date(iso) < new Date(dateFrom)) {
                    setDateFrom(iso);
                    try { if (fromFp.current) fromFp.current.setDate(iso, true); } catch (e) { }
                  }
                }
              }
            });
            try { if (fromFp.current) fromFp.current.set('maxDate', dateTo); if (toFp.current) toFp.current.set('minDate', dateFrom); } catch (e) { }
          }
          loadLatest();
          return function () { try { if (fromFp.current) fromFp.current.destroy(); } catch (e) { } try { if (toFp.current) toFp.current.destroy(); } catch (e) { } };
          // eslint-disable-next-line
        }, []);

        useEffect(function () {
          try { if (fromFp.current && dateFrom) fromFp.current.setDate(dateFrom, false); } catch (e) { }
          try { if (toFp.current && dateTo) toFp.current.setDate(dateTo, false); } catch (e) { }
          try { if (fromFp.current) fromFp.current.set('maxDate', dateTo); } catch (e) { }
          try { if (toFp.current) toFp.current.set('minDate', dateFrom); } catch (e) { }
        }, [dateFrom, dateTo]);

        async function runForRange() {
          setLoading(true);
          setRows([]); setSummary({ rows: 0, flagged_rows: 0, files: [], end_date: null }); setReasonsCount({});
          try {
            var start = new Date(dateFrom);
            var end = new Date(dateTo);
            var dateList = datesBetween(start, end).map(d => formatDateISO(d));
            var accRows = []; var totalRows = 0, totalFlagged = 0, files = [];
            for (var i = 0; i < dateList.length; i++) {
              var d = dateList[i];
              var url = API_BASE + "/run?date=" + d;
              var r = await fetch(url, { method: 'GET' });
              if (!r.ok) { var txt = await r.text(); throw new Error("API returned " + r.status + ": " + txt); }
              var js = await r.json();
              var sample = js.sample || [];
              if (Array.isArray(sample) && sample.length) accRows = accRows.concat(sample);
              if (typeof js.rows === 'number') totalRows += js.rows; else totalRows += (Array.isArray(sample) ? sample.length : 0);
              totalFlagged += (js.flagged_rows || 0);
              if (js.files) files = files.concat(js.files);
            }
            setRows(accRows);
            setSummary({ rows: totalRows, flagged_rows: totalFlagged, files: files, end_date: formatDateISO(new Date(dateTo)) });
            computeReasons(accRows);
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message);
            console.error(err);
          } finally { setLoading(false); }
        }

        async function loadLatest() {
          setLoading(true);
          try {
            var r = await fetch(API_BASE + "/latest");
            if (!r.ok) throw new Error("latest failed: " + r.status);
            var js = await r.json();
            var sample = js.sample || [];
            if (!Array.isArray(sample)) sample = [];
            setRows(sample);
            setSummary({ rows: (js.rows || sample.length || 0), flagged_rows: (sample.filter(function (x) { return !!x.Reasons; }).length || 0), files: [js.file] });
            computeReasons(sample);
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message + (err.message === 'latest failed: 0' ? " (check backend/CORS)" : ""));
            console.error(err);
          } finally { setLoading(false); }
        }

        function computeReasons(dataRows) {
          var counts = {};
          (dataRows || []).forEach(function (r) {
            if (!r.Reasons) return;
            var parts = String(r.Reasons).split(";").map(function (s) { return s.trim(); }).filter(Boolean);
            parts.forEach(function (p) { counts[p] = (counts[p] || 0) + 1; });
          });
          setReasonsCount(counts);
          buildChart(counts);
        }

        function buildChart(counts) {
          var labels = Object.keys(counts).sort(function (a, b) { return counts[b] - counts[a]; });
          var values = labels.map(function (l) { return counts[l]; });
          var ctx = chartRef.current && chartRef.current.getContext ? chartRef.current.getContext('2d') : null;
          if (!ctx) return;
          try { if (chartInst.current) chartInst.current.destroy(); } catch (e) { }
          chartInst.current = new Chart(ctx, {
            type: 'bar',
            data: { labels: labels, datasets: [{ label: 'Events', data: values, backgroundColor: labels.map(() => 'rgba(37,99,235,0.85)') }] },
            options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true } } }
          });
        }

        // filtering & pagination
        var filtered = (rows || []).filter(function (r) {
          var hay = (sanitizeName(r) + " " + (r.EmployeeID || "") + " " + (r.CardNumber || "") + " " + (r.Reasons || "")).toLowerCase();
          var textOk = !filterText || hay.indexOf(filterText.toLowerCase()) !== -1;
          var reasonOk = !selectedReason || (r.Reasons && ((";" + String(r.Reasons) + ";").indexOf(selectedReason) !== -1));
          return textOk && reasonOk;
        });
        var totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
        var pageRows = filtered.slice((page - 1) * pageSize, page * pageSize);

        function exportFiltered() { downloadCSV(filtered, "trend_filtered_export.csv"); }

        function onReasonClick(reason) {
          if (!reason) { setSelectedReason(""); return; }
          if (selectedReason === reason) setSelectedReason(""); else setSelectedReason(reason);
          setPage(1);
        }

        // open evidence modal (explicit Evidence button)
        async function openEvidence(row) {
          setModalRow(row);
          setModalDetails(null);
          setModalLoading(true);
          try {
            const q = encodeURIComponent(row.EmployeeID || row.person_uid || "");
            const resp = await fetch(API_BASE + "/record?employee_id=" + q);
            if (!resp.ok) { const txt = await resp.text(); throw new Error("record failed: " + resp.status + " - " + txt); }
            const js = await resp.json();
            const details = { aggregated_rows: js.aggregated_rows || [], raw_swipe_files: js.raw_swipe_files || [], raw_swipes: js.raw_swipes || [] };
            setModalDetails(details);
          } catch (e) {
            alert("Failed loading details: " + e.message);
            console.error(e);
          } finally { setModalLoading(false); }
        }

        function closeModal() { setModalRow(null); setModalDetails(null); }

        var rowsCount = (summary && typeof summary.rows === 'number') ? summary.rows : (rows ? rows.length : 0);
        var flaggedCount = (summary && typeof summary.flagged_rows === 'number') ? summary.flagged_rows : (rows ? rows.filter(function (r) { return !!r.Reasons; }).length : 0);
        var flaggedPct = rowsCount ? Math.round((flaggedCount * 100) / (rowsCount || 1)) : 0;

        function renderOverlapCell(r) {
          var ov = r.OverlapWith || r.swipe_overlap || r.overlap_with || null;
          if (ov && typeof ov === 'string') {
            var parts = ov.split(";").map(function (s) { return s.trim(); }).filter(Boolean);
            if (parts.length === 0) return <span className="muted">—</span>;
            return <span className="pill" title={ov}>{parts.length} overlap</span>;
          }
          return <span className="muted">—</span>;
        }

        function renderReasonChips(reasonText) {
          if (!reasonText) return <span className="muted">—</span>;
          const parts = String(reasonText).split(";").map(s => s.trim()).filter(Boolean);
          return parts.map((p, idx) => (<span key={idx} className="pill" title={SCENARIO_EXPLANATIONS[p] || p}>{p}</span>));
        }

        function renderReasonExplanations(reasonText) {
          if (!reasonText) return <div className="muted">No flags</div>;
          const parts = String(reasonText).split(";").map(s => s.trim()).filter(Boolean);
          return (
            <div>
              {parts.map((p, idx) => (
                <div key={idx} className="why-item">
                  <b>{p}</b>
                  <div className="small">{SCENARIO_EXPLANATIONS[p] || "No explanation available."}</div>
                </div>
              ))}
            </div>
          );
        }

        // render timeline with requested highlights:
        function renderSwipeTimeline(details, modalRow) {
          if (!details || !details.raw_swipes || details.raw_swipes.length === 0) {
            return <div className="muted">No raw swipe evidence available (person not flagged or raw file missing).</div>;
          }
          const all = details.raw_swipes.slice().map(r => {
            const obj = Object.assign({}, r);
            try {
              if (obj.Date && obj.Time) { obj.__ts = new Date(obj.Date + "T" + obj.Time); }
              else if (obj.Date && obj.Time === undefined && obj.LocaleMessageTime) { obj.__ts = new Date(obj.LocaleMessageTime); }
              else if (obj.LocaleMessageTime) { obj.__ts = new Date(obj.LocaleMessageTime); }
              else { obj.__ts = null; }
            } catch (e) { obj.__ts = null; }
            let gap = null;
            if (obj.SwipeGapSeconds !== undefined && obj.SwipeGapSeconds !== null) { gap = Number(obj.SwipeGapSeconds); if (isNaN(gap)) gap = null; }
            else if (obj.SwipeGap) {
              try { const parts = String(obj.SwipeGap).split(':').map(p => Number(p)); if (parts.length === 3) gap = parts[0] * 3600 + parts[1] * 60 + parts[2]; } catch (e) { gap = null; }
            }
            obj.__gap = gap;
            obj.__zone_l = String((obj.Zone || '')).toLowerCase();
            return obj;
          }).sort((a, b) => {
            if (a.__ts && b.__ts) return a.__ts - b.__ts;
            if (a.__ts) return -1;
            if (b.__ts) return 1;
            return 0;
          });

          const flags = new Array(all.length).fill({}).map(() => ({ dayStart: false, outReturn: false }));
          for (let i = 0; i < all.length; i++) {
            const cur = all[i]; const prev = all[i - 1];
            try {
              const curDate = cur.Date ? cur.Date.slice(0, 10) : (cur.__ts ? cur.__ts.toISOString().slice(0, 10) : null);
              const prevDate = prev ? (prev.Date ? prev.Date.slice(0, 10) : (prev.__ts ? prev.__ts.toISOString().slice(0, 10) : null)) : null;
              if (!prev || prevDate !== curDate) { flags[i].dayStart = true; }
            } catch (e) { }
          }
          for (let i = 0; i < all.length - 1; i++) {
            const a = all[i], b = all[i + 1];
            const aZone = a.__zone_l || ''; const bZone = b.__zone_l || ''; const bGap = b.__gap || 0;
            if (aZone.includes('out of office') || aZone.includes('out_of_office') || aZone.includes('out of')) {
              if (!bZone.includes('out of office') && (bGap >= OUT_RETURN_GAP_SECONDS || bGap === null && aZone.includes('out'))) {
                flags[i].outReturn = true; flags[i + 1].outReturn = true;
              }
            }
          }

          return (
            <div className="table-scroll">
              <table className="evidence-table" role="table" aria-label="Swipe timeline">
                <thead>
                  <tr>
                    <th>Employee Name</th>
                    <th>Employee ID</th>
                    <th>Card</th>
                    <th>Date</th>
                    <th>Time</th>
                    <th>SwipeGap</th>
                    <th>Door</th>
                    <th>Direction</th>
                    <th>Zone</th>
                    <th>Note</th>
                  </tr>
                </thead>
                <tbody>
                  {all.map((rObj, idx) => {
                    const r = rObj || {};
                    const g = r.__gap;
                    const gapFormatted = (r.SwipeGap && String(r.SwipeGap).trim()) ? String(r.SwipeGap) : (g !== null && g !== undefined) ? formatSecondsToHmsJS(g) : "-";
                    const cls = [];
                    if (flags[idx].dayStart) cls.push('row-day-start');
                    if (flags[idx].outReturn) cls.push('row-out-return');
                    if (g && g >= OUT_RETURN_GAP_SECONDS) cls.push('highlight-long-duration');
                    return (
                      <tr key={idx} className={cls.join(' ')}>
                        <td className="small">{r.EmployeeName || '-'}</td>
                        <td className="small">{r.EmployeeID || '-'}</td>
                        <td className="small">{r.CardNumber || r.Card || '-'}</td>
                        <td className="small">{r.Date || '-'}</td>
                        <td className="small">{r.Time || (r.__ts ? r.__ts.toTimeString().slice(0, 8) : '-')}</td>
                        <td className="small">{gapFormatted}</td>
                        <td className="small" style={{ minWidth: 160 }}>{r.Door || '-'}</td>
                        <td className="small">{r.Direction || '-'}</td>
                        <td className="small">{r.Zone || '-'}</td>
                        <td className="small">{r.Note || '-'}{r._source ? <span className="muted"> ({r._source})</span> : null}</td>
                      </tr>
                    );
                  })
                  }
                </tbody>
              </table>
            </div>
          );
        }

        return (
          <div className="container" aria-live="polite">
            {loading && (
              <div className="spinner-overlay" role="status" aria-label="Loading">
                <div className="spinner-box">
                  <div className="spinner" />
                  <div style={{ fontWeight: 700 }}>Loading…</div>
                </div>
              </div>
            )}

            <div className="topbar" role="banner">
              <div className="wu-brand" aria-hidden={false}>
                <div className="wu-logo">WU</div>
                <div className="title-block">
                  <h1>Western Union — Trend Analysis</h1>
                  <p>Pune</p>
                </div>
              </div>

              <div className="header-actions" role="region" aria-label="controls">
                <div className="control">
                  <label className="small" htmlFor="fromDate">From</label>
                  <input id="fromDate" ref={fromRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                </div>

                <div className="control">
                  <label className="small" htmlFor="toDate">To</label>
                  <input id="toDate" ref={toRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                </div>

                <button className="btn-primary" onClick={runForRange} disabled={loading}>Run</button>
                <button className="btn-ghost" onClick={loadLatest} disabled={loading}>Load latest</button>
              </div>
            </div>

            <div className="card-shell">

              <div className="cards" aria-hidden={loading}>
                <div className="card" title="Rows analysed">
                  <div className="card-content">
                    <div className="card-icon">
                      <i className="bi bi-table"></i>
                    </div>
                    <div className="card-text">
                      <h3>{(rowsCount !== undefined && rowsCount !== null) ? rowsCount.toLocaleString() : 0}</h3>
                      <p>Rows analysed</p>
                    </div>
                  </div>
                  <div className="card-gradient"></div>
                </div>

                <div className="card card-flagged" title="Flagged rows">
                  <div className="card-content">
                    <div className="card-icon">
                      <i className="bi bi-flag-fill"></i>
                    </div>
                    <div className="card-text">
                      <h3>{(flaggedCount !== undefined && flaggedCount !== null) ? flaggedCount.toLocaleString() : 0}</h3>
                      <p>Flagged rows</p>
                    </div>
                  </div>
                  <div className="card-gradient"></div>
                </div>

                <div className="card card-rate" title="Flagged rate">
                  <div className="card-content">
                    <div className="card-icon">
                      <i className="bi bi-graph-up-arrow"></i>
                    </div>
                    <div className="card-text">
                      <h3>{flaggedPct}%</h3>
                      <p>Flagged rate</p>
                    </div>
                  </div>
                  <div className="card-gradient"></div>
                </div>
              </div>
              <div className="main">
                <div className="left">
                  <div className="chart-wrap">
                    <canvas ref={chartRef}></canvas>
                  </div>

                  <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginTop: 6 }}>
                    <input placeholder="Search name, employee id, card or reason..." value={filterText} onChange={function (e) { setFilterText(e.target.value); setPage(1); }} style={{ flex: 1, padding: 10, borderRadius: 6, border: '1px solid #e6edf3' }} />
                    <div className="muted">Showing {filtered.length} / {rows.length} rows</div>
                    <button className="small-button" onClick={exportFiltered}>Export filtered</button>
                  </div>

                  <div style={{ marginTop: 10 }} className="table-scroll" role="region" aria-label="results table">
                    <table>
                      <thead>
                        <tr>
                          <th>Employee</th>
                          <th className="small">ID</th>
                          <th className="small">Card</th>
                          <th className="small">Date</th>
                          <th className="small">Duration</th>
                          <th className="small">Reasons</th>
                          <th className="small">Overlap</th>
                          <th className="small">Evidence</th>
                        </tr>
                      </thead>
                      <tbody>
                        {pageRows.map(function (r, idx) {
                          var empName = sanitizeName(r);
                          var displayDate = safeDateDisplay(r.Date || r.FirstSwipe || r.LastSwipe);
                          var durText = r.Duration || (r.DurationMinutes ? Math.round(r.DurationMinutes) + " min" : "");
                          var flagged = r.Reasons && String(r.Reasons).trim();
                          return (
                            <tr key={idx} className={flagged ? "flagged-row" : ""}>
                              <td className="row-click" onClick={function () { openEvidence(r); }}>{empName || <span className="muted">—</span>}</td>
                              <td className="small">{r.EmployeeID || ""}</td>
                              <td className="small">{r.CardNumber || ""}</td>
                              <td className="small">{displayDate}</td>
                              <td className="small">{durText}</td>
                              <td className="small">{renderReasonChips(r.Reasons)}</td>
                              <td className="small">{renderOverlapCell(r)}</td>
                              <td className="small">
                                <button className="evidence-btn" onClick={function () { openEvidence(r); }}>Evidence</button>
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>

                  <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginTop: 10 }}>
                    <button onClick={function () { setPage(function (p) { return Math.max(1, p - 1); }); }} disabled={page <= 1}>Prev</button>
                    <div className="muted">Page {page} / {totalPages}</div>
                    <button onClick={function () { setPage(function (p) { return Math.min(totalPages, p + 1); }); }} disabled={page >= totalPages}>Next</button>
                  </div>
                </div>

                <aside className="right" aria-label="side panel">
                  <div style={{ marginBottom: 12 }}>
                    <strong>Files:</strong>
                    <div className="muted" style={{ marginTop: 6 }}>{(summary.files || []).join(", ")}</div>
                  </div>

                  <div style={{ marginBottom: 12 }}>
                    <strong>Top reasons summary</strong>
                    <div className="small muted" style={{ marginTop: 6 }}>Click a reason to filter the table by that reason. Click again to clear.</div>

                    <div style={{ marginTop: 8, display: 'flex', gap: 8 }}>
                      <input placeholder="Filter reason list..." value={reasonFilterText} onChange={function (e) { setReasonFilterText(e.target.value); }} style={{ flex: 1, padding: '6px 8px', borderRadius: 6, border: '1px solid #e2e8f0' }} />
                      <button className="small-button" onClick={function () { setSelectedReason(''); setReasonFilterText(''); }}>Clear</button>
                    </div>

                    <div style={{ marginTop: 8, maxHeight: 320, overflow: 'auto' }}>
                      {Object.keys(reasonsCount).length === 0 && <div className="muted">No flags found</div>}
                      {Object.entries(reasonsCount).sort(function (a, b) { return b[1] - a[1]; }).filter(function (kv) {
                        var name = kv[0];
                        if (!reasonFilterText) return true;
                        return name.toLowerCase().indexOf(reasonFilterText.toLowerCase()) !== -1;
                      }).slice(0, 50).map(function (kv) {
                        var name = kv[0], count = kv[1];
                        var active = selectedReason === name;
                        return (
                          <div key={name} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 8, marginBottom: 6 }}>
                            <button className={"chip " + (active ? "active" : "")} style={{ textAlign: 'left', flex: 1 }} onClick={function () { onReasonClick(name); }}>
                              {name}
                            </button>
                            <div style={{ minWidth: 48, textAlign: 'right' }} className="small"><b>{count}</b></div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </aside>
              </div>
            </div>


            {modalRow &&
              <div className="modal" onClick={closeModal}>
                <div className="modal-inner" onClick={function (e) { e.stopPropagation(); }}>
                  {/* Enhanced Header */}
                  <div className="modal-header">
                    <div className="header-content">
                      <div className="header-icon">
                        <i className="bi bi-clipboard2-data-fill"></i>
                      </div>
                      <div className="header-text">
                        <h3>Details — Evidence</h3>
                      </div>
                    </div>
                    <button className="close-btn" onClick={closeModal}>
                      <i className="bi bi-x-lg"></i>
                      Close
                    </button>
                  </div>

                  <div className="modal-body">
                    {modalLoading && (
                      <div className="loading-state">
                        <div className="loading-spinner"></div>
                        <span>Loading evidence…</span>
                      </div>
                    )}

                    {/* Enhanced Top Section */}
                    <div className="modal-top" role="region" aria-label="evidence summary">
                      {/* Column 1 - Enhanced Image with Multi-color Border */}
                      <div className="image-section">
                        <div className="image-container">
                          <div className="multi-color-border">
                            <div className="color-ring color-1"></div>
                            <div className="color-ring color-2"></div>
                            <div className="color-ring color-3"></div>
                            <div className="color-ring color-4"></div>
                            <div className="image-content">
                              {(modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows.length > 0) ? (
                                (() => {
                                  const md = modalDetails.aggregated_rows[0];
                                  if (md && md.imageUrl) {
                                    return (
                                      <img
                                        className="modal-image"
                                        src={API_BASE + md.imageUrl}
                                        alt="Employee"
                                        onError={(e) => {
                                          e.target.style.display = 'none';
                                          e.target.nextSibling.style.display = 'flex';
                                        }}
                                      />
                                    );
                                  } else {
                                    return <div className="modal-image-placeholder">No image</div>;
                                  }
                                })()
                              ) : (
                                <div className="modal-image-placeholder">
                                  <i className="bi bi-person-square"></i>
                                  <span>No image</span>
                                </div>
                              )}
                            </div>
                          </div>
                        </div>
                      </div>

                      {/* Column 2 - Enhanced Employee Details */}
                      <div className="modal-details">
                        <div className="details-header">
                          <div className="emp-name">{sanitizeName(modalRow) || "—"}</div>
                          <div className="emp-badge">
                            <i className="bi bi-person-badge"></i>
                            ID: {modalRow.EmployeeID || "—"}
                          </div>
                        </div>

                        <div className="details-grid">
                          <div className="detail-item">
                            <div className="detail-icon">
                              <i className="bi bi-credit-card"></i>
                            </div>
                            <div className="detail-content">
                              <label>Card Number</label>
                              <span>{modalRow.CardNumber || "—"}</span>
                            </div>
                          </div>

                          <div className="detail-item">
                            <div className="detail-icon">
                              <i className="bi bi-envelope"></i>
                            </div>
                            <div className="detail-content">
                              <label>Email</label>
                              <span>{(modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0] && modalDetails.aggregated_rows[0].EmployeeEmail) ? modalDetails.aggregated_rows[0].EmployeeEmail : <span className="muted">—</span>}</span>
                            </div>
                          </div>

                          <div className="detail-item">
                            <div className="detail-icon">
                              <i className="bi bi-calendar-date"></i>
                            </div>
                            <div className="detail-content">
                              <label>Date</label>
                              <span>{safeDateDisplay(modalRow.Date || modalRow.FirstSwipe)}</span>
                            </div>
                          </div>

                          <div className="detail-item">
                            <div className="detail-icon">
                              <i className="bi bi-clock"></i>
                            </div>
                            <div className="detail-content">
                              <label>Duration</label>
                              <span className="duration-badge">
                                {modalRow.Duration || (modalRow.DurationMinutes ? Math.round(modalRow.DurationMinutes) + " min" : "—")}
                              </span>
                            </div>
                          </div>
                        </div>
                      </div>

                      {/* Column 3 - Enhanced Reasons & Why Section */}
                      <div className="modal-reasons">
                       

                        <div className="reasons-section">
                          <div className="section-title">
                            <i className="bi bi-list-check"></i>
                            Reasons Flagged
                          </div>
                          <div className="reasons-list">
                            {renderReasonChips(modalRow.Reasons)}
                          </div>
                        </div>

                        <div className="why-section">
                          <div className="section-title">
                            <i className="bi bi-question-circle"></i>
                            Why Highlighted
                          </div>
                          <div className="why-box">
                            <div>
                              {renderReasonExplanations(modalRow.Reasons)}
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>

                    {/* Enhanced Evidence Files Section */}
                    <div className="evidence-section">
                      <div className="section-header">
                        <i className="bi bi-folder2-open"></i>
                        <h4>Available Evidence Files</h4>
                      </div>
                      <div className="files-container">
                        {modalDetails && modalDetails.raw_swipe_files && modalDetails.raw_swipe_files.length > 0 ? (
                          <div className="files-list">
                            {modalDetails.raw_swipe_files.map((f, i) => (
                              <div key={i} className="file-item">
                                <i className="bi bi-file-earmark-text"></i>
                                <span className="file-name">{f}</span>
                                <button
                                  className="download-btn"
                                  onClick={function () { window.location = API_BASE + "/swipes/" + encodeURIComponent(f); }}
                                >
                                  <i className="bi bi-download"></i>
                                  Download
                                </button>
                              </div>
                            ))}
                          </div>
                        ) : (
                          <div className="no-files">
                            <i className="bi bi-folder-x"></i>
                            <span>No raw swipe files found for this person/date.</span>
                          </div>
                        )}
                      </div>
                    </div>

                    {/* Enhanced Timeline Section */}
                    <div className="timeline-section">
                      <div className="section-header">
                        <i className="bi bi-clock-history"></i>
                        <h4>Swipe Timeline</h4>
                        <span className="subtitle">Filtered for this person/date</span>
                      </div>
                      <div className="timeline-content">
                        {modalDetails ? renderSwipeTimeline(modalDetails, modalRow) : (
                          <div className="loading-timeline">
                            <i className="bi bi-hourglass-split"></i>
                            <span>Evidence not loaded yet.</span>
                          </div>
                        )}
                      </div>
                    </div>

                    {/* Raw JSON Toggle */}
                    <div className="raw-json-section">
                      <label className="toggle-label">
                        <input
                          type="checkbox"
                          id="showraw"
                          onChange={function (e) {
                            const el = document.getElementById('rawpayload');
                            if (el) el.style.display = e.target.checked ? 'block' : 'none';
                          }}
                        />
                        <span className="toggle-slider"></span>
                        <span className="toggle-text">
                          <i className="bi bi-code-slash"></i>
                          Show raw aggregated JSON
                        </span>
                      </label>
                      <div id="rawpayload" className="raw-json">
                        <pre>{JSON.stringify(modalRow, null, 2)}</pre>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            }

          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(App));
    })();
  </script>
</body>

</html>

