<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Trend Analysis — Dashboard</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- React + ReactDOM + Babel (quick prototyping) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Flatpickr (high-quality calendar) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

    <style>
      /* ---------- Global ---------- */
      :root{
        --wu-yellow: #ffd400;
        --wu-black: #0a0a0a;
        --card-bg: #ffffff;
        --muted: #64748b;
        --accent: #2563eb;
        --panel: #f7fafc;
        --pill-bg: #eef6ff;
        --pill-text: #0b4f7a;
      }

      html,body { height:100%; }
      body { font-family: Inter, Roboto, Arial, sans-serif; margin: 0; padding: 0; background:#f6f7fb; color:#1f2937; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
      .container { max-width:1250px; margin:12px auto; padding:0; }

      /* ---------- Header (Western Union look) ---------- */
      .topbar {
        display:flex;
        align-items:center;
        justify-content:space-between;
        background: linear-gradient(90deg, #111 0%, #000 30%);
        color:var(--wu-yellow);
        padding: 12px 16px;
        border-radius: 8px 8px 0 0;
        box-shadow: 0 8px 24px rgba(2,6,23,0.18);
        gap:12px;
        flex-wrap:wrap;
      }
      .wu-brand { display:flex; gap:12px; align-items:center; min-width:0; }
      .wu-logo { width:54px; height:34px; background:var(--wu-yellow); color:#000; display:flex; align-items:center; justify-content:center; font-weight:700; border-radius:4px; box-shadow: inset 0 -2px 0 rgba(0,0,0,0.08); font-family: "Helvetica Neue", Arial, sans-serif; flex-shrink:0; }
      .title-block { line-height:1; min-width:0; }
      .title-block h1 { margin:0; font-size:18px; color:var(--wu-yellow); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:260px; }
      .title-block p { margin:0; color:#e6e6e6; font-size:13px; }

      .header-actions { display:flex; gap:8px; align-items:center; margin-left:auto; flex-wrap:wrap; }
      .header-actions .control { display:flex; align-items:center; gap:6px; }
      .header-actions .control label { color:#e7e7e7; font-size:13px; margin-right:4px; white-space:nowrap; }
      .date-input { padding:8px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.12); background:transparent; color:#fff; min-width:130px; }
      .header-actions button { padding:8px 12px; border-radius:6px; border:0; font-weight:600; cursor:pointer; }
      .btn-primary { background:var(--wu-yellow); color:var(--wu-black); }
      .btn-ghost { background:transparent; color:#fff; border:1px solid rgba(255,255,255,0.12); }

      /* ---------- Main card area ---------- */
      .card-shell { background:var(--card-bg); padding:10px 14px 14px 14px; border-radius:0 0 8px 8px; box-shadow:0 6px 18px rgba(16,24,40,0.04); margin-top:4px; }
      .cards { display:flex; gap:10px; margin:6px 0 10px 0; padding:6px 0; align-items:stretch; }
      .card { flex:1; background:linear-gradient(180deg,#fff,#fbfdff); padding:12px 12px; border-radius:8px; text-align:center; border: 2px solid rgba(255,212,66,0.16); box-shadow: 0 6px 18px rgba(16,24,40,0.04); min-width:120px; }
      .card h3 { margin:4px 0; font-size:20px; color:#0f172a; }
      .card p { margin:0; color:var(--muted); font-weight:600; }

      .main { display:flex; gap:14px; margin-top:6px; padding-bottom:18px; }
      .left { flex:2; background:transparent; padding-right:6px; }
      .right { flex:1; min-width:260px; }

      .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
      .date-input::-webkit-calendar-picker-indicator { display:none; }

      /* ---------- Chart ---------- */
      .chart-wrap { background:#fff; padding:10px; border-radius:8px; box-shadow: inset 0 0 0 1px #f1f5f9; height:260px; margin-bottom:10px; }

      /* ---------- Table ---------- */
      table { width:100%; border-collapse:collapse; margin-top:8px; background:#fff; border-radius:6px; overflow:hidden; box-shadow:0 4px 20px rgba(2,6,23,0.03); }
      thead th { padding:10px 8px; font-weight:700; font-size:13px; background: linear-gradient(90deg,#fff,#fbfbfb); border-bottom:3px solid #e2e8f0; text-align:left; }
      tbody td { padding:8px; border-bottom:1px solid #f1f5f9; font-size:13px; color:#0f172a; vertical-align:middle; }
      .small { font-size:12px; color:var(--muted); }
      .row-click { cursor:pointer; color:#0f172a; }
      .flagged-row { background: linear-gradient(90deg,#fff8f0,#fff); }









/* ---------- Chips & reasons ---------- */
.pill {
  display:inline-block;
  padding:4px 6px;
  border-radius:999px;
  background:var(--pill-bg);
  color:var(--pill-text);
  font-size:11px;
  cursor:pointer;
  margin:3px 6px 3px 0;
  border:1px solid rgba(2,80,160,0.06);
  box-shadow: 0 1px 6px rgba(2,80,160,0.03);
}
.chip {
  display:inline-block;
  padding:5px 8px;
  border-radius:999px;
  background:#eef2ff;
  color:#034f84;
  font-size:12px;
  cursor:pointer;
  margin:3px;
  border:1px solid transparent;
}
.chip.active {
  background:#ffd;
  border-color:#f7c948;
  box-shadow:0 2px 6px rgba(39,39,56,0.06);
}

/* ---------- Evidence modal ---------- */
.modal { position:fixed; left:0; right:0; top:0; bottom:0; display:flex; align-items:center; justify-content:center; z-index:1000; background: rgba(3,6,23,0.45); }

/* FIXED modal size requested by user */
.modal-inner {
  width:1000px;
  height:640px;
  max-width:96%;
  max-height:92%;
  overflow:hidden;
  background:#fff;
  border-radius:10px;
  padding:0;
  box-shadow:0 30px 60px rgba(2,6,23,0.45);
  border: 1px solid #e6edf3;
  display:flex;
  flex-direction:column;
}
.modal-header {
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:14px 18px;
  border-radius:8px 8px 0 0;
  background: linear-gradient(90deg, var(--wu-yellow), #ffd966);
  color: #080808;
}
.modal-header h3 { margin:0; color:#000; font-size:18px; letter-spacing:0.2px; }
.close-btn { background:#ef4444; color:#fff; border-radius:8px; padding:8px 12px; border:0; cursor:pointer; font-weight:700; margin-left:12px; }

/* body inside modal scrolls; header remains fixed */
.modal-body { padding:18px; overflow:auto; flex:1; }

/* top area card */
.modal-top {
  display:grid;
  grid-template-columns: 220px 1fr 360px;
  gap:14px;
  align-items:start;
  background: linear-gradient(180deg,#ffffff,#fbfdff);
  padding:14px;
  border-radius:8px;
  box-shadow: 0 6px 20px rgba(10,20,40,0.03);
  border: 1px solid #eef3f8;
}

/* employee photo styling — square, full-fit for clear image */
.modal-image {
  width: 250px;
  height: 270px;
  object-fit: cover;         /* ensures the image fully fills and is cropped nicely */
  border-radius: 2px;        /* square corners with slight rounding */
  border: 0px solid #fff;    /* inner white ring for separation */
  box-shadow: 0 6px 22px rgba(2,6,23,0.12);
  display:block;
  image-rendering: auto;     /* keep smoothing for photos */
}

/* yellow outer ring wrapper adapted for square */
.image-wrap {
  width: 250px;
  height: 270px;
  border-radius: 0px;
  display:flex;
  align-items:center;
  justify-content:center;
  background: linear-gradient(180deg, rgba(255,212,66,0.98), rgba(255,212,66,0.85));
  padding:0px; /* outer ring */
  box-sizing: content-box;
}
.modal-image-placeholder {
  width:250px;
  height:270px;
  display:flex;
  align-items:center;
  justify-content:center;
  color:#64748b;
  background:#f3f4f6;
  border-radius:1px;
  border:1px dashed #e6edf3;
  font-weight:600;
}

/* details column — smaller, tighter typography */
.modal-details { padding:6px 4px; }
.emp-name {
  font-size:16px;        /* reduced from 20 */
  font-weight:700;
  color:#0f172a;
  margin-bottom:6px;
}
.emp-meta {
  display:flex;
  flex-direction:column;
  gap:6px;
  color:#12263b;
  font-weight:600;
  font-size:13px;        /* slightly smaller */
}
.meta-row { display:flex; gap:8px; align-items:center; }
.meta-label { min-width:100px; color:var(--muted); font-weight:700; font-size:13px; }
.meta-value { color:#0b1720; font-weight:700; font-size:13px; }

/* reasons/why column compact + scrollable but hide scrollbar */
.modal-reasons {
  padding:6px;
  border-radius:8px;
  background: linear-gradient(180deg,#fbfdff,#f8fafc);
  border: 1px solid #eef3f8;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.reasons-title { font-weight:700; margin-bottom:6px; color:#0f172a; font-size:14px; }
.reasons-list {
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  max-height:72px;        /* compact area for chips */
  overflow:auto;
  padding-right:6px;
  font-size:12px;
}
.why-box {
  margin-top:0;
  background: linear-gradient(180deg,#fff,#fff);
  padding:8px;
  border-radius:8px;
  border-left: 4px solid var(--wu-yellow);
  box-shadow: 0 6px 18px rgba(2,6,23,0.03);
  max-height:140px;       /* reduced height */
  overflow:auto;
  padding-right:8px;
  font-size:13px;
  line-height:1.25;
}
.why-item { margin-bottom:8px; }
.why-item b { display:block; font-weight:700; margin-bottom:4px; color:#0b1720; font-size:13px; }
.why-item .small { color:#475569; font-weight:600; font-size:12px; }

/* hide scrollbars for reasons and why-box (cross-browser) */
.reasons-list, .why-box {
  -ms-overflow-style: none;  /* IE/Edge */
  scrollbar-width: none;     /* Firefox */
}
.reasons-list::-webkit-scrollbar, .why-box::-webkit-scrollbar { display:none; width:0; height:0; }

/* small tweak: slightly smaller chips for compact layout */
.pill, .chip { line-height:1; }

/* responsive adjustments */
@media (max-width: 1100px) {
  .modal-top { grid-template-columns: 180px 1fr 300px; }
  .image-wrap { width:188px; height:188px; }
  .modal-image { width:180px; height:180px; border-radius:6px; }
  .modal-image-placeholder { width:180px; height:180px; border-radius:6px; }
}
@media (max-width: 860px) {
  .modal-inner { width:92%; height:82vh; }
  .modal-top { grid-template-columns: 1fr; gap:12px; }
  .image-wrap { justify-content:flex-start; }
}





      /* smaller text */
      .muted { color:var(--muted); font-size:13px; }
      .small { font-size:13px; color:var(--muted); }

      /* evidence table styles & highlight classes */
      .evidence-table { width:100%; border-collapse:collapse; margin-top:8px; }
      .evidence-table th, .evidence-table td { padding:8px 10px; border:1px solid #e6edf3; font-size:13px; text-align:left; vertical-align:middle; }
      .gap-flag { background:#fff5f0; color:#9a3412; padding:4px 6px; border-radius:6px; display:inline-block; margin-left:8px; font-weight:600; }

      /* Highlights requested by user */
      .row-day-start { background: linear-gradient(90deg,#eefbe8,#f7ffef); }
      .row-out-return { background: linear-gradient(90deg,#fff0f0,#fff6f6); }
      .row-out { background: linear-gradient(90deg,#fff7ed,#fffdf8); }
      .highlight-long-duration { outline: 2px solid rgba(239,68,68,0.12); }

      /* Loading overlay */
      .spinner-overlay { position: fixed; inset: 0; background: rgba(255,255,255,0.65); z-index: 2000; display:flex; align-items:center; justify-content:center; backdrop-filter: blur(2px); }
      .spinner-box { display:flex; gap:12px; align-items:center; background:#fff; padding:14px 18px; border-radius:10px; box-shadow: 0 10px 30px rgba(2,6,23,0.15); border: 1px solid #e6edf3; }
      .spinner { width:28px; height:28px; border-radius:50%; border:4px solid #e6e6e6; border-top-color:var(--accent); animation: spin 1s linear infinite; }
      @keyframes spin { 100% { transform: rotate(360deg); } }

      .evidence-btn { padding:7px 10px; background:#0ea5a4; color:#fff; border-radius:6px; border:0; cursor:pointer; }
      .small-button { padding:6px 8px; font-size:12px; border-radius:6px; border:1px solid #e2e8f0; background:transparent; cursor:pointer; }

      .table-scroll { overflow:auto; max-width:100%; }

      /* ---------- Responsive ---------- */
      @media (max-width: 1100px) {
        .modal-top { grid-template-columns: 180px 1fr 300px; }
        .image-wrap { width:196px; height:196px; }
        .modal-image { width: 188px; height:188px; }
      }
      @media (max-width: 860px) {
        .modal-inner { width:92%; height:82vh; }
        .modal-top { grid-template-columns: 1fr; gap:12px; }
        .image-wrap { justify-content:flex-start; }
      }

      /* calendar input tweaks */
      .date-input { padding: 4px 6px; font-size: 12px; border-radius: 4px; min-width: 110px; background: #ffd700; color: #000; border: 1px solid #b89f00; }
      .flatpickr-calendar { font-size: 12px; transform: scale(0.9); transform-origin: top left; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      (function(){
        const { useState, useEffect, useRef } = React;

        // CHANGE THIS IF YOUR API HOST DIFFERS
        const API_BASE = "http://localhost:8002";

        // Threshold used to detect "long out then return" pattern (seconds)
        const OUT_RETURN_GAP_SECONDS = 60 * 60; // 1 hour (tweak if you want)

        const SCENARIO_EXPLANATIONS = {
          "long_gap_>=90min": "Long gap between swipes (>= 90 minutes) — could indicate long out-of-office break.",
          "short_duration_<4h": "Short total duration in office (< 4 hours).",
          "coffee_badging": "Frequent short badge cycles (>=4) with short duration — possible 'coffee badging'.",
          "low_swipe_count_<=2": "Low swipe count (<=2) for the day.",
          "single_door": "All swipes used the same door — single-door behavior.",
          "only_in": "Only IN swipe(s) recorded for the day.",
          "only_out": "Only OUT swipe(s) recorded for the day.",
          "overtime_>=10h": "Long duration (>=10 hours) — overtime.",
          "very_long_duration_>=16h": "Very long duration (>=16 hours) — suspiciously long presence.",
          "zero_swipes": "No swipes recorded.",
          "unusually_high_swipes": "Unusually high number of swipes versus historical median.",
          "repeated_short_breaks": "Multiple short breaks within the day.",
          "multiple_location_same_day": "Swipes recorded at multiple locations same day.",
          "weekend_activity": "Activity recorded on weekend.",
          "repeated_rejection_count": "Several card rejections.",
          "badge_sharing_suspected": "Badge sharing suspected (same card used by multiple persons on same day).",
          "early_arrival_before_06": "First swipe before 06:00.",
          "late_exit_after_22": "Last swipe after 22:00.",
          "shift_inconsistency": "Duration inconsistent with historical shift patterns.",
          "trending_decline": "Historical trending decline flagged.",
          "consecutive_absent_days": "Marked absent for consecutive days historically.",
          "high_variance_duration": "High variance in durations historically.",
          "short_duration_on_high_presence_days": "Short duration even though employee usually attends many days.",
          "swipe_overlap": "Simultaneous swipe(s) near the same time with other uid(s) (possible tailgating or collusion).",
          "shortstay_longout_repeat": "Pattern: short stay, long out-of-office, short return (repeat)."
        };

        function pad(n){ return n.toString().padStart(2,'0'); }
        function formatDateISO(d){
          if(!d) return "";
          const dt = (d instanceof Date) ? d : new Date(d);
          return dt.getFullYear() + "-" + pad(dt.getMonth()+1) + "-" + pad(dt.getDate());
        }
        function datesBetween(start, end){
          var out = [];
          var cur = new Date(start);
          while(cur <= end){
            out.push(new Date(cur));
            cur.setDate(cur.getDate()+1);
          }
          return out;
        }
        function safeDateDisplay(val){
          if(!val && val !== 0) return "";
          try {
            var d = (val instanceof Date) ? val : new Date(val);
            if(isNaN(d.getTime())) return String(val);
            return d.toLocaleString();
          } catch(e) {
            return String(val);
          }
        }
        function sanitizeName(row){
          return row.EmployeeName || row.EmployeeName_x || row.EmployeeName_y || row.person_uid || "";
        }
        function downloadCSV(rows, filename){
          if(!rows || !rows.length) { alert("No rows to export"); return; }
          var cols = Object.keys(rows[0]);
          var lines = [cols.join(",")];
          rows.forEach(function(r){
            var row = cols.map(function(c){
              var v = (r[c] === undefined || r[c] === null) ? "" : String(r[c]).replace(/\n/g,' ');
              return JSON.stringify(v);
            }).join(",");
            lines.push(row);
          });
          var blob = new Blob([lines.join("\n")], {type:'text/csv'});
          var url = URL.createObjectURL(blob);
          var a = document.createElement('a'); a.href = url; a.download = filename || 'export.csv'; a.click(); URL.revokeObjectURL(url);
        }

        // convert seconds -> "HH:mm:ss"
        function formatSecondsToHmsJS(seconds){
          if (seconds === null || seconds === undefined || seconds === '') return "-";
          const n = Number(seconds);
          if (isNaN(n) || !isFinite(n)) return "-";
          const s = Math.max(0, Math.floor(n));
          const hh = Math.floor(s / 3600);
          const mm = Math.floor((s % 3600) / 60);
          const ss = s % 60;
          return pad(hh) + ":" + pad(mm) + ":" + pad(ss);
        }

        function App(){
          var yesterday = new Date();
          yesterday.setDate(yesterday.getDate()-1);

          const [dateFrom, setDateFrom] = useState(formatDateISO(yesterday));
          const [dateTo, setDateTo] = useState(formatDateISO(new Date()));
          const [loading, setLoading] = useState(false);
          const [summary, setSummary] = useState({rows:0, flagged_rows:0, files:[], end_date:null});
          const [rows, setRows] = useState([]);
          const [reasonsCount, setReasonsCount] = useState({});
          const [filterText, setFilterText] = useState("");
          const [page, setPage] = useState(1);
          const [selectedReason, setSelectedReason] = useState("");
          const [reasonFilterText, setReasonFilterText] = useState("");
          const [modalRow, setModalRow] = useState(null);
          const [modalDetails, setModalDetails] = useState(null); // {aggregated_rows, raw_swipes, raw_swipe_files}
          const [modalLoading, setModalLoading] = useState(false);
          const pageSize = 25;
          const chartRef = useRef(null);
          const chartInst = useRef(null);

          // flatpickr refs
          const fromRef = useRef(null);
          const toRef = useRef(null);
          const fromFp = useRef(null);
          const toFp = useRef(null);

          useEffect(function(){
            if(window.flatpickr && fromRef.current && toRef.current){
              try { if(fromFp.current) fromFp.current.destroy(); } catch(e){}
              try { if(toFp.current) toFp.current.destroy(); } catch(e){}
              fromFp.current = window.flatpickr(fromRef.current, {
                dateFormat: "Y-m-d",
                defaultDate: dateFrom,
                allowInput: true,
                onChange: function(selectedDates, str){
                  if(selectedDates && selectedDates.length){
                    const iso = formatDateISO(selectedDates[0]);
                    setDateFrom(iso);
                    try { if(toFp.current) toFp.current.set('minDate', iso); } catch(e){}
                    if(dateTo && new Date(iso) > new Date(dateTo)){
                      setDateTo(iso);
                      try{ if(toFp.current) toFp.current.setDate(iso, true); }catch(e){}
                    }
                  }
                }
              });
              toFp.current = window.flatpickr(toRef.current, {
                dateFormat: "Y-m-d",
                defaultDate: dateTo,
                allowInput: true,
                onChange: function(selectedDates, str){
                  if(selectedDates && selectedDates.length){
                    const iso = formatDateISO(selectedDates[0]);
                    setDateTo(iso);
                    try { if(fromFp.current) fromFp.current.set('maxDate', iso); } catch(e){}
                    if(dateFrom && new Date(iso) < new Date(dateFrom)){
                      setDateFrom(iso);
                      try{ if(fromFp.current) fromFp.current.setDate(iso, true); }catch(e){}
                    }
                  }
                }
              });
              try { if(fromFp.current) fromFp.current.set('maxDate', dateTo); if(toFp.current) toFp.current.set('minDate', dateFrom); } catch(e){}
            }
            loadLatest();
            return function(){ try{ if(fromFp.current) fromFp.current.destroy(); } catch(e){} try{ if(toFp.current) toFp.current.destroy(); } catch(e){} };
            // eslint-disable-next-line
          }, []);

          useEffect(function(){
            try { if(fromFp.current && dateFrom) fromFp.current.setDate(dateFrom, false); } catch(e){}
            try { if(toFp.current && dateTo) toFp.current.setDate(dateTo, false); } catch(e){}
            try { if(fromFp.current) fromFp.current.set('maxDate', dateTo); } catch(e){}
            try { if(toFp.current) toFp.current.set('minDate', dateFrom); } catch(e){}
          }, [dateFrom, dateTo]);

          async function runForRange(){
            setLoading(true);
            setRows([]); setSummary({rows:0, flagged_rows:0, files:[], end_date:null}); setReasonsCount({});
            try {
              var start = new Date(dateFrom);
              var end = new Date(dateTo);
              var dateList = datesBetween(start, end).map(d => formatDateISO(d));
              var accRows = []; var totalRows = 0, totalFlagged = 0, files = [];
              for(var i=0;i<dateList.length;i++){
                var d = dateList[i];
                var url = API_BASE + "/run?date=" + d;
                var r = await fetch(url, { method:'GET' });
                if(!r.ok){ var txt = await r.text(); throw new Error("API returned " + r.status + ": " + txt); }
                var js = await r.json();
                var sample = js.sample || [];
                if(Array.isArray(sample) && sample.length) accRows = accRows.concat(sample);
                if(typeof js.rows === 'number') totalRows += js.rows; else totalRows += (Array.isArray(sample) ? sample.length : 0);
                totalFlagged += (js.flagged_rows || 0);
                if(js.files) files = files.concat(js.files);
              }
              setRows(accRows);
              setSummary({rows: totalRows, flagged_rows: totalFlagged, files: files, end_date: formatDateISO(new Date(dateTo))});
              computeReasons(accRows);
              setPage(1);
            } catch(err){
              alert("Error: " + err.message);
              console.error(err);
            } finally { setLoading(false); }
          }

          async function loadLatest(){
            setLoading(true);
            try{
              var r = await fetch(API_BASE + "/latest");
              if(!r.ok) throw new Error("latest failed: " + r.status);
              var js = await r.json();
              var sample = js.sample || [];
              if(!Array.isArray(sample)) sample = [];
              setRows(sample);
              setSummary({rows: (js.rows || sample.length || 0), flagged_rows: (sample.filter(function(x){ return !!x.Reasons; }).length || 0), files:[js.file]});
              computeReasons(sample);
              setPage(1);
            } catch(err){
              alert("Error: " + err.message + (err.message === 'latest failed: 0' ? " (check backend/CORS)" : ""));
              console.error(err);
            } finally { setLoading(false); }
          }

          function computeReasons(dataRows){
            var counts = {};
            (dataRows || []).forEach(function(r){
              if(!r.Reasons) return;
              var parts = String(r.Reasons).split(";").map(function(s){ return s.trim(); }).filter(Boolean);
              parts.forEach(function(p){ counts[p] = (counts[p] || 0) + 1; });
            });
            setReasonsCount(counts);
            buildChart(counts);
          }

          function buildChart(counts){
            var labels = Object.keys(counts).sort(function(a,b){ return counts[b] - counts[a]; });
            var values = labels.map(function(l){ return counts[l]; });
            var ctx = chartRef.current && chartRef.current.getContext ? chartRef.current.getContext('2d') : null;
            if(!ctx) return;
            try { if(chartInst.current) chartInst.current.destroy(); } catch(e){}
            chartInst.current = new Chart(ctx, {
              type:'bar',
              data:{ labels: labels, datasets:[{ label:'Events', data: values, backgroundColor: labels.map(()=> 'rgba(37,99,235,0.85)') }] },
              options:{ responsive:true, maintainAspectRatio:false, plugins:{ legend:{ display:false } }, scales:{ y:{ beginAtZero:true } } }
            });
          }

          // filtering & pagination
          var filtered = (rows || []).filter(function(r){
            var hay = (sanitizeName(r) + " " + (r.EmployeeID||"") + " " + (r.CardNumber||"") + " " + (r.Reasons||"")).toLowerCase();
            var textOk = !filterText || hay.indexOf(filterText.toLowerCase()) !== -1;
            var reasonOk = !selectedReason || (r.Reasons && ((";" + String(r.Reasons) + ";").indexOf(selectedReason) !== -1));
            return textOk && reasonOk;
          });
          var totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
          var pageRows = filtered.slice((page-1)*pageSize, page*pageSize);

          function exportFiltered(){ downloadCSV(filtered, "trend_filtered_export.csv"); }

          function onReasonClick(reason){
            if(!reason) { setSelectedReason(""); return; }
            if(selectedReason === reason) setSelectedReason(""); else setSelectedReason(reason);
            setPage(1);
          }

          // open evidence modal (explicit Evidence button)
          async function openEvidence(row){
            setModalRow(row);
            setModalDetails(null);
            setModalLoading(true);
            try {
              const q = encodeURIComponent(row.EmployeeID || row.person_uid || "");
              const resp = await fetch(API_BASE + "/record?employee_id=" + q);
              if(!resp.ok){ const txt = await resp.text(); throw new Error("record failed: " + resp.status + " - " + txt); }
              const js = await resp.json();
              const details = { aggregated_rows: js.aggregated_rows || [], raw_swipe_files: js.raw_swipe_files || [], raw_swipes: js.raw_swipes || [] };
              setModalDetails(details);
            } catch(e){
              alert("Failed loading details: " + e.message);
              console.error(e);
            } finally { setModalLoading(false); }
          }

          function closeModal(){ setModalRow(null); setModalDetails(null); }

          var rowsCount = (summary && typeof summary.rows === 'number') ? summary.rows : (rows ? rows.length : 0);
          var flaggedCount = (summary && typeof summary.flagged_rows === 'number') ? summary.flagged_rows : (rows ? rows.filter(function(r){ return !!r.Reasons; }).length : 0);
          var flaggedPct = rowsCount ? Math.round((flaggedCount*100)/(rowsCount||1)) : 0;

          function renderOverlapCell(r){
            var ov = r.OverlapWith || r.swipe_overlap || r.overlap_with || null;
            if(ov && typeof ov === 'string'){
              var parts = ov.split(";").map(function(s){ return s.trim(); }).filter(Boolean);
              if(parts.length === 0) return <span className="muted">—</span>;
              return <span className="pill" title={ov}>{parts.length} overlap</span>;
            }
            return <span className="muted">—</span>;
          }

          function renderReasonChips(reasonText){
            if(!reasonText) return <span className="muted">—</span>;
            const parts = String(reasonText).split(";").map(s=>s.trim()).filter(Boolean);
            return parts.map((p,idx)=>(<span key={idx} className="pill" title={SCENARIO_EXPLANATIONS[p] || p}>{p}</span>));
          }

          function renderReasonExplanations(reasonText){
            if(!reasonText) return <div className="muted">No flags</div>;
            const parts = String(reasonText).split(";").map(s=>s.trim()).filter(Boolean);
            return (
              <div>
                {parts.map((p,idx)=>(
                  <div key={idx} className="why-item">
                    <b>{p}</b>
                    <div className="small">{ SCENARIO_EXPLANATIONS[p] || "No explanation available." }</div>
                  </div>
                ))}
              </div>
            );
          }

          // render timeline with requested highlights:
          function renderSwipeTimeline(details, modalRow){
            if(!details || !details.raw_swipes || details.raw_swipes.length === 0){
              return <div className="muted">No raw swipe evidence available (person not flagged or raw file missing).</div>;
            }
            const all = details.raw_swipes.slice().map(r => {
              const obj = Object.assign({}, r);
              try {
                if(obj.Date && obj.Time){ obj.__ts = new Date(obj.Date + "T" + obj.Time); }
                else if(obj.Date && obj.Time === undefined && obj.LocaleMessageTime){ obj.__ts = new Date(obj.LocaleMessageTime); }
                else if(obj.LocaleMessageTime){ obj.__ts = new Date(obj.LocaleMessageTime); }
                else { obj.__ts = null; }
              } catch(e){ obj.__ts = null; }
              let gap = null;
              if(obj.SwipeGapSeconds !== undefined && obj.SwipeGapSeconds !== null){ gap = Number(obj.SwipeGapSeconds); if(isNaN(gap)) gap = null; }
              else if(obj.SwipeGap){
                try { const parts = String(obj.SwipeGap).split(':').map(p=>Number(p)); if(parts.length===3) gap = parts[0]*3600 + parts[1]*60 + parts[2]; } catch(e){ gap = null; }
              }
              obj.__gap = gap;
              obj.__zone_l = String((obj.Zone || '')).toLowerCase();
              return obj;
            }).sort((a,b) => {
              if(a.__ts && b.__ts) return a.__ts - b.__ts;
              if(a.__ts) return -1;
              if(b.__ts) return 1;
              return 0;
            });

            const flags = new Array(all.length).fill({}).map(()=>({dayStart:false, outReturn:false}));
            for(let i=0;i<all.length;i++){
              const cur = all[i]; const prev = all[i-1];
              try {
                const curDate = cur.Date ? cur.Date.slice(0,10) : (cur.__ts ? cur.__ts.toISOString().slice(0,10) : null);
                const prevDate = prev ? (prev.Date ? prev.Date.slice(0,10) : (prev.__ts ? prev.__ts.toISOString().slice(0,10) : null)) : null;
                if(!prev || prevDate !== curDate){ flags[i].dayStart = true; }
              } catch(e){}
            }
            for(let i=0;i<all.length-1;i++){
              const a = all[i], b = all[i+1];
              const aZone = a.__zone_l || ''; const bZone = b.__zone_l || ''; const bGap = b.__gap || 0;
              if(aZone.includes('out of office') || aZone.includes('out_of_office') || aZone.includes('out of') ){
                if(!bZone.includes('out of office') && (bGap >= OUT_RETURN_GAP_SECONDS || bGap === null && aZone.includes('out'))){
                  flags[i].outReturn = true; flags[i+1].outReturn = true;
                }
              }
            }

            return (
              <div className="table-scroll">
                <table className="evidence-table" role="table" aria-label="Swipe timeline">
                  <thead>
                    <tr>
                      <th>Employee Name</th>
                      <th>Employee ID</th>
                      <th>Card</th>
                      <th>Date</th>
                      <th>Time</th>
                      <th>SwipeGap</th>
                      <th>Door</th>
                      <th>Direction</th>
                      <th>Zone</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    { all.map((rObj, idx) => {
                        const r = rObj || {};
                        const g = r.__gap;
                        const gapFormatted = (r.SwipeGap && String(r.SwipeGap).trim()) ? String(r.SwipeGap) : (g !== null && g !== undefined) ? formatSecondsToHmsJS(g) : "-";
                        const cls = [];
                        if(flags[idx].dayStart) cls.push('row-day-start');
                        if(flags[idx].outReturn) cls.push('row-out-return');
                        if(g && g >= OUT_RETURN_GAP_SECONDS) cls.push('highlight-long-duration');
                        return (
                          <tr key={idx} className={cls.join(' ')}>
                            <td className="small">{ r.EmployeeName || '-' }</td>
                            <td className="small">{ r.EmployeeID || '-' }</td>
                            <td className="small">{ r.CardNumber || r.Card || '-' }</td>
                            <td className="small">{ r.Date || '-' }</td>
                            <td className="small">{ r.Time || (r.__ts ? r.__ts.toTimeString().slice(0,8) : '-') }</td>
                            <td className="small">{ gapFormatted }</td>
                            <td className="small" style={{minWidth:160}}>{ r.Door || '-' }</td>
                            <td className="small">{ r.Direction || '-' }</td>
                            <td className="small">{ r.Zone || '-' }</td>
                            <td className="small">{ r.Note || '-' }{ r._source ? <span className="muted"> ({r._source})</span> : null }</td>
                          </tr>
                        );
                      })
                    }
                  </tbody>
                </table>
              </div>
            );
          }

          return (
            <div className="container" aria-live="polite">
              { loading && (
                <div className="spinner-overlay" role="status" aria-label="Loading">
                  <div className="spinner-box">
                    <div className="spinner" />
                    <div style={{fontWeight:700}}>Loading…</div>
                  </div>
                </div>
              ) }

              <div className="topbar" role="banner">
                <div className="wu-brand" aria-hidden={false}>
                  <div className="wu-logo">WU</div>
                  <div className="title-block">
                    <h1>Western Union — Trend Analysis</h1>
                    <p>Pune</p>
                  </div>
                </div>

                <div className="header-actions" role="region" aria-label="controls">
                  <div className="control">
                    <label className="small" htmlFor="fromDate">From</label>
                    <input id="fromDate" ref={fromRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                  </div>

                  <div className="control">
                    <label className="small" htmlFor="toDate">To</label>
                    <input id="toDate" ref={toRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                  </div>

                  <button className="btn-primary" onClick={runForRange} disabled={loading}>Run</button>
                  <button className="btn-ghost" onClick={loadLatest} disabled={loading}>Load latest</button>
                </div>
              </div>

              <div className="card-shell">
                <div className="cards" aria-hidden={loading}>
                  <div className="card" title="Rows analysed">
                    <h3>{ (rowsCount !== undefined && rowsCount !== null) ? rowsCount : 0 }</h3>
                    <p>Rows analysed</p>
                  </div>
                  <div className="card" title="Flagged rows">
                    <h3>{ (flaggedCount !== undefined && flaggedCount !== null) ? flaggedCount : 0 }</h3>
                    <p>Flagged rows</p>
                  </div>
                  <div className="card" title="Flagged rate">
                    <h3>{ flaggedPct }%</h3>
                    <p>Flagged rate</p>
                  </div>
                </div>

                <div className="main">
                  <div className="left">
                    <div className="chart-wrap">
                      <canvas ref={chartRef}></canvas>
                    </div>

                    <div style={{display:'flex',alignItems:'center',gap:8, marginTop:6}}>
                      <input placeholder="Search name, employee id, card or reason..." value={filterText} onChange={function(e){ setFilterText(e.target.value); setPage(1); }} style={{flex:1,padding:10,borderRadius:6,border:'1px solid #e6edf3'}} />
                      <div className="muted">Showing { filtered.length } / { rows.length } rows</div>
                      <button className="small-button" onClick={exportFiltered}>Export filtered</button>
                    </div>

                    <div style={{marginTop:10}} className="table-scroll" role="region" aria-label="results table">
                      <table>
                        <thead>
                          <tr>
                            <th>Employee</th>
                            <th className="small">ID</th>
                            <th className="small">Card</th>
                            <th className="small">Date</th>
                            <th className="small">Duration</th>
                            <th className="small">Reasons</th>
                            <th className="small">Overlap</th>
                            <th className="small">Evidence</th>
                          </tr>
                        </thead>
                        <tbody>
                          { pageRows.map(function(r, idx){
                              var empName = sanitizeName(r);
                              var displayDate = safeDateDisplay(r.Date || r.FirstSwipe || r.LastSwipe);
                              var durText = r.Duration || (r.DurationMinutes ? Math.round(r.DurationMinutes) + " min" : "");
                              var flagged = r.Reasons && String(r.Reasons).trim();
                              return (
                                <tr key={idx} className={ flagged ? "flagged-row" : "" }>
                                  <td className="row-click" onClick={function(){ openEvidence(r); }}>{ empName || <span className="muted">—</span> }</td>
                                  <td className="small">{ r.EmployeeID || "" }</td>
                                  <td className="small">{ r.CardNumber || "" }</td>
                                  <td className="small">{ displayDate }</td>
                                  <td className="small">{ durText }</td>
                                  <td className="small">{ renderReasonChips(r.Reasons) }</td>
                                  <td className="small">{ renderOverlapCell(r) }</td>
                                  <td className="small">
                                    <button className="evidence-btn" onClick={function(){ openEvidence(r); }}>Evidence</button>
                                  </td>
                                </tr>
                            );
                          }) }
                        </tbody>
                      </table>
                    </div>

                    <div style={{display:'flex', gap:8, alignItems:'center', marginTop:10}}>
                      <button onClick={function(){ setPage(function(p){ return Math.max(1,p-1); }); }} disabled={page<=1}>Prev</button>
                      <div className="muted">Page { page } / { totalPages }</div>
                      <button onClick={function(){ setPage(function(p){ return Math.min(totalPages,p+1); }); }} disabled={page>=totalPages}>Next</button>
                    </div>
                  </div>

                  <aside className="right" aria-label="side panel">
                    <div style={{marginBottom:12}}>
                      <strong>Files:</strong>
                      <div className="muted" style={{marginTop:6}}>{ (summary.files || []).join(", ") }</div>
                    </div>

                    <div style={{marginBottom:12}}>
                      <strong>Top reasons summary</strong>
                      <div className="small muted" style={{marginTop:6}}>Click a reason to filter the table by that reason. Click again to clear.</div>

                      <div style={{marginTop:8, display:'flex', gap:8}}>
                        <input placeholder="Filter reason list..." value={reasonFilterText} onChange={function(e){ setReasonFilterText(e.target.value); }} style={{flex:1, padding:'6px 8px', borderRadius:6, border:'1px solid #e2e8f0'}} />
                        <button className="small-button" onClick={function(){ setSelectedReason(''); setReasonFilterText(''); }}>Clear</button>
                      </div>

                      <div style={{marginTop:8, maxHeight:320, overflow:'auto'}}>
                        { Object.keys(reasonsCount).length === 0 && <div className="muted">No flags found</div> }
                        { Object.entries(reasonsCount).sort(function(a,b){ return b[1]-a[1]; }).filter(function(kv){
                            var name = kv[0];
                            if(!reasonFilterText) return true;
                            return name.toLowerCase().indexOf(reasonFilterText.toLowerCase()) !== -1;
                          }).slice(0, 50).map(function(kv){
                            var name = kv[0], count = kv[1];
                            var active = selectedReason === name;
                            return (
                              <div key={name} style={{display:'flex', alignItems:'center', justifyContent:'space-between', gap:8, marginBottom:6}}>
                                <button className={ "chip " + (active ? "active" : "") } style={{textAlign:'left', flex:1}} onClick={function(){ onReasonClick(name); }}>
                                  {name}
                                </button>
                                <div style={{minWidth:48, textAlign:'right'}} className="small"><b>{count}</b></div>
                              </div>
                            );
                          }) }
                      </div>
                    </div>
                  </aside>
                </div>
              </div>

              { modalRow &&
                <div className="modal" onClick={closeModal}>
                  <div className="modal-inner" onClick={function(e){ e.stopPropagation(); }}>
                    <div className="modal-header">
                      <h3>Details — Evidence</h3>
                      <div style={{display:'flex',alignItems:'center',gap:8}}>
                        <button className="close-btn" onClick={closeModal}>Close</button>
                      </div>
                    </div>

                    <div className="modal-body">
                      { modalLoading && <div className="muted">Loading evidence…</div> }

                      <div className="modal-top" role="region" aria-label="evidence summary">
                        {/* Column 1 - Image (wrap to create yellow ring) */}
                        <div style={{display:'flex',alignItems:'center',justifyContent:'center'}}>
                          <div className="image-wrap">
                            { (modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows.length > 0) ? (
                              (() => {
                                const md = modalDetails.aggregated_rows[0];
                                if(md && md.imageUrl) {
                                  return <img className="modal-image" src={ API_BASE + md.imageUrl } alt="Employee" onError={(e)=>{ e.target.style.display='none'; }} />;
                                } else {
                                  return <div className="modal-image-placeholder">No image</div>;
                                }
                              })()
                            ) : (
                              <div className="modal-image-placeholder">—</div>
                            ) }
                          </div>
                        </div>

                        {/* Column 2 - Employee details */}
                        <div className="modal-details">
                          <div className="emp-name">{ sanitizeName(modalRow) || "—" }</div>
                          <div className="emp-meta">
                            <div className="meta-row"><div className="meta-label">Employee ID</div><div className="meta-value">{ modalRow.EmployeeID || "—" }</div></div>
                            <div className="meta-row"><div className="meta-label">Card</div><div className="meta-value">{ modalRow.CardNumber || "—" }</div></div>
                            <div className="meta-row"><div className="meta-label">Employee Email</div><div className="meta-value">{ (modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0] && modalDetails.aggregated_rows[0].EmployeeEmail) ? modalDetails.aggregated_rows[0].EmployeeEmail : <span className="muted">—</span> }</div></div>
                            <div className="meta-row"><div className="meta-label">Date</div><div className="meta-value">{ safeDateDisplay(modalRow.Date || modalRow.FirstSwipe) }</div></div>
                            <div className="meta-row"><div className="meta-label">Duration</div><div className="meta-value">{ modalRow.Duration || (modalRow.DurationMinutes ? Math.round(modalRow.DurationMinutes) + " min" : "—") }</div></div>
                          </div>
                        </div>

                        {/* Column 3 - Reasons & Why highlighted (compact, scrollable, no scrollbar) */}
                        <div className="modal-reasons">
                          <div className="reasons-title">Reasons</div>
                          <div className="reasons-list">
                            { renderReasonChips(modalRow.Reasons) }
                          </div>

                          <div className="why-box">
                            <div style={{fontWeight:800, marginBottom:8}}>Why highlighted</div>
                            <div>
                              { renderReasonExplanations(modalRow.Reasons) }
                            </div>
                          </div>
                        </div>
                      </div>

                      <hr style={{marginTop:18, marginBottom:14}} />

                      <h4>Available evidence files</h4>
                      <div style={{marginTop:8}}>
                        { modalDetails && modalDetails.raw_swipe_files && modalDetails.raw_swipe_files.length > 0
                          ? <div>
                              <ul>
                                { modalDetails.raw_swipe_files.map((f,i)=>(
                                  <li key={i}><b>{f}</b> — <button onClick={function(){ window.location = API_BASE + "/swipes/" + encodeURIComponent(f); }}>Download</button></li>
                                )) }
                              </ul>
                            </div>
                          : <div className="muted">No raw swipe files found for this person/date.</div>
                        }
                      </div>

                      <div style={{marginTop:12}}>
                        <strong>Swipe timeline (filtered for this person/date)</strong>
                        <div style={{marginTop:8}}>
                          { modalDetails ? renderSwipeTimeline(modalDetails, modalRow) : <div className="muted">Evidence not loaded yet.</div> }
                        </div>
                      </div>

                      <hr/>
                      <div style={{marginTop:8}}>
                        <label><input type="checkbox" id="showraw" onChange={function(e){
                          const el = document.getElementById('rawpayload');
                          if(el) el.style.display = e.target.checked ? 'block' : 'none';
                        }} /> Show raw aggregated JSON</label>
                        <div id="rawpayload" style={{display:'none', marginTop:8}}><pre>{ JSON.stringify(modalRow, null, 2) }</pre></div>
                      </div>
                    </div>

                  </div>
                </div>
              }
            </div>
          );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
      })();
    </script>
  </body>
</html>





****************************************************************
****************************************************************



#  # backend/duration_report.py
# from __future__ import annotations

# import logging
# import os
# import re
# import warnings
# from datetime import date, datetime, timedelta
# from pathlib import Path
# from typing import Optional, List, Dict, Any

# import pandas as pd

# try:
#     import pyodbc
# except Exception:
#     pyodbc = None

# # ODBC driver name (override with environment variable if needed)
# ODBC_DRIVER = os.getenv("ODBC_DRIVER", "ODBC Driver 17 for SQL Server")

# # REGION configuration - databases list used to build UNION queries
# REGION_CONFIG = {
#     "apac": {
#         "user": "GSOC_Test",
#         "password": "Westernccure@2025",
#         "server": "SRVWUPNQ0986V",
#         "databases": [
#             "ACVSUJournal_00010030","ACVSUJournal_00010029","ACVSUJournal_00010028",
#             "ACVSUJournal_00010027","ACVSUJournal_00010026","ACVSUJournal_00010025"
#         ],
#         "partitions": ["APAC.Default", "JP.Tokyo", "PH.Manila", "MY.Kuala Lumpur", "IN.HYD"]
#     },
#     "emea": {
#         "user": "GSOC_Test",
#         "password": "Westernccure@2025",
#         "server": "SRVWUFRA0986V",
#         "databases": [
#             "ACVSUJournal_00011029","ACVSUJournal_00011028","ACVSUJournal_00011027",
#             "ACVSUJournal_00011026","ACVSUJournal_00011025","ACVSUJournal_00011024",
#             "ACVSUJournal_00011023"
#         ],
#         "partitions": ["LT.Vilnius", "AUT.Vienna", "IE.DUblin", "DU.Abu Dhab", "ES.Madrid"]
#     },
#     "laca": {
#         "user": "GSOC_Test",
#         "password": "Westernccure@2025",
#         "server": "SRVWUSJO0986V",
#         "databases": [
#             "ACVSUJournal_00010030","ACVSUJournal_00010029","ACVSUJournal_00010028",
#             "ACVSUJournal_00010027","ACVSUJournal_00010026","ACVSUJournal_00010025"
#         ],
#         "partitions": ["AR.Cordoba", "BR.Sao Paulo", "CR.Costa Rica Partition", "MX.Mexico City"]
#     },
#     "namer": {
#         "user": "GSOC_Test",
#         "password": "Westernccure@2025",
#         "server": "SRVWUDEN0891V",
#         "databases": [
#             "ACVSUJournal_00010030","ACVSUJournal_00010029","ACVSUJournal_00010028",
#             "ACVSUJournal_00010027","ACVSUJournal_00010026","ACVSUJournal_00010025"
#         ],
#         "partitions": ["Denver", "Austin Texas", "Miami", "New York"],
#         "logical_like": ["%HQ%", "%Austin%", "%Miami%", "%NYC%"]
#     }
# }



# GENERIC_SQL_TEMPLATE = r"""
# SELECT
#     t1.[ObjectName1] AS EmployeeName,
#     t1.[ObjectName2] AS Door,
#     -- prefer contractor text12 else Int1 (match original logic)
#     CASE WHEN t3.[Name] IN ('Contractor','Terminated Contractor') THEN t2.[Text12] ELSE CAST(t2.[Int1] AS NVARCHAR) END AS EmployeeID,
#     t2.[Int1] AS Int1,
#     t2.[Text12] AS Text12,
#     -- expose raw XML & shredded value so downstream code can attempt robust extraction
#     t_xml.XmlMessage AS XmlMessage,
#     sc.value AS XmlShredValue,
#     -- CardNumber: try CHUID/Card inside XmlMessage, fallback to shredded value, then text12/int1
#     COALESCE(
#       TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
#       TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
#       sc.value,
#       NULLIF(CAST(t2.[Int1] AS NVARCHAR),'0'),
#       t2.[Text12]
#     ) AS CardNumber,
#     t3.[Name] AS PersonnelTypeName,
#     t1.ObjectIdentity1 AS EmployeeIdentity,
#     t1.PartitionName2,
#     DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
#     t1.MessageType,
#     t5d.value AS Direction,
#     t2.Text4 AS CompanyName,
#     t2.Text5 AS PrimaryLocation
# FROM [{db}].dbo.ACVSUJournalLog AS t1
# LEFT JOIN ACVSCore.Access.Personnel AS t2 ON t1.ObjectIdentity1 = t2.GUID
# LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeID = t3.ObjectID
# LEFT JOIN [{db}].dbo.ACVSUJournalLogxmlShred t5d
#   ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
# LEFT JOIN [{db}].dbo.ACVSUJournalLogxml t_xml
#   ON t1.XmlGUID = t_xml.GUID
# LEFT JOIN (
#   SELECT GUID, value
#   FROM [{db}].dbo.ACVSUJournalLogxmlShred
#   WHERE Name IN ('Card','CHUID')
# ) AS sc
#   ON t1.XmlGUID = sc.GUID
# WHERE t1.MessageType = 'CardAdmitted'
#   AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) = '{date}'
#   {region_filter}
# """
# # Helpers
# def _split_db_name(dbname: str):
#     m = re.match(r"^(.*?)(\d+)$", dbname)
#     if not m:
#         return dbname, None
#     return m.group(1), m.group(2)

# def _expand_databases_from_base(db_base: str, last_n: int) -> List[str]:
#     prefix, digits = _split_db_name(db_base)
#     if digits is None:
#         return [db_base]
#     width = len(digits)
#     try:
#         cur = int(digits)
#     except Exception:
#         return [db_base]
#     out = []
#     for i in range(last_n):
#         num = cur - i
#         if num < 0:
#             break
#         out.append(f"{prefix}{str(num).zfill(width)}")
#     return out

# def _get_candidate_databases(rc: Dict[str, Any]) -> List[str]:
#     if "databases" in rc and isinstance(rc["databases"], list) and rc["databases"]:
#         return rc["databases"]
#     base_db = rc.get("database")
#     if not base_db:
#         return []
#     last_n = int(rc.get("last_n_databases", 1) or 1)
#     if last_n <= 1:
#         return [base_db]
#     return _expand_databases_from_base(base_db, last_n)

# def _connect_master(rc: Dict[str, Any]):
#     if pyodbc is None:
#         logging.debug("pyodbc not available; cannot connect to master for DB discovery.")
#         return None
#     try:
#         conn_str = (
#             f"DRIVER={{{ODBC_DRIVER}}};"
#             f"SERVER={rc['server']};DATABASE=master;UID={rc['user']};PWD={rc['password']};"
#             "TrustServerCertificate=Yes;"
#         )
#         return pyodbc.connect(conn_str, autocommit=True)
#     except Exception:
#         logging.exception("Failed to connect to master DB for server %s", rc.get("server"))
#         return None

# def _filter_existing_databases(rc: Dict[str, Any], candidates: List[str]) -> List[str]:
#     if not candidates:
#         return []
#     master_conn = _connect_master(rc)
#     if master_conn is None:
#         logging.warning("Unable to validate DB existence (no master connection). Proceeding with candidate list: %s", candidates)
#         return candidates
#     try:
#         exists = []
#         cursor = master_conn.cursor()
#         for db in candidates:
#             try:
#                 cursor.execute("SELECT COUNT(1) FROM sys.databases WHERE name = ?", (db,))
#                 row = cursor.fetchone()
#                 if row and row[0] and int(row[0]) > 0:
#                     exists.append(db)
#             except Exception:
#                 logging.exception("Error checking existence for database %s", db)
#         cursor.close()
#         logging.info("Databases present for server %s: %s", rc.get("server"), exists)
#         return exists if exists else candidates
#     finally:
#         try:
#             master_conn.close()
#         except Exception:
#             pass

# def build_region_query(region_key: str, target_date: date) -> str:
#     rc = REGION_CONFIG[region_key]
#     date_str = target_date.strftime("%Y-%m-%d")
#     region_filter = ""

#     if region_key in ("apac", "emea", "laca"):
#         partitions = rc.get("partitions", [])
#         parts_sql = ", ".join(f"'{p}'" for p in partitions)
#         region_filter = f"AND t1.PartitionName2 IN ({parts_sql})"
#     elif region_key == "namer":
#         likes = rc.get("logical_like", [])
#         like_sql = " OR ".join(f"t1.[ObjectName2] LIKE '{p}'" for p in likes)
#         region_filter = f"AND ({like_sql})"
#     else:
#         region_filter = ""

#     candidates = _get_candidate_databases(rc)
#     if not candidates:
#         candidates = [rc.get("database")]

#     valid_dbs = _filter_existing_databases(rc, candidates)

#     union_parts = []
#     for dbname in valid_dbs:
#         union_parts.append(GENERIC_SQL_TEMPLATE.format(db=dbname, date=date_str, region_filter=region_filter))

#     if not union_parts:
#         dbname = rc.get("database")
#         return GENERIC_SQL_TEMPLATE.format(db=dbname, date=date_str, region_filter=region_filter)

#     sql = "\nUNION ALL\n".join(union_parts)
#     return sql
    
# # DB connection & fetch
# def get_connection(region_key: str):
#     if pyodbc is None:
#         raise RuntimeError("pyodbc is not available. Install it with 'pip install pyodbc'.")

#     rc = REGION_CONFIG[region_key]
#     # use first database in list if present
#     db = rc.get("databases", [rc.get("database")])[0]
#     conn_str = (
#         f"DRIVER={{{ODBC_DRIVER}}};"
#         f"SERVER={rc['server']};DATABASE={db};UID={rc['user']};PWD={rc['password']};"
#         "TrustServerCertificate=Yes;"
#     )
#     return pyodbc.connect(conn_str, autocommit=True)

# def fetch_swipes_for_region(region_key: str, target_date: date) -> pd.DataFrame:
#     sql = build_region_query(region_key, target_date)
#     logging.info("Built SQL for region %s, date %s", region_key, target_date)
#     cols = [
#     "EmployeeName", "Door", "EmployeeID", "Int1", "Text12", "XmlMessage", "XmlShredValue", "CardNumber",
#     "PersonnelTypeName", "EmployeeIdentity", "PartitionName2", "LocaleMessageTime", "MessageType",
#     "Direction", "CompanyName", "PrimaryLocation"
# ]

#     if pyodbc is None:
#         logging.warning("pyodbc not available - returning empty DataFrame skeleton for region %s", region_key)
#         return pd.DataFrame(columns=cols)

#     conn = None
#     try:
#         conn = get_connection(region_key)
#         with warnings.catch_warnings():
#             warnings.filterwarnings("ignore", message="pandas only supports SQLAlchemy connectable")
#             df = pd.read_sql(sql, conn)
#     except Exception:
#         logging.exception("Failed to run query for region %s", region_key)
#         df = pd.DataFrame(columns=cols)
#     finally:
#         try:
#             if conn is not None:
#                 conn.close()
#         except Exception:
#             pass

#     for c in cols:
#         if c not in df.columns:
#             df[c] = None

#     try:
#         df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")
#     except Exception:
#         df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"].astype(str), errors="coerce")

#     # maintain person_uid same as compute logic
#     def make_person_uid(row):
#         eid = row.get("EmployeeIdentity")
#         if pd.notna(eid) and str(eid).strip() != "":
#             return str(eid).strip()
#         pieces = [
#             (str(row.get("EmployeeID")) if row.get("EmployeeID") is not None else "").strip(),
#             (str(row.get("CardNumber")) if row.get("CardNumber") is not None else "").strip(),
#             (str(row.get("EmployeeName")) if row.get("EmployeeName") is not None else "").strip()
#         ]
#         joined = "|".join([p for p in pieces if p])
#         return joined or None

#     if not df.empty:
#         df['person_uid'] = df.apply(make_person_uid, axis=1)

#     return df[cols + (['person_uid'] if 'person_uid' in df.columns else [])]

# # compute durations (unchanged largely)
# def compute_daily_durations(swipes_df: pd.DataFrame) -> pd.DataFrame:
#     out_cols = [
#         "person_uid", "EmployeeIdentity", "EmployeeID", "EmployeeName", "CardNumber",
#         "Date", "FirstSwipe", "LastSwipe", "FirstDoor", "LastDoor", "CountSwipes",
#         "DurationSeconds", "Duration", "PersonnelTypeName", "PartitionName2",
#         "CompanyName", "PrimaryLocation", "FirstDirection", "LastDirection"
#     ]

#     if swipes_df is None or swipes_df.empty:
#         return pd.DataFrame(columns=out_cols)

#     df = swipes_df.copy()
#     expected = ["EmployeeIdentity", "EmployeeID", "CardNumber", "EmployeeName", "LocaleMessageTime", "Door",
#                 "PersonnelTypeName", "PartitionName2", "CompanyName", "PrimaryLocation", "Direction", "person_uid"]
#     for col in expected:
#         if col not in df.columns:
#             df[col] = None

#     if df["LocaleMessageTime"].dtype == object:
#         df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")

#     dedupe_cols = ["EmployeeIdentity", "LocaleMessageTime", "EmployeeID", "CardNumber", "Door"]
#     df = df.drop_duplicates(subset=dedupe_cols, keep="first")

#     df["Date"] = df["LocaleMessageTime"].dt.date

#     df["person_uid"] = df.apply(
#         lambda row: row["person_uid"]
#         if pd.notna(row.get("person_uid")) and str(row.get("person_uid")).strip() != ""
#         else "|".join([str(row.get(c)).strip() for c in ["EmployeeID", "CardNumber", "EmployeeName"] if pd.notna(row.get(c)) and str(row.get(c)).strip() != ""]),
#         axis=1
#     )
#     df = df[df["person_uid"].notna()].copy()

#     try:
#         df = df.sort_values("LocaleMessageTime")
#         grouped = df.groupby(["person_uid", "Date"], sort=False).agg(
#             FirstSwipe=("LocaleMessageTime", "first"),
#             LastSwipe=("LocaleMessageTime", "last"),
#             FirstDoor=("Door", "first"),
#             LastDoor=("Door", "last"),
#             CountSwipes=("LocaleMessageTime", "count"),
#             EmployeeIdentity=("EmployeeIdentity", "first"),
#             EmployeeID=("EmployeeID", "first"),
#             EmployeeName=("EmployeeName", "first"),
#             CardNumber=("CardNumber", "first"),
#             PersonnelTypeName=("PersonnelTypeName", "first"),
#             PartitionName2=("PartitionName2", "first"),
#             CompanyName=("CompanyName", "first"),
#             PrimaryLocation=("PrimaryLocation", "first"),
#             FirstDirection=("Direction", "first"),
#             LastDirection=("Direction", "last")
#         ).reset_index()
#     except Exception:
#         def agg_for_group(g):
#             g_sorted = g.sort_values("LocaleMessageTime")
#             first = g_sorted.iloc[0]
#             last = g_sorted.iloc[-1]
#             return pd.Series({
#                 "person_uid": first["person_uid"],
#                 "EmployeeIdentity": first.get("EmployeeIdentity"),
#                 "EmployeeID": first.get("EmployeeID"),
#                 "EmployeeName": first.get("EmployeeName"),
#                 "CardNumber": first.get("CardNumber"),
#                 "Date": first["Date"],
#                 "FirstSwipe": first["LocaleMessageTime"],
#                 "LastSwipe": last["LocaleMessageTime"],
#                 "FirstDoor": first.get("Door"),
#                 "LastDoor": last.get("Door"),
#                 "CountSwipes": int(len(g_sorted)),
#                 "PersonnelTypeName": first.get("PersonnelTypeName"),
#                 "PartitionName2": first.get("PartitionName2"),
#                 "CompanyName": first.get("CompanyName"),
#                 "PrimaryLocation": first.get("PrimaryLocation"),
#                 "FirstDirection": first.get("Direction"),
#                 "LastDirection": last.get("Direction")
#             })
#         grouped = df.groupby(["person_uid", "Date"], sort=False).apply(agg_for_group).reset_index(drop=True)

#     grouped["DurationSeconds"] = (grouped["LastSwipe"] - grouped["FirstSwipe"]).dt.total_seconds().clip(lower=0)
#     grouped["Duration"] = grouped["DurationSeconds"].apply(
#         lambda s: str(timedelta(seconds=int(s))) if pd.notna(s) and s >= 0 else None
#     )

#     for c in out_cols:
#         if c not in grouped.columns:
#             grouped[c] = None

#     return grouped[out_cols]

# # runner helper: run_for_date
# def run_for_date(target_date: date, regions: List[str], outdir: str, city: Optional[str] = None) -> Dict[str, Any]:
#     outdir_path = Path(outdir)
#     outdir_path.mkdir(parents=True, exist_ok=True)

#     results: Dict[str, Any] = {}
#     for r in regions:
#         r = r.lower()
#         if r not in REGION_CONFIG:
#             logging.warning("Unknown region '%s' - skipping", r)
#             continue
#         logging.info("Fetching swipes for region %s on %s", r, target_date)
#         try:
#             swipes = fetch_swipes_for_region(r, target_date)
#         except Exception:
#             logging.exception("Failed fetching swipes for region %s", r)
#             swipes = pd.DataFrame()

#         # optional city filter
#         if city and not swipes.empty:
#             city_l = str(city).strip().lower()
#             mask_parts = []
#             for col in ("PartitionName2", "PrimaryLocation", "Door", "EmployeeName"):
#                 if col in swipes.columns:
#                     mask_parts.append(swipes[col].fillna("").astype(str).str.lower().str.contains(city_l, na=False))
#             if mask_parts:
#                 combined_mask = mask_parts[0]
#                 for m in mask_parts[1:]:
#                     combined_mask = combined_mask | m
#                 swipes = swipes[combined_mask].copy()

#         try:
#             durations = compute_daily_durations(swipes)
#         except Exception:
#             logging.exception("Failed computing durations for region %s", r)
#             durations = pd.DataFrame()

#         csv_path = outdir_path / f"{r}_duration_{target_date.strftime('%Y%m%d')}.csv"
#         swipes_csv_path = outdir_path / f"{r}_swipes_{target_date.strftime('%Y%m%d')}.csv"
#         try:
#             durations.to_csv(csv_path, index=False)
#         except Exception:
#             logging.exception("Failed writing durations CSV for %s", r)
#         try:
#             swipes.to_csv(swipes_csv_path, index=False)
#         except Exception:
#             logging.exception("Failed writing swipes CSV for %s", r)

#         logging.info("Wrote duration CSV for %s to %s (rows=%d)", r, csv_path, len(durations))
#         logging.info("Wrote swipes CSV for %s to %s (rows=%d)", r, swipes_csv_path, len(swipes))
#         results[r] = {"swipes": swipes, "durations": durations}

#     return results











# backend/duration_report.py
from __future__ import annotations

import logging
import os
import re
import warnings
from datetime import date, datetime, timedelta
from pathlib import Path
from typing import Optional, List, Dict, Any

import pandas as pd

try:
    import pyodbc
except Exception:
    pyodbc = None

# ODBC driver name (override with environment variable if needed)
ODBC_DRIVER = os.getenv("ODBC_DRIVER", "ODBC Driver 17 for SQL Server")

# Try to import shared door/zone helpers from config; fall back to a small local implementation if missing.
try:
    from config.door_zone import map_door_to_zone, BREAK_ZONES, OUT_OF_OFFICE_ZONE
except Exception:
    # fallback — keep behaviour if config file unavailable
    BREAK_ZONES = set(["East Outdoor Area", "West Outdoor Area", "Assembly Area"])
    OUT_OF_OFFICE_ZONE = "Out of office"

    def map_door_to_zone(door: object, direction: object = None) -> str:
        """
        Fallback: Map a raw Door string (and optionally Direction) to a logical zone.
        (This is only used if config.door_zone can't be imported.)
        """
        try:
            if door is None:
                return None
            s = str(door).strip()
            if not s:
                return None
            s_l = s.lower()
            # fallback: direction-based inference
            if direction and isinstance(direction, str):
                d = direction.strip().lower()
                if "out" in d:
                    return OUT_OF_OFFICE_ZONE
                if "in" in d:
                    # assume reception/working
                    return "Reception Area"
            # heuristic fallback
            if "out" in s_l or "exit" in s_l or ("turnstile" in s_l and "out" in s_l):
                return OUT_OF_OFFICE_ZONE
            # else treat as working area
            return "Working Area"
        except Exception:
            return None

# REGION configuration - databases list used to build UNION queries
REGION_CONFIG = {
    "apac": {
        "user": "GSOC_Test",
        "password": "Westernccure@2025",
        "server": "SRVWUPNQ0986V",
        "databases": [
            "ACVSUJournal_00010030","ACVSUJournal_00010029","ACVSUJournal_00010028",
            "ACVSUJournal_00010027","ACVSUJournal_00010026","ACVSUJournal_00010025"
        ],
        "partitions": ["APAC.Default", "JP.Tokyo", "PH.Manila", "MY.Kuala Lumpur", "IN.HYD"]
    },
    "emea": {
        "user": "GSOC_Test",
        "password": "Westernccure@2025",
        "server": "SRVWUFRA0986V",
        "databases": [
            "ACVSUJournal_00011029","ACVSUJournal_00011028","ACVSUJournal_00011027",
            "ACVSUJournal_00011026","ACVSUJournal_00011025","ACVSUJournal_00011024",
            "ACVSUJournal_00011023"
        ],
        "partitions": ["LT.Vilnius", "AUT.Vienna", "IE.DUblin", "DU.Abu Dhab", "ES.Madrid"]
    },
    "laca": {
        "user": "GSOC_Test",
        "password": "Westernccure@2025",
        "server": "SRVWUSJO0986V",
        "databases": [
            "ACVSUJournal_00010030","ACVSUJournal_00010029","ACVSUJournal_00010028",
            "ACVSUJournal_00010027","ACVSUJournal_00010026","ACVSUJournal_00010025"
        ],
        "partitions": ["AR.Cordoba", "BR.Sao Paulo", "CR.Costa Rica Partition", "MX.Mexico City"]
    },
    "namer": {
        "user": "GSOC_Test",
        "password": "Westernccure@2025",
        "server": "SRVWUDEN0891V",
        "databases": [
            "ACVSUJournal_00010030","ACVSUJournal_00010029","ACVSUJournal_00010028",
            "ACVSUJournal_00010027","ACVSUJournal_00010026","ACVSUJournal_00010025"
        ],
        "partitions": ["Denver", "Austin Texas", "Miami", "New York"],
        "logical_like": ["%HQ%", "%Austin%", "%Miami%", "%NYC%"]
    }
}



GENERIC_SQL_TEMPLATE = r"""
SELECT
    t1.[ObjectName1] AS EmployeeName,
    t1.[ObjectName2] AS Door,
    -- prefer contractor text12 else Int1 (match original logic)
    CASE WHEN t3.[Name] IN ('Contractor','Terminated Contractor') THEN t2.[Text12] ELSE CAST(t2.[Int1] AS NVARCHAR) END AS EmployeeID,
    t2.[Int1] AS Int1,
    t2.[Text12] AS Text12,
    -- expose raw XML & shredded value so downstream code can attempt robust extraction
    t_xml.XmlMessage AS XmlMessage,
    sc.value AS XmlShredValue,
    -- CardNumber: try CHUID/Card inside XmlMessage, fallback to shredded value, then text12/int1
    COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
      sc.value,
      NULLIF(CAST(t2.[Int1] AS NVARCHAR),'0'),
      t2.[Text12]
    ) AS CardNumber,
    t3.[Name] AS PersonnelTypeName,
    t1.ObjectIdentity1 AS EmployeeIdentity,
    t1.PartitionName2,
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    t1.MessageType,
    t5d.value AS Direction,
    t2.Text4 AS CompanyName,
    t2.Text5 AS PrimaryLocation
FROM [{db}].dbo.ACVSUJournalLog AS t1
LEFT JOIN ACVSCore.Access.Personnel AS t2 ON t1.ObjectIdentity1 = t2.GUID
LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeID = t3.ObjectID
LEFT JOIN [{db}].dbo.ACVSUJournalLogxmlShred t5d
  ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
LEFT JOIN [{db}].dbo.ACVSUJournalLogxml t_xml
  ON t1.XmlGUID = t_xml.GUID
LEFT JOIN (
  SELECT GUID, value
  FROM [{db}].dbo.ACVSUJournalLogxmlShred
  WHERE Name IN ('Card','CHUID')
) AS sc
  ON t1.XmlGUID = sc.GUID
WHERE t1.MessageType = 'CardAdmitted'
  AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) = '{date}'
  {region_filter}
"""
# Helpers
def _split_db_name(dbname: str):
    m = re.match(r"^(.*?)(\d+)$", dbname)
    if not m:
        return dbname, None
    return m.group(1), m.group(2)

def _expand_databases_from_base(db_base: str, last_n: int) -> List[str]:
    prefix, digits = _split_db_name(db_base)
    if digits is None:
        return [db_base]
    width = len(digits)
    try:
        cur = int(digits)
    except Exception:
        return [db_base]
    out = []
    for i in range(last_n):
        num = cur - i
        if num < 0:
            break
        out.append(f"{prefix}{str(num).zfill(width)}")
    return out

def _get_candidate_databases(rc: Dict[str, Any]) -> List[str]:
    if "databases" in rc and isinstance(rc["databases"], list) and rc["databases"]:
        return rc["databases"]
    base_db = rc.get("database")
    if not base_db:
        return []
    last_n = int(rc.get("last_n_databases", 1) or 1)
    if last_n <= 1:
        return [base_db]
    return _expand_databases_from_base(base_db, last_n)

def _connect_master(rc: Dict[str, Any]):
    if pyodbc is None:
        logging.debug("pyodbc not available; cannot connect to master for DB discovery.")
        return None
    try:
        conn_str = (
            f"DRIVER={{{ODBC_DRIVER}}};"
            f"SERVER={rc['server']};DATABASE=master;UID={rc['user']};PWD={rc['password']};"
            "TrustServerCertificate=Yes;"
        )
        return pyodbc.connect(conn_str, autocommit=True)
    except Exception:
        logging.exception("Failed to connect to master DB for server %s", rc.get("server"))
        return None

def _filter_existing_databases(rc: Dict[str, Any], candidates: List[str]) -> List[str]:
    if not candidates:
        return []
    master_conn = _connect_master(rc)
    if master_conn is None:
        logging.warning("Unable to validate DB existence (no master connection). Proceeding with candidate list: %s", candidates)
        return candidates
    try:
        exists = []
        cursor = master_conn.cursor()
        for db in candidates:
            try:
                cursor.execute("SELECT COUNT(1) FROM sys.databases WHERE name = ?", (db,))
                row = cursor.fetchone()
                if row and row[0] and int(row[0]) > 0:
                    exists.append(db)
            except Exception:
                logging.exception("Error checking existence for database %s", db)
        cursor.close()
        logging.info("Databases present for server %s: %s", rc.get("server"), exists)
        return exists if exists else candidates
    finally:
        try:
            master_conn.close()
        except Exception:
            pass

def build_region_query(region_key: str, target_date: date) -> str:
    rc = REGION_CONFIG[region_key]
    date_str = target_date.strftime("%Y-%m-%d")
    region_filter = ""

    if region_key in ("apac", "emea", "laca"):
        partitions = rc.get("partitions", [])
        parts_sql = ", ".join(f"'{p}'" for p in partitions)
        region_filter = f"AND t1.PartitionName2 IN ({parts_sql})"
    elif region_key == "namer":
        likes = rc.get("logical_like", [])
        like_sql = " OR ".join(f"t1.[ObjectName2] LIKE '{p}'" for p in likes)
        region_filter = f"AND ({like_sql})"
    else:
        region_filter = ""

    candidates = _get_candidate_databases(rc)
    if not candidates:
        candidates = [rc.get("database")]

    valid_dbs = _filter_existing_databases(rc, candidates)

    union_parts = []
    for dbname in valid_dbs:
        union_parts.append(GENERIC_SQL_TEMPLATE.format(db=dbname, date=date_str, region_filter=region_filter))

    if not union_parts:
        dbname = rc.get("database")
        return GENERIC_SQL_TEMPLATE.format(db=dbname, date=date_str, region_filter=region_filter)

    sql = "\nUNION ALL\n".join(union_parts)
    return sql
    
# DB connection & fetch
def get_connection(region_key: str):
    if pyodbc is None:
        raise RuntimeError("pyodbc is not available. Install it with 'pip install pyodbc'.")

    rc = REGION_CONFIG[region_key]
    # use first database in list if present
    db = rc.get("databases", [rc.get("database")])[0]
    conn_str = (
        f"DRIVER={{{ODBC_DRIVER}}};"
        f"SERVER={rc['server']};DATABASE={db};UID={rc['user']};PWD={rc['password']};"
        "TrustServerCertificate=Yes;"
    )
    return pyodbc.connect(conn_str, autocommit=True)

def fetch_swipes_for_region(region_key: str, target_date: date) -> pd.DataFrame:
    sql = build_region_query(region_key, target_date)
    logging.info("Built SQL for region %s, date %s", region_key, target_date)
    cols = [
    "EmployeeName", "Door", "EmployeeID", "Int1", "Text12", "XmlMessage", "XmlShredValue", "CardNumber",
    "PersonnelTypeName", "EmployeeIdentity", "PartitionName2", "LocaleMessageTime", "MessageType",
    "Direction", "CompanyName", "PrimaryLocation"
]

    if pyodbc is None:
        logging.warning("pyodbc not available - returning empty DataFrame skeleton for region %s", region_key)
        return pd.DataFrame(columns=cols)

    conn = None
    try:
        conn = get_connection(region_key)
        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", message="pandas only supports SQLAlchemy connectable")
            df = pd.read_sql(sql, conn)
    except Exception:
        logging.exception("Failed to run query for region %s", region_key)
        df = pd.DataFrame(columns=cols)
    finally:
        try:
            if conn is not None:
                conn.close()
        except Exception:
            pass

    for c in cols:
        if c not in df.columns:
            df[c] = None

    try:
        df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")
    except Exception:
        df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"].astype(str), errors="coerce")

    # maintain person_uid same as compute logic
    def make_person_uid(row):
        eid = row.get("EmployeeIdentity")
        if pd.notna(eid) and str(eid).strip() != "":
            return str(eid).strip()
        pieces = [
            (str(row.get("EmployeeID")) if row.get("EmployeeID") is not None else "").strip(),
            (str(row.get("CardNumber")) if row.get("CardNumber") is not None else "").strip(),
            (str(row.get("EmployeeName")) if row.get("EmployeeName") is not None else "").strip()
        ]
        joined = "|".join([p for p in pieces if p])
        return joined or None

    if not df.empty:
        df['person_uid'] = df.apply(make_person_uid, axis=1)

    return df[cols + (['person_uid'] if 'person_uid' in df.columns else [])]

# compute durations (unchanged largely)
def compute_daily_durations(swipes_df: pd.DataFrame) -> pd.DataFrame:
    out_cols = [
        "person_uid", "EmployeeIdentity", "EmployeeID", "EmployeeName", "CardNumber",
        "Date", "FirstSwipe", "LastSwipe", "FirstDoor", "LastDoor", "CountSwipes",
        "DurationSeconds", "Duration", "PersonnelTypeName", "PartitionName2",
        "CompanyName", "PrimaryLocation", "FirstDirection", "LastDirection"
    ]

    if swipes_df is None or swipes_df.empty:
        return pd.DataFrame(columns=out_cols)

    df = swipes_df.copy()
    expected = ["EmployeeIdentity", "EmployeeID", "CardNumber", "EmployeeName", "LocaleMessageTime", "Door",
                "PersonnelTypeName", "PartitionName2", "CompanyName", "PrimaryLocation", "Direction", "person_uid"]
    for col in expected:
        if col not in df.columns:
            df[col] = None

    if df["LocaleMessageTime"].dtype == object:
        df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")

    dedupe_cols = ["EmployeeIdentity", "LocaleMessageTime", "EmployeeID", "CardNumber", "Door"]
    df = df.drop_duplicates(subset=dedupe_cols, keep="first")

    df["Date"] = df["LocaleMessageTime"].dt.date

    df["person_uid"] = df.apply(
        lambda row: row["person_uid"]
        if pd.notna(row.get("person_uid")) and str(row.get("person_uid")).strip() != ""
        else "|".join([str(row.get(c)).strip() for c in ["EmployeeID", "CardNumber", "EmployeeName"] if pd.notna(row.get(c)) and str(row.get(c)).strip() != ""]),
        axis=1
    )
    df = df[df["person_uid"].notna()].copy()

    try:
        df = df.sort_values("LocaleMessageTime")
        grouped = df.groupby(["person_uid", "Date"], sort=False).agg(
            FirstSwipe=("LocaleMessageTime", "first"),
            LastSwipe=("LocaleMessageTime", "last"),
            FirstDoor=("Door", "first"),
            LastDoor=("Door", "last"),
            CountSwipes=("LocaleMessageTime", "count"),
            EmployeeIdentity=("EmployeeIdentity", "first"),
            EmployeeID=("EmployeeID", "first"),
            EmployeeName=("EmployeeName", "first"),
            CardNumber=("CardNumber", "first"),
            PersonnelTypeName=("PersonnelTypeName", "first"),
            PartitionName2=("PartitionName2", "first"),
            CompanyName=("CompanyName", "first"),
            PrimaryLocation=("PrimaryLocation", "first"),
            FirstDirection=("Direction", "first"),
            LastDirection=("Direction", "last")
        ).reset_index()
    except Exception:
        def agg_for_group(g):
            g_sorted = g.sort_values("LocaleMessageTime")
            first = g_sorted.iloc[0]
            last = g_sorted.iloc[-1]
            return pd.Series({
                "person_uid": first["person_uid"],
                "EmployeeIdentity": first.get("EmployeeIdentity"),
                "EmployeeID": first.get("EmployeeID"),
                "EmployeeName": first.get("EmployeeName"),
                "CardNumber": first.get("CardNumber"),
                "Date": first["Date"],
                "FirstSwipe": first["LocaleMessageTime"],
                "LastSwipe": last["LocaleMessageTime"],
                "FirstDoor": first.get("Door"),
                "LastDoor": last.get("Door"),
                "CountSwipes": int(len(g_sorted)),
                "PersonnelTypeName": first.get("PersonnelTypeName"),
                "PartitionName2": first.get("PartitionName2"),
                "CompanyName": first.get("CompanyName"),
                "PrimaryLocation": first.get("PrimaryLocation"),
                "FirstDirection": first.get("Direction"),
                "LastDirection": last.get("Direction")
            })
        grouped = df.groupby(["person_uid", "Date"], sort=False).apply(agg_for_group).reset_index(drop=True)

    grouped["DurationSeconds"] = (grouped["LastSwipe"] - grouped["FirstSwipe"]).dt.total_seconds().clip(lower=0)
    grouped["Duration"] = grouped["DurationSeconds"].apply(
        lambda s: str(timedelta(seconds=int(s))) if pd.notna(s) and s >= 0 else None
    )

    for c in out_cols:
        if c not in grouped.columns:
            grouped[c] = None

    return grouped[out_cols]

# runner helper: run_for_date
def run_for_date(target_date: date, regions: List[str], outdir: str, city: Optional[str] = None) -> Dict[str, Any]:
    outdir_path = Path(outdir)
    outdir_path.mkdir(parents=True, exist_ok=True)

    results: Dict[str, Any] = {}
    for r in regions:
        r = r.lower()
        if r not in REGION_CONFIG:
            logging.warning("Unknown region '%s' - skipping", r)
            continue
        logging.info("Fetching swipes for region %s on %s", r, target_date)
        try:
            swipes = fetch_swipes_for_region(r, target_date)
        except Exception:
            logging.exception("Failed fetching swipes for region %s", r)
            swipes = pd.DataFrame()

        # optional city filter
        if city and not swipes.empty:
            city_l = str(city).strip().lower()
            mask_parts = []
            for col in ("PartitionName2", "PrimaryLocation", "Door", "EmployeeName"):
                if col in swipes.columns:
                    mask_parts.append(swipes[col].fillna("").astype(str).str.lower().str.contains(city_l, na=False))
            if mask_parts:
                combined_mask = mask_parts[0]
                for m in mask_parts[1:]:
                    combined_mask = combined_mask | m
                swipes = swipes[combined_mask].copy()

        try:
            durations = compute_daily_durations(swipes)
        except Exception:
            logging.exception("Failed computing durations for region %s", r)
            durations = pd.DataFrame()

        csv_path = outdir_path / f"{r}_duration_{target_date.strftime('%Y%m%d')}.csv"
        swipes_csv_path = outdir_path / f"{r}_swipes_{target_date.strftime('%Y%m%d')}.csv"
        try:
            durations.to_csv(csv_path, index=False)
        except Exception:
            logging.exception("Failed writing durations CSV for %s", r)
        try:
            swipes.to_csv(swipes_csv_path, index=False)
        except Exception:
            logging.exception("Failed writing swipes CSV for %s", r)

        logging.info("Wrote duration CSV for %s to %s (rows=%d)", r, csv_path, len(durations))
        logging.info("Wrote swipes CSV for %s to %s (rows=%d)", r, swipes_csv_path, len(swipes))
        results[r] = {"swipes": swipes, "durations": durations}

    return results














***************************************************
***************************************************


# backend/logic.py
import pandas as pd
import numpy as np
import logging
from pathlib import Path

PROFILE_PATH = Path(__file__).parent / "current_analysis.csv"
if PROFILE_PATH.exists():
    try:
        employee_profile = pd.read_csv(PROFILE_PATH)
        logging.info("logic.py: loaded historical profile (%d rows)", len(employee_profile))
    except Exception as e:
        logging.warning("logic.py: failed to read current_analysis.csv: %s", e)
        employee_profile = pd.DataFrame()
else:
    logging.warning("logic.py: current_analysis.csv not found; history-based checks will be limited.")
    employee_profile = pd.DataFrame()


def _safe_get_emp_hist(employee_id):
    if employee_profile.empty or employee_id is None or (isinstance(employee_id, float) and np.isnan(employee_id)):
        return pd.DataFrame()
    # normalize employee_id comparison as string/int
    try:
        empid_str = str(employee_id).strip()
    except Exception:
        empid_str = employee_id
    if 'EmployeeID' in employee_profile.columns:
        # try numeric match first
        try:
            # if both numeric/int equal
            emp_numeric = None
            try:
                emp_numeric = float(empid_str)
            except Exception:
                emp_numeric = None
            if emp_numeric is not None and not np.isnan(emp_numeric):
                # try numeric comparison when employee_profile EmployeeID numeric-like
                try:
                    profile_nums = pd.to_numeric(employee_profile['EmployeeID'], errors='coerce')
                    mask = (profile_nums == emp_numeric)
                    res = employee_profile[mask]
                    if not res.empty:
                        return res
                except Exception:
                    pass
        except Exception:
            pass
        # fallback to string match
        try:
            return employee_profile[employee_profile['EmployeeID'].astype(str).str.strip() == empid_str]
        except Exception:
            return pd.DataFrame()
    return pd.DataFrame()


def flag_employee(row_dict):
    """
    Return (is_flagged: bool, reasons: list[str])
    This is an extra per-employee heuristic (uses historical profile if available).
    It will return (False, []) when there is no historical data; do not return stray reasons.
    """
    employee_id = row_dict.get('EmployeeID')
    personnel_type = row_dict.get('PersonnelType') or row_dict.get('PersonnelTypeName')
    try:
        days_present = int(row_dict.get('DaysPresentInWeek') or 0)
    except Exception:
        days_present = 0

    logging.info("flag_employee: checking EmployeeID=%s", employee_id)

    emp_hist = _safe_get_emp_hist(employee_id)
    if emp_hist.empty:
        # do not fabricate a reason when history missing — caller can still combine other signals
        return False, []

    reasons = []

    # example checks
    try:
        if row_dict.get('InTime') and row_dict.get('OutTime'):
            reasons.append("Has both InTime and OutTime (possible short cycles)")
    except Exception:
        pass

    if int(row_dict.get("OnlyIn", 0) or 0) == 1:
        reasons.append("OnlyIn entry detected")
    if int(row_dict.get("OnlyOut", 0) or 0) == 1:
        reasons.append("OnlyOut entry detected")
    if int(row_dict.get("SingleDoor", 0) or 0) == 1:
        reasons.append("SingleDoor usage detected")

    if personnel_type and str(personnel_type).strip().lower() == "employee":
        is_defaulter = row_dict.get("Defaulter", "No")
        if str(is_defaulter).strip().lower() == "yes":
            reasons.append("Flagged as Defaulter by company policy")

    # historical median/std checks for numeric metrics
    metric_column_map = {
        'DurationMinutes': ('AvgDurationMins_median', 'AvgDurationMins_std'),
        'TotalSwipes': ('TotalSwipes_median', 'TotalSwipes_std')
    }

    for metric, (median_col, std_col) in metric_column_map.items():
        try:
            live_val = row_dict.get(metric)
            if live_val is None or (isinstance(live_val, float) and np.isnan(live_val)):
                # don't automatically add reason; only when metric is required
                continue
            if median_col in emp_hist.columns and std_col in emp_hist.columns:
                median_val = emp_hist.iloc[0].get(median_col, np.nan)
                std_val = emp_hist.iloc[0].get(std_col, np.nan)
                if pd.notna(median_val) and pd.notna(std_val) and std_val >= 0:
                    try:
                        median_val = float(median_val)
                        std_val = float(std_val)
                        buffer = 2.5 * std_val
                        if float(live_val) < median_val - buffer or float(live_val) > median_val + buffer:
                            reasons.append(f"Abnormal {metric}: {live_val} outside expected [{median_val-buffer:.1f}, {median_val+buffer:.1f}]")
                    except Exception:
                        pass
        except Exception as e:
            logging.debug("flag_employee: error evaluating metric %s: %s", metric, e)

    try:
        duration = float(row_dict.get('DurationMinutes') or 0)
        if days_present < 3 and duration < 480:
            reasons.append("Duration < 8 hours on limited office days")
    except Exception:
        pass

    return (len(reasons) > 0), reasons







***********************************************
***********************************************





# ml_training.py
"""
Train one binary classifier per scenario using the training CSV produced by trend_runner.build_monthly_training.
Usage:
    python ml_training.py --input outputs/training_person_month.csv --models_dir models/
Outputs:
    models/<scenario>.joblib
Requirements:
    scikit-learn, joblib, pandas, numpy
"""
import argparse
from pathlib import Path
import pandas as pd
import numpy as np
import logging

logging.basicConfig(level=logging.INFO)

try:
    from sklearn.ensemble import RandomForestClassifier
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import classification_report
    import joblib
except Exception as e:
    logging.error("Required ML packages missing: %s", e)
    logging.error("Install scikit-learn and joblib: pip install scikit-learn joblib")
    raise

DEFAULT_FEATURE_COLS = [
    'CountSwipes_median', 'CountSwipes_mean', 'CountSwipes_sum',
    'DurationMinutes_median', 'DurationMinutes_mean', 'DurationMinutes_sum',
    'MaxSwipeGapSeconds_max', 'MaxSwipeGapSeconds_median',
    'ShortGapCount_sum', 'UniqueDoors_median', 'UniqueLocations_median', 'RejectionCount_sum',
    'days_present'
]

def auto_detect_scenarios(df):
    scenario_labels = [c for c in df.columns if c.endswith('_label')]
    scenarios = [c[:-6] for c in scenario_labels]
    return scenarios

def prepare_features(df, features=None):
    if features is None:
        features = DEFAULT_FEATURE_COLS
    # ensure columns exist, fill missing with 0/median
    X = df.copy()
    for f in features:
        if f not in X.columns:
            X[f] = 0.0
    X = X[features].fillna(0.0)
    return X

def train_one(df, scenario, features):
    label_col = f"{scenario}_label"
    if label_col not in df.columns:
        logging.warning("Label %s not in dataframe, skipping", label_col)
        return None
    y = df[label_col].astype(int)
    if y.sum() == 0:
        logging.warning("No positive examples for %s; skipping model training", scenario)
        return None
    X = prepare_features(df, features)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)
    clf = RandomForestClassifier(n_estimators=100, random_state=42, n_jobs=-1)
    clf.fit(X_train, y_train)
    y_pred = clf.predict(X_test)
    logging.info("Classification report for %s:\n%s", scenario, classification_report(y_test, y_pred, zero_division=0))
    return clf

def main(input_csv: Path, models_dir: Path, feature_cols=None):
    if not input_csv.exists():
        raise FileNotFoundError(f"input CSV not found: {input_csv}")
    df = pd.read_csv(input_csv)
    scenarios = auto_detect_scenarios(df)
    if not scenarios:
        logging.error("No scenarios ( *_label ) columns found in %s", input_csv)
        return
    models_dir.mkdir(parents=True, exist_ok=True)
    for s in scenarios:
        logging.info("Training for scenario: %s", s)
        clf = train_one(df, s, feature_cols)
        if clf is not None:
            outp = models_dir / f"{s}.joblib"
            joblib.dump({"model": clf, "features": (feature_cols or DEFAULT_FEATURE_COLS)}, outp)
            logging.info("Saved model to %s", outp)
        else:
            logging.info("Skipped training for %s", s)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--input", required=True, help="training CSV (person-month) created by /train endpoint")
    parser.add_argument("--models_dir", default="models", help="folder to save models")
    parser.add_argument("--features", default=None, help="comma separated feature columns (optional)")
    args = parser.parse_args()

    input_csv = Path(args.input)
    models_dir = Path(args.models_dir)
    feature_cols = args.features.split(",") if args.features else None

    main(input_csv, models_dir, feature_cols)


**************************************************
**************************************************




# backend/trend_runner.py (UPDATED)
from datetime import date, datetime, time, timedelta
from pathlib import Path
import pandas as pd
import numpy as np
import logging
import hashlib
import math
import re
import os

# IMPORTANT: duration_report must exist and expose run_for_date(date, regions, outdir, city)
from duration_report import run_for_date
from config.door_zone import map_door_to_zone, BREAK_ZONES, OUT_OF_OFFICE_ZONE

# HIST_PATH: try a few likely locations (project config, repository root, absolute path)
CANDIDATE_HISTORY = [
    Path(__file__).parent / "config" / "current_analysis.csv",
    Path(__file__).parent.parent / "config" / "current_analysis.csv",
    Path.cwd() / "current_analysis.csv",
    Path(__file__).parent / "current_analysis.csv"
]
HIST_PATH = None
for p in CANDIDATE_HISTORY:
    if p.exists():
        HIST_PATH = p
        break

if HIST_PATH is None:
    logging.warning("Historical profile file current_analysis.csv not found in candidate locations.")
    HIST_DF = pd.DataFrame()
else:
    try:
        HIST_DF = pd.read_csv(HIST_PATH)
        logging.info("Loaded historical profile from %s (rows=%d)", HIST_PATH, len(HIST_DF))
    except Exception as e:
        logging.warning("Failed to load historical profile: %s", e)
        HIST_DF = pd.DataFrame()

OUTDIR = Path("./outputs")
OUTDIR.mkdir(parents=True, exist_ok=True)
MODELS_DIR = Path("./models")
MODELS_DIR.mkdir(parents=True, exist_ok=True)
logging.basicConfig(level=logging.INFO)


# ----- small shared helpers: treat empty/placeholder tokens as None -----
_PLACEHOLDER_STRS = set(['', 'nan', 'na', 'n/a', '-', '—', '–', 'none', 'null'])

def _is_placeholder_str(s: object) -> bool:
    try:
        if s is None:
            return True
        st = str(s).strip().lower()
        return st in _PLACEHOLDER_STRS
    except Exception:
        return False


def _normalize_id_val(v):
    """
    Normalize an id-like value: strip, convert floats like '320172.0' -> '320172'
    Return None for NaN/empty/placeholder.
    """
    try:
        if pd.isna(v):
            return None
    except Exception:
        pass
    if v is None:
        return None
    s = str(v).strip()
    if s == "" or s.lower() == "nan" or _is_placeholder_str(s):
        return None
    # strip .0 if integer-like
    try:
        if '.' in s:
            f = float(s)
            if math.isfinite(f) and f.is_integer():
                return str(int(f))
    except Exception:
        pass
    return s


# prefer to avoid emp:<GUID> person_uids — only treat emp: if value looks like a human id (not GUID)
_GUID_RE = re.compile(r'^[0-9A-Fa-f]{8}-(?:[0-9A-Fa-f]{4}-){3}[0-9A-Fa-f]{12}$')

def _looks_like_guid(s: object) -> bool:
    """Return True if s looks like a GUID/UUID string."""
    if s is None:
        return False
    try:
        st = str(s).strip()
        if not st:
            return False
        return bool(_GUID_RE.match(st))
    except Exception:
        return False

def _looks_like_name(s: object) -> bool:
    """Heuristic: treat as a plausible human name if it contains letters and not a GUID."""
    if s is None:
        return False
    try:
        st = str(s).strip()
        if not st:
            return False
        # reject GUIDs and obviously numeric ids
        if _looks_like_guid(st):
            return False
        # require at least one alphabetic character
        return bool(re.search(r'[A-Za-z]', st))
    except Exception:
        return False

def _pick_first_non_guid_value(series):
    """Pick the first non-null, non-GUID, non-placeholder value from a pandas Series (as str) or None."""
    for v in series:
        if v is None:
            continue
        try:
            s = str(v).strip()
            if not s:
                continue
            if _is_placeholder_str(s):
                continue
            if _looks_like_guid(s):
                continue
            return s
        except Exception:
            continue
    return None

def _canonical_person_uid(row):
    """
    Create canonical person uid:
      - prefer EmployeeID (normalized) -> 'emp:<id>' only if it is not a GUID
      - else EmployeeIdentity -> 'uid:<val>' (GUID allowed)
      - else EmployeeName -> hash-based 'name:<shorthash>'
    """
    empid = row.get('EmployeeID', None)
    empident = row.get('EmployeeIdentity', None)
    name = row.get('EmployeeName', None)
    empid_n = _normalize_id_val(empid)
    if empid_n and not _looks_like_guid(empid_n):
        return f"emp:{empid_n}"
    empident_n = _normalize_id_val(empident)
    if empident_n:
        return f"uid:{empident_n}"
    if name and str(name).strip():
        # stable short hash of name
        h = hashlib.sha1(str(name).strip().lower().encode('utf8')).hexdigest()[:10]
        return f"name:{h}"
    return None


# small helper to extract Card from XML-like strings
_CARD_XML_RE = re.compile(r'<Card>([^<]+)</Card>', re.IGNORECASE | re.DOTALL)
def _extract_card_from_xml(txt):
    try:
        if not txt or not isinstance(txt, str):
            return None
        m = _CARD_XML_RE.search(txt)
        if m:
            return m.group(1).strip()
        # fallback: look for CHUID ... Card: pattern or Card: 12345
        m2 = re.search(r'CHUID.*?Card.*?[:=]\s*([0-9A-Za-z\-\_]+)', txt, re.IGNORECASE | re.DOTALL)
        if m2:
            return m2.group(1).strip()
    except Exception:
        pass
    return None


# explicit list of zones considered breaks
BREAK_ZONES = set(["East Outdoor Area", "West Outdoor Area", "Assembly Area"])
OUT_OF_OFFICE_ZONE = "Out of office"

def map_door_to_zone(door: object, direction: object = None) -> str:
    """
    Map a raw Door string (and optionally Direction) to a logical zone.
    - Uses substring matching on lowercased door text and door map.
    - Falls back to PartitionName2 heuristics if door is missing.
    """
    try:
        if door is None:
            return None
        s = str(door).strip()
        if not s:
            return None
        s_l = s.lower()
        # try exact substring matches from map
        # DOOR_ZONE_MAP is expected to be in config.door_zone, but we fallback to keywords
        try:
            from config.door_zone import DOOR_ZONE_MAP
            for k, v in DOOR_ZONE_MAP.items():
                if k in s_l:
                    return v
        except Exception:
            pass
        # fallback: direction-based inference
        if direction and isinstance(direction, str):
            d = direction.strip().lower()
            if "out" in d:
                return OUT_OF_OFFICE_ZONE
            if "in" in d:
                # assume reception/working
                return "Reception Area"
        # heuristic fallback
        if "out" in s_l or "exit" in s_l or ("turnstile" in s_l and "out" in s_l):
            return OUT_OF_OFFICE_ZONE
        # else treat as working area
        return "Working Area"
    except Exception:
        return None

# --- compute_features (replaced/updated) ---
def compute_features(swipes: pd.DataFrame, durations: pd.DataFrame) -> pd.DataFrame:
    """
    Compute per person-per-date features used by scenarios.
    Returns DataFrame per (person_uid, Date) with feature columns and normalized IDs/names.
    """
    if swipes is None or swipes.empty:
        return pd.DataFrame()

    sw = swipes.copy()

    # Build lowercase->actual column map for flexible column detection
    cols_lower = {c.lower(): c for c in sw.columns}

    # detect time column
    time_candidates = ['localemessagetime', 'messagetime', 'timestamp', 'time', 'localemessagetimestamp']
    found_time_col = next((cols_lower[c] for c in time_candidates if c in cols_lower), None)
    if found_time_col:
        sw['LocaleMessageTime'] = pd.to_datetime(sw[found_time_col], errors='coerce')
        sw['Date'] = sw['LocaleMessageTime'].dt.date
    else:
        if 'Date' in sw.columns:
            sw['Date'] = pd.to_datetime(sw['Date'], errors='coerce').dt.date
        else:
            sw['Date'] = None

    # find these earlier in compute_features — prefer Int1/Text12 for EmployeeID and CHUID/Card for CardNumber
    name_candidates = ['employeename', 'objectname1', 'objectname', 'employee_name', 'name', 'object_name']
    employeeid_candidates = ['int1', 'text12', 'employeeid', 'employee_id', 'empid', 'id']
    card_candidates = ['cardnumber', 'chuid', 'card', 'card_no', 'cardnum', 'value']
    door_candidates = ['door', 'doorname', 'door_name']
    direction_candidates = ['direction', 'directionname', 'direction_name']

    name_col = next((cols_lower[c] for c in name_candidates if c in cols_lower), None)
    empid_col = next((cols_lower[c] for c in employeeid_candidates if c in cols_lower), None)
    card_col = next((cols_lower[c] for c in card_candidates if c in cols_lower), None)
    door_col = next((cols_lower[c] for c in door_candidates if c in cols_lower), None)
    dir_col = next((cols_lower[c] for c in direction_candidates if c in cols_lower), None)

    # Filter personnel types: prefer PersonnelTypeName, fallback to PersonnelType
    if 'PersonnelTypeName' in sw.columns:
        sw = sw[sw['PersonnelTypeName'].isin(['Employee', 'Terminated Personnel'])]
    elif 'PersonnelType' in sw.columns:
        sw = sw[sw['PersonnelType'].isin(['Employee', 'Terminated Personnel'])]
    # else keep everything

    if sw.empty:
        logging.info("compute_features: no rows after PersonnelType filter")
        return pd.DataFrame()

    # ensure stable person_uid (canonical)
    if 'person_uid' not in sw.columns:
        def make_person_uid_local(r):
            # prefer canonical EmployeeID (normalized, non-GUID) then EmployeeIdentity then EmployeeName
            empid_val = None
            if empid_col and empid_col in r and pd.notna(r.get(empid_col)):
                empid_val = r.get(empid_col)
            elif 'EmployeeID' in r and pd.notna(r.get('EmployeeID')):
                empid_val = r.get('EmployeeID')

            empident_val = r.get('EmployeeIdentity') if 'EmployeeIdentity' in r else None
            name_val = None
            if name_col and name_col in r:
                name_val = r.get(name_col)
            elif 'EmployeeName' in r:
                name_val = r.get('EmployeeName')
            elif 'ObjectName1' in r:
                name_val = r.get('ObjectName1')

            return _canonical_person_uid({
                'EmployeeID': empid_val,
                'EmployeeIdentity': empident_val,
                'EmployeeName': name_val
            })
        sw['person_uid'] = sw.apply(make_person_uid_local, axis=1)

    # selection columns for aggregation: include discovered columns
    sel_cols = set(['LocaleMessageTime', 'Direction', 'Door', 'PartitionName2', 'Rejection_Type',
                    'CardNumber', 'EmployeeID', 'EmployeeName', 'ObjectName1', 'PersonnelType', 'PersonnelTypeName',
                    'EmployeeIdentity'])
    if name_col:
        sel_cols.add(name_col)
    if empid_col:
        sel_cols.add(empid_col)
    if card_col:
        sel_cols.add(card_col)
    if door_col:
        sel_cols.add(door_col)
    if dir_col:
        sel_cols.add(dir_col)
    sel_cols = [c for c in sel_cols if c in sw.columns]

    def agg_swipe_group(g):
        # g is a DataFrame for one person_uid + date
        times = sorted(g['LocaleMessageTime'].dropna().tolist()) if 'LocaleMessageTime' in g else []
        gaps = []
        short_gap_count = 0
        for i in range(1, len(times)):
            s = (times[i] - times[i-1]).total_seconds()
            gaps.append(s)
            if s <= 5*60:
                short_gap_count += 1
        max_gap = int(max(gaps)) if gaps else 0

        # Direction counts (default to column names present)
        in_count = int((g['Direction'] == 'InDirection').sum()) if 'Direction' in g.columns else 0
        out_count = int((g['Direction'] == 'OutDirection').sum()) if 'Direction' in g.columns else 0
        unique_doors = int(g['Door'].nunique()) if 'Door' in g.columns else 0
        unique_locations = int(g['PartitionName2'].nunique()) if 'PartitionName2' in g.columns else 0
        rejection_count = int(g['Rejection_Type'].notna().sum()) if 'Rejection_Type' in g.columns else 0

        # pick first non-placeholder, non-guid card number if present (prefer cardnumber/chuid)
        card_numbers = []
        # 1) direct known column
        if card_col and card_col in g.columns:
            card_numbers = list(pd.unique(g[card_col].dropna()))
        # 2) explicit 'CardNumber' output column (from SQL COALESCE)
        if not card_numbers and 'CardNumber' in g.columns:
            card_numbers = list(pd.unique(g['CardNumber'].dropna()))
        # 3) some XML-shred columns may appear as 'value' or other column names
        if not card_numbers:
            for c in g.columns:
                cl = c.lower()
                if 'value' == cl or 'xml' in cl or 'msg' in cl or 'shred' in cl:
                    try:
                        vals = list(pd.unique(g[c].dropna()))
                        if vals:
                            card_numbers.extend(vals)
                    except Exception:
                        continue
        # 4) lastly try to extract from XmlMessage fields
        if not card_numbers:
            for c in g.columns:
                cl = c.lower()
                if 'xml' in cl or 'xmlmessage' in cl or 'xml_msg' in cl or 'xmlmessage' in cl:
                    for raw in g[c].dropna().astype(str):
                        extracted = _extract_card_from_xml(raw)
                        if extracted:
                            card_numbers.append(extracted)
        # 5) final unique
        card_numbers = list(dict.fromkeys(card_numbers))  # preserve order, unique

        card_number = None
        for c in card_numbers:
            n = _normalize_id_val(c)
            # explicitly reject GUIDs as card numbers
            if n and not _looks_like_guid(n):
                card_number = n
                break

        # stable id/name from the group using discovered columns first
        employee_id = None
        employee_name = None
        employee_identity = None
        personnel_type = None

        # Employee ID: prefer Int1/Text12 then EmployeeID; DO NOT use EmployeeIdentity as EmployeeID
        # use _pick_first_non_guid_value to skip GUIDs automatically
        if empid_col and empid_col in g.columns:
            vals = g[empid_col].dropna().astype(str).map(lambda x: x.strip())
            employee_id = _pick_first_non_guid_value(vals)
            if employee_id is None and not vals.empty:
                # final trial: numeric normalization (strip .0) but still reject GUIDs
                v0 = vals.iloc[0]
                normalized = _normalize_id_val(v0)
                if normalized and not _looks_like_guid(normalized):
                    employee_id = normalized
        elif 'EmployeeID' in g.columns:
            vals = g['EmployeeID'].dropna().astype(str).map(lambda x: x.strip())
            employee_id = _pick_first_non_guid_value(vals)
            if employee_id is None and not vals.empty:
                v0 = vals.iloc[0]
                normalized = _normalize_id_val(v0)
                if normalized and not _looks_like_guid(normalized):
                    employee_id = normalized

        # If still no employee_id and PersonnelType indicates contractor -> prefer Text12 explicitly
        if (not employee_id) and 'PersonnelType' in g.columns:
            try:
                pvals = g['PersonnelType'].dropna().astype(str)
                if not pvals.empty:
                    p0 = pvals.iloc[0]
                    if str(p0).strip().lower() in ('contractor', 'terminated contractor', 'contractor '):
                        # look for text12 explicitly (case-insensitive)
                        for c in g.columns:
                            if c.lower() == 'text12':
                                vals = g[c].dropna().astype(str).map(lambda x: x.strip())
                                employee_id = _pick_first_non_guid_value(vals)
                                if employee_id:
                                    break
            except Exception:
                pass

        # Employee identity (GUID) — keep but do not promote to EmployeeID
        if 'EmployeeIdentity' in g.columns:
            vals = g['EmployeeIdentity'].dropna().astype(str).map(lambda x: x.strip())
            if not vals.empty:
                employee_identity = vals.iloc[0]

        # Employee name: pick non-GUID candidate
        candidate_name_vals = None
        if name_col and name_col in g.columns:
            candidate_name_vals = g[name_col].dropna().astype(str).map(lambda x: x.strip())
        elif 'EmployeeName' in g.columns:
            candidate_name_vals = g['EmployeeName'].dropna().astype(str).map(lambda x: x.strip())
        elif 'ObjectName1' in g.columns:
            candidate_name_vals = g['ObjectName1'].dropna().astype(str).map(lambda x: x.strip())

        if candidate_name_vals is not None and not candidate_name_vals.empty:
            employee_name = _pick_first_non_guid_value(candidate_name_vals)
            if employee_name is None:
                # accept any value that looks like a name
                for v in candidate_name_vals:
                    if _looks_like_name(v) and not _is_placeholder_str(v):
                        employee_name = str(v).strip()
                        break

        # personnel type
        if 'PersonnelTypeName' in g.columns:
            vals = g['PersonnelTypeName'].dropna()
            if not vals.empty:
                personnel_type = vals.iloc[0]
        elif 'PersonnelType' in g.columns:
            vals = g['PersonnelType'].dropna()
            if not vals.empty:
                personnel_type = vals.iloc[0]

        # First/Last swipe times
        first_swipe = None
        last_swipe = None
        if times:
            first_swipe = times[0]
            last_swipe = times[-1]

        # ----------------- NEW: break/out-of-office sequence analysis -----------------
        # Build a timeline of (time, door, direction, zone)
        timeline = []
        for _, row in g.sort_values('LocaleMessageTime').iterrows():
            t = row.get('LocaleMessageTime')
            dname = None
            if door_col and door_col in row and pd.notna(row.get(door_col)):
                dname = row.get(door_col)
            elif 'Door' in row and pd.notna(row.get('Door')):
                dname = row.get('Door')
            direction = None
            if dir_col and dir_col in row and pd.notna(row.get(dir_col)):
                direction = row.get(dir_col)
            elif 'Direction' in row and pd.notna(row.get('Direction')):
                direction = row.get('Direction')
            zone = map_door_to_zone(dname, direction)
            timeline.append((t, dname, direction, zone))

        # compress timeline into segments with labels: 'work', 'break', 'out_of_office'
        segments = []
        if timeline:
            cur_zone = None
            seg_start = timeline[0][0]
            seg_label = None
            for (t, dname, direction, zone) in timeline:
                # determine label
                if zone in BREAK_ZONES:
                    lbl = 'break'
                elif zone == OUT_OF_OFFICE_ZONE:
                    lbl = 'out_of_office'
                else:
                    lbl = 'work'
                if cur_zone is None:
                    cur_zone = zone
                    seg_label = lbl
                    seg_start = t
                else:
                    # if label changes, close previous segment
                    if lbl != seg_label:
                        segments.append({
                            'label': seg_label,
                            'start': seg_start,
                            'end': t,
                            'start_zone': cur_zone
                        })
                        seg_start = t
                        seg_label = lbl
                        cur_zone = zone
                    else:
                        # keep current segment
                        cur_zone = cur_zone or zone
            # close last
            if seg_label is not None:
                segments.append({
                    'label': seg_label,
                    'start': seg_start,
                    'end': timeline[-1][0],
                    'start_zone': cur_zone
                })

        # Compute break metrics
        break_count = 0
        long_break_count = 0
        total_break_minutes = 0.0
        for s in segments:
            if s['label'] in ('break', 'out_of_office'):
                dur_mins = (s['end'] - s['start']).total_seconds() / 60.0 if (s['end'] and s['start']) else 0
                total_break_minutes += dur_mins
                break_count += 1
                if dur_mins >= 60:
                    long_break_count += 1

        # Detect the specific pattern:
        pattern_flag = False
        pattern_sequence = None
        try:
            # create simplified label list with durations
            seq = []
            for s in segments:
                dur_mins = (s['end'] - s['start']).total_seconds() / 60.0 if (s['end'] and s['start']) else 0
                seq.append((s['label'], round(dur_mins)))
            # look for the pattern anywhere in sequence
            for i in range(len(seq)-3):
                a = seq[i]     # first work
                b = seq[i+1]   # long out
                c = seq[i+2]   # short work
                d = seq[i+3]   # out / break
                if a[0] == 'work' and a[1] < 60 and \
                   b[0] in ('out_of_office','break') and b[1] >= 180 and \
                   c[0] == 'work' and c[1] < 60 and \
                   d[0] in ('out_of_office','break','work'):
                    pattern_flag = True
                    pattern_sequence = f"{a}->{b}->{c}->{d}"
                    break
        except Exception:
            pattern_flag = False
            pattern_sequence = None

        # ----------------- return aggregated metrics (including new ones) -----------------
        return pd.Series({
            'CountSwipes': int(len(g)),
            'MaxSwipeGapSeconds': max_gap,
            'ShortGapCount': int(short_gap_count),
            'InCount': in_count,
            'OutCount': out_count,
            'UniqueDoors': unique_doors,
            'UniqueLocations': unique_locations,
            'RejectionCount': rejection_count,
            'CardNumber': card_number,
            'EmployeeID': employee_id,
            'EmployeeIdentity': employee_identity,
            'EmployeeName': employee_name,
            'PersonnelType': personnel_type,
            'FirstSwipe': first_swipe,
            'LastSwipe': last_swipe,
            # new break features
            'BreakCount': int(break_count),
            'LongBreakCount': int(long_break_count),
            'TotalBreakMinutes': float(round(total_break_minutes,1)),
            'PatternShortLongRepeat': bool(pattern_flag),
            'PatternSequence': pattern_sequence
        })

    grouped = sw[['person_uid', 'Date'] + sel_cols].groupby(['person_uid', 'Date'])
    grouped = grouped.apply(agg_swipe_group).reset_index()

    dur = pd.DataFrame() if durations is None else durations.copy()
    if not dur.empty and 'Date' in dur.columns:
        dur['Date'] = pd.to_datetime(dur['Date'], errors='coerce').dt.date

    merged = pd.merge(grouped, dur, how='left', on=['person_uid', 'Date'])

    # --- START PATCH: coalesce duplicate columns produced by merge ---
    def _coalesce_merge_columns(df, bases):
        for base in bases:
            x = base + "_x"
            y = base + "_y"
            try:
                has_base = base in df.columns
                base_all_null = False
                if has_base:
                    base_all_null = df[base].isnull().all()
            except Exception:
                has_base = base in df.columns
                base_all_null = True

            if (not has_base) or base_all_null:
                if x in df.columns and y in df.columns:
                    try:
                        df[base] = df[x].combine_first(df[y])
                    except Exception:
                        try:
                            df[base] = df[x].where(df[x].notna(), df[y] if y in df.columns else None)
                        except Exception:
                            if x in df.columns:
                                df[base] = df[x]
                            elif y in df.columns:
                                df[base] = df[y]
                elif x in df.columns:
                    df[base] = df[x]
                elif y in df.columns:
                    df[base] = df[y]
    _coalesce_merge_columns(merged, [
        "EmployeeID", "Int1", "Text12", "CardNumber", "EmployeeName", "EmployeeIdentity"
    ])
    drop_cols = [c for c in merged.columns if c.endswith("_x") or c.endswith("_y")]
    if drop_cols:
        try:
            merged.drop(columns=drop_cols, inplace=True)
        except Exception:
            for c in drop_cols:
                if c in merged.columns:
                    try:
                        merged.drop(columns=[c], inplace=True)
                    except Exception:
                        pass
    # --- END PATCH ---

    # coalesce helpers (ensure column existence)
    def ensure_col(df, col, default=None):
        if col not in df.columns:
            df[col] = default

    ensure_col(merged, 'DurationSeconds', 0)
    ensure_col(merged, 'FirstSwipe', pd.NaT)
    ensure_col(merged, 'LastSwipe', pd.NaT)
    ensure_col(merged, 'CountSwipes', 0)
    ensure_col(merged, 'MaxSwipeGapSeconds', 0)
    ensure_col(merged, 'ShortGapCount', 0)
    ensure_col(merged, 'RejectionCount', 0)
    ensure_col(merged, 'UniqueLocations', 0)
    ensure_col(merged, 'UniqueDoors', 0)
    ensure_col(merged, 'CardNumber', None)
    ensure_col(merged, 'EmployeeID', None)
    ensure_col(merged, 'EmployeeName', None)
    ensure_col(merged, 'EmployeeIdentity', None)
    ensure_col(merged, 'PersonnelType', None)
    ensure_col(merged, 'BreakCount', 0)
    ensure_col(merged, 'LongBreakCount', 0)
    ensure_col(merged, 'TotalBreakMinutes', 0.0)
    ensure_col(merged, 'PatternShortLongRepeat', False)
    ensure_col(merged, 'PatternSequence', None)

    # If EmployeeName is missing or a GUID, try to get a better name from durations (durations typically has EmployeeName)
    if 'EmployeeName' in merged.columns:
        def choose_best_name(row):
            gname = row.get('EmployeeName')
            dname = None
            for cand in ('EmployeeName', 'employee_name', 'objectname1', 'ObjectName1'):
                if cand in row and row.get(cand) is not None:
                    dname = row.get(cand)
                    break
            if _looks_like_name(gname):
                return str(gname).strip()
            if _looks_like_name(dname):
                return str(dname).strip()
            if gname and not _looks_like_guid(gname) and not _is_placeholder_str(gname):
                return str(gname).strip()
            if dname and not _is_placeholder_str(dname):
                return str(dname).strip()
            return None
        merged['EmployeeName'] = merged.apply(choose_best_name, axis=1)
    else:
        if not dur.empty:
            def fill_name_from_dur(row):
                gname = row.get('EmployeeName')
                if _looks_like_name(gname) and not _is_placeholder_str(gname):
                    return gname
                for cand in ('EmployeeName', 'EmployeeName_y', 'EmployeeName_x'):
                    if cand in row and _looks_like_name(row[cand]) and not _is_placeholder_str(row[cand]):
                        return row[cand]
                return None
            merged['EmployeeName'] = merged.apply(fill_name_from_dur, axis=1)

    # numeric normalization for EmployeeID: ensure not GUIDs/placeholder, convert floats like '320172.0' -> '320172'
    def normalize_empid(v):
        if v is None:
            return None
        try:
            s = str(v).strip()
            if s == '' or s.lower() == 'nan' or _is_placeholder_str(s):
                return None
            if _looks_like_guid(s):
                return None
            try:
                if '.' in s:
                    f = float(s)
                    if math.isfinite(f) and f.is_integer():
                        return str(int(f))
            except Exception:
                pass
            return s
        except Exception:
            return None

    merged['EmployeeID'] = merged['EmployeeID'].apply(normalize_empid)

    # normalize card numbers: reject GUIDs and placeholder tokens
    def normalize_card(v):
        if v is None:
            return None
        try:
            s = str(v).strip()
            if s == '' or s.lower() == 'nan' or _is_placeholder_str(s):
                return None
            if _looks_like_guid(s):
                return None
            return s
        except Exception:
            return None

    merged['CardNumber'] = merged['CardNumber'].apply(normalize_card)

    # numeric normalization
    # If durations DataFrame provided DurationSeconds, use that; else fall back to computed (LastSwipe-FirstSwipe)
    if 'DurationSeconds' not in merged.columns or merged['DurationSeconds'].isnull().all():
        try:
            merged['DurationSeconds'] = (pd.to_datetime(merged['LastSwipe']) - pd.to_datetime(merged['FirstSwipe'])).dt.total_seconds().clip(lower=0).fillna(0)
        except Exception:
            merged['DurationSeconds'] = merged.get('DurationSeconds', 0)

    merged['DurationSeconds'] = pd.to_numeric(merged['DurationSeconds'], errors='coerce').fillna(0).astype(float)
    merged['DurationMinutes'] = (merged['DurationSeconds'] / 60.0).astype(float)
    merged['CountSwipes'] = merged['CountSwipes'].fillna(0).astype(int)
    merged['MaxSwipeGapSeconds'] = merged['MaxSwipeGapSeconds'].fillna(0).astype(int)
    merged['ShortGapCount'] = merged['ShortGapCount'].fillna(0).astype(int)
    merged['RejectionCount'] = merged['RejectionCount'].fillna(0).astype(int)
    merged['UniqueLocations'] = merged['UniqueLocations'].fillna(0).astype(int)
    merged['UniqueDoors'] = merged['UniqueDoors'].fillna(0).astype(int)
    merged['BreakCount'] = merged['BreakCount'].fillna(0).astype(int)
    merged['LongBreakCount'] = merged['LongBreakCount'].fillna(0).astype(int)
    merged['TotalBreakMinutes'] = merged['TotalBreakMinutes'].fillna(0.0).astype(float)
    merged['PatternShortLongRepeat'] = merged['PatternShortLongRepeat'].fillna(False).astype(bool)

    # ensure FirstSwipe/LastSwipe are datetimes
    for col in ['FirstSwipe', 'LastSwipe']:
        try:
            merged[col] = pd.to_datetime(merged[col], errors='coerce')
        except Exception:
            merged[col] = pd.NaT

    merged['OnlyIn'] = ((merged.get('InCount', 0) > 0) & (merged.get('OutCount', 0) == 0)).astype(int)
    merged['OnlyOut'] = ((merged.get('OutCount', 0) > 0) & (merged.get('InCount', 0) == 0)).astype(int)
    merged['SingleDoor'] = (merged.get('UniqueDoors', 0) <= 1).astype(int)

    # EmpHistoryPresent
    hist_map = {}
    if not HIST_DF.empty and 'EmployeeID' in HIST_DF.columns:
        hist_map = HIST_DF.set_index('EmployeeID').to_dict(orient='index')
    merged['EmpHistoryPresent'] = merged['EmployeeID'].apply(lambda x: _normalize_id_val(x) in hist_map if pd.notna(x) else False)

    # normalize string columns for safe downstream use; EmployeeName keep as readable-only
    for c in ['EmployeeID', 'CardNumber', 'EmployeeIdentity', 'PersonnelType']:
        if c in merged.columns:
            def _clean_str_val(v):
                if v is None:
                    return None
                try:
                    s = str(v).strip()
                    if s == '' or s.lower() == 'nan' or _is_placeholder_str(s):
                        return None
                    return s
                except Exception:
                    return None
            merged[c] = merged[c].apply(_clean_str_val)

    # EmployeeName: keep None if empty or GUID/placeholder; otherwise string.
    if 'EmployeeName' in merged.columns:
        merged['EmployeeName'] = merged['EmployeeName'].apply(lambda v: None if (v is None or (isinstance(v, float) and np.isnan(v)) or _looks_like_guid(v) or _is_placeholder_str(v)) else str(v).strip())

    return merged


# ---------------- SCENARIOS (boolean functions) ----------------
def scenario_long_gap(row):
    return (row.get('MaxSwipeGapSeconds') or 0) >= 90 * 60

def scenario_short_duration(row):
    return (row.get('DurationMinutes') or 0) < 240

def scenario_coffee_badging(row):
    return (row.get('CountSwipes') or 0) >= 4 and (row.get('DurationMinutes') or 0) < 60

def scenario_low_swipe_count(row):
    return 0 < (row.get('CountSwipes') or 0) <= 2

def scenario_single_door(row):
    return (row.get('UniqueDoors') or 0) <= 1

def scenario_only_in(row):
    return int(row.get('OnlyIn', 0)) == 1

def scenario_only_out(row):
    return int(row.get('OnlyOut', 0)) == 1

def scenario_overtime(row):
    return (row.get('DurationMinutes') or 0) >= 10 * 60

def scenario_very_long_duration(row):
    return (row.get('DurationMinutes') or 0) >= 16 * 60

def scenario_zero_swipes(row):
    return int(row.get('CountSwipes', 0)) == 0

def scenario_unusually_high_swipes(row):
    cur = row.get('CountSwipes') or 0
    empid = row.get('EmployeeID')
    try:
        if not HIST_DF.empty and empid is not None and empid in HIST_DF['EmployeeID'].values:
            rec = HIST_DF[HIST_DF['EmployeeID'] == empid].iloc[0]
            median = float(rec.get('TotalSwipes_median', np.nan))
            if np.isfinite(median) and median > 0:
                return cur > 3 * median
    except Exception:
        pass
    if not HIST_DF.empty and 'TotalSwipes_median' in HIST_DF.columns:
        global_med = HIST_DF['TotalSwipes_median'].median()
        if pd.notna(global_med) and global_med > 0:
            return cur > 3 * global_med
    return cur > 50

def scenario_repeated_short_breaks(row):
    return (row.get('ShortGapCount') or 0) >= 3

def scenario_multiple_location_same_day(row):
    return (row.get('UniqueLocations') or 0) > 1

def scenario_weekend_activity(row):
    try:
        d = pd.to_datetime(row['Date'])
        return d.weekday() >= 5
    except Exception:
        return False

def scenario_repeated_rejection_count(row):
    return (row.get('RejectionCount') or 0) >= 2

def scenario_badge_sharing_suspected(row, badge_map=None):
    card = row.get('CardNumber')
    d = row.get('Date')
    if card is None or pd.isna(card) or d is None:
        return False
    if badge_map is None:
        return False
    return badge_map.get((d, card), 0) > 1

def scenario_early_arrival_before_06(row):
    fs = row.get('FirstSwipe')
    if pd.isna(fs) or fs is None:
        return False
    try:
        t = pd.to_datetime(fs).time()
        return t < time(hour=6)
    except Exception:
        return False

def scenario_late_exit_after_22(row):
    ls = row.get('LastSwipe')
    if pd.isna(ls) or ls is None:
        return False
    try:
        t = pd.to_datetime(ls).time()
        return t >= time(hour=22)
    except Exception:
        return False

def scenario_shift_inconsistency(row):
    empid = row.get('EmployeeID')
    dur = row.get('DurationMinutes') or 0
    if HIST_DF is not None and not HIST_DF.empty and empid in HIST_DF['EmployeeID'].values:
        rec = HIST_DF[HIST_DF['EmployeeID'] == empid].iloc[0]
        med = rec.get('AvgDurationMins_median', np.nan)
        std = rec.get('AvgDurationMins_std', np.nan)
        if pd.notna(med) and pd.notna(std):
            return (dur < med - 2.5 * std) or (dur > med + 2.5 * std)
    return False

def scenario_trending_decline(row):
    empid = row.get('EmployeeID')
    if HIST_DF is None or HIST_DF.empty:
        return False
    if 'TrendingDecline' in HIST_DF.columns:
        rec = HIST_DF[HIST_DF['EmployeeID'] == empid]
        if not rec.empty:
            val = rec.iloc[0].get('TrendingDecline')
            return str(val).strip().lower() == 'yes' if pd.notna(val) else False
    return False

def scenario_consecutive_absent_days(row):
    if row.get('CountSwipes') == 0:
        empid = row.get('EmployeeID')
        if HIST_DF is not None and not HIST_DF.empty and 'ConsecAbsent3Plus' in HIST_DF.columns:
            rec = HIST_DF[HIST_DF['EmployeeID'] == empid]
            if not rec.empty:
                v = rec.iloc[0].get('ConsecAbsent3Plus')
                return str(v).strip().lower() in ('yes', 'true', '1')
        return False
    return False

def scenario_high_variance_duration(row):
    empid = row.get('EmployeeID')
    if HIST_DF is not None and not HIST_DF.empty and empid in HIST_DF['EmployeeID'].values:
        rec = HIST_DF[HIST_DF['EmployeeID'] == empid].iloc[0]
        med = rec.get('AvgDurationMins_median', np.nan)
        std = rec.get('AvgDurationMins_std', np.nan)
        if pd.notna(med) and pd.notna(std) and med > 0:
            return (std / med) > 1.0
    return False

def scenario_short_duration_on_high_presence_days(row):
    days_present = row.get('DaysPresentInWeek') or 0
    dur = row.get('DurationMinutes') or 0
    return (days_present >= 4) and (dur < 240)

def scenario_swipe_overlap(row, swipe_overlap_map=None):
    d = row.get('Date')
    uid = row.get('person_uid')
    if swipe_overlap_map is None or d is None or uid is None:
        return False
    return (d, uid) in swipe_overlap_map

# NEW scenario: the pattern described by the user
def scenario_shortstay_longout_repeat(row):
    # Uses the feature computed in compute_features: PatternShortLongRepeat
    return bool(row.get('PatternShortLongRepeat', False))


# scenario list (name, fn)
SCENARIOS = [
    ("long_gap_>=90min", scenario_long_gap),
    ("short_duration_<4h", scenario_short_duration),
    ("coffee_badging", scenario_coffee_badging),
    ("low_swipe_count_<=2", scenario_low_swipe_count),
    ("single_door", scenario_single_door),
    ("only_in", scenario_only_in),
    ("only_out", scenario_only_out),
    ("overtime_>=10h", scenario_overtime),
    ("very_long_duration_>=16h", scenario_very_long_duration),
    ("zero_swipes", scenario_zero_swipes),
    ("unusually_high_swipes", scenario_unusually_high_swipes),
    ("repeated_short_breaks", scenario_repeated_short_breaks),
    ("multiple_location_same_day", scenario_multiple_location_same_day),
    ("weekend_activity", scenario_weekend_activity),
    ("repeated_rejection_count", scenario_repeated_rejection_count),
    ("badge_sharing_suspected", scenario_badge_sharing_suspected),
    ("early_arrival_before_06", scenario_early_arrival_before_06),
    ("late_exit_after_22", scenario_late_exit_after_22),
    ("shift_inconsistency", scenario_shift_inconsistency),
    ("trending_decline", scenario_trending_decline),
    ("consecutive_absent_days", scenario_consecutive_absent_days),
    ("high_variance_duration", scenario_high_variance_duration),
    ("short_duration_on_high_presence_days", scenario_short_duration_on_high_presence_days),
    ("swipe_overlap", scenario_swipe_overlap),
    # new pattern scenario
    ("shortstay_longout_repeat", scenario_shortstay_longout_repeat)
]


def run_trend_for_date(target_date: date, outdir: str = "./outputs", city='Pune'):
    logging.info("run_trend_for_date: date=%s (city=%s)", target_date, city)
    results = run_for_date(target_date, regions=['apac'], outdir=outdir, city=city)
    apac = results.get('apac', {})
    swipes = apac.get('swipes', pd.DataFrame())
    durations = apac.get('durations', pd.DataFrame())

    # save raw swipes for evidence (full raw)
    try:
        if swipes is not None and not swipes.empty:
            sw_out = Path(outdir) / f"swipes_{city.lower().replace(' ','_')}_{target_date.strftime('%Y%m%d')}.csv"
            swipes.to_csv(sw_out, index=False)
            logging.info("Saved raw swipes to %s", sw_out)
    except Exception as e:
        logging.warning("Failed to save raw swipes: %s", e)

       # --- AFTER computing features = compute_features(swipes, durations)
    features = compute_features(swipes, durations)
    if features.empty:
        logging.warning("run_trend_for_date: no features computed")
        return pd.DataFrame()
  
      # ===== START FIX: reconcile zero CountSwipes with raw swipe files =====
    try:
        if swipes is not None and not swipes.empty and 'person_uid' in swipes.columns:
            tsw = swipes.copy()
            # Ensure LocaleMessageTime is datetime and Date is date
            if 'LocaleMessageTime' in tsw.columns:
                tsw['LocaleMessageTime'] = pd.to_datetime(tsw['LocaleMessageTime'], errors='coerce')
            else:
                # try common time columns
                for cand in ('MessageUTC','MessageTime','Timestamp','timestamp'):
                    if cand in tsw.columns:
                        tsw['LocaleMessageTime'] = pd.to_datetime(tsw[cand], errors='coerce')
                        break
            if 'Date' not in tsw.columns:
                if 'LocaleMessageTime' in tsw.columns:
                    tsw['Date'] = tsw['LocaleMessageTime'].dt.date
                else:
                    # try to parse a Date-like column
                    for cand in ('date','Date'):
                        if cand in tsw.columns:
                            try:
                                tsw['Date'] = pd.to_datetime(tsw[cand], errors='coerce').dt.date
                            except Exception:
                                tsw['Date'] = None
                            break

            # Build lookup maps keyed by (person_uid, Date)
            try:
                grp = tsw.dropna(subset=['person_uid', 'Date']).groupby(['person_uid', 'Date'])
                counts = grp.size().to_dict()  # (person_uid, date) -> count
                firsts = grp['LocaleMessageTime'].min().to_dict()
                lasts = grp['LocaleMessageTime'].max().to_dict()
            except Exception:
                counts = {}
                firsts = {}
                lasts = {}

            # For any feature row with CountSwipes == 0, try to populate from raw swipes
            def _fix_row_by_raw(idx, row):
                key = (row.get('person_uid'), row.get('Date'))
                if key in counts and (row.get('CountSwipes', 0) == 0 or pd.isna(row.get('CountSwipes'))):
                    try:
                        c = int(counts.get(key, 0))
                        features.at[idx, 'CountSwipes'] = c
                        # set first/last swipe if available and not set
                        f = firsts.get(key)
                        l = lasts.get(key)
                        if pd.notna(f) and (pd.isna(row.get('FirstSwipe')) or row.get('FirstSwipe') is None):
                            features.at[idx, 'FirstSwipe'] = pd.to_datetime(f)
                        if pd.notna(l) and (pd.isna(row.get('LastSwipe')) or row.get('LastSwipe') is None):
                            features.at[idx, 'LastSwipe'] = pd.to_datetime(l)
                        # recompute DurationSeconds/DurationMinutes
                        try:
                            fs = features.at[idx, 'FirstSwipe']
                            ls = features.at[idx, 'LastSwipe']
                            if pd.notna(fs) and pd.notna(ls):
                                dursec = (pd.to_datetime(ls) - pd.to_datetime(fs)).total_seconds()
                                dursec = max(0, dursec)
                                features.at[idx, 'DurationSeconds'] = float(dursec)
                                features.at[idx, 'DurationMinutes'] = float(dursec / 60.0)
                        except Exception:
                            pass
                    except Exception:
                        pass

            for ix, r in features[features['CountSwipes'].fillna(0).astype(int) == 0].iterrows():
                try:
                    _fix_row_by_raw(ix, r)
                except Exception:
                    logging.debug("Failed to reconcile row %s with raw swipes", ix)
    except Exception:
        logging.exception("Error while reconciling aggregated features with raw swipes (zero-swipe fix).")
    # ===== END FIX =====


    # Build badge map and swipe overlap maps for higher-severity scenarios
    badge_map = {}
    if 'CardNumber' in swipes.columns and 'person_uid' in swipes.columns and 'Date' in swipes.columns:
        tmp = swipes[['CardNumber', 'person_uid', 'Date']].dropna(subset=['CardNumber'])
        if not tmp.empty:
            grouped_card = tmp.groupby(['Date', 'CardNumber'])['person_uid'].nunique().reset_index(name='distinct_users')
            badge_map = {(row.Date, row.CardNumber): int(row.distinct_users) for row in grouped_card.itertuples(index=False)}

    swipe_overlap_map = {}
    overlap_window_seconds = 2
    if {'Door', 'LocaleMessageTime', 'person_uid', 'Date'}.issubset(swipes.columns):
        tmp = swipes[['Door', 'LocaleMessageTime', 'person_uid', 'Date']].dropna()
        if not tmp.empty:
            tmp = tmp.sort_values(['Door', 'LocaleMessageTime'])
            for (d, door), g in tmp.groupby(['Date', 'Door']):
                items = list(g[['LocaleMessageTime', 'person_uid']].itertuples(index=False, name=None))
                n = len(items)
                for i in range(n):
                    t_i, uid_i = items[i]
                    j = i+1
                    while j < n and (items[j][0] - t_i).total_seconds() <= overlap_window_seconds:
                        uid_j = items[j][1]
                        if uid_i != uid_j:
                            swipe_overlap_map.setdefault((d, uid_i), set()).add(uid_j)
                            swipe_overlap_map.setdefault((d, uid_j), set()).add(uid_i)
                        j += 1

    # Evaluate scenarios (use weighting to compute anomaly score)
    WEIGHTS = {
        "long_gap_>=90min": 0.3,
        "short_duration_<4h": 1.0,
        "coffee_badging": 1.0,
        "low_swipe_count_<=2": 0.5,
        "single_door": 0.25,
        "only_in": 0.8,
        "only_out": 0.8,
        "overtime_>=10h": 0.2,
        "very_long_duration_>=16h": 1.5,
        "zero_swipes": 0.4,
        "unusually_high_swipes": 1.5,
        "repeated_short_breaks": 0.5,
        "multiple_location_same_day": 0.6,
        "weekend_activity": 0.6,
        "repeated_rejection_count": 0.8,
        "badge_sharing_suspected": 2.0,
        "early_arrival_before_06": 0.4,
        "late_exit_after_22": 0.4,
        "shift_inconsistency": 1.2,
        "trending_decline": 0.7,
        "consecutive_absent_days": 1.2,
        "high_variance_duration": 0.8,
        "short_duration_on_high_presence_days": 1.1,
        "swipe_overlap": 2.0,
        # weight for new scenario
        "shortstay_longout_repeat": 2.0
    }
    ANOMALY_THRESHOLD = 1.5

    # evaluate scenarios and compute score
    for name, fn in SCENARIOS:
        if name == "badge_sharing_suspected":
            features[name] = features.apply(lambda r: scenario_badge_sharing_suspected(r, badge_map=badge_map), axis=1)
        elif name == "swipe_overlap":
            features[name] = features.apply(lambda r: scenario_swipe_overlap(r, swipe_overlap_map), axis=1)
        else:
            features[name] = features.apply(lambda r, f=fn: bool(f(r)), axis=1)

    def compute_score(r):
        score = 0.0
        detected = []
        for name, _ in SCENARIOS:
            val = bool(r.get(name))
            w = WEIGHTS.get(name, 0.0)
            if val and w > 0:
                score += float(w)
                detected.append(name)
        return score, detected

    scores = features.apply(lambda r: pd.Series(compute_score(r), index=['AnomalyScore', 'DetectedScenarios']), axis=1)
    features['AnomalyScore'] = scores['AnomalyScore'].astype(float)
    features['DetectedScenarios'] = scores['DetectedScenarios'].apply(lambda x: "; ".join(x) if (isinstance(x, (list, tuple)) and len(x)>0) else None)
    features['IsFlagged'] = features['AnomalyScore'].apply(lambda s: bool(s >= ANOMALY_THRESHOLD))

    def reasons_for_row(r):
        if not bool(r.get('IsFlagged')):
            return None
        ds = r.get('DetectedScenarios')
        if ds:
            # prefer human explanation for the new pattern
            reasons = []
            for sc in (ds.split(";") if isinstance(ds, str) else []):
                sc = sc.strip()
                if sc == "shortstay_longout_repeat":
                    # explain with computed pattern sequence and break durations
                    seq = r.get('PatternSequence') or "sequence_not_available"
                    reasons.append(f"Pattern detected (short stay -> long out -> short return): {seq}")
                else:
                    reasons.append(sc)
            return "; ".join(reasons) if reasons else ds
        return None
    features['Reasons'] = features.apply(reasons_for_row, axis=1)

    if 'OverlapWith' not in features.columns:
        def overlap_with_fn(r):
            d = r.get('Date')
            uid = r.get('person_uid')
            if (d, uid) in swipe_overlap_map:
                return ";".join(sorted(str(x) for x in swipe_overlap_map[(d, uid)]))
            return None
        features['OverlapWith'] = features.apply(overlap_with_fn, axis=1)

    # Remove suffix columns and fix duplicates
    cols_to_drop = [c for c in features.columns if c.endswith("_x") or c.endswith("_y")]
    if cols_to_drop:
        for c in cols_to_drop:
            base = c[:-2]
            if base in features.columns:
                try:
                    features.drop(columns=[c], inplace=True)
                except Exception:
                    pass
            else:
                try:
                    features.rename(columns={c: base}, inplace=True)
                except Exception:
                    pass
    features = features.loc[:, ~features.columns.duplicated()]

    # ensure booleans are native Python (avoid numpy.bool_)
    for col in [name for name, _ in SCENARIOS] + ['IsFlagged']:
        if col in features.columns:
            features[col] = features[col].astype(bool)

    # write CSV with native types
    out_csv = Path(outdir) / f"trend_pune_{target_date.strftime('%Y%m%d')}.csv"
    try:
        write_df = features.copy()
        # FirstSwipe/LastSwipe -> ISO strings
        for dtcol in ('FirstSwipe', 'LastSwipe'):
            if dtcol in write_df.columns:
                write_df[dtcol] = pd.to_datetime(write_df[dtcol], errors='coerce').dt.strftime('%Y-%m-%dT%H:%M:%S')
        # Date -> ISO date
        if 'Date' in write_df.columns:
            try:
                write_df['Date'] = pd.to_datetime(write_df['Date'], errors='coerce').dt.date
                write_df['Date'] = write_df['Date'].apply(lambda d: d.isoformat() if pd.notna(d) else None)
            except Exception:
                pass
        write_df = write_df.where(pd.notnull(write_df), None)
        write_df.to_csv(out_csv, index=False)
        logging.info("run_trend_for_date: wrote %s (rows=%d)", out_csv, len(write_df))
    except Exception as e:
        logging.exception("Failed to write trend CSV: %s", e)

    return features


# ---------------- training dataset builder (restored) ----------------
def build_monthly_training(end_date: date = None, months: int = 3, min_unique_employees: int = 1000,
                           outdir: str = "./outputs", city: str = "Pune"):
    if end_date is None:
        end_date = datetime.now().date()
    logging.info("build_monthly_training: end_date=%s months=%d min_unique=%d", end_date, months, min_unique_employees)
    outdir = Path(outdir)
    month_windows = []
    cur = end_date.replace(day=1)
    for _ in range(months):
        start = cur
        next_month = (cur.replace(day=28) + timedelta(days=4)).replace(day=1)
        last = next_month - timedelta(days=1)
        month_windows.append((start, last))
        cur = (start - timedelta(days=1)).replace(day=1)

    person_month_rows = []
    unique_persons = set()

    for start, last in month_windows:
        d = start
        month_dfs = []
        while d <= last:
            csv_path = outdir / f"trend_pune_{d.strftime('%Y%m%d')}.csv"
            if csv_path.exists():
                try:
                    df = pd.read_csv(csv_path)
                    month_dfs.append(df)
                except Exception:
                    try:
                        df = pd.read_csv(csv_path, dtype=str)
                        month_dfs.append(df)
                    except Exception as e:
                        logging.warning("Failed reading %s: %s", csv_path, e)
            else:
                # generate the daily trend if missing
                logging.info("Monthly builder: trend CSV missing for %s — generating by running run_trend_for_date", d.isoformat())
                try:
                    run_trend_for_date(d, outdir=str(outdir), city=city)
                    # attempt to read after generating
                    if csv_path.exists():
                        try:
                            df = pd.read_csv(csv_path)
                            month_dfs.append(df)
                        except Exception:
                            try:
                                df = pd.read_csv(csv_path, dtype=str)
                                month_dfs.append(df)
                            except Exception as e:
                                logging.warning("Failed reading %s after generation: %s", csv_path, e)
                except Exception as e:
                    logging.warning("Failed to generate trend for %s: %s", d, e)
            d = d + timedelta(days=1)

        if not month_dfs:
            logging.info("No daily trend CSVs found for month %s - %s", start.isoformat(), last.isoformat())
            continue

        month_df = pd.concat(month_dfs, ignore_index=True)
        # ensure person_uid exists
        if 'person_uid' not in month_df.columns:
            def make_person_uid(row):
                parts = []
                for c in ('EmployeeIdentity', 'EmployeeID', 'EmployeeName'):
                    v = row.get(c)
                    if pd.notna(v) and str(v).strip():
                        parts.append(str(v).strip())
                return "|".join(parts) if parts else None
            month_df['person_uid'] = month_df.apply(make_person_uid, axis=1)

        # convert boolean columns to int for aggregation if necessary
        for name, _ in SCENARIOS:
            if name in month_df.columns:
                month_df[name] = month_df[name].astype(int)

        agg_funcs = {
            'CountSwipes': ['median', 'mean', 'sum'],
            'DurationMinutes': ['median', 'mean', 'sum'],
            'MaxSwipeGapSeconds': ['max', 'median'],
            'ShortGapCount': ['sum'],
            'UniqueDoors': ['median'],
            'UniqueLocations': ['median'],
            'RejectionCount': ['sum']
        }
        scenario_cols = [name for name,_ in SCENARIOS if name in month_df.columns]
        group_cols = ['person_uid']
        grp = month_df.groupby(group_cols)

        for person, g in grp:
            row = {}
            row['person_uid'] = person
            row['EmployeeID'] = next((v for v in g.get('EmployeeID', []) if pd.notna(v) and not _is_placeholder_str(v)), None)
            row['EmployeeName'] = next((v for v in g.get('EmployeeName', []) if pd.notna(v) and not _is_placeholder_str(v)), None)
            row['MonthStart'] = start.isoformat()
            row['MonthEnd'] = last.isoformat()
            for col, funcs in agg_funcs.items():
                if col in g.columns:
                    for f in funcs:
                        key = f"{col}_{f}"
                        try:
                            val = getattr(g[col], f)()
                            row[key] = float(val) if pd.notna(val) else None
                        except Exception:
                            row[key] = None
                else:
                    for f in funcs:
                        row[f"{col}_{f}"] = None
            for s in scenario_cols:
                row[f"{s}_days"] = int(g[s].sum())
                row[f"{s}_label"] = int(g[s].sum() > 0)
            row['days_present'] = int(g.shape[0])
            person_month_rows.append(row)
            unique_persons.add(person)

        if len(unique_persons) >= min_unique_employees:
            logging.info("Reached min unique employees=%d, stopping aggregation early", min_unique_employees)
            break

    if not person_month_rows:
        logging.warning("No person-month rows created (no data).")
        return None

    training_df = pd.DataFrame(person_month_rows)
    train_out = outdir / "training_person_month.csv"
    training_df.to_csv(train_out, index=False)
    logging.info("Saved training CSV to %s (rows=%d unique_persons=%d)", train_out, len(training_df), len(unique_persons))
    return train_out


if __name__ == "__main__":
    today = datetime.now().date()
    df = run_trend_for_date(today)
    print("Completed; rows:", len(df) if df is not None else 0)









