Check below all Login details pages carefully and want to Update like ...
our issue is 
1) When we got access for someone then add option for create password and change password .
so password will diffrent for everyone..

2) Access Grant option is Working Perfect but Access Revoke button is not Working Which is need to fix strickly when Access removed 
remove access from database fix issue carefully


Check below file carefully..

C:\Users\W0024618\Desktop\global-page\frontend\src\pages\AccessManager.jsx

import React, { useEffect, useState } from 'react';
import { Box, Paper, TextField, Button, Typography, Checkbox, FormControlLabel, Grid, Alert } from '@mui/material';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';

// Define available page keys (map to UI names)
// Added granular keys: headcount.<region>, gsoc_reports.<report>, upload/export perms, global_access
const PAGES = [
  { key: 'global_access', label: 'Global Access (all pages)' },
  { key: 'device_health', label: 'Device Health Dashboard' },
  { key: 'headcount', label: 'HeadCount (any region)' },
  { key: 'headcount.apac', label: 'HeadCount — APAC' },
  { key: 'headcount.emea', label: 'HeadCount — EMEA' },
  { key: 'headcount.laca', label: 'HeadCount — LACA' },
  { key: 'headcount.namer', label: 'HeadCount — NAMER' },
  { key: 'headcount.partition.pune', label: 'HeadCount — Pune (partition)' },

  { key: 'ert', label: 'ERT Members' },
  { key: 'associate_verify', label: 'Associate Verification Tool' },

  // GSOC reports per-report keys
  { key: 'gsoc_reports', label: 'GSOC Reports (all)' },
  { key: 'gsoc_reports.daily_access', label: 'GSOC — Daily Access' },
  { key: 'gsoc_reports.raw', label: 'GSOC — Raw' },
  { key: 'gsoc_reports.rejection', label: 'GSOC — Rejection' },
  { key: 'gsoc_reports.euroc', label: 'GSOC — EUROC Admit/Reject' },
  { key: 'gsoc_reports.time_duration', label: 'GSOC — Time Duration' },
  { key: 'gsoc_reports.headcount', label: 'GSOC — HeadCount (external nav)' },

  // Upload / export permissions
  { key: 'upload_active_employees', label: 'Upload Active Employee Sheet' },
  { key: 'upload_active_contractors', label: 'Upload Active Contractor Sheet' },
  { key: 'export_compare', label: 'Export Comparison (Missing vs CCURE)' },

  { key: 'global_duration', label: 'Duration Page (global)' },
  { key: 'can_grant', label: 'Grant permissions (admin)' },
];

export default function AccessManager() {
  const auth = useAuth();
  const [employeeId, setEmployeeId] = useState('');
  const [employeeName, setEmployeeName] = useState('');
  const [checked, setChecked] = useState({});
  const [status, setStatus] = useState(null);

  useEffect(() => {
    // nothing heavy here
  }, []);

  if (!auth.canGrant) {
    return <Box sx={{ p: 3 }}><Alert severity="error">You don't have grant permissions.</Alert></Box>;
  }

  const handleCheck = (k) => {
    setChecked(prev => ({ ...prev, [k]: !prev[k] }));
  };

  const handleGrant = async () => {
    if (!employeeId && !employeeName) {
      setStatus({ type: 'error', msg: 'Enter Employee ID or name to grant access' });
      return;
    }
    setStatus({ type: 'info', msg: 'Granting...' });
    try {
      const pages = Object.keys(checked).filter(k => checked[k]);
      await axios.post('/api/auth/grant', { grantee_employee_id: employeeId, grantee_name: employeeName, pages });
      setStatus({ type: 'success', msg: 'Granted successfully' });
      // refresh permission cache for current user if implemented by auth
      try { if (auth.refresh) await auth.refresh(); } catch (e) { /* ignore */ }
    } catch (err) {
      console.error(err);
      setStatus({ type: 'error', msg: err?.response?.data?.detail || err?.message || 'Grant failed' });
    }
  };

  const handleRevoke = async () => {
    if (!employeeId && !employeeName) {
      setStatus({ type: 'error', msg: 'Enter Employee ID or name to revoke access' });
      return;
    }
    setStatus({ type: 'info', msg: 'Revoking...' });
    try {
      const pages = Object.keys(checked).filter(k => checked[k]);

      const resp = await axios.post('/api/auth/revoke', { grantee_employee_id: employeeId, grantee_name: employeeName, pages });

      // Some backends return 204 No Content; others return 200 + message
      if (resp && (resp.status === 200 || resp.status === 204)) {
        setStatus({ type: 'success', msg: 'Revoked successfully' });
      } else {
        setStatus({ type: 'success', msg: 'Revoked (response received)' });
      }

      // Refresh current user's permissions (if the backend supports it)
      try { if (auth.refresh) await auth.refresh(); } catch (e) { console.warn('auth.refresh failed', e); }

      // Clear the checked boxes for user feedback
      setChecked({});
    } catch (err) {
      console.error(err);

      // prefer structured server detail if present
      const serverMsg = err?.response?.data?.detail || err?.response?.data?.error || err?.response?.data || null;
      setStatus({ type: 'error', msg: serverMsg || err?.message || 'Revoke failed' });
    }
  };

  const selectAll = () => {
    const obj = {};
    PAGES.forEach(p => obj[p.key] = true);
    setChecked(obj);
  };
  const clearAll = () => setChecked({});

  return (
    <Box sx={{ p: 3 }}>
      <Paper sx={{ p: 3 }}>
        <Typography variant="h6" sx={{ mb: 2 }}>Access Manager — Grant / Revoke Pages</Typography>

        {status && <Alert severity={status.type} sx={{ mb: 2 }}>{status.msg}</Alert>}

        <Grid container spacing={2}>
          <Grid item xs={12} md={6}>
            <TextField fullWidth label="Employee ID (e.g. W0025562)" value={employeeId} onChange={e => setEmployeeId(e.target.value)} helperText="EmployeeID or login"/>
          </Grid>
          <Grid item xs={12} md={6}>
            <TextField fullWidth label="Employee Name (optional)" value={employeeName} onChange={e => setEmployeeName(e.target.value)} />
          </Grid>

          <Grid item xs={12}>
            <Typography sx={{ mb: 1, fontWeight: 700 }}>Pages to grant / revoke</Typography>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
              {PAGES.map(p => (
                <FormControlLabel
                  key={p.key}
                  control={<Checkbox checked={!!checked[p.key]} onChange={() => handleCheck(p.key)} />}
                  label={p.label}
                />
              ))}
            </Box>

            <Box sx={{ display: 'flex', gap: 1, mt: 2 }}>
              <Button variant="outlined" onClick={selectAll}>Select all</Button>
              <Button variant="outlined" onClick={clearAll}>Clear</Button>
              <Button variant="contained" color="primary" onClick={handleGrant}>Grant access</Button>
              <Button variant="contained" color="error" onClick={handleRevoke}>Revoke access</Button>
            </Box>

            <Typography variant="caption" sx={{ display: 'block', mt: 2, color: 'text.secondary' }}>
              Granting will call backend and store the mapping. Revoking will remove access. After changes, this UI refreshes current user's permissions (if affected).
            </Typography>
          </Grid>
        </Grid>
      </Paper>
    </Box>
  );
}







C:\Users\W0024618\Desktop\global-page\frontend\src\pages\LoginPage.jsx

// frontend/src/pages/LoginPage.jsx
import React, { useState } from 'react';
import { Box, Paper, TextField, Button, Typography, Alert } from '@mui/material';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

export default function LoginPage() {
  const auth = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [busy, setBusy] = useState(false);
  const [error, setError] = useState('');

  const from = (location.state && location.state.from) || '/';

  const handleSubmit = async (e) => {
    e?.preventDefault();
    setBusy(true);
    setError('');
    const res = await auth.login(username.trim(), password);
    setBusy(false);
    if (res.ok) {
      navigate(from, { replace: true });
    } else {
      setError(res.error || 'Invalid credentials');
    }
  };

  return (
    <Box sx={{
      minHeight: '100vh',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      background: 'linear-gradient(180deg,#0b0b0b,#111)'
    }}>
      <Paper sx={{ width: 420, p: 4, borderRadius: 2, boxShadow: 6 }}>
        <Typography variant="h6" sx={{ mb: 2, fontWeight: 800 }}>Login — Global Page</Typography>
        {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
        <form onSubmit={handleSubmit}>
          <TextField fullWidth label="Username (Employee name or ID)" value={username} onChange={e => setUsername(e.target.value)} sx={{ mb: 2 }} />
          <TextField fullWidth label="Password" type="password" value={password} onChange={e => setPassword(e.target.value)} sx={{ mb: 2 }} />
          <Box sx={{ display: 'flex', gap: 1, justifyContent: 'space-between', alignItems: 'center' }}>
            <Button variant="contained" type="submit" disabled={busy}>{busy ? 'Signing in...' : 'Sign in'}</Button>
            <Button variant="outlined" onClick={() => { setUsername(''); setPassword(''); }}>Clear</Button>
          </Box>
        </form>

        <Typography variant="caption" sx={{ display: 'block', mt: 2, color: 'text.secondary' }}>
          Tip: use backend-registered employee credentials. Admins with grant permissions will see an Access Manager link.
        </Typography>
      </Paper>
    </Box>
  );
}








//C:\Users\W0024618\Desktop\global-page\frontend\src\context\AuthContext.jsx

import React, { createContext, useContext, useEffect, useState } from 'react';
import axios from 'axios';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null); // { EmployeeName, EmployeeID, username, ...}
  const [permissions, setPermissions] = useState({}); // { device_health: true, headcount.apac: true, ... }
  const [loading, setLoading] = useState(true);
  const [token, setToken] = useState(() => localStorage.getItem('auth_token') || null);

  // Set axios default header when token changed
  useEffect(() => {
    if (token) {
      axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      localStorage.setItem('auth_token', token);
    } else {
      delete axios.defaults.headers.common['Authorization'];
      localStorage.removeItem('auth_token');
    }
  }, [token]);

  // Try to load user/permissions on start if token exists
  useEffect(() => {
    let cancelled = false;
    async function fetchMe() {
      if (!token) {
        setLoading(false);
        return;
      }
      try {
        const res = await axios.get('/api/auth/me'); // expects { user, permissions }
        if (cancelled) return;
        setUser(res.data.user || null);
        setPermissions(res.data.permissions || {});
      } catch (err) {
        console.warn('fetch /api/auth/me failed', err?.message || err);
        // if token invalid -> clear
        setToken(null);
        setUser(null);
        setPermissions({});
      } finally {
        if (!cancelled) setLoading(false);
      }
    }
    fetchMe();
    return () => { cancelled = true; };
  }, [token]);

  const login = async (username, password) => {
    try {
      const res = await axios.post('/api/auth/login', { username, password });
      const { token: t, user: u, permissions: p } = res.data;
      if (!t) throw new Error('missing token in login response');
      setToken(t);
      setUser(u || null);
      setPermissions(p || {});
      return { ok: true };
    } catch (err) {
      console.error('login failed', err?.response?.data || err?.message || err);
      const msg = err?.response?.data?.detail || err?.response?.data?.error || err?.message || 'Login failed';
      return { ok: false, error: msg };
    }
  };

  const logout = () => {
    setToken(null);
    setUser(null);
    setPermissions({});
  };

  // New: hasPermission supports:
  // - single permission string (e.g. 'device_health' or 'headcount.apac')
  // - returns true if user has 'global_access' (super-permission)
  // - returns true if exact key exists or if asked for 'headcount' and user has any 'headcount.*'
  // - accepts null/undefined -> false
  const hasPermission = (perm) => {
    if (!perm) return false;
    // super-permission
    if (permissions && permissions.global_access) return true;

    // if permission is array - require any match
    if (Array.isArray(perm)) {
      return perm.some(p => hasPermission(p));
    }

    // exact
    if (permissions && permissions[perm]) return true;

    // parent lookup: if asked 'headcount' and user has any headcount.* key - treat as allowed
    const parts = perm.split('.');
    if (parts.length === 1) {
      const prefix = `${perm}.`;
      for (const k of Object.keys(permissions || {})) {
        if (k.startsWith(prefix) && permissions[k]) return true;
      }
    }

    return false;
  };

  // canGrant (kept)
  const canGrant = !!permissions?.can_grant;

  // helper to refresh permissions (call when granting/revoking or token change)
  const refresh = async () => {
    if (!token) return;
    try {
      const res = await axios.get('/api/auth/me');
      setUser(res.data.user || null);
      setPermissions(res.data.permissions || {});
    } catch (err) {
      console.warn('refresh failed', err);
    }
  };

  return (
    <AuthContext.Provider value={{
      user,
      token,
      loading,
      login,
      logout,
      hasPermission,
      canGrant,
      permissions,
      refresh,
    }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  return useContext(AuthContext);
}









// backend/routes/auth.js
import express from 'express';
import { readFile, writeFile } from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import crypto from 'crypto';

const router = express.Router();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const USERS_FILE = path.resolve(__dirname, '../config/users.json');

// In-memory token->employeeId map (lost on server restart)
const activeTokens = new Map();

async function loadUsers() {
  try {
    const raw = await readFile(USERS_FILE, 'utf8');
    const obj = JSON.parse(raw);
    return obj && Array.isArray(obj.users) ? obj.users : [];
  } catch (err) {
    // If missing file, return empty array
    return [];
  }
}

async function saveUsers(users) {
  const payload = { users };
  await writeFile(USERS_FILE, JSON.stringify(payload, null, 2), 'utf8');
}

function genToken() {
  return crypto.randomBytes(32).toString('hex');
}

function findUser(users, { username, employeeId }) {
  if (employeeId) {
    const byId = users.find(u => String(u.employeeId).toLowerCase() === String(employeeId).toLowerCase());
    if (byId) return byId;
  }
  if (username) {
    const byName = users.find(u => String(u.username).toLowerCase() === String(username).toLowerCase());
    if (byName) return byName;
    // also allow login by exact EmployeeID sent in username field
    const byId2 = users.find(u => String(u.employeeId).toLowerCase() === String(username).toLowerCase());
    if (byId2) return byId2;
  }
  return null;
}

// middleware to require token and attach user object to req.currentUser
async function requireAuth(req, res, next) {
  try {
    const auth = req.headers.authorization || '';
    if (!auth.startsWith('Bearer ')) return res.status(401).json({ detail: 'Missing auth token' });
    const token = auth.slice(7).trim();
    const empId = activeTokens.get(token);
    if (!empId) return res.status(401).json({ detail: 'Invalid or expired token' });

    const users = await loadUsers();
    const user = users.find(u => String(u.employeeId).toLowerCase() === String(empId).toLowerCase());
    if (!user) return res.status(401).json({ detail: 'Invalid token (user not found)' });

    req.currentUser = user;
    req.currentToken = token;
    next();
  } catch (err) {
    next(err);
  }
}

// --- POST /login
// body: { username, password }
router.post('/login', async (req, res, next) => {
  try {
    const { username, password } = req.body || {};
    if (!username || !password) return res.status(400).json({ detail: 'username and password are required' });

    const users = await loadUsers();
    const user = findUser(users, { username });
    if (!user) return res.status(401).json({ detail: 'Invalid credentials' });

    // plain-text compare for prototype. Replace with bcrypt in prod.
    if (String(user.password || '') !== String(password)) return res.status(401).json({ detail: 'Invalid credentials' });

    // generate token and store mapping
    const token = genToken();
    activeTokens.set(token, user.employeeId);

    // Return minimal user object (do not expose password)
    const safeUser = {
      username: user.username,
      employeeId: user.employeeId,
      // you can include additional fields if present
    };

    return res.json({ token, user: safeUser, permissions: user.permissions || {} });
  } catch (err) {
    next(err);
  }
});

// --- GET /me
// header: Authorization: Bearer <token>
router.get('/me', requireAuth, async (req, res, next) => {
  try {
    const user = req.currentUser;
    const safeUser = { username: user.username, employeeId: user.employeeId };
    return res.json({ user: safeUser, permissions: user.permissions || {} });
  } catch (err) {
    next(err);
  }
});

// --- POST /grant
// body: { grantee_employee_id, grantee_name, pages: ['headcount','ert', ...] }
// Only callers with currentUser.permissions.can_grant === true
router.post('/grant', requireAuth, async (req, res, next) => {
  try {
    const caller = req.currentUser;
    if (!caller.permissions || !caller.permissions.can_grant) return res.status(403).json({ detail: 'You do not have grant permission' });

    const { grantee_employee_id, grantee_name, pages } = req.body || {};
    if ((!grantee_employee_id && !grantee_name) || !Array.isArray(pages)) {
      return res.status(400).json({ detail: 'grantee_employee_id or grantee_name and pages[] are required' });
    }

    const users = await loadUsers();

    let grantee = findUser(users, { employeeId: grantee_employee_id, username: grantee_name });

    if (!grantee) {
      // create minimal user record (password blank) — admin should set password later
      grantee = {
        username: grantee_name || (grantee_employee_id ? `emp-${grantee_employee_id}` : 'unknown'),
        employeeId: grantee_employee_id || `unknown-${Date.now()}`,
        password: '',
        permissions: {}
      };
      users.push(grantee);
    }

    if (!grantee.permissions) grantee.permissions = {};
    for (const p of pages) {
      grantee.permissions[p] = true;
    }

    await saveUsers(users);

    // Return updated grantee (sans password)
    const safeGrantee = { username: grantee.username, employeeId: grantee.employeeId, permissions: grantee.permissions };
    return res.json({ ok: true, grantee: safeGrantee });
  } catch (err) {
    next(err);
  }
});

// --- POST /revoke
// body: { grantee_employee_id, grantee_name, pages: ['headcount', ...] }
// Only callers with can_grant
router.post('/revoke', requireAuth, async (req, res, next) => {
  try {
    const caller = req.currentUser;
    if (!caller.permissions || !caller.permissions.can_grant) return res.status(403).json({ detail: 'You do not have grant permission' });

    const { grantee_employee_id, grantee_name, pages } = req.body || {};
    if ((!grantee_employee_id && !grantee_name) || !Array.isArray(pages)) {
      return res.status(400).json({ detail: 'grantee_employee_id or grantee_name and pages[] are required' });
    }

    const users = await loadUsers();
    const grantee = findUser(users, { employeeId: grantee_employee_id, username: grantee_name });
    if (!grantee) return res.status(404).json({ detail: 'Grantee not found' });

    if (!grantee.permissions) grantee.permissions = {};
    for (const p of pages) {
      delete grantee.permissions[p]; // remove key
    }

    await saveUsers(users);

    const safeGrantee = { username: grantee.username, employeeId: grantee.employeeId, permissions: grantee.permissions };
    return res.json({ ok: true, grantee: safeGrantee });
  } catch (err) {
    next(err);
  }
});

// --- GET /list  (debug; returns users without passwords)
router.get('/list', requireAuth, async (req, res, next) => {
  try {
    const users = await loadUsers();
    const safe = users.map(u => ({ username: u.username, employeeId: u.employeeId, permissions: u.permissions || {} }));
    return res.json({ users: safe });
  } catch (err) {
    next(err);
  }
});

export default router;








C:\Users\W0024618\Desktop\global-page\backend\config\users.json

{
  "users": [
    {
      "username": "Lloyds Das",
      "employeeId": "314345",
      "password": "password123",
      "permissions": {
        "can_grant": true,
        "global_access": true,
        "device_health": true,
        "headcount": true,
        "headcount.apac": true,
        "headcount.emea": true,
        "headcount.laca": true,
        "headcount.namer": true,
        "ert": true,
        "associate_verify": true,
        "gsoc_reports": true,
        "global_duration": true,
        "upload_active_employees": true,
        "upload_active_contractors": true,
        "export_compare": true
      }
    },
    {
      "username": "Pandey Sonu",
      "employeeId": "326131",
      "password": "password123",
      "permissions": {
        "can_grant": true,
        "global_access": true,
        "device_health": true,
        "headcount": true,
        "headcount.apac": true,
        "headcount.emea": true,
        "headcount.laca": true,
        "headcount.namer": true,
        "ert": true,
        "associate_verify": true,
        "gsoc_reports": true,
        "global_duration": true,
        "upload_active_employees": true,
        "upload_active_contractors": true,
        "export_compare": true,
        "gsoc_reports.raw": true
      }
    },
    {
      "username": "Diwate Swapnil",
      "employeeId": "W0024618",
      "password": "password123",
      "permissions": {
        "can_grant": true,
        "global_access": true,
        "device_health": true,
        "headcount": true,
        "headcount.apac": true,
        "headcount.emea": true,
        "headcount.laca": true,
        "headcount.namer": true,
        "ert": true,
        "associate_verify": true,
        "gsoc_reports": true,
        "global_duration": true,
        "upload_active_employees": true,
        "upload_active_contractors": true,
        "export_compare": true
      }
    },
    {
      "username": "Dhobale, Abhishek",
      "employeeId": "W0025562",
      "password": "password123",
      "permissions": {
        "ert": true,
        "device_health": true
      }
    },
    {
      "username": "Sankalp Mahitkar",
      "employeeId": "W0019060",
      "password": "password123",
      "permissions": {
        "device_health": true,
        "headcount.apac": true
      }
    },
    {
      "username": "Sejal Satpute",
      "employeeId": "W0019059",
      "password": "password123",
      "permissions": {
        "headcount.apac": true
      }
    },
    {
      "username": "Vrutik",
      "employeeId": "W0019061",
      "password": "",
      "permissions": {}
    }
  ]
}


