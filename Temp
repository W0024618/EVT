# incident_report.py  --- additions / replacements for selected parts
import os
import json
from typing import Optional, List, Dict, Any
from datetime import datetime, date, time
from fastapi import APIRouter, HTTPException, UploadFile, File, Form, Depends, Response
from fastapi.responses import FileResponse
from pydantic import BaseModel, Field, EmailStr, validator
from sqlalchemy import Column, Integer, String, DateTime, Text, func, and_
from sqlalchemy.dialects.sqlite import JSON as SQLITE_JSON
from sqlalchemy.orm import Session

from database import Base, engine, SessionLocal

router = APIRouter(prefix="/incident", tags=["incident"])

# Ensure uploads directory exists
BASE_DIR = os.path.dirname(__file__)
UPLOAD_DIR = os.path.join(BASE_DIR, "uploads")
os.makedirs(UPLOAD_DIR, exist_ok=True)

# (Your existing IncidentReport model assumed unchanged)
class IncidentReport(Base):
    __tablename__ = "incident_reports"

    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    # ... (keep all existing columns as-is)
    type_of_incident = Column(String, nullable=False)
    other_type_text = Column(String, nullable=True)
    date_of_report = Column(String, nullable=False)
    time_of_report = Column(String, nullable=False)
    impacted_name = Column(String, nullable=False)
    impacted_employee_id = Column(String, nullable=False)
    was_reported_verbally = Column(Integer, default=0)
    incident_reported_to = Column(String, nullable=True)
    reported_to_details = Column(String, nullable=True)
    location = Column(String, nullable=False)
    reported_by_name = Column(String, nullable=False)
    reported_by_employee_id = Column(String, nullable=False)
    reported_by_email = Column(String, nullable=False)
    reported_by_contact = Column(String, nullable=False)
    date_of_incident = Column(String, nullable=False)
    time_of_incident = Column(String, nullable=False)
    detailed_description = Column(Text, nullable=False)
    immediate_actions_taken = Column(Text, nullable=False)
    accompanying_person = Column(SQLITE_JSON, nullable=True)
    witnesses = Column(SQLITE_JSON, nullable=True)
    witness_contacts = Column(SQLITE_JSON, nullable=True)
    root_cause_analysis = Column(Text, nullable=True)
    preventive_actions = Column(Text, nullable=True)
    proofs = Column(SQLITE_JSON, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

Base.metadata.create_all(bind=engine)


# ---------- Improved file saving ----------
MAX_UPLOAD_BYTES = 10 * 1024 * 1024  # 10 MB per file (adjust as corporate policy)
ALLOWED_EXTENSIONS = {".png", ".jpg", ".jpeg", ".pdf", ".gif", ".bmp"}

def secure_filename(filename: str) -> str:
    # simple sanitization keeping alnum and a few chars
    name = "".join(c for c in filename if c.isalnum() or c in (" ", ".", "_", "-")).strip()
    return name or "upload"

def save_uploads(upload_files: Optional[List[UploadFile]]) -> List[str]:
    """Save uploaded files under uploads/YYYY/MM/ and return filenames (relative)."""
    if not upload_files:
        return []
    saved = []
    for f in upload_files:
        raw_name = getattr(f, "filename", "upload")
        name = secure_filename(raw_name)
        ext = os.path.splitext(name)[1].lower()
        if ext and ext not in ALLOWED_EXTENSIONS:
            # ignore or raise depending on policy; here we raise
            raise HTTPException(status_code=400, detail=f"File type not allowed: {ext}")
        # read file into memory up to limit
        data = awaitable_readfile(f)
        if len(data) > MAX_UPLOAD_BYTES:
            raise HTTPException(status_code=400, detail=f"File too large: {name}")
        ts = datetime.utcnow().strftime("%Y%m%d%H%M%S%f")
        # create folder by year/month
        y = datetime.utcnow().strftime("%Y")
        m = datetime.utcnow().strftime("%m")
        folder = os.path.join(UPLOAD_DIR, y, m)
        os.makedirs(folder, exist_ok=True)
        filename = f"{ts}_{name}"
        path = os.path.join(folder, filename)
        with open(path, "wb") as fh:
            fh.write(data)
        # store relative path from UPLOAD_DIR (so download endpoint can find later)
        rel = os.path.join(y, m, filename)
        saved.append(rel)
    return saved

# helper to safely read UploadFile contents (sync environment)
def awaitable_readfile(upload_file: UploadFile) -> bytes:
    """Read UploadFile.file.read() safely (UploadFile.file is a SpooledTemporaryFile)."""
    # NOTE: UploadFile.file.read() is blocking but small files ok for sync handlers.
    # If you switch to async endpoints, use await upload_file.read()
    upload_file.file.seek(0)
    data = upload_file.file.read()
    return data


# -------------------------
# Create endpoint (unchanged mostly)
# -------------------------
@router.post("/create", response_model=IncidentOut)
async def create_incident(
    payload: str = Form(...),            # JSON string of all fields (see IncidentCreate)
    proofs: Optional[List[UploadFile]] = File(None)
):
    try:
        data = json.loads(payload)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Invalid JSON payload: {e}")

    try:
        incident = IncidentCreate.parse_obj(data)
    except Exception as e:
        raise HTTPException(status_code=422, detail=str(e))

    db = SessionLocal()
    try:
        saved_files = []
        if proofs:
            # proofs may be UploadFile objects:
            saved_files = save_uploads_sync(proofs)  # using sync helper
        inst = IncidentReport(
            type_of_incident = incident.type_of_incident.strip(),
            other_type_text = incident.other_type_text.strip() if incident.other_type_text else None,
            date_of_report = incident.date_of_report.isoformat(),
            time_of_report = incident.time_of_report.strftime("%H:%M:%S"),
            impacted_name = incident.impacted_name.strip(),
            impacted_employee_id = incident.impacted_employee_id.strip(),
            was_reported_verbally = 1 if incident.was_reported_verbally else 0,
            incident_reported_to = json.dumps(incident.incident_reported_to) if incident.incident_reported_to else None,
            reported_to_details = incident.reported_to_details.strip() if incident.reported_to_details else None,
            location = incident.location.strip(),
            reported_by_name = incident.reported_by_name.strip(),
            reported_by_employee_id = incident.reported_by_employee_id.strip(),
            reported_by_email = str(incident.reported_by_email),
            reported_by_contact = incident.reported_by_contact.strip(),
            date_of_incident = incident.date_of_incident.isoformat(),
            time_of_incident = incident.time_of_incident.strftime("%H:%M:%S"),
            detailed_description = incident.detailed_description.strip(),
            immediate_actions_taken = incident.immediate_actions_taken.strip(),
            accompanying_person = [p.dict() for p in incident.accompanying_person] if incident.accompanying_person else None,
            witnesses = incident.witnesses if incident.witnesses else None,
            witness_contacts = incident.witness_contacts if incident.witness_contacts else None,
            root_cause_analysis = incident.root_cause_analysis.strip() if incident.root_cause_analysis else None,
            preventive_actions = incident.preventive_actions.strip() if incident.preventive_actions else None,
            proofs = saved_files if saved_files else None,
            created_at = datetime.utcnow()
        )

        db.add(inst)
        db.commit()
        db.refresh(inst)

        # convert incident_reported_to JSON-string back to list for response
        if inst.incident_reported_to:
            try:
                inst.incident_reported_to = json.loads(inst.incident_reported_to)
            except:
                inst.incident_reported_to = None

        return inst

    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        db.close()

# small sync wrapper for save_uploads (since we used blocking file.read)
def save_uploads_sync(upload_files: Optional[List[UploadFile]]) -> List[str]:
    if not upload_files:
        return []
    saved = []
    for f in upload_files:
        raw_name = getattr(f, "filename", "upload")
        name = secure_filename(raw_name)
        ext = os.path.splitext(name)[1].lower()
        if ext and ext not in ALLOWED_EXTENSIONS:
            raise HTTPException(status_code=400, detail=f"File type not allowed: {ext}")
        f.file.seek(0)
        data = f.file.read()
        if len(data) > MAX_UPLOAD_BYTES:
            raise HTTPException(status_code=400, detail=f"File too large: {name}")
        ts = datetime.utcnow().strftime("%Y%m%d%H%M%S%f")
        y = datetime.utcnow().strftime("%Y")
        m = datetime.utcnow().strftime("%m")
        folder = os.path.join(UPLOAD_DIR, y, m)
        os.makedirs(folder, exist_ok=True)
        filename = f"{ts}_{name}"
        path = os.path.join(folder, filename)
        with open(path, "wb") as fh:
            fh.write(data)
        rel = os.path.join(y, m, filename)
        saved.append(rel)
    return saved


# -------------------------
# Attachment download
# -------------------------
@router.get("/{incident_id}/attachment/{filename}")
def download_attachment(incident_id: int, filename: str):
    # filename here should be stored relative path (YYYY/MM/ts_name.ext)
    # Compose path and ensure file exists
    safe_path = os.path.normpath(os.path.join(UPLOAD_DIR, filename))
    # Prevent path traversal
    if not safe_path.startswith(os.path.abspath(UPLOAD_DIR)):
        raise HTTPException(status_code=400, detail="Invalid filename")
    if not os.path.exists(safe_path):
        raise HTTPException(status_code=404, detail="Attachment not found")
    return FileResponse(safe_path, filename=os.path.basename(safe_path))


# -------------------------
# Enhanced list endpoint with filters & pagination
# -------------------------
@router.get("/list", response_model=List[IncidentOut])
def list_incidents(
    limit: int = 200,
    page: int = 1,
    page_size: int = 50,
    type_of_incident: Optional[str] = None,
    location: Optional[str] = None,
    start_date: Optional[str] = None,   # ISO date string: YYYY-MM-DD
    end_date: Optional[str] = None      # ISO date string
):
    db = SessionLocal()
    try:
        q = db.query(IncidentReport)
        # filters (date fields are ISO strings; safe to compare lexicographically)
        if type_of_incident:
            q = q.filter(IncidentReport.type_of_incident == type_of_incident)
        if location:
            q = q.filter(IncidentReport.location.ilike(f"%{location}%"))
        if start_date:
            q = q.filter(IncidentReport.date_of_incident >= start_date)
        if end_date:
            q = q.filter(IncidentReport.date_of_incident <= end_date)

        # pagination
        page = max(page, 1)
        page_size = min(max(page_size, 1), 500)
        offset = (page - 1) * page_size

        rows = q.order_by(IncidentReport.created_at.desc()).offset(offset).limit(page_size).all()

        for r in rows:
            if isinstance(r.incident_reported_to, str):
                try:
                    r.incident_reported_to = json.loads(r.incident_reported_to)
                except:
                    r.incident_reported_to = None
        return rows
    finally:
        db.close()


# -------------------------
# Monthly aggregation endpoint
# -------------------------
@router.get("/stats/monthly")
def monthly_stats(year: Optional[int] = None):
    """
    Returns counts grouped by month and incident type.
    Example response:
    {
      "2025-11": {"Medical": 3, "Theft": 1},
      "2025-12": {"Medical": 2, "Other": 5}
    }
    """
    db = SessionLocal()
    try:
        # sqlite strftime on ISO date-string
        month_label = func.strftime('%Y-%m', IncidentReport.date_of_incident).label('month')
        q = db.query(month_label, IncidentReport.type_of_incident, func.count().label('cnt'))
        if year:
            # restrict to that year
            start = f"{year:04d}-01-01"
            end = f"{year:04d}-12-31"
            q = q.filter(IncidentReport.date_of_incident >= start, IncidentReport.date_of_incident <= end)
        q = q.group_by(month_label, IncidentReport.type_of_incident).order_by(month_label.desc())
        rows = q.all()

        out: Dict[str, Dict[str, int]] = {}
        for month, typ, cnt in rows:
            if month is None:
                month = "unknown"
            out.setdefault(month, {})[typ] = cnt
        return out
    finally:
        db.close()


# -------------------------
# Summary stats endpoint (type-wise & severity estimation)
# -------------------------
@router.get("/stats/summary")
def summary_stats():
    """
    Return overall totals, and totals by type and by month (last 12 months).
    """
    db = SessionLocal()
    try:
        total = db.query(func.count(IncidentReport.id)).scalar()
        by_type = db.query(IncidentReport.type_of_incident, func.count().label('cnt')).group_by(IncidentReport.type_of_incident).all()
        # last 12 months counts
        month_label = func.strftime('%Y-%m', IncidentReport.date_of_incident).label('month')
        last_12 = db.query(month_label, func.count().label('cnt')) \
                    .group_by(month_label) \
                    .order_by(month_label.desc()) \
                    .limit(12) \
                    .all()

        return {
            "total": total or 0,
            "by_type": {typ: cnt for typ, cnt in by_type},
            "last_12_months": {m: cnt for m, cnt in last_12}
        }
    finally:
        db.close()










// replace existing fetchIncidents implementation with this:
const fetchIncidents = async (page = 1, pageSize = 50) => {
  setLoading(true);
  try {
    // build query params
    const params = new URLSearchParams();
    params.append('page', page);
    params.append('page_size', pageSize);
    if (filters.type && filters.type !== 'all') params.append('type_of_incident', filters.type);
    if (filters.dateRange === 'today') {
      const today = new Date().toISOString().split('T')[0];
      params.append('start_date', today);
      params.append('end_date', today);
    } else if (filters.dateRange === 'week') {
      const now = new Date();
      const start = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 7).toISOString().split('T')[0];
      params.append('start_date', start);
    } else if (filters.dateRange === 'month') {
      const now = new Date();
      const start = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0];
      params.append('start_date', start);
    }
    // location & searchTerm can be sent too
    if (searchTerm) params.append('location', searchTerm);

    const response = await fetch(`${API_URL}/incident/list?${params.toString()}`);
    if (!response.ok) throw new Error('Failed to fetch incidents');
    const data = await response.json();
    setIncidents(data);
    setFilteredIncidents(data);
    calculateStats(data); // optionally keep client-side fallback
  } catch (err) {
    setError(err.message);
    console.error('Error fetching incidents:', err);
  } finally {
    setLoading(false);
  }
};




















check below incidence dashboard details carefully i want to integrate this incidence page as per corporate level 
actully this will use in western union envirnoment 

previously we manintain this entry manually in register frorm so 
refer attacheed pdf indented carefuly and as per this code update and integrate all file carefully ..
also for analysis part
i want to build register (Digital register ) where user register all incidence throw frontend then out incidence management team take action as per 
for that i want to improve this register ...

alos want to store register date 
how month wise , incidence wise like 

initially check below file carefully then improve code logic


C:\Users\W0024618\Desktop\incidenceDashboard\Backend\database.py

# database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "sqlite:///./database.db"

engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False}
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()






C:\Users\W0024618\Desktop\incidenceDashboard\Backend\incident_report.py
# incident_report.py
import os
import json
from typing import Optional, List
from datetime import datetime, date, time

from fastapi import APIRouter, HTTPException, UploadFile, File, Form
from pydantic import BaseModel, Field, EmailStr, validator
from sqlalchemy import Column, Integer, String, DateTime, Text
from sqlalchemy.dialects.sqlite import JSON as SQLITE_JSON

from database import Base, engine, SessionLocal

router = APIRouter(prefix="/incident", tags=["incident"])

# Ensure uploads directory exists
UPLOAD_DIR = os.path.join(os.path.dirname(__file__), "uploads")
os.makedirs(UPLOAD_DIR, exist_ok=True)

# -------------------------
# SQLAlchemy model
# -------------------------
class IncidentReport(Base):
    __tablename__ = "incident_reports"

    id = Column(Integer, primary_key=True, index=True, autoincrement=True)

    # basic fields (strings)
    type_of_incident = Column(String, nullable=False)   # e.g. Medical / Theft / Other
    other_type_text = Column(String, nullable=True)     # filled when type_of_incident == "Other"

    date_of_report = Column(String, nullable=False)     # ISO date string e.g. "2025-12-03"
    time_of_report = Column(String, nullable=False)     # HH:MM

    impacted_name = Column(String, nullable=False)
    impacted_employee_id = Column(String, nullable=False)

    was_reported_verbally = Column(Integer, default=0)    # 1 = True, 0 = False
    incident_reported_to = Column(String, nullable=True) # JSON-string list when present
    reported_to_details = Column(String, nullable=True)

    location = Column(String, nullable=False)

    reported_by_name = Column(String, nullable=False)
    reported_by_employee_id = Column(String, nullable=False)
    reported_by_email = Column(String, nullable=False)
    reported_by_contact = Column(String, nullable=False)

    date_of_incident = Column(String, nullable=False)
    time_of_incident = Column(String, nullable=False)

    detailed_description = Column(Text, nullable=False)
    immediate_actions_taken = Column(Text, nullable=False)

    accompanying_person = Column(SQLITE_JSON, nullable=True)   # list of {name, contact}
    witnesses = Column(SQLITE_JSON, nullable=True)            # list of strings
    witness_contacts = Column(SQLITE_JSON, nullable=True)     # list of strings

    root_cause_analysis = Column(Text, nullable=True)         # optional
    preventive_actions = Column(Text, nullable=True)          # optional

    proofs = Column(SQLITE_JSON, nullable=True)               # list of uploaded filenames

    created_at = Column(DateTime, default=datetime.utcnow)

# create table(s)
Base.metadata.create_all(bind=engine)

# -------------------------
# Pydantic Schemas (strict types)
# -------------------------
class AccompanyPerson(BaseModel):
    name: str = Field(..., min_length=1)
    contact: str = Field(..., min_length=3)

class IncidentCreate(BaseModel):
    # required
    type_of_incident: str = Field(..., min_length=1)
    other_type_text: Optional[str] = None

    date_of_report: date
    time_of_report: time

    impacted_name: str = Field(..., min_length=1)
    impacted_employee_id: str = Field(..., min_length=1)

    was_reported_verbally: bool

    # If was_reported_verbally true
    incident_reported_to: Optional[List[str]] = None
    reported_to_details: Optional[str] = None

    location: str = Field(..., min_length=1)

    reported_by_name: str = Field(..., min_length=1)
    reported_by_employee_id: str = Field(..., min_length=1)
    reported_by_email: EmailStr
    reported_by_contact: str = Field(..., min_length=3)

    date_of_incident: date
    time_of_incident: time

    detailed_description: str = Field(..., min_length=5)
    immediate_actions_taken: str = Field(..., min_length=1)

    accompanying_person: List[AccompanyPerson] = Field(..., min_items=0)
    witnesses: List[str] = Field(..., min_items=0)
    witness_contacts: List[str] = Field(..., min_items=0)

    root_cause_analysis: Optional[str] = None
    preventive_actions: Optional[str] = None

    # proofs are handled via multipart upload; not present here

    @validator("other_type_text", always=True)
    def require_other_text_if_other(cls, v, values):
        if values.get("type_of_incident") and values.get("type_of_incident").strip().lower() == "other":
            if not v or not v.strip():
                raise ValueError("When type_of_incident is 'Other', provide other_type_text.")
            return v
        return v

    @validator("incident_reported_to", always=True)
    def validate_reported_to_if_needed(cls, v, values):
        if values.get("was_reported_verbally"):
            if not v or len(v) == 0:
                raise ValueError("When was_reported_verbally is True, provide incident_reported_to (list).")
        return v

    @validator("reported_to_details", always=True)
    def validate_reported_to_details_if_needed(cls, v, values):
        if values.get("was_reported_verbally"):
            if v is None or not str(v).strip():
                # require details when verbally reported (per your spec)
                raise ValueError("When was_reported_verbally is True, provide reported_to_details (Name and Department).")
        return v

    @validator("witness_contacts", always=True)
    def validate_witness_lengths(cls, v, values):
        w = values.get("witnesses") or []
        if len(w) != len(v):
            raise ValueError("witnesses and witness_contacts must have the same length (parallel arrays).")
        return v

class IncidentOut(BaseModel):
    id: int
    type_of_incident: str
    other_type_text: Optional[str] = None
    date_of_report: str
    time_of_report: str
    impacted_name: str
    impacted_employee_id: str
    was_reported_verbally: bool
    incident_reported_to: Optional[List[str]] = None
    reported_to_details: Optional[str] = None
    location: str
    reported_by_name: str
    reported_by_employee_id: str
    reported_by_email: str
    reported_by_contact: str
    date_of_incident: str
    time_of_incident: str
    detailed_description: str
    immediate_actions_taken: str
    accompanying_person: Optional[List[dict]] = None
    witnesses: Optional[List[str]] = None
    witness_contacts: Optional[List[str]] = None
    root_cause_analysis: Optional[str] = None
    preventive_actions: Optional[str] = None
    proofs: Optional[List[str]] = None
    created_at: datetime

    class Config:
        orm_mode = True

# -------------------------
# Helpers
# -------------------------
def save_uploads(upload_files: Optional[List[UploadFile]]) -> List[str]:
    """Save uploaded files to UPLOAD_DIR and return list of filenames (relative)."""
    if not upload_files:
        return []
    saved = []
    for f in upload_files:
        # sanitize and create unique filename
        ts = datetime.utcnow().strftime("%Y%m%d%H%M%S%f")
        name = f.filename or "upload"
        # simple sanitization
        name = "".join(c for c in name if c.isalnum() or c in (" ", ".", "_", "-")).strip()
        filename = f"{ts}_{name}"
        path = os.path.join(UPLOAD_DIR, filename)
        # write file
        with open(path, "wb") as fh:
            fh.write(f.file.read())
        saved.append(filename)
    return saved

# -------------------------
# Endpoints
# -------------------------
@router.post("/create", response_model=IncidentOut)
async def create_incident(
    payload: str = Form(...),            # JSON string of all fields (see IncidentCreate)
    proofs: Optional[List[UploadFile]] = File(None)
):
    """
    Accepts multipart/form-data:
      - payload: JSON string matching IncidentCreate schema
      - proofs: optional list of files (images, pdf)
    """
    # parse JSON payload
    try:
        data = json.loads(payload)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Invalid JSON payload: {e}")

    # validate payload with Pydantic
    try:
        incident = IncidentCreate.parse_obj(data)
    except Exception as e:
        raise HTTPException(status_code=422, detail=str(e))

    db = SessionLocal()
    try:
        saved_files = save_uploads(proofs)

        inst = IncidentReport(
            type_of_incident = incident.type_of_incident.strip(),
            other_type_text = incident.other_type_text.strip() if incident.other_type_text else None,
            date_of_report = incident.date_of_report.isoformat(),
            time_of_report = incident.time_of_report.strftime("%H:%M:%S"),
            impacted_name = incident.impacted_name.strip(),
            impacted_employee_id = incident.impacted_employee_id.strip(),
            was_reported_verbally = 1 if incident.was_reported_verbally else 0,
            incident_reported_to = json.dumps(incident.incident_reported_to) if incident.incident_reported_to else None,
            reported_to_details = incident.reported_to_details.strip() if incident.reported_to_details else None,
            location = incident.location.strip(),
            reported_by_name = incident.reported_by_name.strip(),
            reported_by_employee_id = incident.reported_by_employee_id.strip(),
            reported_by_email = str(incident.reported_by_email),
            reported_by_contact = incident.reported_by_contact.strip(),
            date_of_incident = incident.date_of_incident.isoformat(),
            time_of_incident = incident.time_of_incident.strftime("%H:%M:%S"),
            detailed_description = incident.detailed_description.strip(),
            immediate_actions_taken = incident.immediate_actions_taken.strip(),
            accompanying_person = [p.dict() for p in incident.accompanying_person] if incident.accompanying_person else None,
            witnesses = incident.witnesses if incident.witnesses else None,
            witness_contacts = incident.witness_contacts if incident.witness_contacts else None,
            root_cause_analysis = incident.root_cause_analysis.strip() if incident.root_cause_analysis else None,
            preventive_actions = incident.preventive_actions.strip() if incident.preventive_actions else None,
            proofs = saved_files if saved_files else None,
            created_at = datetime.utcnow()
        )

        db.add(inst)
        db.commit()
        db.refresh(inst)

        # convert incident_reported_to JSON-string back to list for response
        if inst.incident_reported_to:
            try:
                inst.incident_reported_to = json.loads(inst.incident_reported_to)
            except:
                inst.incident_reported_to = None

        return inst

    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        db.close()

@router.get("/list", response_model=List[IncidentOut])
def list_incidents(limit: int = 200):
    db = SessionLocal()
    try:
        rows = db.query(IncidentReport).order_by(IncidentReport.created_at.desc()).limit(limit).all()
        # parse JSON strings
        for r in rows:
            if isinstance(r.incident_reported_to, str):
                try:
                    r.incident_reported_to = json.loads(r.incident_reported_to)
                except:
                    r.incident_reported_to = None
        return rows
    finally:
        db.close()

@router.get("/{incident_id}", response_model=IncidentOut)
def get_incident(incident_id: int):
    db = SessionLocal()
    try:
        row = db.query(IncidentReport).filter(IncidentReport.id == incident_id).first()
        if not row:
            raise HTTPException(status_code=404, detail="Incident not found")
        if isinstance(row.incident_reported_to, str):
            try:
                row.incident_reported_to = json.loads(row.incident_reported_to)
            except:
                row.incident_reported_to = None
        return row
    finally:
        db.close()






C:\Users\W0024618\Desktop\incidenceDashboard\Backend\main.py


# main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from incident_report import router as incident_router

app = FastAPI(title="Incident Reporting API")

origins = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    # add other origins if frontend hosted elsewhere
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(incident_router)

@app.get("/")
def read_root():
    return {"message": "Incident Reporting Backend is running"}






C:\Users\W0024618\Desktop\incidenceDashboard\frontend\src\components\IncidentForm.jsx

// C:\Users\W0024618\Desktop\IncidentDashboard\frontend\src\components\IncidentForm.jsx
import React, { useEffect, useRef, useState } from "react";
import "../assets/css/IncidentForm.css";

const INCIDENT_TYPES = [
  "Medical",
  "Theft",
  "Fire",
  "HR Related Incident",
  "Outside Work Place Violence",
  "Threat",
  "Death",
  "Fraud",
  "Any Other Safety / Security Related Incident",
  "Other"
];

const REPORTED_TO_OPTIONS = [
  "Supervisor",
  "Manager",
  "HR",
  "Other Employee",
  "Not Reported"
];

const emptyForm = {
  type_of_incident: "",
  other_type_text: "",
  date_of_report: "",
  time_of_report: "",
  impacted_name: "",
  impacted_employee_id: "",
  was_reported_verbally: null,
  incident_reported_to: [],
  reported_to_details: "",
  location: "",
  reported_by_name: "",
  reported_by_employee_id: "",
  reported_by_email: "",
  reported_by_contact: "",
  date_of_incident: "",
  time_of_incident: "",
  detailed_description: "",
  immediate_actions_taken: "",
  accompanying_person: [],
  witnesses: [],
  witness_contacts: [],
  root_cause_analysis: "",
  preventive_actions: ""
};

export default function IncidentForm({ onSubmitted }) {
  const [form, setForm] = useState(emptyForm);
  const [files, setFiles] = useState([]);
  const [errors, setErrors] = useState({});
  const [saving, setSaving] = useState(false);
  const autosaveRef = useRef(null);

  // ðŸ‘‡ NEW: Show only 1â€“6 initially
  const [showAfterSix, setShowAfterSix] = useState(false);

  // NEW: touched fields (to avoid showing required errors before user interacts)
  const [touched, setTouched] = useState({});

  useEffect(() => {
    try {
      const raw = localStorage.getItem("incident_draft");
      if (raw) setForm(prev => ({ ...prev, ...JSON.parse(raw) }));
    } catch (e) {
      console.warn("Restore draft failed", e);
    }
  }, []);

  useEffect(() => {
    clearTimeout(autosaveRef.current);
    setSaving(true);
    autosaveRef.current = setTimeout(() => {
      try {
        localStorage.setItem("incident_draft", JSON.stringify(form));
      } catch (e) {
        console.warn("Autosave failed", e);
      }
      setSaving(false);
    }, 700);

    return () => clearTimeout(autosaveRef.current);
  }, [form]);

  // regexes used by both live validation and final validate()
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  const empIdRegex = /^[A-Za-z0-9\-_.]{1,20}$/;

  /**
   * PHONE UTILITIES
   * - only allow a single leading '+' (optional) and digits
   * - enforce E.164 acceptable range: 7..15 digits total (this is global-friendly)
  */

  const sanitizePhoneInput = (val) => {
    if (!val && val !== "") return val;
    // remove everything except digits and plus
    let v = String(val).replace(/[^\d+]/g, "");
    // allow + only at start, and only one
    v = v.replace(/\++/g, "+");
    if (v.indexOf("+") > 0) {
      // move any '+' not at start to start only if existed
      v = "+" + v.replace(/\+/g, "");
    }
    // if multiple plus signs, keep single leading +
    if (v.startsWith("+")) {
      v = "+" + v.slice(1).replace(/\+/g, "");
    } else {
      v = v.replace(/\+/g, "");
    }
    return v;
  };

  const countPhoneDigits = (val) => {
    if (!val) return 0;
    return (String(val).replace(/\D/g, "") || "").length;
  };

  const isValidPhoneLive = (val) => {
    if (!val) return false;
    const digits = countPhoneDigits(val);
    // E.164: maximum 15 digits; set minimum to 7 (common smallest usable numbers)
    return digits >= 7 && digits <= 15;
  };

  // validate single field live and update errors state accordingly
  const validateField = (key, value, extra = {}) => {
    // extra can include index for witness/accompany or other context
    setErrors(prev => {
      const next = { ...prev };

      const setErr = (k, msg) => (next[k] = msg);
      const clearErr = (k) => { if (next[k]) delete next[k]; };

      switch (key) {
        case "type_of_incident":
          if (!value && touched.type_of_incident) setErr("type_of_incident", "Type is required.");
          else clearErr("type_of_incident");
          break;
        case "other_type_text":
          if (form.type_of_incident === "Other" && (!value || !value.trim()) && touched.other_type_text)
            setErr("other_type_text", "Please enter the incident type.");
          else clearErr("other_type_text");
          break;
        case "date_of_report":
          if (!value && touched.date_of_report) setErr("date_of_report", "Date of report required.");
          else clearErr("date_of_report");
          break;
        case "time_of_report":
          if (!value && touched.time_of_report) setErr("time_of_report", "Time of report required.");
          else clearErr("time_of_report");
          break;
        case "impacted_name":
          if (!value && touched.impacted_name) setErr("impacted_name", "Impacted name is required.");
          else clearErr("impacted_name");
          break;
        case "impacted_employee_id":
          if (!value && touched.impacted_employee_id) setErr("impacted_employee_id", "Impacted employee ID is required.");
          else if (value && !empIdRegex.test(value)) setErr("impacted_employee_id", "Invalid employee ID.");
          else clearErr("impacted_employee_id");
          break;
        case "was_reported_verbally":
          if (value === null && touched.was_reported_verbally) setErr("was_reported_verbally", "Please select Yes or No.");
          else clearErr("was_reported_verbally");
          break;
        case "incident_reported_to":
          if (form.was_reported_verbally === true && (!value || !value.length) && touched.incident_reported_to)
            setErr("incident_reported_to", "Select at least one option.");
          else clearErr("incident_reported_to");
          break;
        case "reported_to_details":
          if (form.was_reported_verbally === true && (!value || !value.trim()) && touched.reported_to_details)
            setErr("reported_to_details", "Provide name & department.");
          else clearErr("reported_to_details");
          break;
        case "location":
          if ((!value || !String(value).trim()) && touched.location) setErr("location", "Location is required.");
          else clearErr("location");
          break;
        case "reported_by_name":
          if (!value && touched.reported_by_name) setErr("reported_by_name", "Reporter name required.");
          else clearErr("reported_by_name");
          break;
        case "reported_by_employee_id":
          if (!value && touched.reported_by_employee_id) setErr("reported_by_employee_id", "Reporter employee ID required.");
          else if (value && !empIdRegex.test(value)) setErr("reported_by_employee_id", "Invalid employee ID.");
          else clearErr("reported_by_employee_id");
          break;
        case "reported_by_email":
          if (!value && touched.reported_by_email) setErr("reported_by_email", "Reporter email required.");
          else if (value && !emailRegex.test(value)) setErr("reported_by_email", "Invalid email address.");
          else clearErr("reported_by_email");
          break;
        case "reported_by_contact":
          if (!value && touched.reported_by_contact) setErr("reported_by_contact", "Reporter contact required.");
          else if (value && !isValidPhoneLive(value)) setErr("reported_by_contact", "Invalid phone number â€” must be 7 to 15 digits (can include leading +).");
          else clearErr("reported_by_contact");
          break;
        case "date_of_incident":
          if (!value && touched.date_of_incident) setErr("date_of_incident", "Date of incident required.");
          else clearErr("date_of_incident");
          break;
        case "time_of_incident":
          if (!value && touched.time_of_incident) setErr("time_of_incident", "Time of incident required.");
          else clearErr("time_of_incident");
          break;
        case "detailed_description":
          if ((!value || !String(value).trim() || String(value).length < 5) && touched.detailed_description)
            setErr("detailed_description", "Please provide a detailed description (min 5 chars).");
          else clearErr("detailed_description");
          break;
        case "immediate_actions_taken":
          if ((!value || !String(value).trim()) && touched.immediate_actions_taken)
            setErr("immediate_actions_taken", "Immediate actions are required.");
          else clearErr("immediate_actions_taken");
          break;
        default:
          break;
      }

      // witness / accompanying contact validation by index if provided
      if (extra.type === "witness_contact") {
        const idx = extra.index;
        const keyName = `witness_contacts_${idx}`;
        if (!value && touched[`witness_contacts_${idx}`]) {
          next[keyName] = "Contact required for this witness.";
        } else if (value && !isValidPhoneLive(value)) {
          next[keyName] = "Invalid phone number â€” must be 7 to 15 digits (can include leading +).";
        } else {
          if (next[keyName]) delete next[keyName];
        }
      }

      if (extra.type === "accompany_contact") {
        const idx = extra.index;
        const keyName = `accompanying_person_contact_${idx}`;
        if (!value && touched[keyName]) {
          next[keyName] = "Contact required for this person.";
        } else if (value && !isValidPhoneLive(value)) {
          next[keyName] = "Invalid phone number â€” must be 7 to 15 digits (can include leading +).";
        } else {
          if (next[keyName]) delete next[keyName];
        }
      }

      // cleanup: if witness count mismatch error existed but counts fixed, remove it
      if ((form.witnesses || []).length === (form.witness_contacts || []).length) {
        if (next.witness_contacts) delete next.witness_contacts;
      }

      return next;
    });
  };

  const update = (k, v) => {
    // mark touched
    setTouched(prev => ({ ...prev, [k]: true }));

    // Special handling for phone-like fields: sanitize input
    if (k === "reported_by_contact") {
      v = sanitizePhoneInput(v);
    }

    // Update state
    setForm(prev => ({ ...prev, [k]: v }));

    // Run live validation for this field
    validateField(k, v);

    // For fields that depend on others, also validate dependent fields:
    if (k === "type_of_incident") validateField("other_type_text", form.other_type_text);
    if (k === "was_reported_verbally") {
      setShowAfterSix(true); // ðŸ‘ˆ When user answers Q6 â†’ show rest
      validateField("incident_reported_to", form.incident_reported_to);
      validateField("reported_to_details", form.reported_to_details);
    }
  };

  const toggleReportedTo = (opt) => {
    const arr = [...(form.incident_reported_to || [])];
    const idx = arr.indexOf(opt);
    if (idx >= 0) arr.splice(idx, 1);
    else arr.push(opt);
    update("incident_reported_to", arr);
  };

  const addAccompany = () => update("accompanying_person", [...(form.accompanying_person || []), { name: "", contact: "" }]);
  const removeAccompany = (i) => {
    const arr = [...(form.accompanying_person || [])];
    arr.splice(i, 1);
    update("accompanying_person", arr);
    // clear any contact error for this index
    setErrors(prev => {
      const next = { ...prev };
      const keyName = `accompanying_person_contact_${i}`;
      if (next[keyName]) delete next[keyName];
      return next;
    });
  };
  const setAccompany = (i, key, val) => {
    const arr = [...(form.accompanying_person || [])];
    arr[i] = { ...(arr[i] || {}), [key]: val };
    update("accompanying_person", arr);

    // If this is the contact field, sanitize and validate
    if (key === "contact") {
      const sanitized = sanitizePhoneInput(val);
      // update the specific value immediately in form (avoid double-touch race by directly setting)
      setForm(prev => {
        const next = { ...prev };
        const copy = [...(next.accompanying_person || [])];
        copy[i] = { ...(copy[i] || {}), contact: sanitized };
        next.accompanying_person = copy;
        return next;
      });
      setTouched(prev => ({ ...prev, [`accompanying_person_contact_${i}`]: true }));
      validateField("accompanying_person", sanitized, { type: "accompany_contact", index: i });
    } else {
      // if non-contact field changed, no special validation (name maybe)
    }
  };

  const addWitness = () => {
    update("witnesses", [...(form.witnesses || []), ""]);
    update("witness_contacts", [...(form.witness_contacts || []), ""]);
  };
  const removeWitness = (i) => {
    const w = [...(form.witnesses || [])];
    const wc = [...(form.witness_contacts || [])];
    w.splice(i, 1);
    wc.splice(i, 1);
    update("witnesses", w);
    update("witness_contacts", wc);

    // clear any per-index errors
    setErrors(prev => {
      const next = { ...prev };
      const keyName = `witness_contacts_${i}`;
      if (next[keyName]) delete next[keyName];
      return next;
    });
  };
  const setWitness = (i, val) => {
    const w = [...(form.witnesses || [])];
    w[i] = val;
    update("witnesses", w);
  };
  const setWitnessContact = (i, val) => {
    // sanitize input
    const sanitized = sanitizePhoneInput(val);

    const wc = [...(form.witness_contacts || [])];
    wc[i] = sanitized;
    update("witness_contacts", wc);

    // mark touched for this witness contact and validate
    setTouched(prev => ({ ...prev, [`witness_contacts_${i}`]: true }));
    validateField("witness_contacts", sanitized, { type: "witness_contact", index: i });
  };

  const onFilesSelected = (evt) => {
    const selected = Array.from(evt.target.files || []);
    setFiles(prev => [...prev, ...selected]);
    evt.target.value = "";
  };
  const removeFile = (i) => setFiles(prev => {
    const a = [...prev];
    a.splice(i, 1);
    return a;
  });

/**
 * 
 * @returns 
 * 
 */

  const validate = () => {
    const e = {};

    if (form.was_reported_verbally === null)
      e.was_reported_verbally = "Please select Yes or No.";

    if (!form.type_of_incident) e.type_of_incident = "Type is required.";
    if (form.type_of_incident === "Other" && !form.other_type_text) e.other_type_text = "Please enter the incident type.";
    if (!form.date_of_report) e.date_of_report = "Date of report required.";
    if (!form.time_of_report) e.time_of_report = "Time of report required.";
    if (!form.impacted_name) e.impacted_name = "Impacted name is required.";
    if (!form.impacted_employee_id) e.impacted_employee_id = "Impacted employee ID is required.";
    else if (!empIdRegex.test(form.impacted_employee_id)) e.impacted_employee_id = "Invalid employee ID.";

    if (form.was_reported_verbally === true) {
      if (!form.incident_reported_to?.length)
        e.incident_reported_to = "Select at least one option.";
      if (!form.reported_to_details?.trim())
        e.reported_to_details = "Provide name & department.";
    }

    if (!form.location?.trim()) e.location = "Location is required.";
    if (!form.reported_by_name) e.reported_by_name = "Reporter name required.";
    if (!form.reported_by_employee_id) e.reported_by_employee_id = "Reporter employee ID required.";
    else if (!empIdRegex.test(form.reported_by_employee_id)) e.reported_by_employee_id = "Invalid employee ID.";
    if (!form.reported_by_email) e.reported_by_email = "Reporter email required.";
    else if (!emailRegex.test(form.reported_by_email)) e.reported_by_email = "Invalid email address.";
    if (!form.reported_by_contact) e.reported_by_contact = "Reporter contact required.";
    else if (!/^[+\d][\d\s\-().]{5,}$/.test(form.reported_by_contact)) e.reported_by_contact = "Invalid phone number.";
    if (!form.date_of_incident) e.date_of_incident = "Date of incident required.";
    if (!form.time_of_incident) e.time_of_incident = "Time of incident required.";
    if (!form.detailed_description?.trim() || form.detailed_description.length < 5) e.detailed_description = "Please provide a detailed description (min 5 chars).";
    if (!form.immediate_actions_taken?.trim()) e.immediate_actions_taken = "Immediate actions are required.";

    if ((form.witnesses || []).length !== (form.witness_contacts || []).length)
      e.witness_contacts = "Add contact for each witness.";

    setErrors(e);
    return Object.keys(e).length === 0;
  };

  const handleSubmit = async (ev) => {
    ev.preventDefault();
    if (!validate()) {
      window.scrollTo({ top: 0, behavior: "smooth" });
      return;
    }

    const padSeconds = (t) => {
      if (!t) return null;
      if (t.length === 5) return `${t}:00`;
      return t;
    };

    const payloadObj = {
      type_of_incident: form.type_of_incident,
      other_type_text: form.type_of_incident === "Other" ? form.other_type_text : null,
      date_of_report: form.date_of_report,
      time_of_report: padSeconds(form.time_of_report),
      impacted_name: form.impacted_name,
      impacted_employee_id: form.impacted_employee_id,
      was_reported_verbally: !!form.was_reported_verbally,
      incident_reported_to: form.incident_reported_to?.length ? form.incident_reported_to : null,
      reported_to_details: form.reported_to_details || null,
      location: form.location,
      reported_by_name: form.reported_by_name,
      reported_by_employee_id: form.reported_by_employee_id,
      reported_by_email: form.reported_by_email,
      reported_by_contact: form.reported_by_contact,
      date_of_incident: form.date_of_incident,
      time_of_incident: padSeconds(form.time_of_incident),
      detailed_description: form.detailed_description,
      immediate_actions_taken: form.immediate_actions_taken,
      accompanying_person: form.accompanying_person?.length ? form.accompanying_person : [],
      witnesses: form.witnesses?.length ? form.witnesses : [],
      witness_contacts: form.witness_contacts?.length ? form.witness_contacts : [],
      root_cause_analysis: form.root_cause_analysis || null,
      preventive_actions: form.preventive_actions || null
    };

    try {
      const fd = new FormData();
      fd.append("payload", JSON.stringify(payloadObj));
      files.forEach(f => fd.append("proofs", f));

      const res = await fetch("http://localhost:8000/incident/create", {
        method: "POST",
        body: fd
      });

      const data = await res.json();
      if (!res.ok) throw new Error(data.detail || JSON.stringify(data));

      alert("Incident submitted successfully (ID: " + data.id + ")");
      localStorage.removeItem("incident_draft");
      setForm(emptyForm);
      setFiles([]);
      setErrors({});
      setTouched({});
      if (typeof onSubmitted === "function") onSubmitted(data);
    } catch (err) {
      console.error("Submit error", err);
      alert("Submit failed: " + (err.message || err));
    }
  };

  const clearDraft = () => {
    localStorage.removeItem("incident_draft");
    setForm(emptyForm);
    setFiles([]);
    setErrors({});
    setTouched({});
  };

  const handlePrint = () => {
    window.print();
  };

  return (
    <div className="incident-card">
      <div className="incident-header">
        <h2>Incident Reporting Form</h2>
        <div className="muted">When you submit this form, it will not automatically collect your details like name and email address unless you provide it yourself.</div>
      </div>

      <form className="incident-form" onSubmit={handleSubmit} noValidate>

        {/* -------------------------
             ALWAYS SHOW Q1â€“Q6
        -------------------------- */}

        <div className="row">
          <label>1. Type of Incident / Accident <span className="required">*</span></label>
          <select value={form.type_of_incident} onChange={e => update("type_of_incident", e.target.value)}>
            <option value="">-- select type --</option>
            {INCIDENT_TYPES.map(t => <option key={t} value={t}>{t}</option>)}
          </select>
          {form.type_of_incident === "Other" && (
            <>
              <input className="mt8" placeholder="Please enter the incident type" value={form.other_type_text} onChange={e => update("other_type_text", e.target.value)} />
              {errors.other_type_text && <div className="error">{errors.other_type_text}</div>}
            </>
          )}
          {errors.type_of_incident && <div className="error">{errors.type_of_incident}</div>}
        </div>

        <div className="row row-grid-2">
          <div>
            <label>2. Date of Report <span className="required">*</span></label>
            <input type="date" value={form.date_of_report} onChange={e => update("date_of_report", e.target.value)} />
            {errors.date_of_report && <div className="error">{errors.date_of_report}</div>}
          </div>
          <div>
            <label>3. Time of Report (HH:MM) <span className="required">*</span></label>
            <input type="time" value={form.time_of_report} onChange={e => update("time_of_report", e.target.value)} />
            {errors.time_of_report && <div className="error">{errors.time_of_report}</div>}
          </div>
        </div>

        <div className="row row-grid-2">
          <div>
            <label>4. Name of Impacted Employee / Person <span className="required">*</span></label>
            <input value={form.impacted_name} onChange={e => update("impacted_name", e.target.value)} />
            {errors.impacted_name && <div className="error">{errors.impacted_name}</div>}
          </div>
          <div>
            <label>5. Employee ID of Impacted Employee <span className="required">*</span></label>
            <input value={form.impacted_employee_id} onChange={e => update("impacted_employee_id", e.target.value)} />
            {errors.impacted_employee_id && <div className="error">{errors.impacted_employee_id}</div>}
          </div>
        </div>

        <div className="row">
          <label>6. Was this incident reported verbally before submitting this report? <span className="required">*</span></label>
          <div className="radio-row">
            <label><input type="radio" name="reported" checked={form.was_reported_verbally === true} onChange={() => update("was_reported_verbally", true)} /> Yes</label>
            <label><input type="radio" name="reported" checked={form.was_reported_verbally === false} onChange={() => update("was_reported_verbally", false)} /> No</label>
          </div>
          {errors.was_reported_verbally && <div className="error">{errors.was_reported_verbally}</div>}
          <div className="muted">** In case of medical emergency inform local HR</div>
        </div>

        {/* -------------------------
           SHOW REST ONLY AFTER Q6
        -------------------------- */}
        {showAfterSix && (
          <>
            {form.was_reported_verbally === true && (
              <>
                <div className="row">
                  <label>7. Incident reported to: <span className="required">*</span></label>
                  <select
                    value={form.incident_reported_to[0] || ""} // only single selection
                    onChange={e => update("incident_reported_to", [e.target.value])}
                  >
                    <option value="">-- select --</option>
                    {REPORTED_TO_OPTIONS.map(opt => (
                      <option key={opt} value={opt}>{opt}</option>
                    ))}
                  </select>
                  {errors.incident_reported_to && <div className="error">{errors.incident_reported_to}</div>}
                </div>

                <div className="row">
                  <label>8. If Yes, to whom (Name and Department): <span className="required">*</span></label>
                  <input value={form.reported_to_details} onChange={e => update("reported_to_details", e.target.value)} />
                  {errors.reported_to_details && <div className="error">{errors.reported_to_details}</div>}
                </div>
              </>
            )}

            {/* Q9â€“Q21 appear normally */}
            <div className="row">
              <label>9. Location of Incident or Accident (Specify Office / Branch) <span className="required">*</span></label>
              <input value={form.location} onChange={e => update("location", e.target.value)} />
              {errors.location && <div className="error">{errors.location}</div>}
            </div>

            {/* (No changes below this point â€“ your original code continues) */}
            {/* ------------------------------ */}
            {/* REST OF YOUR FORM UNCHANGED   */}
            {/* ------------------------------ */}

            <div className="row row-grid-3">
              <div>
                <label>10. Reported By - Name <span className="required">*</span></label>
                <input value={form.reported_by_name} onChange={e => update("reported_by_name", e.target.value)} />
                {errors.reported_by_name && <div className="error">{errors.reported_by_name}</div>}
              </div>
              <div>
                <label>11. Reported By - Employee ID <span className="required">*</span></label>
                <input value={form.reported_by_employee_id} onChange={e => update("reported_by_employee_id", e.target.value)} />
                {errors.reported_by_employee_id && <div className="error">{errors.reported_by_employee_id}</div>}
              </div>
              <div>
                <label>12. Reported By - Email <span className="required">*</span></label>
                <input value={form.reported_by_email} onChange={e => update("reported_by_email", e.target.value)} />
                {errors.reported_by_email && <div className="error">{errors.reported_by_email}</div>}
              </div>
            </div>

            <div className="row">
              <label>12b. Reported By - Contact Number <span className="required">*</span></label>
              <input value={form.reported_by_contact} onChange={e => update("reported_by_contact", e.target.value)} />
              {errors.reported_by_contact && <div className="error">{errors.reported_by_contact}</div>}
            </div>

            <div className="row row-grid-2">
              <div>
                <label>13. Date of Incident Occurred <span className="required">*</span></label>
                <input type="date" value={form.date_of_incident} onChange={e => update("date_of_incident", e.target.value)} />
                {errors.date_of_incident && <div className="error">{errors.date_of_incident}</div>}
              </div>
              <div>
                <label>14. Time of Incident <span className="required">*</span></label>
                <input type="time" value={form.time_of_incident} onChange={e => update("time_of_incident", e.target.value)} />
                {errors.time_of_incident && <div className="error">{errors.time_of_incident}</div>}
              </div>
            </div>

            <div className="row">
              <label>15. Detailed Description of Incident <span className="required">*</span></label>
              <textarea value={form.detailed_description} onChange={e => update("detailed_description", e.target.value)} rows={5} />
              {errors.detailed_description && <div className="error">{errors.detailed_description}</div>}
            </div>

            <div className="row">
              <label>16. Immediate Actions Taken <span className="required">*</span></label>
              <textarea value={form.immediate_actions_taken} onChange={e => update("immediate_actions_taken", e.target.value)} rows={3} />
              {errors.immediate_actions_taken && <div className="error">{errors.immediate_actions_taken}</div>}
            </div>

            <div className="row">
              <label>17. Accompanying Person Name and Contact Details</label>
              {(form.accompanying_person || []).map((p, i) => (
                <div key={i} className="accompany-row">
                  <input placeholder="Name" value={p.name} onChange={e => setAccompany(i, "name", e.target.value)} />
                  <input placeholder="Contact" value={p.contact} onChange={e => setAccompany(i, "contact", e.target.value)} />
                  {errors[`accompanying_person_contact_${i}`] && <div className="error">{errors[`accompanying_person_contact_${i}`]}</div>}
                  <button type="button" className="btn small" onClick={() => removeAccompany(i)}>Remove</button>
                </div>
              ))}
              <button type="button" className="btn" onClick={addAccompany}>Add Accompanying Person</button>
            </div>

            <div className="row">
              <label>18. Name of Witnesses / 19. Contact Number</label>
              {(form.witnesses || []).map((w, i) => (
                <div key={i} className="accompany-row">
                  <input placeholder="Witness Name" value={w} onChange={e => setWitness(i, e.target.value)} />
                  <input placeholder="Contact" value={(form.witness_contacts || [])[i] || ""} onChange={e => setWitnessContact(i, e.target.value)} />
                  {errors[`witness_contacts_${i}`] && <div className="error">{errors[`witness_contacts_${i}`]}</div>}
                  <button type="button" className="btn small" onClick={() => removeWitness(i)}>Remove</button>
                </div>
              ))}
              <button type="button" className="btn" onClick={addWitness}>Add Witness</button>
              {errors.witness_contacts && <div className="error">{errors.witness_contacts}</div>}
            </div>

            <div className="row">
              <label>20. Root cause analysis of the incident/accident</label>
              <textarea value={form.root_cause_analysis} onChange={e => update("root_cause_analysis", e.target.value)} rows={3} />
            </div>

            <div className="row">
              <label>21. Preventive actions taken during or after incident/accident (If any)</label>
              <textarea value={form.preventive_actions} onChange={e => update("preventive_actions", e.target.value)} rows={3} />
            </div>

            <div className="row">
              <label>Attach files (images / pdf) â€” optional</label>
              <input type="file" multiple onChange={onFilesSelected} />
              <div className="file-list">
                {files.map((f, i) => (
                  <div key={i} className="file-item">
                    <span>{f.name} ({Math.round(f.size / 1024)} KB)</span>
                    <button type="button" className="btn small" onClick={() => removeFile(i)}>Remove</button>
                  </div>
                ))}
              </div>
            </div>

            <div className="form-actions">
              <button type="submit" className="btn primary">Submit</button>
              <button type="button" className="btn outline" onClick={clearDraft}>Clear Draft</button>
              <button type="button" className="btn" onClick={handlePrint}>Print (PDF)</button>
              <div className="muted">{saving ? "Saving draft..." : "Draft saved locally"}</div>
            </div>

          </>
        )}

      </form>
    </div>
  );
}









C:\Users\W0024618\Desktop\incidenceDashboard\frontend\src\components\IncidentList.jsx


// C:\Users\W0028758\Desktop\incidenceDashboard\frontend\src\components\IncidentList.jsx
import React, { useState, useEffect, useMemo } from 'react';
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Chip,
  IconButton,
  TextField,
  InputAdornment,
  MenuItem,
  Select,
  FormControl,
  InputLabel,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Typography,
  Box,
  Grid,
  Card,
  CardContent,
  LinearProgress,
  Alert,
  Tooltip,
  Badge,
  Avatar,
  AvatarGroup,
  useMediaQuery,
  useTheme
} from '@mui/material';
import {
  Search,
  FilterList,
  Download,
  Visibility,
  Edit,
  Delete,
  Refresh,
  Add,
  BarChart,
  DateRange,
  Warning,
  CheckCircle,
  Pending,
  Person,
  LocationOn,
  AccessTime,
  Category,
  Sort,
  ExpandMore,
  ExpandLess,
  FileCopy
} from '@mui/icons-material';
import { styled } from '@mui/material/styles';
import { format, parseISO, isValid } from 'date-fns';

// API URL - update based on your environment
const API_URL = 'http://localhost:8000';

// Custom styled components for premium look
const PremiumCard = styled(Card)(({ theme }) => ({
  borderRadius: '16px',
  boxShadow: '0 8px 32px rgba(0, 0, 0, 0.08)',
  border: `1px solid ${theme.palette.divider}`,
  transition: 'all 0.3s ease',
  '&:hover': {
    boxShadow: '0 12px 48px rgba(0, 0, 0, 0.12)',
  },
}));

const StatusChip = styled(Chip)(({ theme, severity }) => {
  const colors = {
    high: theme.palette.error.main,
    medium: theme.palette.warning.main,
    low: theme.palette.success.main,
    closed: theme.palette.grey[500]
  };
  return {
    backgroundColor: `${colors[severity]}15`,
    color: colors[severity],
    fontWeight: 600,
    borderRadius: '8px',
  };
});

// Incident severity mapping based on type
const getIncidentSeverity = (type) => {
  const highRisk = ['Medical', 'Security', 'Fire'];
  const mediumRisk = ['Theft', 'Harassment', 'Accident'];
  const lowRisk = ['Maintenance', 'Other'];
  
  if (highRisk.includes(type)) return 'high';
  if (mediumRisk.includes(type)) return 'medium';
  if (lowRisk.includes(type)) return 'low';
  return 'low';
};

// Incident status mapping (mock - you can extend with real status field)
const getIncidentStatus = (incident) => {
  // Mock status based on creation date and type
  const created = new Date(incident.created_at);
  const hoursAgo = (new Date() - created) / (1000 * 60 * 60);
  
  if (hoursAgo > 48) return 'closed';
  if (hoursAgo > 24) return 'in-progress';
  return 'new';
};

const IncidentList = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const isTablet = useMediaQuery(theme.breakpoints.down('lg'));

  // State
  const [incidents, setIncidents] = useState([]);
  const [filteredIncidents, setFilteredIncidents] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [selectedIncident, setSelectedIncident] = useState(null);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [filters, setFilters] = useState({
    type: 'all',
    severity: 'all',
    status: 'all',
    dateRange: 'all'
  });
  const [sortConfig, setSortConfig] = useState({
    key: 'created_at',
    direction: 'desc'
  });
  const [stats, setStats] = useState({
    total: 0,
    high: 0,
    medium: 0,
    low: 0,
    new: 0,
    inProgress: 0,
    closed: 0
  });

  // Fetch incidents
  const fetchIncidents = async () => {
    setLoading(true);
    try {
      const response = await fetch(`${API_URL}/incident/list?limit=200`);
      if (!response.ok) throw new Error('Failed to fetch incidents');
      const data = await response.json();
      setIncidents(data);
      setFilteredIncidents(data);
      calculateStats(data);
    } catch (err) {
      setError(err.message);
      console.error('Error fetching incidents:', err);
    } finally {
      setLoading(false);
    }
  };

  // Calculate statistics
  const calculateStats = (incidentData) => {
    const stats = {
      total: incidentData.length,
      high: 0,
      medium: 0,
      low: 0,
      new: 0,
      inProgress: 0,
      closed: 0
    };

    incidentData.forEach(incident => {
      const severity = getIncidentSeverity(incident.type_of_incident);
      const status = getIncidentStatus(incident);
      
      stats[severity]++;
      stats[status === 'new' ? 'new' : status === 'in-progress' ? 'inProgress' : 'closed']++;
    });

    setStats(stats);
  };

  // Filter and search incidents
  useEffect(() => {
    let result = incidents;

    // Search
    if (searchTerm) {
      const term = searchTerm.toLowerCase();
      result = result.filter(incident =>
        incident.impacted_name.toLowerCase().includes(term) ||
        incident.impacted_employee_id.toLowerCase().includes(term) ||
        incident.type_of_incident.toLowerCase().includes(term) ||
        incident.location.toLowerCase().includes(term) ||
        incident.reported_by_name.toLowerCase().includes(term)
      );
    }

    // Filters
    if (filters.type !== 'all') {
      result = result.filter(incident => incident.type_of_incident === filters.type);
    }

    if (filters.severity !== 'all') {
      result = result.filter(incident => getIncidentSeverity(incident.type_of_incident) === filters.severity);
    }

    if (filters.status !== 'all') {
      result = result.filter(incident => getIncidentStatus(incident) === filters.status);
    }

    // Date range filter (simplified)
    if (filters.dateRange !== 'all') {
      const now = new Date();
      result = result.filter(incident => {
        const incidentDate = new Date(incident.date_of_incident);
        const diffDays = Math.floor((now - incidentDate) / (1000 * 60 * 60 * 24));
        
        switch (filters.dateRange) {
          case 'today': return diffDays === 0;
          case 'week': return diffDays <= 7;
          case 'month': return diffDays <= 30;
          default: return true;
        }
      });
    }

    // Sorting
    result.sort((a, b) => {
      const aValue = a[sortConfig.key];
      const bValue = b[sortConfig.key];
      
      if (sortConfig.key === 'created_at' || sortConfig.key.includes('date') || sortConfig.key.includes('time')) {
        const aDate = new Date(aValue);
        const bDate = new Date(bValue);
        return sortConfig.direction === 'asc' ? aDate - bDate : bDate - aDate;
      }
      
      if (sortConfig.key === 'severity') {
        const severityOrder = { high: 3, medium: 2, low: 1 };
        const aSeverity = getIncidentSeverity(a.type_of_incident);
        const bSeverity = getIncidentSeverity(b.type_of_incident);
        return sortConfig.direction === 'asc' 
          ? severityOrder[aSeverity] - severityOrder[bSeverity]
          : severityOrder[bSeverity] - severityOrder[aSeverity];
      }
      
      return sortConfig.direction === 'asc'
        ? String(aValue).localeCompare(String(bValue))
        : String(bValue).localeCompare(String(aValue));
    });

    setFilteredIncidents(result);
  }, [incidents, searchTerm, filters, sortConfig]);

  // Initial fetch
  useEffect(() => {
    fetchIncidents();
  }, []);

  // Handlers
  const handleViewIncident = (incident) => {
    setSelectedIncident(incident);
    setDialogOpen(true);
  };

  const handleCloseDialog = () => {
    setDialogOpen(false);
    setSelectedIncident(null);
  };

  const handleSort = (key) => {
    setSortConfig(prev => ({
      key,
      direction: prev.key === key && prev.direction === 'desc' ? 'asc' : 'desc'
    }));
  };

  const handleExportData = () => {
    const csv = [
      ['ID', 'Type', 'Severity', 'Impacted Person', 'Employee ID', 'Location', 'Date', 'Time', 'Reported By', 'Status'],
      ...filteredIncidents.map(incident => [
        incident.id,
        incident.type_of_incident,
        getIncidentSeverity(incident.type_of_incident).toUpperCase(),
        incident.impacted_name,
        incident.impacted_employee_id,
        incident.location,
        incident.date_of_incident,
        incident.time_of_incident,
        incident.reported_by_name,
        getIncidentStatus(incident)
      ])
    ].map(row => row.join(',')).join('\n');

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `incidents_${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
  };

  // Render functions
  const renderStatusIcon = (status) => {
    switch (status) {
      case 'new': return <Warning sx={{ color: theme.palette.warning.main }} />;
      case 'in-progress': return <Pending sx={{ color: theme.palette.info.main }} />;
      case 'closed': return <CheckCircle sx={{ color: theme.palette.success.main }} />;
      default: return null;
    }
  };

  const renderTable = () => {
    if (isMobile) {
      return renderMobileCards();
    }

    return (
      <TableContainer component={Paper} sx={{ borderRadius: '12px', overflow: 'hidden' }}>
        <Table>
          <TableHead sx={{ backgroundColor: theme.palette.grey[50] }}>
            <TableRow>
              <TableCell sx={{ fontWeight: 700 }}>ID</TableCell>
              <TableCell sx={{ fontWeight: 700 }}>
                <Box display="flex" alignItems="center" gap={0.5}>
                  Type
                  <IconButton size="small" onClick={() => handleSort('type_of_incident')}>
                    <Sort fontSize="small" />
                  </IconButton>
                </Box>
              </TableCell>
              <TableCell sx={{ fontWeight: 700 }}>Severity</TableCell>
              <TableCell sx={{ fontWeight: 700 }}>
                <Box display="flex" alignItems="center" gap={0.5}>
                  Impacted Person
                  <IconButton size="small" onClick={() => handleSort('impacted_name')}>
                    <Sort fontSize="small" />
                  </IconButton>
                </Box>
              </TableCell>
              <TableCell sx={{ fontWeight: 700 }}>Location</TableCell>
              <TableCell sx={{ fontWeight: 700 }}>
                <Box display="flex" alignItems="center" gap={0.5}>
                  Date & Time
                  <IconButton size="small" onClick={() => handleSort('created_at')}>
                    <Sort fontSize="small" />
                  </IconButton>
                </Box>
              </TableCell>
              <TableCell sx={{ fontWeight: 700 }}>Status</TableCell>
              <TableCell sx={{ fontWeight: 700 }}>Actions</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {filteredIncidents.map((incident) => {
              const severity = getIncidentSeverity(incident.type_of_incident);
              const status = getIncidentStatus(incident);
              
              return (
                <TableRow 
                  key={incident.id}
                  hover
                  sx={{ 
                    '&:hover': { backgroundColor: theme.palette.action.hover },
                    cursor: 'pointer'
                  }}
                  onClick={() => handleViewIncident(incident)}
                >
                  <TableCell>
                    <Typography variant="body2" sx={{ fontWeight: 600, color: theme.palette.text.primary }}>
                      #{incident.id.toString().padStart(4, '0')}
                    </Typography>
                  </TableCell>
                  <TableCell>
                    <Box display="flex" alignItems="center" gap={1}>
                      <Category sx={{ color: theme.palette.primary.main, fontSize: 16 }} />
                      <Typography variant="body2">
                        {incident.type_of_incident}
                        {incident.other_type_text && (
                          <Typography component="span" variant="caption" color="text.secondary" sx={{ ml: 1 }}>
                            ({incident.other_type_text})
                          </Typography>
                        )}
                      </Typography>
                    </Box>
                  </TableCell>
                  <TableCell>
                    <StatusChip
                      size="small"
                      label={severity.toUpperCase()}
                      severity={severity}
                    />
                  </TableCell>
                  <TableCell>
                    <Box>
                      <Typography variant="body2" sx={{ fontWeight: 500 }}>
                        {incident.impacted_name}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        ID: {incident.impacted_employee_id}
                      </Typography>
                    </Box>
                  </TableCell>
                  <TableCell>
                    <Box display="flex" alignItems="center" gap={0.5}>
                      <LocationOn sx={{ fontSize: 16, color: theme.palette.text.secondary }} />
                      <Typography variant="body2">
                        {incident.location}
                      </Typography>
                    </Box>
                  </TableCell>
                  <TableCell>
                    <Box>
                      <Typography variant="body2">
                        {format(parseISO(incident.date_of_incident), 'MMM dd, yyyy')}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        {incident.time_of_incident}
                      </Typography>
                    </Box>
                  </TableCell>
                  <TableCell>
                    <Box display="flex" alignItems="center" gap={1}>
                      {renderStatusIcon(status)}
                      <Typography variant="body2" sx={{ 
                        textTransform: 'capitalize',
                        fontWeight: status === 'new' ? 600 : 400
                      }}>
                        {status}
                      </Typography>
                    </Box>
                  </TableCell>
                  <TableCell onClick={(e) => e.stopPropagation()}>
                    <Box display="flex" gap={1}>
                      <Tooltip title="View Details">
                        <IconButton 
                          size="small" 
                          onClick={() => handleViewIncident(incident)}
                          sx={{ 
                            backgroundColor: theme.palette.primary.main + '10',
                            '&:hover': { backgroundColor: theme.palette.primary.main + '20' }
                          }}
                        >
                          <Visibility fontSize="small" sx={{ color: theme.palette.primary.main }} />
                        </IconButton>
                      </Tooltip>
                      <Tooltip title="Edit">
                        <IconButton 
                          size="small"
                          sx={{ 
                            backgroundColor: theme.palette.info.main + '10',
                            '&:hover': { backgroundColor: theme.palette.info.main + '20' }
                          }}
                        >
                          <Edit fontSize="small" sx={{ color: theme.palette.info.main }} />
                        </IconButton>
                      </Tooltip>
                    </Box>
                  </TableCell>
                </TableRow>
              );
            })}
          </TableBody>
        </Table>
      </TableContainer>
    );
  };

  const renderMobileCards = () => {
    return (
      <Box display="flex" flexDirection="column" gap={2}>
        {filteredIncidents.map((incident) => {
          const severity = getIncidentSeverity(incident.type_of_incident);
          const status = getIncidentStatus(incident);
          
          return (
            <PremiumCard key={incident.id} onClick={() => handleViewIncident(incident)}>
              <CardContent>
                <Box display="flex" justifyContent="space-between" alignItems="flex-start" mb={1}>
                  <Box>
                    <Typography variant="h6" sx={{ fontWeight: 600 }}>
                      #{incident.id.toString().padStart(4, '0')}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      {incident.type_of_incident}
                    </Typography>
                  </Box>
                  <StatusChip
                    size="small"
                    label={severity.toUpperCase()}
                    severity={severity}
                  />
                </Box>
                
                <Box mb={1}>
                  <Typography variant="body1" sx={{ fontWeight: 500 }}>
                    {incident.impacted_name}
                  </Typography>
                  <Typography variant="caption" color="text.secondary">
                    ID: {incident.impacted_employee_id}
                  </Typography>
                </Box>
                
                <Box display="flex" justifyContent="space-between" alignItems="center" mb={1}>
                  <Box display="flex" alignItems="center" gap={0.5}>
                    <LocationOn sx={{ fontSize: 14 }} />
                    <Typography variant="caption">{incident.location}</Typography>
                  </Box>
                  <Box display="flex" alignItems="center" gap={0.5}>
                    <AccessTime sx={{ fontSize: 14 }} />
                    <Typography variant="caption">
                      {format(parseISO(incident.date_of_incident), 'MMM dd')}
                    </Typography>
                  </Box>
                </Box>
                
                <Box display="flex" justifyContent="space-between" alignItems="center">
                  <Box display="flex" alignItems="center" gap={0.5}>
                    {renderStatusIcon(status)}
                    <Typography variant="caption" sx={{ textTransform: 'capitalize' }}>
                      {status}
                    </Typography>
                  </Box>
                  <Button 
                    size="small" 
                    variant="outlined"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleViewIncident(incident);
                    }}
                  >
                    View
                  </Button>
                </Box>
              </CardContent>
            </PremiumCard>
          );
        })}
      </Box>
    );
  };

  if (loading) {
    return (
      <Box p={3}>
        <LinearProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Box p={3}>
        <Alert severity="error" action={
          <Button color="inherit" size="small" onClick={fetchIncidents}>
            Retry
          </Button>
        }>
          {error}
        </Alert>
      </Box>
    );
  }

  return (
    <Box p={isMobile ? 2 : 3}>
      {/* Header */}
      <Box mb={3}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <Box>
            <Typography variant={isMobile ? "h5" : "h4"} sx={{ fontWeight: 700 }}>
              Incident Dashboard
            </Typography>
            <Typography variant="body1" color="text.secondary">
              Manage and monitor all reported incidents
            </Typography>
          </Box>
          <Box display="flex" gap={1}>
            <Tooltip title="Refresh">
              <IconButton onClick={fetchIncidents}>
                <Refresh />
              </IconButton>
            </Tooltip>
            <Tooltip title="Export Data">
              <IconButton onClick={handleExportData}>
                <Download />
              </IconButton>
            </Tooltip>
            <Button
              variant="contained"
              startIcon={<Add />}
              sx={{
                borderRadius: '8px',
                textTransform: 'none',
                fontWeight: 600
              }}
            >
              New Incident
            </Button>
          </Box>
        </Box>

        {/* Stats Cards */}
        <Grid container spacing={2} mb={3}>
          <Grid item xs={6} sm={4} lg={2}>
            <PremiumCard>
              <CardContent>
                <Typography variant="h4" sx={{ fontWeight: 700, color: theme.palette.primary.main }}>
                  {stats.total}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Total Incidents
                </Typography>
              </CardContent>
            </PremiumCard>
          </Grid>
          <Grid item xs={6} sm={4} lg={2}>
            <PremiumCard>
              <CardContent>
                <Typography variant="h4" sx={{ fontWeight: 700, color: theme.palette.error.main }}>
                  {stats.high}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  High Severity
                </Typography>
              </CardContent>
            </PremiumCard>
          </Grid>
          <Grid item xs={6} sm={4} lg={2}>
            <PremiumCard>
              <CardContent>
                <Typography variant="h4" sx={{ fontWeight: 700, color: theme.palette.warning.main }}>
                  {stats.medium}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Medium Severity
                </Typography>
              </CardContent>
            </PremiumCard>
          </Grid>
          <Grid item xs={6} sm={4} lg={2}>
            <PremiumCard>
              <CardContent>
                <Typography variant="h4" sx={{ fontWeight: 700, color: theme.palette.success.main }}>
                  {stats.new}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  New Incidents
                </Typography>
              </CardContent>
            </PremiumCard>
          </Grid>
          <Grid item xs={6} sm={4} lg={2}>
            <PremiumCard>
              <CardContent>
                <Typography variant="h4" sx={{ fontWeight: 700, color: theme.palette.info.main }}>
                  {stats.inProgress}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  In Progress
                </Typography>
              </CardContent>
            </PremiumCard>
          </Grid>
          <Grid item xs={6} sm={4} lg={2}>
            <PremiumCard>
              <CardContent>
                <Typography variant="h4" sx={{ fontWeight: 700, color: theme.palette.grey[600] }}>
                  {stats.closed}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Closed
                </Typography>
              </CardContent>
            </PremiumCard>
          </Grid>
        </Grid>

        {/* Filters and Search */}
        <PremiumCard sx={{ mb: 3 }}>
          <CardContent>
            <Grid container spacing={2} alignItems="center">
              <Grid item xs={12} md={4}>
                <TextField
                  fullWidth
                  placeholder="Search incidents..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <Search />
                      </InputAdornment>
                    ),
                    sx: { borderRadius: '8px' }
                  }}
                  size="small"
                />
              </Grid>
              
              <Grid item xs={6} sm={3} md={2}>
                <FormControl fullWidth size="small">
                  <InputLabel>Type</InputLabel>
                  <Select
                    value={filters.type}
                    label="Type"
                    onChange={(e) => setFilters({ ...filters, type: e.target.value })}
                  >
                    <MenuItem value="all">All Types</MenuItem>
                    <MenuItem value="Medical">Medical</MenuItem>
                    <MenuItem value="Theft">Theft</MenuItem>
                    <MenuItem value="Other">Other</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
              
              <Grid item xs={6} sm={3} md={2}>
                <FormControl fullWidth size="small">
                  <InputLabel>Severity</InputLabel>
                  <Select
                    value={filters.severity}
                    label="Severity"
                    onChange={(e) => setFilters({ ...filters, severity: e.target.value })}
                  >
                    <MenuItem value="all">All</MenuItem>
                    <MenuItem value="high">High</MenuItem>
                    <MenuItem value="medium">Medium</MenuItem>
                    <MenuItem value="low">Low</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
              
              <Grid item xs={6} sm={3} md={2}>
                <FormControl fullWidth size="small">
                  <InputLabel>Status</InputLabel>
                  <Select
                    value={filters.status}
                    label="Status"
                    onChange={(e) => setFilters({ ...filters, status: e.target.value })}
                  >
                    <MenuItem value="all">All</MenuItem>
                    <MenuItem value="new">New</MenuItem>
                    <MenuItem value="in-progress">In Progress</MenuItem>
                    <MenuItem value="closed">Closed</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
              
              <Grid item xs={6} sm={3} md={2}>
                <FormControl fullWidth size="small">
                  <InputLabel>Date Range</InputLabel>
                  <Select
                    value={filters.dateRange}
                    label="Date Range"
                    onChange={(e) => setFilters({ ...filters, dateRange: e.target.value })}
                  >
                    <MenuItem value="all">All Time</MenuItem>
                    <MenuItem value="today">Today</MenuItem>
                    <MenuItem value="week">This Week</MenuItem>
                    <MenuItem value="month">This Month</MenuItem>
                  </Select>
                </FormControl>
              </Grid>
            </Grid>
          </CardContent>
        </PremiumCard>

        {/* Results Info */}
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <Typography variant="body1" color="text.secondary">
            Showing {filteredIncidents.length} of {incidents.length} incidents
          </Typography>
          {filteredIncidents.length !== incidents.length && (
            <Button
              size="small"
              onClick={() => {
                setSearchTerm('');
                setFilters({
                  type: 'all',
                  severity: 'all',
                  status: 'all',
                  dateRange: 'all'
                });
              }}
            >
              Clear Filters
            </Button>
          )}
        </Box>

        {/* Incidents Table/Cards */}
        {filteredIncidents.length === 0 ? (
          <PremiumCard>
            <CardContent>
              <Box textAlign="center" py={4}>
                <Typography variant="h6" color="text.secondary" gutterBottom>
                  No incidents found
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Try adjusting your search or filters
                </Typography>
              </Box>
            </CardContent>
          </PremiumCard>
        ) : (
          renderTable()
        )}
      </Box>

      {/* Incident Detail Dialog */}
      <Dialog 
        open={dialogOpen} 
        onClose={handleCloseDialog}
        maxWidth="md"
        fullWidth
        fullScreen={isMobile}
      >
        {selectedIncident && (
          <>
            <DialogTitle sx={{ 
              borderBottom: `1px solid ${theme.palette.divider}`,
              pb: 2
            }}>
              <Box display="flex" justifyContent="space-between" alignItems="center">
                <Typography variant="h5" sx={{ fontWeight: 600 }}>
                  Incident #{selectedIncident.id.toString().padStart(4, '0')}
                </Typography>
                <StatusChip
                  label={getIncidentSeverity(selectedIncident.type_of_incident).toUpperCase()}
                  severity={getIncidentSeverity(selectedIncident.type_of_incident)}
                />
              </Box>
            </DialogTitle>
            
            <DialogContent dividers>
              <Grid container spacing={3}>
                {/* Basic Information */}
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                    BASIC INFORMATION
                  </Typography>
                  <Grid container spacing={2}>
                    <Grid item xs={12}>
                      <Typography variant="body2" sx={{ fontWeight: 500 }}>Type of Incident</Typography>
                      <Typography variant="body1">
                        {selectedIncident.type_of_incident}
                        {selectedIncident.other_type_text && ` (${selectedIncident.other_type_text})`}
                      </Typography>
                    </Grid>
                    <Grid item xs={6}>
                      <Typography variant="body2" sx={{ fontWeight: 500 }}>Date of Incident</Typography>
                      <Typography variant="body1">
                        {format(parseISO(selectedIncident.date_of_incident), 'PPP')}
                      </Typography>
                    </Grid>
                    <Grid item xs={6}>
                      <Typography variant="body2" sx={{ fontWeight: 500 }}>Time of Incident</Typography>
                      <Typography variant="body1">{selectedIncident.time_of_incident}</Typography>
                    </Grid>
                    <Grid item xs={12}>
                      <Typography variant="body2" sx={{ fontWeight: 500 }}>Location</Typography>
                      <Typography variant="body1">{selectedIncident.location}</Typography>
                    </Grid>
                  </Grid>
                </Grid>

                {/* Impacted Person */}
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                    IMPACTED PERSON
                  </Typography>
                  <Box p={2} sx={{ backgroundColor: theme.palette.grey[50], borderRadius: 1 }}>
                    <Typography variant="body1" sx={{ fontWeight: 600 }}>
                      {selectedIncident.impacted_name}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Employee ID: {selectedIncident.impacted_employee_id}
                    </Typography>
                  </Box>
                </Grid>

                {/* Reported By */}
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                    REPORTED BY
                  </Typography>
                  <Box p={2} sx={{ backgroundColor: theme.palette.grey[50], borderRadius: 1 }}>
                    <Typography variant="body1" sx={{ fontWeight: 600 }}>
                      {selectedIncident.reported_by_name}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      ID: {selectedIncident.reported_by_employee_id}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Email: {selectedIncident.reported_by_email}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      Contact: {selectedIncident.reported_by_contact}
                    </Typography>
                  </Box>
                </Grid>

                {/* Incident Details */}
                <Grid item xs={12}>
                  <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                    INCIDENT DETAILS
                  </Typography>
                  <Grid container spacing={2}>
                    <Grid item xs={12}>
                      <Typography variant="body2" sx={{ fontWeight: 500 }}>Detailed Description</Typography>
                      <Typography variant="body1" paragraph>
                        {selectedIncident.detailed_description}
                      </Typography>
                    </Grid>
                    <Grid item xs={12}>
                      <Typography variant="body2" sx={{ fontWeight: 500 }}>Immediate Actions Taken</Typography>
                      <Typography variant="body1" paragraph>
                        {selectedIncident.immediate_actions_taken}
                      </Typography>
                    </Grid>
                  </Grid>
                </Grid>

                {/* Additional Information */}
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                    WITNESSES
                  </Typography>
                  {selectedIncident.witnesses && selectedIncident.witnesses.length > 0 ? (
                    <Box display="flex" flexDirection="column" gap={1}>
                      {selectedIncident.witnesses.map((witness, index) => (
                        <Typography key={index} variant="body2">
                          {witness} ({selectedIncident.witness_contacts?.[index] || 'No contact'})
                        </Typography>
                      ))}
                    </Box>
                  ) : (
                    <Typography variant="body2" color="text.secondary">No witnesses reported</Typography>
                  )}
                </Grid>

                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                    ACCOMPANYING PERSONS
                  </Typography>
                  {selectedIncident.accompanying_person && selectedIncident.accompanying_person.length > 0 ? (
                    <Box display="flex" flexDirection="column" gap={1}>
                      {selectedIncident.accompanying_person.map((person, index) => (
                        <Typography key={index} variant="body2">
                          {person.name} ({person.contact})
                        </Typography>
                      ))}
                    </Box>
                  ) : (
                    <Typography variant="body2" color="text.secondary">No accompanying persons</Typography>
                  )}
                </Grid>

                {/* Analysis */}
                {(selectedIncident.root_cause_analysis || selectedIncident.preventive_actions) && (
                  <Grid item xs={12}>
                    <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                      ANALYSIS & PREVENTION
                    </Typography>
                    <Grid container spacing={2}>
                      {selectedIncident.root_cause_analysis && (
                        <Grid item xs={12} md={6}>
                          <Typography variant="body2" sx={{ fontWeight: 500 }}>Root Cause Analysis</Typography>
                          <Typography variant="body1">
                            {selectedIncident.root_cause_analysis}
                          </Typography>
                        </Grid>
                      )}
                      {selectedIncident.preventive_actions && (
                        <Grid item xs={12} md={6}>
                          <Typography variant="body2" sx={{ fontWeight: 500 }}>Preventive Actions</Typography>
                          <Typography variant="body1">
                            {selectedIncident.preventive_actions}
                          </Typography>
                        </Grid>
                      )}
                    </Grid>
                  </Grid>
                )}
              </Grid>
            </DialogContent>
            
            <DialogActions sx={{ p: 2, borderTop: `1px solid ${theme.palette.divider}` }}>
              <Button onClick={handleCloseDialog}>Close</Button>
              <Button variant="contained" startIcon={<FileCopy />}>
                Create Follow-up
              </Button>
            </DialogActions>
          </>
        )}
      </Dialog>
    </Box>
  );
};

export default IncidentList;











C:\Users\W0024618\Desktop\incidenceDashboard\frontend\src\App.js

import { BrowserRouter, Routes, Route } from "react-router-dom";

import IncidentForm from "./components/IncidentForm";
import IncidentList from "./components/IncidentList";
import Dashboard from "./pages/Dashboard"; // main dashboard only

export default function App() {
  return (
    <BrowserRouter>
      <Routes>

        {/* MAIN DASHBOARD */}
        <Route path="/" element={<Dashboard />} />

        {/* INCIDENT ROUTES (COMPONENTS ONLY) */}
        <Route path="/incidentList" element={<IncidentList />} />
        <Route path="/incidentsForm" element={<IncidentForm />} />

      </Routes>
    </BrowserRouter>
  );
}








