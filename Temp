C:\Users\W0024618\Desktop\global-page\backend\routes\auth.js



import express from 'express';
import { readFile, writeFile } from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import crypto from 'crypto';

const router = express.Router();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const USERS_FILE = path.resolve(__dirname, '../config/users.json');

const activeTokens = new Map();

async function loadUsers() {
  try {
    const raw = await readFile(USERS_FILE, 'utf8');
    const obj = JSON.parse(raw);
    return obj && Array.isArray(obj.users) ? obj.users : [];
  } catch (err) {
    return [];
  }
}

async function saveUsers(users) {
  const payload = { users };
  await writeFile(USERS_FILE, JSON.stringify(payload, null, 2), 'utf8');
}

function genToken() {
  return crypto.randomBytes(32).toString('hex');
}

function findUser(users, { username, employeeId }) {
  if (employeeId) {
    const byId = users.find(u => String(u.employeeId).toLowerCase() === String(employeeId).toLowerCase());
    if (byId) return byId;
  }
  if (username) {
    const byName = users.find(u => String(u.username).toLowerCase() === String(username).toLowerCase());
    if (byName) return byName;
    const byId2 = users.find(u => String(u.employeeId).toLowerCase() === String(username).toLowerCase());
    if (byId2) return byId2;
  }
  return null;
}

async function requireAuth(req, res, next) {
  try {
    const auth = req.headers.authorization || '';
    if (!auth.startsWith('Bearer ')) return res.status(401).json({ detail: 'Missing auth token' });
    const token = auth.slice(7).trim();
    const empId = activeTokens.get(token);
    if (!empId) return res.status(401).json({ detail: 'Invalid or expired token' });

    const users = await loadUsers();
    const user = users.find(u => String(u.employeeId).toLowerCase() === String(empId).toLowerCase());
    if (!user) return res.status(401).json({ detail: 'Invalid token (user not found)' });

    req.currentUser = user;
    req.currentToken = token;
    next();
  } catch (err) {
    next(err);
  }
}

// POST /login unchanged
router.post('/login', async (req, res, next) => {
  try {
    const { username, password } = req.body || {};
    if (!username || !password) return res.status(400).json({ detail: 'username and password are required' });

    const users = await loadUsers();
    const user = findUser(users, { username });
    if (!user) return res.status(401).json({ detail: 'Invalid credentials' });

    // plain-text compare for prototype
    if (String(user.password || '') !== String(password)) return res.status(401).json({ detail: 'Invalid credentials' });

    const token = genToken();
    activeTokens.set(token, user.employeeId);

    const safeUser = {
      username: user.username,
      employeeId: user.employeeId,
    };

    return res.json({ token, user: safeUser, permissions: user.permissions || {} });
  } catch (err) {
    next(err);
  }
});

// GET /me unchanged
router.get('/me', requireAuth, async (req, res, next) => {
  try {
    const user = req.currentUser;
    const safeUser = { username: user.username, employeeId: user.employeeId };
    return res.json({ user: safeUser, permissions: user.permissions || {} });
  } catch (err) {
    next(err);
  }
});

// POST /grant now supports optional 'password'
router.post('/grant', requireAuth, async (req, res, next) => {
  try {
    const caller = req.currentUser;
    if (!caller.permissions || !caller.permissions.can_grant) return res.status(403).json({ detail: 'You do not have grant permission' });

    const { grantee_employee_id, grantee_name, pages, password } = req.body || {};
    if ((!grantee_employee_id && !grantee_name) || !Array.isArray(pages)) {
      return res.status(400).json({ detail: 'grantee_employee_id or grantee_name and pages[] are required' });
    }

    const users = await loadUsers();

    let grantee = findUser(users, { employeeId: grantee_employee_id, username: grantee_name });

    if (!grantee) {
      grantee = {
        username: grantee_name || (grantee_employee_id ? `emp-${grantee_employee_id}` : 'unknown'),
        employeeId: grantee_employee_id || `unknown-${Date.now()}`,
        password: '',
        permissions: {}
      };
      users.push(grantee);
    }

    if (!grantee.permissions) grantee.permissions = {};
    for (const p of pages) {
      grantee.permissions[p] = true;
    }

    // If password provided, set it (plain-text in prototype)
    if (password && typeof password === 'string') {
      grantee.password = password;
    }

    await saveUsers(users);

    const safeGrantee = { username: grantee.username, employeeId: grantee.employeeId, permissions: grantee.permissions };
    return res.json({ ok: true, grantee: safeGrantee });
  } catch (err) {
    next(err);
  }
});

// POST /revoke: if pages array empty or missing -> delete user record; otherwise remove keys.
router.post('/revoke', requireAuth, async (req, res, next) => {
  try {
    const caller = req.currentUser;
    if (!caller.permissions || !caller.permissions.can_grant) return res.status(403).json({ detail: 'You do not have grant permission' });

    const { grantee_employee_id, grantee_name, pages } = req.body || {};
    if ((!grantee_employee_id && !grantee_name)) {
      return res.status(400).json({ detail: 'grantee_employee_id or grantee_name is required' });
    }

    const users = await loadUsers();
    const grantee = findUser(users, { employeeId: grantee_employee_id, username: grantee_name });
    if (!grantee) return res.status(404).json({ detail: 'Grantee not found' });

    // If pages not provided or empty array -> remove the user entirely
    if (!Array.isArray(pages) || pages.length === 0) {
      const idx = users.findIndex(u => String(u.employeeId).toLowerCase() === String(grantee.employeeId).toLowerCase());
      if (idx >= 0) {
        users.splice(idx, 1);
        await saveUsers(users);
        return res.json({ ok: true, removed: true });
      } else {
        return res.status(404).json({ detail: 'Grantee not found for deletion' });
      }
    }

    // Otherwise remove only listed permission keys
    if (!grantee.permissions) grantee.permissions = {};
    for (const p of pages) {
      delete grantee.permissions[p];
    }

    await saveUsers(users);

    const safeGrantee = { username: grantee.username, employeeId: grantee.employeeId, permissions: grantee.permissions };
    return res.json({ ok: true, grantee: safeGrantee });
  } catch (err) {
    next(err);
  }
});

// NEW: POST /set-password
// body: { grantee_employee_id, grantee_name, password }
// caller can set password for someone if caller has can_grant
// OR a user can change their own password (employeeId/username matches caller)
router.post('/set-password', requireAuth, async (req, res, next) => {
  try {
    const caller = req.currentUser;
    const { grantee_employee_id, grantee_name, password } = req.body || {};

    if ((!grantee_employee_id && !grantee_name) || !password) {
      return res.status(400).json({ detail: 'grantee_employee_id or grantee_name and password are required' });
    }

    // allow if admin or self
    const isSelf = String(caller.employeeId).toLowerCase() === String(grantee_employee_id || '').toLowerCase()
      || (grantee_name && String(caller.username).toLowerCase() === String(grantee_name).toLowerCase());

    if (!isSelf && !(caller.permissions && caller.permissions.can_grant)) {
      return res.status(403).json({ detail: 'You do not have permission to set this password' });
    }

    const users = await loadUsers();
    const grantee = findUser(users, { employeeId: grantee_employee_id, username: grantee_name });
    if (!grantee) return res.status(404).json({ detail: 'Grantee not found' });

    // NOTE: plain-text in prototype. Use hashing (bcrypt) in production.
    grantee.password = String(password);

    await saveUsers(users);

    return res.json({ ok: true, msg: 'Password set' });
  } catch (err) {
    next(err);
  }
});

// GET /list unchanged (debug)
router.get('/list', requireAuth, async (req, res, next) => {
  try {
    const users = await loadUsers();
    const safe = users.map(u => ({ username: u.username, employeeId: u.employeeId, permissions: u.permissions || {} }));
    return res.json({ users: safe });
  } catch (err) {
    next(err);
  }
});

export default router;





