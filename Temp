@@
-          {markers.map((m, i) => {
-            const r = 1 * zoom;
-            return (
-              <Marker
-                key={i}
-                coordinates={m.coords}
-                onClick={() => {
-                  if (m.url) {
-                    window.location.href=m.url; // ✅ Use URL from data
-                  }
-                }}
-                style={{ cursor: 'pointer' }}
-              >
+          {markers.map((m, i) => {
+            const r = 1 * zoom;
+            return (
+              <Marker
+                key={i}
+                coordinates={m.coords}
+                onClick={() => {
+                  // delegate navigation/permission-check to parent
+                  if (typeof onClickSite === 'function') {
+                    onClickSite({ ...m, region: selected });
+                    return;
+                  }
+                  // fallback (preserve previous behaviour if no handler passed)
+                  if (m.url) window.location.href = m.url;
+                }}
+                style={{ cursor: 'pointer' }}
+              >











@@
   const auth = useAuth();
+  // helper to attempt navigation or show access denied
+  const attemptNav = (permCandidates, actionFn, label) => {
+    if (!auth.hasPermission(permCandidates)) {
+      setSnack({ open: true, severity: 'warning', message: `Access denied to ${label || 'this resource'}` });
+      return false;
+    }
+    try {
+      actionFn && actionFn();
+    } catch (e) {
+      console.error('Navigation action failed', e);
+    }
+    return true;
+  };









-          {auth?.hasPermission('gsoc_reports') && (
-            <IconButton component={Link} to="/reports" sx={{ color: '#FFC72C', ml: 1 }}>
-              <DescriptionIcon fontSize="medium" />
-            </IconButton>
-          )}
+          <IconButton
+            component={Link}
+            to="#"
+            sx={{ color: '#FFC72C', ml: 1 }}
+            onClick={(e) => {
+              e.preventDefault();
+              attemptNav(['gsoc_reports'], () => navigate('/reports'), 'Reports');
+            }}
+          >
+            <DescriptionIcon fontSize="medium" />
+          </IconButton>











-                onClick={() => {
-                  if (region.key === 'global') {
-                    const el = document.querySelector('[data-global-left-panel]');
-                    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
-                    setSelected('global');
-                    return;
-                  }
-                  // require permission: headcount.<region> OR headcount OR global_access
-                  const permCandidates = [`headcount.${region.key}`, 'headcount', 'global_access'];
-                  if (!auth.hasPermission(permCandidates)) {
-                    // simple UX: alert (could be replaced by nicer toast)
-                    setSnack({ open: true, severity: 'warning', message: `Access denied to ${region.label} headcount` });
-                    return;
-                  }
-                  if (region.url) window.location.href = region.url;
-                }}
+                onClick={() => {
+                  if (region.key === 'global') {
+                    const el = document.querySelector('[data-global-left-panel]');
+                    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
+                    setSelected('global');
+                    return;
+                  }
+                  const permCandidates = [`headcount.${region.key}`, 'headcount', 'global_access'];
+                  attemptNav(permCandidates, () => {
+                    if (region.url) window.location.href = region.url;
+                  }, `${region.label} headcount`);
+                }}











-            <MapChart selected={selected} onClickSite={r => setSelected(r)} initialZoom={1.8} />
+            <MapChart
+              selected={selected}
+              initialZoom={1.8}
+              onClickSite={(marker) => {
+                // marker.region is the current selected region from MapChart call
+                const regionKey = marker.region || selected || 'global';
+                const permCandidates = [`headcount.${regionKey}`, 'headcount', 'global_access'];
+                attemptNav(permCandidates, () => {
+                  if (marker.url) window.location.href = marker.url;
+                }, `${regionKey.toUpperCase()}`);
+              }}
+            />











   const handleRevoke = async () => {
     if (!employeeId && !employeeName) {
       setStatus({ type: 'error', msg: 'Enter Employee ID or name to revoke access' });
       return;
     }
     setStatus({ type: 'info', msg: 'Revoking...' });
     try {
       const pages = Object.keys(checked).filter(k => checked[k]);
-      await axios.post('/api/auth/revoke', { grantee_employee_id: employeeId, grantee_name: employeeName, pages });
+      const resp = await axios.post('/api/auth/revoke', { grantee_employee_id: employeeId, grantee_name: employeeName, pages });
+      // Some backends return 204 No Content; others return 200 + message
+      if (resp && (resp.status === 200 || resp.status === 204)) {
+        setStatus({ type: 'success', msg: 'Revoked successfully' });
+      } else {
+        setStatus({ type: 'success', msg: 'Revoked (response received)' });
+      }
       auth.refresh();
+      // Clear the checked boxes for user feedback
+      setChecked({});
     } catch (err) {
       console.error(err);
-      setStatus({ type: 'error', msg: err?.response?.data?.detail || err?.message || 'Revoke failed' });
+      // prefer structured server detail if present
+      const serverMsg = err?.response?.data?.detail || err?.response?.data?.error || err?.response?.data || null;
+      setStatus({ type: 'error', msg: serverMsg || err?.message || 'Revoke failed' });
     }
   };







-import React, { useState, useMemo, useEffect, useCallback, useRef } from "react";
+import React, { useState, useMemo, useEffect, useCallback, useRef } from "react";
+import { useAuth } from "../context/AuthContext";


-  const [region, setRegion] = useState("apac");
+  const [region, setRegion] = useState("apac");
+  const auth = useAuth();



   useEffect(() => {
     async function fetchCities() {
-      setCitiesForRegion([]);
-      setCity("");
+      // clear previous UI
+      setCitiesForRegion([]);
+      setCity("");
+      // permission guard
+      if (!auth.hasPermission(['headcount', `headcount.${region}`, 'global_access'])) {
+        setError(`Access denied to ${region.toUpperCase()} locations`);
+        return;
+      } else {
+        setError("");
+      }





     try {
+        // permission guard for region-level data
+        if (!auth.hasPermission(['headcount', `headcount.${region}`, 'global_access'])) {
+          throw new Error(`Access denied to ${region.toUpperCase()}`);
+        }







   const applyOverride = async () => {
     ...
-    setOverrideApplying(true);
+    // region permission
+    if (!auth.hasPermission(['headcount', `headcount.${region}`, 'global_access'])) {
+      alert(`Access denied to apply overrides for ${region.toUpperCase()}`);
+      return;
+    }
+    setOverrideApplying(true);





















Now I want Update like 
Currently system Works like When EMployee does not have access then syssytem hide all details tab from page .and only display Accesiable 
icon ..

So i want to update like 
Always display all tabs in all time if someone have access or not 
only when click on accesable link then open page else generate pop up Access denied ..

I have review Grant Button is Working but revoke button is not Working ..need to fix ...

also refer below Map Chart.js file carefully and restrict all API page endpoints ..

like If Someone have Access for HeadCout APAC , Then Only when click APAC open page 
and APAC location

example - Mayur has Access for APAC page .
Then mayur is able to click Pune , Manila , Qiezon , Taguig like ...

Mayur is not able to open EMEA , LACA , NAMER like ...



Restrict all below API Endpoint as per Region..


//C:\Users\W0024618\Desktop\global-page\frontend\src\components\MapChart.jsx
import React, { useState, useEffect } from 'react';
import {
  ComposableMap,
  Geographies,
  Geography,
  Marker,
  ZoomableGroup,
} from 'react-simple-maps';
import { useTheme } from '@mui/material/styles';
import Box from '@mui/material/Box';
import IconButton from '@mui/material/IconButton';
import AddIcon from '@mui/icons-material/Add';
import RemoveIcon from '@mui/icons-material/Remove';
import theme, { brandColors } from '../theme.js';

const geoUrl = '/world-110m.json';

const apacList = [
  { name: 'Pune, India', coords: [73.8567, 18.5204], url: 'http://10.199.22.57:3011' },
  { name: 'Quezon City, Philippines', coords: [121.0509, 14.6760], url: 'http://10.199.22.57:3000/partition/Quezon%20City' },
  { name: 'Tokyo, Japan', coords: [139.6917, 35.6895], url: 'http://10.199.22.57:3000/partition/JP.Tokyo' },
  { name: 'Taguig City, Philippines', coords: [121.0437, 14.5547], url: 'http://10.199.22.57:3000/partition/Taguig%20City' },
  { name: 'Kuala Lumpur, Malaysia', coords: [101.6869, 3.1390], url: 'http://10.199.22.57:3000/partition/MY.Kuala%20Lumpur' },
];

const lacaList = [
  { name: 'San José, Costa Rica', coords: [-84.0907, 9.9281], url: 'http://10.199.22.57:3003/partition/CR.Costa%20Rica%20Partition' },
  { name: 'Mexico City, Mexico', coords: [-99.1332, 19.4326], url: 'http://10.199.22.57:3003/partition/MX.Mexico%20City' },
  { name: 'Buenos Aires, Argentina', coords: [-58.3816, -34.6037], url: 'http://10.199.22.57:3003/partition/AR.Cordoba' },
  { name: 'Panama City, Panama', coords: [-79.5167, 8.9833], url: 'http://10.199.22.57:3003/partition/PA.Panama%20City' },
  { name: 'Lima, Peru', coords: [-77.0428, -12.0464], url: 'http://10.199.22.57:3003/partition/PE.Lima' },
  { name: 'Brasília, Brazil', coords: [-47.8825, -15.7942], url: 'http://10.199.22.57:3003/partition/BR.Sao%20Paulo' },
];

const emeaList = [
  { name: 'Dubai, UAE', coords: [55.2708, 25.2048], url: 'http://10.199.22.57:3001/partition/DU.Abu%20Dhab' },
  { name: 'London, UK', coords: [-0.1278, 51.5074], url: 'http://10.199.22.57:3001/partition/UK.London' },
  { name: 'Dublin, Ireland', coords: [-6.2603, 53.3498], url: 'http://10.199.22.57:3001/partition/IE.Dublin' },
  { name: 'Moscow, Russia', coords: [37.6173, 55.7558], url: 'http://10.199.22.57:3001/partition/RU.Moscow' },
  { name: 'Casablanca, Morocco', coords: [-7.5898, 33.5731], url: 'http://10.199.22.57:3001/partition/MA.Casablanca' },
  { name: 'Vilnius, Lithuania', coords: [25.2797, 54.6872], url: 'http://10.199.22.57:3001/partition/LT.Vilnius' },
];

const namerList = [
  { name: 'Denver, USA', coords: [-104.9903, 39.7392], url: 'http://10.199.22.57:3012'},
  { name: 'New York, USA', coords: [-74.0060, 40.7128], url: 'http://10.199.22.57:3002/partition/US.NYC' },
  { name: 'Miami, USA', coords: [-80.1918, 25.7617], url: 'http://10.199.22.57:3002/partition/US.FL.Miami' },
  { name: 'Austin, USA', coords: [-97.7431, 30.2672], url: 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default' },
];

const REGION_COUNTRIES = {
  global: [...apacList, ...emeaList, ...lacaList, ...namerList],
  apac: apacList,
  emea: emeaList,
  laca: lacaList,
  namer: namerList,
};

const regionOrder = ['global', 'apac', 'emea', 'laca', 'namer'];
function getColor(region, palette) {
  return palette[regionOrder.indexOf(region) % palette.length];
}



// Instead of hiding label, we'll only offset their positions
const CITY_OFFSETS = {
  'Taguig City, Philippines': [5.5, -8], // slightly to the right & down
  'Panama City, Panama': [5.5, -8],
  'Dublin, Ireland': [9.9, -10],
  'Moscow, Russia': [7.5, -0.5],
};



// export default function MapChart({ selected = 'global', onClickSite, initialZoom = 5, }) {
//   const theme = useTheme();
//   const brands = theme.palette.brand.colors;

export default function MapChart({ selected = 'global', onClickSite, initialZoom = 5, }) {
  const theme = useTheme();
  // pull colors array directly instead of theme.palette.brand
  const brands = brandColors;



  // Zoom & center
  // const [zoom, setZoom] = useState();

  // Zoom & center
  // Use a ref to know if we’re mounting for the first time
  const firstMount = React.useRef(true);
  const [zoom, setZoom] = useState(initialZoom);


  const [center, setCenter] = useState([0, 20]);
  useEffect(() => {


    // recenter every time region changes
    if (selected === 'global') {
      setCenter([0, 13]);
      // only reset zoom on first mount if you want; otherwise keep whatever zoom is
      if (firstMount.current) {
        setZoom(initialZoom);
        firstMount.current = false;
      }
    } else {

      const list = REGION_COUNTRIES[selected] || [];
      if (list.length) {
        setCenter(list[0].coords);
        setZoom(selected === 'apac' || selected === 'emea' ? 2 : 3);
      }
    }
  }, [selected]);

  const handleZoomIn = () => setZoom(z => Math.min(z * 1.9, 10));
  const handleZoomOut = () => setZoom(z => Math.max(z / 1.5, 1));

  // Build markers with label / tooltip behavior
  const markers = REGION_COUNTRIES[selected].map((m, idx) => {
    const [city] = m.name.split(',');




const offset = CITY_OFFSETS[m.name] || [0, 0];
const coords = [m.coords[0] + offset[0], m.coords[1] + offset[1]];

return {
  name: city.trim(),
  coords,
  color: brands[idx % brands.length],
  showLabel: true, // ✅ Show label for all cities
  tooltip: null,    // Optional: keep tooltip if needed
  url: m.url,
};


  });




  return (
    <Box sx={{ position: 'relative', width: '100%', height: '100%' }}>
      {/* Zoom Controls */}
      <Box
        sx={{
          position: 'absolute',
          top: 8,
          right: 8,
          display: 'flex',
          flexDirection: 'column',
          zIndex: 10,
        }}
      >
        <IconButton size="small" onClick={handleZoomIn}>
          <AddIcon fontSize="small" />
        </IconButton>
        <IconButton size="small" onClick={handleZoomOut}>
          <RemoveIcon fontSize="small" />
        </IconButton>
      </Box>

      <ComposableMap
        projectionConfig={{ rotate: [-10, 0, 0], scale: 150 }}
        style={{
          width: '100%',
          height: '100%',

          // border: '1px solid #d0d0d0', // professional border
          borderRadius: '12px',
          boxShadow: '0 4px 20px rgba(0, 0, 0, 0.1)',
        }}
      >
        <ZoomableGroup center={center} zoom={zoom}>
          {/* Countries */}
          <Geographies geography={geoUrl}>
            {({ geographies }) =>
              geographies.map(geo => {
                const name = geo.properties.NAME;
                const inRegion = REGION_COUNTRIES[selected].some(
                  c => c.name.split(',').pop().trim() === name
                );
                return (
                  <Geography
                    key={geo.rsmKey}
                    geography={geo}
                    fill={
                      inRegion
                        ? getColor(selected, brands)
                        : theme.palette.grey[900]
                    }
                    stroke={theme.palette.grey[700]}
                    strokeWidth={0.5}
                    style={{ default: { outline: 'none' } }}
                  />
                );
              })
            }
          </Geographies>

         

          {markers.map((m, i) => {
            const r = 1 * zoom;
            return (
              <Marker
                key={i}
                coordinates={m.coords}
                onClick={() => {
                  if (m.url) {
                    window.location.href=m.url; // ✅ Use URL from data
                  }
                }}
                style={{ cursor: 'pointer' }}
              >
                <svg
                  width={5 * zoom}
                  height={5 * zoom}
                  viewBox="0 0 16 16"
                  fill={m.color}
                  xmlns="http://www.w3.org/2000/svg"
                  style={{ transform: 'translate(-8px, -16px)', cursor: 'pointer' }}
                >
                  <path d="M8 0a5 5 0 0 0-5 5c0 4.25 5 11 5 11s5-6.75 5-11a5 5 0 0 0-5-5zm0 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4z" />
                  {m.tooltip && <title>{m.tooltip}</title>}
                </svg>

                {m.showLabel && (
                  <text
                    textAnchor="middle"
                    y={-12 * zoom}
                    fill={m.color}
                    fontSize={5 * zoom}
                    fontWeight="bold"
                    style={{
                      paintOrder: 'stroke',
                      strokeWidth: 1,
                      strokeLinejoin: 'round',
                      cursor: 'pointer', // Ensure text also shows pointer
                    }}
                  >
                    {m.name}
                  </text>
                )}
              </Marker>
            );
          })}


        </ZoomableGroup>
      </ComposableMap>
    </Box>
  );
}








C:\Users\W0024618\Desktop\global-page\frontend\src\components\ProtectedRoute.jsx

//C:\Users\W0024618\Desktop\global-page\frontend\src\components\ProtectedRoute.jsx
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

/**
 * Usage:
 * <ProtectedRoute>
 *   <SomePage />
 * </ProtectedRoute>
 *
 * or with permission or multiple allowed permissions:
 * <ProtectedRoute permission="headcount"><HeadCountPage/></ProtectedRoute>
 * <ProtectedRoute permission={['gsoc_reports', 'headcount']}><ReportsPage/></ProtectedRoute>
 */
export default function ProtectedRoute({ children, permission = null }) {
  const auth = useAuth();
  const location = useLocation();

  if (auth.loading) {
    // while loading, show nothing to avoid flicker; you can show a spinner here
    return null;
  }

  if (!auth.user) {
    return <Navigate to="/login" state={{ from: location.pathname }} replace />;
  }

  if (permission) {
    // permission can be string or array
    if (!auth.hasPermission(permission)) {
      return (
        <div style={{ padding: 24 }}>
          <h3>Access denied</h3>
          <p>You do not have permission to view this resource.</p>
        </div>
      );
    }
  }

  return children;
}





//C:\Users\W0024618\Desktop\global-page\frontend\src\context\AuthContext.jsx

import React, { createContext, useContext, useEffect, useState } from 'react';
import axios from 'axios';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null); // { EmployeeName, EmployeeID, username, ...}
  const [permissions, setPermissions] = useState({}); // { device_health: true, headcount.apac: true, ... }
  const [loading, setLoading] = useState(true);
  const [token, setToken] = useState(() => localStorage.getItem('auth_token') || null);

  // Set axios default header when token changed
  useEffect(() => {
    if (token) {
      axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      localStorage.setItem('auth_token', token);
    } else {
      delete axios.defaults.headers.common['Authorization'];
      localStorage.removeItem('auth_token');
    }
  }, [token]);

  // Try to load user/permissions on start if token exists
  useEffect(() => {
    let cancelled = false;
    async function fetchMe() {
      if (!token) {
        setLoading(false);
        return;
      }
      try {
        const res = await axios.get('/api/auth/me'); // expects { user, permissions }
        if (cancelled) return;
        setUser(res.data.user || null);
        setPermissions(res.data.permissions || {});
      } catch (err) {
        console.warn('fetch /api/auth/me failed', err?.message || err);
        // if token invalid -> clear
        setToken(null);
        setUser(null);
        setPermissions({});
      } finally {
        if (!cancelled) setLoading(false);
      }
    }
    fetchMe();
    return () => { cancelled = true; };
  }, [token]);

  const login = async (username, password) => {
    try {
      const res = await axios.post('/api/auth/login', { username, password });
      const { token: t, user: u, permissions: p } = res.data;
      if (!t) throw new Error('missing token in login response');
      setToken(t);
      setUser(u || null);
      setPermissions(p || {});
      return { ok: true };
    } catch (err) {
      console.error('login failed', err?.response?.data || err?.message || err);
      const msg = err?.response?.data?.detail || err?.response?.data?.error || err?.message || 'Login failed';
      return { ok: false, error: msg };
    }
  };

  const logout = () => {
    setToken(null);
    setUser(null);
    setPermissions({});
  };

  // New: hasPermission supports:
  // - single permission string (e.g. 'device_health' or 'headcount.apac')
  // - returns true if user has 'global_access' (super-permission)
  // - returns true if exact key exists or if asked for 'headcount' and user has any 'headcount.*'
  // - accepts null/undefined -> false
  const hasPermission = (perm) => {
    if (!perm) return false;
    // super-permission
    if (permissions && permissions.global_access) return true;

    // if permission is array - require any match
    if (Array.isArray(perm)) {
      return perm.some(p => hasPermission(p));
    }

    // exact
    if (permissions && permissions[perm]) return true;

    // parent lookup: if asked 'headcount' and user has any headcount.* key - treat as allowed
    const parts = perm.split('.');
    if (parts.length === 1) {
      const prefix = `${perm}.`;
      for (const k of Object.keys(permissions || {})) {
        if (k.startsWith(prefix) && permissions[k]) return true;
      }
    }

    return false;
  };

  // canGrant (kept)
  const canGrant = !!permissions?.can_grant;

  // helper to refresh permissions (call when granting/revoking or token change)
  const refresh = async () => {
    if (!token) return;
    try {
      const res = await axios.get('/api/auth/me');
      setUser(res.data.user || null);
      setPermissions(res.data.permissions || {});
    } catch (err) {
      console.warn('refresh failed', err);
    }
  };

  return (
    <AuthContext.Provider value={{
      user,
      token,
      loading,
      login,
      logout,
      hasPermission,
      canGrant,
      permissions,
      refresh,
    }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  return useContext(AuthContext);
}






C:\Users\W0024618\Desktop\global-page\frontend\src\pages\AccessManager.jsx

import React, { useEffect, useState } from 'react';
import { Box, Paper, TextField, Button, Typography, Checkbox, FormControlLabel, Grid, Alert } from '@mui/material';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';

// Define available page keys (map to UI names)
// Added granular keys: headcount.<region>, gsoc_reports.<report>, upload/export perms, global_access
const PAGES = [
  { key: 'global_access', label: 'Global Access (all pages)' },
  { key: 'device_health', label: 'Device Health Dashboard' },
  { key: 'headcount', label: 'HeadCount (any region)' },
  { key: 'headcount.apac', label: 'HeadCount — APAC' },
  { key: 'headcount.emea', label: 'HeadCount — EMEA' },
  { key: 'headcount.laca', label: 'HeadCount — LACA' },
  { key: 'headcount.namer', label: 'HeadCount — NAMER' },
  { key: 'headcount.partition.pune', label: 'HeadCount — Pune (partition)' },

  { key: 'ert', label: 'ERT Members' },
  { key: 'associate_verify', label: 'Associate Verification Tool' },

  // GSOC reports per-report keys
  { key: 'gsoc_reports', label: 'GSOC Reports (all)' },
  { key: 'gsoc_reports.daily_access', label: 'GSOC — Daily Access' },
  { key: 'gsoc_reports.raw', label: 'GSOC — Raw' },
  { key: 'gsoc_reports.rejection', label: 'GSOC — Rejection' },
  { key: 'gsoc_reports.euroc', label: 'GSOC — EUROC Admit/Reject' },
  { key: 'gsoc_reports.time_duration', label: 'GSOC — Time Duration' },
  { key: 'gsoc_reports.headcount', label: 'GSOC — HeadCount (external nav)' },

  // Upload / export permissions
  { key: 'upload_active_employees', label: 'Upload Active Employee Sheet' },
  { key: 'upload_active_contractors', label: 'Upload Active Contractor Sheet' },
  { key: 'export_compare', label: 'Export Comparison (Missing vs CCURE)' },

  { key: 'global_duration', label: 'Duration Page (global)' },
  { key: 'can_grant', label: 'Grant permissions (admin)' },
];

export default function AccessManager() {
  const auth = useAuth();
  const [employeeId, setEmployeeId] = useState('');
  const [employeeName, setEmployeeName] = useState('');
  const [checked, setChecked] = useState({});
  const [status, setStatus] = useState(null);

  useEffect(() => {
    // nothing heavy here
  }, []);

  if (!auth.canGrant) {
    return <Box sx={{ p: 3 }}><Alert severity="error">You don't have grant permissions.</Alert></Box>;
  }

  const handleCheck = (k) => {
    setChecked(prev => ({ ...prev, [k]: !prev[k] }));
  };

  const handleGrant = async () => {
    if (!employeeId && !employeeName) {
      setStatus({ type: 'error', msg: 'Enter Employee ID or name to grant access' });
      return;
    }
    setStatus({ type: 'info', msg: 'Granting...' });
    try {
      const pages = Object.keys(checked).filter(k => checked[k]);
      await axios.post('/api/auth/grant', { grantee_employee_id: employeeId, grantee_name: employeeName, pages });
      setStatus({ type: 'success', msg: 'Granted successfully' });
      auth.refresh();
    } catch (err) {
      console.error(err);
      setStatus({ type: 'error', msg: err?.response?.data?.detail || err?.message || 'Grant failed' });
    }
  };

  const handleRevoke = async () => {
    if (!employeeId && !employeeName) {
      setStatus({ type: 'error', msg: 'Enter Employee ID or name to revoke access' });
      return;
    }
    setStatus({ type: 'info', msg: 'Revoking...' });
    try {
      const pages = Object.keys(checked).filter(k => checked[k]);
      await axios.post('/api/auth/revoke', { grantee_employee_id: employeeId, grantee_name: employeeName, pages });
      setStatus({ type: 'success', msg: 'Revoked successfully' });
      auth.refresh();
    } catch (err) {
      console.error(err);
      setStatus({ type: 'error', msg: err?.response?.data?.detail || err?.message || 'Revoke failed' });
    }
  };

  const selectAll = () => {
    const obj = {};
    PAGES.forEach(p => obj[p.key] = true);
    setChecked(obj);
  };
  const clearAll = () => setChecked({});

  return (
    <Box sx={{ p: 3 }}>
      <Paper sx={{ p: 3 }}>
        <Typography variant="h6" sx={{ mb: 2 }}>Access Manager — Grant / Revoke Pages</Typography>

        {status && <Alert severity={status.type} sx={{ mb: 2 }}>{status.msg}</Alert>}

        <Grid container spacing={2}>
          <Grid item xs={12} md={6}>
            <TextField fullWidth label="Employee ID (e.g. W0025562)" value={employeeId} onChange={e => setEmployeeId(e.target.value)} helperText="EmployeeID or login"/>
          </Grid>
          <Grid item xs={12} md={6}>
            <TextField fullWidth label="Employee Name (optional)" value={employeeName} onChange={e => setEmployeeName(e.target.value)} />
          </Grid>

          <Grid item xs={12}>
            <Typography sx={{ mb: 1, fontWeight: 700 }}>Pages to grant / revoke</Typography>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
              {PAGES.map(p => (
                <FormControlLabel
                  key={p.key}
                  control={<Checkbox checked={!!checked[p.key]} onChange={() => handleCheck(p.key)} />}
                  label={p.label}
                />
              ))}
            </Box>

            <Box sx={{ display: 'flex', gap: 1, mt: 2 }}>
              <Button variant="outlined" onClick={selectAll}>Select all</Button>
              <Button variant="outlined" onClick={clearAll}>Clear</Button>
              <Button variant="contained" color="primary" onClick={handleGrant}>Grant access</Button>
              <Button variant="contained" color="error" onClick={handleRevoke}>Revoke access</Button>
            </Box>

            <Typography variant="caption" sx={{ display: 'block', mt: 2, color: 'text.secondary' }}>
              Granting will call backend and store the mapping. Revoking will remove access. After changes, this UI refreshes current user's permissions (if affected).
            </Typography>
          </Grid>
        </Grid>
      </Paper>
    </Box>
  );
}








// frontend/src/pages/DurationPage.jsx
import React, { useState, useMemo, useEffect, useCallback, useRef } from "react";
import axios from "axios";
import {
  Box,
  Grid,
  Paper,
  Typography,
  TextField,
  Button,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  TableContainer,
  CircularProgress,
  IconButton,
  Tooltip,
  Card,
  CardContent,
  Dialog,
  DialogTitle,
  DialogContent,
  Divider,
  MenuItem,
  Select,
  FormControl,
  InputLabel,
  InputAdornment,
} from "@mui/material";
import DateRangeIcon from "@mui/icons-material/DateRange";
import SearchIcon from "@mui/icons-material/Search";
import DownloadIcon from "@mui/icons-material/CloudDownload";
import ClearIcon from "@mui/icons-material/Clear";
import VisibilityIcon from "@mui/icons-material/Visibility";

const API_BASE =
  import.meta.env.VITE_API_BASE ||
  import.meta.env.REACT_APP_API_BASE ||
  "http://localhost:8000";

const REGIONS = [
  { value: "apac", label: "APAC" },
  { value: "emea", label: "EMEA" },
  { value: "laca", label: "LACA" },
  { value: "namer", label: "NAMER" },
];

function secondsToHMS(s) {
  if (s == null) return "";
  const sec = Number(s);
  if (!Number.isFinite(sec)) return "";
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const r = Math.floor(sec % 60);
  return `${h}:${String(m).padStart(2, "0")}:${String(r).padStart(2, "0")}`;
}

function isoToDDMMYYYY(iso) {
  if (!iso) return iso;
  const dt = new Date(iso.includes("T") ? iso : `${iso}T00:00:00Z`);
  if (Number.isNaN(dt.getTime())) return iso;
  const dd = String(dt.getUTCDate()).padStart(2, "0");
  const mm = String(dt.getUTCMonth() + 1).padStart(2, "0");
  const yyyy = dt.getUTCFullYear();
  return `${dd}-${mm}-${yyyy}`;
}

function isoToLongDateNoCommas(iso) {
  if (!iso) return iso;
  const dt = new Date(iso.includes("T") ? iso : `${iso}T00:00:00Z`);
  if (Number.isNaN(dt.getTime())) return iso;
  const weekday = dt.toLocaleDateString(undefined, { weekday: "short" });
  const day = String(dt.getUTCDate()).padStart(2, "0");
  const month = String(dt.getUTCMonth() + 1).padStart(2, "0");
  const year = dt.getUTCFullYear();
  return `${weekday} ${day}-${month}-${year}`;
}

// threshold used for highlighting swipe differences > 6 hours
const SWIPE_DIFF_RED_THRESHOLD = 6 * 3600;

export default function DurationPage() {
  const [region, setRegion] = useState("apac");
  const [city, setCity] = useState("");
  const [citiesForRegion, setCitiesForRegion] = useState([]);
  const [startDate, setStartDate] = useState("");
  const [endDate, setEndDate] = useState("");
  const [singleDate, setSingleDate] = useState("");
  const [useRange, setUseRange] = useState(true);

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const [searchEmployeeId, setSearchEmployeeId] = useState("");
  const [searchEmployeeName, setSearchEmployeeName] = useState("");
  const [searchCardNumber, setSearchCardNumber] = useState("");

  const [swipeDialogOpen, setSwipeDialogOpen] = useState(false);
  const [selectedEmployee, setSelectedEmployee] = useState(null);
  const [selectedSwipes, setSelectedSwipes] = useState([]);

  // New UI state for override selection
  const [overrideDate, setOverrideDate] = useState("");
  const [overrideStartIndex, setOverrideStartIndex] = useState(null);
  const [overrideEndIndex, setOverrideEndIndex] = useState(null);
  const [overrideReason, setOverrideReason] = useState("");
  const [overrideApplying, setOverrideApplying] = useState(false);

  // Refs for native date inputs so we can call showPicker() (if supported)
  const startDateRef = useRef(null);
  const endDateRef = useRef(null);
  const singleDateRef = useRef(null);

  // Styling for tables (borders + header background)
  const tableSx = {
    "& th, & td": { border: "1px solid rgba(0,0,0,0.12)" },
    "& thead th": { backgroundColor: "#FFD700", fontWeight: 700 },
    "& tbody tr": { backgroundColor: "transparent" },
    "& tbody tr:hover": { backgroundColor: "rgba(255, 204, 0, 0.12)" },
  };

  const dialogTableSx = {
    "& th, & td": { border: "1px solid rgba(0,0,0,0.12)" },
    "& thead th": { backgroundColor: "#FFD700", fontWeight: 700 },
    "& tbody tr:hover": { backgroundColor: "rgba(255, 204, 0, 0.08)" },
  };

  // helper to try to open the native date picker (where supported)
  const openNativeDatePicker = (ref) => {
    if (!ref || !ref.current) return;
    try {
      if (typeof ref.current.showPicker === "function") {
        ref.current.showPicker();
      } else {
        ref.current.focus();
      }
    } catch (e) {
      try {
        ref.current.focus();
      } catch {}
    }
  };

  // fetch cities when region changes
  useEffect(() => {
    async function fetchCities() {
      setCitiesForRegion([]);
      setCity("");
      try {
        const res = await axios.get(`${API_BASE}/duration/cities`, {
          params: { region },
          timeout: 20000,
        });
        const cities = res.data?.cities || [];
        setCitiesForRegion(cities);
      } catch (err) {
        console.warn("Failed to fetch cities list:", err?.message || err);
        setCitiesForRegion([]);
      }
    }
    fetchCities();
  }, [region]);

  // --- fetch durations (full) ---
  const fetchDurations = useCallback(
    async (opts = {}) => {
      // default full fetch (used when user clicks Run)
      setError("");
      setLoading(true);
      setData(null);

      try {
        const params = {};
        if (useRange && startDate && endDate) {
          params.start_date = startDate;
          params.end_date = endDate;
        } else if (!useRange && singleDate) {
          params.date = singleDate;
        } else {
          if (singleDate) params.date = singleDate;
        }

        if (region) params.regions = region;
        if (city) params.city = city;

        // server-side filters
        if (searchEmployeeId) params.employee_id = searchEmployeeId;
        if (searchEmployeeName) params.employee_name = searchEmployeeName;
        if (searchCardNumber) params.card_number = searchCardNumber;

        // allow overriding timeout via opts
        const timeout = opts.timeout || 1200000;

        const res = await axios.get(`${API_BASE}/duration`, {
          params,
          timeout,
        });
        setData(res.data);
      } catch (err) {
        console.error(err);
        setError(err?.response?.data?.detail || err.message || "Failed to fetch duration data");
      } finally {
        setLoading(false);
      }
    },
    [useRange, startDate, endDate, singleDate, region, city, searchEmployeeId, searchEmployeeName, searchCardNumber]
  );

  // --- targeted fetch: get only single employee for current region and merge into UI ---
  const fetchAndMergeEmployee = useCallback(
    async ({ employeeId, person_uid } = {}) => {
      if (!employeeId && !person_uid) return;
      try {
        const params = {};
        if (useRange && startDate && endDate) {
          params.start_date = startDate;
          params.end_date = endDate;
        } else if (!useRange && singleDate) {
          params.date = singleDate;
        } else {
          if (singleDate) params.date = singleDate;
        }
        params.regions = region;
        // prefer server-side employee_id filter (EmployeeID)
        if (employeeId) params.employee_id = employeeId;
        // if no EmployeeID but we have person_uid, pass employee_name or a unique param — backend supports employee_id only,
        // but person_uid may match PersonGUID in swipes. We'll pass employee_name if nothing else.
        if (!employeeId && person_uid) {
          params.employee_name = person_uid;
        }
        params.sample_rows = 0; // we only need exact employee rows, avoid extra samples
        const res = await axios.get(`${API_BASE}/duration`, { params, timeout: 120000 });
        const resp = res.data;
        if (!resp || !resp.regions || !resp.regions[region]) {
          // no matching data returned
          return;
        }
        const newRegionObj = resp.regions[region];
        const fetchedEmployees = newRegionObj.employees || [];

        setData((prev) => {
          try {
            if (!prev) {
              // nothing previously, use fetched answer
              return resp;
            }
            const next = { ...prev, regions: { ...(prev.regions || {}) } };
            const prevRegion = (prev.regions || {})[region] || { dates: [], employees: [], swipes_by_date: {} };
            // merge dates and swipes_by_date from fetched
            const mergedRegion = {
              ...prevRegion,
              dates: newRegionObj.dates || prevRegion.dates,
              date_rows: newRegionObj.date_rows || prevRegion.date_rows,
              swipes_by_date: { ...(prevRegion.swipes_by_date || {}), ...(newRegionObj.swipes_by_date || {}) },
            };

            // update (replace) employees: for each fetched employee, replace or insert into prevRegion.employees
            const prevEmployees = Array.isArray(prevRegion.employees) ? [...prevRegion.employees] : [];
            fetchedEmployees.forEach((fe) => {
              const idx = prevEmployees.findIndex((p) => {
                // match by person_uid if present else by EmployeeID
                if (p.person_uid && fe.person_uid) return p.person_uid === fe.person_uid;
                if (p.EmployeeID && fe.EmployeeID) return String(p.EmployeeID) === String(fe.EmployeeID);
                return false;
              });
              if (idx >= 0) {
                prevEmployees[idx] = fe;
              } else {
                // insert (keeping sort might be messy, so append)
                prevEmployees.push(fe);
              }
            });

            mergedRegion.employees = prevEmployees;
            next.regions[region] = mergedRegion;
            return next;
          } catch (e) {
            // fallback: set full response
            console.error("Failed to merge employee data:", e);
            return resp;
          }
        });
      } catch (err) {
        console.error("fetchAndMergeEmployee failed:", err);
      }
    },
    [region, startDate, endDate, singleDate, useRange]
  );

  // derive current region object quickly
  const regionObj = useMemo(() => {
    if (!data || !region) return null;
    return data.regions?.[region] || null;
  }, [data, region]);

  // helpers to compute week starts from regionObj.dates
  const computeWeekStarts = (datesIso) => {
    if (!datesIso || datesIso.length === 0) return [];
    const dateObjs = datesIso.map((d) => new Date(d + "T00:00:00Z"));
    const weekStartSet = new Set();
    dateObjs.forEach((dt) => {
      const day = dt.getUTCDay();
      const diff = (day + 6) % 7; // shift so Monday is week start
      const monday = new Date(dt);
      monday.setUTCDate(dt.getUTCDate() - diff);
      weekStartSet.add(monday.toISOString().slice(0, 10));
    });
    return Array.from(weekStartSet).sort();
  };

  // --- CSV helpers (unchanged, kept local) ---
  const quote = (s) => `"${String(s ?? "").replace(/"/g, '""')}"`;

  const exportSummaryCsv = () => {
    if (!regionObj) return;
    const dates = regionObj.dates || [];
    const rows = regionObj.employees || [];

    const header = ["EmployeeID", "EmployeeName", "TotalSecondsPresentInRange", "DominantCategory", "ComplianceSummary", ...dates.map((d) => d)];
    const csvRows = [header.map((h) => quote(h)).join(",")];

    rows.forEach((r) => {
      const complianceText = r.compliance?.month_summary || "";
      const complianceCell = `'${complianceText}`; // force text in Excel
      const row = [
        quote(r.EmployeeID || ""),
        quote(r.EmployeeName || ""),
        r.total_seconds_present_in_range ?? "",
        quote(r.duration_categories?.dominant_category || ""),
        quote(complianceCell),
        ...dates.map((d) => quote(r.durations?.[d] ?? "")),
      ];
      csvRows.push(row.join(","));
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `duration_summary_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  const exportReportCsv = () => {
    if (!regionObj) return;
    const datesIso = regionObj.dates || [];
    const weekStarts = computeWeekStarts(datesIso);

    const baseHeader = ["Sr.No", "EmployeeID", "EmployeeName", "CardNumber", "PersonnelType", "PartitionName2", "TotalSecondsPresentInRange"];
    const perDayHeaders = [];
    weekStarts.forEach((ws) => {
      for (let i = 0; i < 7; i++) {
        const d = new Date(ws + "T00:00:00Z");
        d.setUTCDate(d.getUTCDate() + i);
        const iso = d.toISOString().slice(0, 10);
        perDayHeaders.push(isoToLongDateNoCommas(iso));
      }
    });
    const perWeekHeaders = weekStarts.map((ws) => `Week compliance ${ws}`);

    const header = [...baseHeader, ...perDayHeaders, ...perWeekHeaders, "DominantCategory", "ComplianceSummary"];
    const csvRows = [header.map((h) => quote(h)).join(",")];

    const rows = regionObj.employees || [];
    rows.forEach((r, idx) => {
      const srNo = idx + 1;
      const employeeId = r.EmployeeID ?? "";
      const employeeName = r.EmployeeName ?? "";
      const cardNumber = r.CardNumber ?? "";
      const personnelType = r.PersonnelType ?? r.PersonnelTypeName ?? "";
      const partition = r.PartitionName2 ?? "";
      const totalSeconds = r.total_seconds_present_in_range ?? "";

      const perDayVals = [];
      weekStarts.forEach((ws) => {
        for (let i = 0; i < 7; i++) {
          const d = new Date(ws + "T00:00:00Z");
          d.setUTCDate(d.getUTCDate() + i);
          const iso = d.toISOString().slice(0, 10);

          const wk = r.compliance && r.compliance.weeks ? r.compliance.weeks[ws] : null;
          let outVal = "0";

          if (wk && wk.dates && Object.prototype.hasOwnProperty.call(wk.dates, iso)) {
            const secs = wk.dates[iso];
            if (secs !== null && secs !== undefined) {
              outVal = r.durations && r.durations[iso] ? r.durations[iso] : secondsToHMS(secs);
            } else {
              outVal = "0";
            }
          } else if (r.durations && Object.prototype.hasOwnProperty.call(r.durations, iso) && r.durations[iso]) {
            outVal = r.durations[iso];
          } else if (r.durations_seconds && Object.prototype.hasOwnProperty.call(r.durations_seconds, iso) && r.durations_seconds[iso]) {
            outVal = secondsToHMS(r.durations_seconds[iso]);
          } else {
            outVal = "0";
          }

          perDayVals.push(outVal);
        }
      });

      const perWeekVals = weekStarts.map((ws) => {
        const wk = r.compliance && r.compliance.weeks ? r.compliance.weeks[ws] : null;
        return wk && wk.compliant ? "Yes" : "No";
      });

      const complianceText = r.compliance?.month_summary || "";
      const complianceCell = `'${complianceText}`;

      const row = [
        `${srNo}`,
        quote(employeeId),
        quote(employeeName),
        quote(cardNumber),
        quote(personnelType),
        quote(partition),
        `${totalSeconds}`,
        ...perDayVals.map((v) => quote(v)),
        ...perWeekVals.map((v) => quote(v)),
        quote(r.duration_categories?.dominant_category || ""),
        quote(complianceCell),
      ];

      csvRows.push(row.join(","));
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `duration_report_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  const exportSwipesCsv = () => {
    if (!regionObj) return;
    const swipesByDate = regionObj.swipes_by_date || {};
    const rows = [];
    Object.entries(swipesByDate).forEach(([d, arr]) => {
      arr.forEach((s) => {
        rows.push({
          Date: d,
          LocaleMessageTime: s.LocaleMessageTime || "",
          Swipe_Time: s.Swipe_Time || "",
          EmployeeID: s.EmployeeID || "",
          PersonGUID: s.PersonGUID || "",
          ObjectName1: s.ObjectName1 || "",
          Door: s.Door || "",
          PersonnelType: s.PersonnelType || "",
          CardNumber: s.CardNumber || "",
          PrimaryLocation: s.PrimaryLocation || s.Text5 || "",
          PartitionName2: s.PartitionName2 || "",
          AdmitCode: s.AdmitCode || "",
          Direction: s.Direction || "",
          CompanyName: s.CompanyName || "",
        });
      });
    });

    if (rows.length === 0) {
      alert("No swipe rows available for current selection to export.");
      return;
    }

    const headers = [
      "Date",
      "LocaleMessageTime",
      "Swipe_Time",
      "EmployeeID",
      "PersonGUID",
      "ObjectName1",
      "Door",
      "PersonnelType",
      "CardNumber",
      "PrimaryLocation",
      "PartitionName2",
      "AdmitCode",
      "Direction",
      "CompanyName",
    ];
    const csvRows = [headers.map((h) => quote(h)).join(",")];
    rows.forEach((r) => {
      const line = headers.map((h) => quote(r[h] ?? "")).join(",");
      csvRows.push(line);
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `swipes_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // Export selected employee's swipes
  const exportSelectedEmployeeSwipes = () => {
    if (!selectedSwipes || selectedSwipes.length === 0) {
      alert("No swipe records to export for selected employee.");
      return;
    }
    const headers = [
      "Date",
      "LocaleMessageTime",
      "Swipe_Time",
      "EmployeeID",
      "PersonGUID",
      "ObjectName1",
      "Door",
      "PersonnelType",
      "CardNumber",
      "PrimaryLocation",
      "PartitionName2",
      "AdmitCode",
      "Direction",
      "CompanyName",
      "DiffSeconds",
      "DiffHHMMSS"
    ];
    const csvRows = [headers.map((h) => quote(h)).join(",")];
    selectedSwipes.forEach((s) => {
      const obj = { ...s };
      const line = headers.map((h) => quote(obj[h] ?? "")).join(",");
      csvRows.push(line);
    });
    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const empId = selectedEmployee?.EmployeeID || "employee";
    const filename = `swipes_${empId}_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // --- Render helpers ---
  const getFilteredRows = useCallback(() => {
    if (!regionObj) return [];
    const rows = regionObj.employees || [];
    return rows.filter((r) => {
      const matchesEmployeeId = !searchEmployeeId || String(r.EmployeeID || "").toLowerCase().includes(searchEmployeeId.toLowerCase());
      const matchesName = !searchEmployeeName || String(r.EmployeeName || "").toLowerCase().includes(searchEmployeeName.toLowerCase());
      const matchesCard = !searchCardNumber || String(r.CardNumber || "").toLowerCase().includes(searchCardNumber.toLowerCase());
      return matchesEmployeeId && matchesName && matchesCard;
    });
  }, [regionObj, searchEmployeeId, searchEmployeeName, searchCardNumber]);

  // compute diffs for selected swipes when opening dialog and attach diff meta


const openSwipeDialogFor = (emp) => {
  setSelectedEmployee(emp);
  const swipesByDate = regionObj?.swipes_by_date || {};
  const matches = [];
  Object.entries(swipesByDate).forEach(([d, arr]) => {
    arr.forEach((s) => {
      const matchByEmployeeId = emp.EmployeeID && s.EmployeeID && String(s.EmployeeID) === String(emp.EmployeeID);
      const matchByCard = emp.CardNumber && s.CardNumber && String(s.CardNumber) === String(emp.CardNumber);
      const matchByPersonGuid = emp.person_uid && s.PersonGUID && String(s.PersonGUID) === String(emp.person_uid);
      if (matchByEmployeeId || matchByCard || matchByPersonGuid) {
        matches.push({ ...s, Date: d });
      }
    });
  });
  matches.sort((a, b) => {
    const ta = a.LocaleMessageTime ? new Date(a.LocaleMessageTime).getTime() : 0;
    const tb = b.LocaleMessageTime ? new Date(b.LocaleMessageTime).getTime() : 0;
    return ta - tb;
  });

  // compute diffs (difference to previous swipe) and attach meta
  const withDiffs = matches.map((row, idx, arr) => {
    let diffSeconds = null;
    if (idx === 0) {
      diffSeconds = null;
    } else {
      const cur = row.LocaleMessageTime ? new Date(row.LocaleMessageTime).getTime() : null;
      const prev = arr[idx - 1].LocaleMessageTime ? new Date(arr[idx - 1].LocaleMessageTime).getTime() : null;
      if (cur != null && prev != null) {
        diffSeconds = Math.max(0, Math.floor((cur - prev) / 1000));
      } else {
        diffSeconds = null;
      }
    }
    return {
      ...row,
      DiffSeconds: diffSeconds,
      DiffHHMMSS: diffSeconds != null ? secondsToHMS(diffSeconds) : "-",
    };
  });

  setSelectedSwipes(withDiffs);

  // reset override state:
  const distinctDates = Array.from(new Set(withDiffs.map((m) => m.Date))).sort();
  // default override date remains the earliest swipe date (but will auto-change when start swipe chosen)
  setOverrideDate(distinctDates.length > 0 ? distinctDates[0] : "");
  setOverrideStartIndex(null);
  setOverrideEndIndex(null);
  setOverrideReason("");
  setSwipeDialogOpen(true);
};



  const computeOverrideDurationSeconds = () => {
    if (!selectedSwipes || selectedSwipes.length === 0) return 0;
    if (overrideStartIndex == null || overrideEndIndex == null) return 0;
    const sIdx = Math.min(overrideStartIndex, overrideEndIndex);
    const eIdx = Math.max(overrideStartIndex, overrideEndIndex);
    const s = selectedSwipes[sIdx];
    const e = selectedSwipes[eIdx];
    if (!s || !e) return 0;
    const sa = s.LocaleMessageTime ? new Date(s.LocaleMessageTime).getTime() : null;
    const eb = e.LocaleMessageTime ? new Date(e.LocaleMessageTime).getTime() : null;
    if (!sa || !eb) return 0;
    return Math.max(0, Math.floor((eb - sa) / 1000));
  };

  const applyOverride = async () => {
    if (!selectedEmployee) return;
    if (!overrideDate) {
      alert("Please select a date for the override.");
      return;
    }
    if (overrideStartIndex == null || overrideEndIndex == null) {
      alert("Please select both start and end swipe entries.");
      return;
    }
    const sIdx = Math.min(overrideStartIndex, overrideEndIndex);
    const eIdx = Math.max(overrideStartIndex, overrideEndIndex);
    const s = selectedSwipes[sIdx];
    const e = selectedSwipes[eIdx];
    if (!s || !e) {
      alert("Invalid swipe selection.");
      return;
    }
    const start_ts = s.LocaleMessageTime || s.Swipe_Time;
    const end_ts = e.LocaleMessageTime || e.Swipe_Time;
    if (!start_ts || !end_ts) {
      alert("Selected swipe rows do not have timestamps.");
      return;
    }
    const seconds = computeOverrideDurationSeconds();
    if (seconds <= 0) {
      if (!window.confirm("Computed duration is 0. Do you still want to apply the override?")) {
        return;
      }
    }

    setOverrideApplying(true);
    try {
      await axios.post(`${API_BASE}/duration/override`, {
        region,
        person_uid: selectedEmployee.person_uid,
        date: overrideDate,
        start_ts: start_ts,
        end_ts: end_ts,
        reason: overrideReason,
        user: "frontend_user"
      }, { timeout: 30000 });

      // Instead of refreshing whole UI, fetch only the updated employee and merge
      await fetchAndMergeEmployee({ employeeId: selectedEmployee.EmployeeID, person_uid: selectedEmployee.person_uid });

      setSwipeDialogOpen(false);
      alert("Override applied — updated employee refreshed.");
    } catch (err) {
      console.error("Failed to apply override:", err);
      alert("Failed to apply override: " + (err?.response?.data?.detail || err.message || "unknown"));
    } finally {
      setOverrideApplying(false);
    }
  };


const renderSwipeSelectionControls = () => {
  if (!selectedSwipes || selectedSwipes.length === 0) return null;

  // distinct dates for the override-date dropdown
  const distinctDates = Array.from(new Set(selectedSwipes.map((m) => m.Date))).sort();

  // We'll present start/end selects which enumerate ALL swipe records (global index into selectedSwipes),
  // so user can pick start on one date and end on another.
  const swipesAll = selectedSwipes;

  return (
    <Box sx={{ mt: 2 }}>
      <Grid container spacing={2} alignItems="center">
        <Grid item xs={12} md={4}>
          <FormControl fullWidth size="small">
            <InputLabel id="override-date-label">Date</InputLabel>
            <Select
              labelId="override-date-label"
              label="Date"
              value={overrideDate}
              onChange={(e) => {
                setOverrideDate(e.target.value);
                // clear selections when changing date manually to avoid confusion
                setOverrideStartIndex(null);
                setOverrideEndIndex(null);
              }}
            >
              {distinctDates.map((d) => (
                <MenuItem key={d} value={d}>{isoToDDMMYYYY(d)}</MenuItem>
              ))}
            </Select>
          </FormControl>
        </Grid>

        <Grid item xs={12} md={4}>
          <FormControl fullWidth size="small">
            <InputLabel id="override-start-label">Start swipe</InputLabel>
            <Select
              labelId="override-start-label"
              label="Start swipe"
              value={overrideStartIndex == null ? "" : overrideStartIndex}
              onChange={(e) => {
                const val = e.target.value === "" ? null : Number(e.target.value);
                setOverrideStartIndex(val);
                // auto-set overrideDate to the start swipe's date (useful when spanning dates)
                if (val !== null && selectedSwipes[val] && selectedSwipes[val].Date) {
                  setOverrideDate(selectedSwipes[val].Date);
                }
                // clear end selection if it was before start (optional UX decision)
                if (overrideEndIndex !== null) {
                  // keep it — user can pick any end; we won't auto-clear to avoid annoyance
                }
              }}
            >
              <MenuItem value=""><em>None</em></MenuItem>
              {swipesAll.map((s, idx) => {
                const timeLabel = s.LocaleMessageTime ? new Date(s.LocaleMessageTime).toLocaleString() : s.Swipe_Time;
                return (
                  <MenuItem key={`start-${idx}`} value={idx}>
                    {s.Date} — {timeLabel} {s.Door ? `— ${s.Door}` : ""}
                  </MenuItem>
                );
              })}
            </Select>
          </FormControl>
        </Grid>

        <Grid item xs={12} md={4}>
          <FormControl fullWidth size="small">
            <InputLabel id="override-end-label">End swipe</InputLabel>
            <Select
              labelId="override-end-label"
              label="End swipe"
              value={overrideEndIndex == null ? "" : overrideEndIndex}
              onChange={(e) => {
                const val = e.target.value === "" ? null : Number(e.target.value);
                setOverrideEndIndex(val);
                // if overrideDate not set (rare), set to end swipe date for safety
                if (val !== null && (!overrideDate || overrideDate === "") && selectedSwipes[val] && selectedSwipes[val].Date) {
                  setOverrideDate(selectedSwipes[val].Date);
                }
              }}
            >
              <MenuItem value=""><em>None</em></MenuItem>
              {swipesAll.map((s, idx) => {
                const timeLabel = s.LocaleMessageTime ? new Date(s.LocaleMessageTime).toLocaleString() : s.Swipe_Time;
                return (
                  <MenuItem key={`end-${idx}`} value={idx}>
                    {s.Date} — {timeLabel} {s.Door ? `— ${s.Door}` : ""}
                  </MenuItem>
                );
              })}
            </Select>
          </FormControl>
        </Grid>

        <Grid item xs={12}>
          <TextField
            fullWidth
            size="small"
            label="Reason (optional)"
            value={overrideReason}
            onChange={(e) => setOverrideReason(e.target.value)}
          />
        </Grid>

        <Grid item xs={12} sx={{ display: "flex", gap: 1, justifyContent: "flex-end" }}>
          <Button
            variant="contained"
            onClick={applyOverride}
            disabled={overrideApplying || !overrideDate || overrideStartIndex == null || overrideEndIndex == null}
          >
            {overrideApplying ? "Applying..." : `Apply Override (${secondsToHMS(computeOverrideDurationSeconds())})`}
          </Button>
        </Grid>
      </Grid>

      <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: "block" }}>
        Tip: start and end swipe selectors now include all swipe records for this employee across the selected range — you can pick start on one date and end on another.
      </Typography>
    </Box>
  );
};



  const renderTable = () => {
    if (!regionObj) return <Typography>No data for selected region.</Typography>;

    const dates = regionObj.dates || [];
    const rows = getFilteredRows();

    const weekStarts = computeWeekStarts(dates);

    return (
      <TableContainer component={Paper} sx={{ mt: 2, width: "100%", overflowX: "auto", boxShadow: 2 }}>
        <Table size="small" stickyHeader sx={tableSx}>
          <TableHead>
            <TableRow>
              <TableCell><b>Sr.No</b></TableCell>
              <TableCell><b>EmployeeID</b></TableCell>
              <TableCell><b>EmployeeName</b></TableCell>
              <TableCell><b>CardNumber</b></TableCell>
              <TableCell><b>PersonnelType</b></TableCell>
              <TableCell><b>PartitionName2</b></TableCell>
              <TableCell align="right"><b>Total (hh:mm:ss)</b></TableCell>
              {dates.map((d) => (
                <TableCell key={d} align="center"><b>{isoToDDMMYYYY(d)}</b></TableCell>
              ))}
              {weekStarts.map((ws) => (
                <TableCell key={ws} align="center"><b>{`Week ${ws} compliant`}</b></TableCell>
              ))}
              <TableCell align="center"><b>Dominant Category</b></TableCell>
              <TableCell align="center"><b>Compliance (weeks met/total)</b></TableCell>
              <TableCell align="center"><b>View</b></TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {rows.length === 0 ? (
              <TableRow>
                <TableCell colSpan={9 + (regionObj.dates || []).length + weekStarts.length} align="center">No employees in the response.</TableCell>
              </TableRow>
            ) : (
              rows.map((r, idx) => (
                <TableRow key={r.person_uid || `${r.EmployeeID}-${r.EmployeeName}`}>
                  <TableCell>{idx + 1}</TableCell>
                  <TableCell>{r.EmployeeID || "-"}</TableCell>
                  <TableCell>{r.EmployeeName || "-"}</TableCell>
                  <TableCell>{r.CardNumber || "-"}</TableCell>
                  <TableCell>{r.PersonnelType || r.PersonnelTypeName || "-"}</TableCell>
                  <TableCell>{r.PartitionName2 || "-"}</TableCell>
                  <TableCell align="right">{secondsToHMS(r.total_seconds_present_in_range)}</TableCell>
                  {dates.map((d) => (
                    <TableCell key={d} align="center">{r.durations?.[d] ?? "-"}</TableCell>
                  ))}
                  {weekStarts.map((ws) => {
                    const wk = r.compliance && r.compliance.weeks ? r.compliance.weeks[ws] : null;
                    return <TableCell key={ws} align="center">{wk && wk.compliant ? "Yes" : "No"}</TableCell>;
                  })}
                  <TableCell align="center">
                    {r.duration_categories?.dominant_category || "-"}
                    {r.duration_categories?.red_flag > 0 ? " ⚠️" : ""}
                  </TableCell>
                  <TableCell align="center">{r.compliance?.month_summary || "-"}</TableCell>
                  <TableCell align="center">
                    <Tooltip title="View swipe records for this employee">
                      <Button size="small" variant="outlined" startIcon={<VisibilityIcon />} onClick={() => openSwipeDialogFor(r)}>
                        View
                      </Button>
                    </Tooltip>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </TableContainer>
    );
  };

  // --- JSX UI (top controls) ---
  return (
    <Box
      sx={{
        p: 3,
        width: "100%",
        maxWidth: "100vw",
        boxSizing: "border-box",
        background: "linear-gradient(180deg,rgb(37, 37, 37),rgb(16, 16, 15))",
        minHeight: "100vh",
      }}
    >
      <Box sx={{ display: "flex", justifyContent: "center", mb: 2 }}>
        <Box
          sx={{
            border: "3px solid #FFD700",
            background: "linear-gradient(90deg,#fffbe6,#fff7cc)",
            borderRadius: 2,
            px: 3,
            py: 1.2,
            width: { xs: "100%", sm: "70%", md: "50%" },
            textAlign: "center",
            boxShadow: 3,
          }}
        >
          <Typography variant="h5" sx={{ fontWeight: 800, color: "#333" }}>
            Duration Reports with Compliance & Category
          </Typography>
        </Box>
      </Box>

      <Grid container spacing={2}>
        <Grid item xs={12}>
          <Card elevation={3}>
            <CardContent>
              <Grid container spacing={2} alignItems="center">
                <Grid item xs={12} md={2}>
                  <FormControl fullWidth size="small">
                    <InputLabel id="region-select-label">Region</InputLabel>
                    <Select
                      labelId="region-select-label"
                      label="Region"
                      value={region}
                      onChange={(e) => setRegion(e.target.value)}
                    >
                      {REGIONS.map((r) => (
                        <MenuItem key={r.value} value={r.value}>{r.label}</MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>

                <Grid item xs={12} md={3}>
                  <FormControl fullWidth size="small">
                    <InputLabel id="city-select-label">City / Partition </InputLabel>
                    <Select
                      labelId="city-select-label"
                      label="City / Partition (optional)"
                      value={city}
                      onChange={(e) => setCity(e.target.value)}
                      renderValue={(v) => v || ""}
                    >
                      <MenuItem value=""><em>All</em></MenuItem>
                      {citiesForRegion && citiesForRegion.length > 0 ? (
                        citiesForRegion.map((c, idx) => (
                          <MenuItem key={idx} value={c}>{c}</MenuItem>
                        ))
                      ) : (
                        <MenuItem disabled value="">
                          No predefined cities (you can type in the input below instead)
                        </MenuItem>
                      )}
                    </Select>
                  </FormControl>
                  <TextField
                    fullWidth
                    size="small"
                    placeholder="Or type to override / fuzzy-match"
                    value={city}
                    onChange={(e) => setCity(e.target.value)}
                    sx={{ mt: 1 }}
                  />
                </Grid>

                <Grid item xs={12} md={5} sx={{ display: "flex", gap: 1, justifyContent: "flex-end", alignItems: "center" }}>
                  <Button
                    startIcon={<DateRangeIcon />}
                    variant={useRange ? "contained" : "outlined"}
                    onClick={() => setUseRange(true)}
                    color="warning"
                  >
                    Range
                  </Button>
                  <Button
                    startIcon={<DateRangeIcon />}
                    variant={!useRange ? "contained" : "outlined"}
                    onClick={() => setUseRange(false)}
                    color="warning"
                  >
                    Single Day
                  </Button>
                </Grid>

                {useRange ? (
                  <>
                    <Grid item xs={12} md={3}>
                      <FormControl fullWidth size="small">
                        <TextField
                          label="Start date"
                          type="date"
                          fullWidth
                          InputLabelProps={{ shrink: true }}
                           value={startDate}
                          onChange={(e) => setStartDate(e.target.value)}
                          size="small"
                          inputRef={startDateRef}
                          InputProps={{
                            endAdornment: (
                              <InputAdornment position="end">
                                <IconButton
                                  size="small"
                                  onClick={() => openNativeDatePicker(startDateRef)}
                                  sx={{ color: "#FFD700" }}
                                >
                                  <DateRangeIcon />
                                </IconButton>
                              </InputAdornment>
                            ),
                          }}
                          sx={{ bgcolor: "#30302e" }}
                        />
                      </FormControl>
                    </Grid>
                    <Grid item xs={12} md={3}>
                      <FormControl fullWidth size="small">
                        <TextField
                          label="End date"
                          type="date"
                          fullWidth
                          InputLabelProps={{ shrink: true }}
                          value={endDate}
                          onChange={(e) => setEndDate(e.target.value)}
                          size="small"
                          inputRef={endDateRef}
                          InputProps={{
                            endAdornment: (
                              <InputAdornment position="end">
                                <IconButton
                                  size="small"
                                  onClick={() => openNativeDatePicker(endDateRef)}
                                  sx={{ color: "#FFD700" }}
                                >
                                  <DateRangeIcon />
                                </IconButton>
                              </InputAdornment>
                            ),
                          }}
                          sx={{ bgcolor: "#30302e" }}
                        />
                      </FormControl>
                    </Grid>
                  </>
                ) : (
                  <Grid item xs={12} md={3}>
                    <FormControl fullWidth size="small">
                      <TextField
                        label="Date"
                        type="date"
                        fullWidth
                        InputLabelProps={{ shrink: true }}
                        value={singleDate}
                        onChange={(e) => setSingleDate(e.target.value)}
                        size="small"
                        inputRef={singleDateRef}
                        InputProps={{
                          endAdornment: (
                            <InputAdornment position="end">
                              <IconButton
                                size="small"
                                onClick={() => openNativeDatePicker(singleDateRef)}
                                sx={{ color: "#FFD700" }}
                              >
                                <DateRangeIcon />
                              </IconButton>
                            </InputAdornment>
                          ),
                        }}
                        sx={{ bgcolor: "transparent" }}
                      />
                    </FormControl>
                  </Grid>
                )}

                <Grid item xs={12} md={6} sx={{ display: "flex", gap: 1, alignItems: "center" }}>
                  <Button
                    variant="contained"
                    startIcon={<SearchIcon />}
                    onClick={() => fetchDurations()}
                    disabled={loading}
                    color="primary"
                  >
                    {loading ? "Loading..." : "Run"}
                  </Button>

                  <Button
                    variant="outlined"
                    startIcon={<ClearIcon />}
                    onClick={() => {
                      setStartDate("");
                      setEndDate("");
                      setSingleDate("");
                      setCity("");
                      setData(null);
                      setError("");
                      setSearchEmployeeId("");
                      setSearchEmployeeName("");
                      setSearchCardNumber("");
                    }}
                  >
                    Clear
                  </Button>

                  <Tooltip title="Export Summary CSV (per-person)">
                    <span>
                      <IconButton onClick={exportSummaryCsv} disabled={!regionObj || (regionObj.employees || []).length === 0}>
                        <DownloadIcon />
                      </IconButton>
                    </span>
                  </Tooltip>

                  <Tooltip title="Export full report (Sr.No, ... Compliance)">
                    <span>
                      <Button variant="contained" onClick={exportReportCsv} disabled={!regionObj || (regionObj.employees || []).length === 0}>
                        Export Report
                      </Button>
                    </span>
                  </Tooltip>

                  <Tooltip title="Export raw swipes for this region/date range">
                    <span>
                      <Button variant="outlined" onClick={exportSwipesCsv} disabled={!regionObj || Object.keys(regionObj.swipes_by_date || {}).length === 0}>
                        Export Swipes
                      </Button>
                    </span>
                  </Tooltip>
                </Grid>

                <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="Search Employee ID"
                    value={searchEmployeeId}
                    onChange={(e) => setSearchEmployeeId(e.target.value)}
                    size="small"
                    helperText="Type an ID and click Run to fetch only that employee (server-side filter)"
                  />
                </Grid>
                <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="Search Employee Name"
                    value={searchEmployeeName}
                    onChange={(e) => setSearchEmployeeName(e.target.value)}
                    size="small"
                    helperText="Type name and click Run to fetch only matching employees"
                  />
                </Grid>
                <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="Search Card Number"
                    value={searchCardNumber}
                    onChange={(e) => setSearchCardNumber(e.target.value)}
                    size="small"
                    helperText="Search card number (server-side filter)"
                  />
                </Grid>

              </Grid>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12}>
          <Paper sx={{ p: 2 }}>
            <Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
              <Typography variant="subtitle1" sx={{ fontWeight: 700 }}>
                {data ? `Showing ${region.toUpperCase()} — ${data.start_date} → ${data.end_date}` : "No results yet"}
              </Typography>
            </Box>

            {loading && (
              <Box sx={{ display: "flex", justifyContent: "center", py: 4 }}>
                <CircularProgress />
              </Box>
            )}

            {error && (
              <Typography color="error" sx={{ mt: 2 }}>
                {error}
              </Typography>
            )}

            {!loading && !error && (
              <Box sx={{ mt: 2 }}>
                {renderTable()}
              </Box>
            )}
          </Paper>
        </Grid>
      </Grid>

      {/* Swipe dialog */}
      <Dialog open={swipeDialogOpen} onClose={() => setSwipeDialogOpen(false)} fullWidth maxWidth="xl">
        <DialogTitle>
          Swipe records for: {selectedEmployee ? `${selectedEmployee.EmployeeID || ""} — ${selectedEmployee.EmployeeName || ""}` : ""}
        </DialogTitle>
        <DialogContent dividers>
          {selectedSwipes.length === 0 ? (
            <Typography>No swipe records found for this employee in the selected range.</Typography>
          ) : (
            <>
              <Table size="small" sx={dialogTableSx}>
                <TableHead>
                  <TableRow>
                    <TableCell><b>Date</b></TableCell>
                    <TableCell><b>Time (local)</b></TableCell>
                    <TableCell><b>Diff (hh:mm:ss)</b></TableCell>
                    <TableCell><b>Door</b></TableCell>
                    <TableCell><b>Direction</b></TableCell>
                    <TableCell><b>CardNumber</b></TableCell>
                    <TableCell><b>PersonnelType</b></TableCell>
                    <TableCell><b>Partition</b></TableCell>
                    <TableCell><b>PrimaryLocation</b></TableCell>
                    <TableCell><b>Company</b></TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {selectedSwipes.map((s, i) => {
                    const isLargeGap = s.DiffSeconds != null && s.DiffSeconds > SWIPE_DIFF_RED_THRESHOLD;
                    return (
                      <TableRow key={i} sx={isLargeGap ? { backgroundColor: "rgba(255,0,0,0.08)" } : {}}>
                        <TableCell>{s.Date}</TableCell>
                        <TableCell>{s.Swipe_Time ?? (s.LocaleMessageTime ? new Date(s.LocaleMessageTime).toLocaleString() : "-")}</TableCell>
                        <TableCell sx={isLargeGap ? { color: "red", fontWeight: 700 } : {}}>{s.DiffHHMMSS ?? "-"}</TableCell>
                        <TableCell>{s.Door || s.ObjectName1 || "-"}</TableCell>
                        <TableCell>{s.Direction || "-"}</TableCell>
                        <TableCell>{s.CardNumber || "-"}</TableCell>
                        <TableCell>{s.PersonnelType || "-"}</TableCell>
                        <TableCell>{s.PartitionName2 || "-"}</TableCell>
                        <TableCell>{s.PrimaryLocation || s.Text5 || "-"}</TableCell>
                        <TableCell>{s.CompanyName || "-"}</TableCell>
                      </TableRow>
                    );
                  })}
                </TableBody>
              </Table>

              {renderSwipeSelectionControls()}
            </>
          )}
        </DialogContent>
        <Divider />
        <Box sx={{ p: 1, display: "flex", justifyContent: "flex-end", gap: 1 }}>
          <Button onClick={() => exportSelectedEmployeeSwipes()} disabled={!selectedSwipes || selectedSwipes.length === 0}>Export Swipes</Button>
          <Button onClick={() => setSwipeDialogOpen(false)}>Close</Button>
        </Box>
      </Dialog>
    </Box>
  );
}










// frontend/src/pages/GlobalPage.jsx
import React, { useState, useEffect, useRef } from 'react';
import {
  Box, Typography, CircularProgress, IconButton, Button, Paper, Divider,
  LinearProgress, Snackbar, Alert, List, ListItem, ListItemText, Tooltip
} from '@mui/material';
import HomeIcon from '@mui/icons-material/Home';
import DescriptionIcon from '@mui/icons-material/Description';
import UploadFileIcon from '@mui/icons-material/UploadFile';
import MapChart from '../components/MapChart.jsx';
import api from '../api';
import { useAuth } from '../context/AuthContext';
import { useNavigate, Link } from 'react-router-dom';

import TimerIcon from "@mui/icons-material/AccessTime"; // duration icon
import { Link as RouterLink } from "react-router-dom";
/*
  Important:
  - Do NOT mix /api/headcount and /api/ccure/verify.
  - Region cards (APAC/EMEA/LACA/NAMER) come only from /api/headcount.
  - Live vs CCURE Summary now comes from /api/ccure/verify?raw=true.
  - Initial region totals are zero (keeps previous UI behaviour).
  - We implement polling for headcount and SSE for ccure/stream (realtime via SSE).
*/

export default function GlobalPage() {
  const navigate = useNavigate();
  const auth = useAuth();


  // Region totals (headcount) - default to zeros so UI shows 0 immediately (preserve previous behaviour)
  const [counts, setCounts] = useState({ apac: 0, emea: 0, laca: 0, namer: 0 });
  const [selected, setSelected] = useState('global');

  // Averages/ccure state (left panel)
  const [averages, setAverages] = useState(null);
  const [loadingAverages, setLoadingAverages] = useState(true);
  const [averagesError, setAveragesError] = useState(null);

  // upload state
  const [uploading, setUploading] = useState(false);
  const [uploadResult, setUploadResult] = useState(null);
  const [uploadError, setUploadError] = useState(null);

  // (kept for backwards-compatibility but upload buttons are always shown now)
  const [uploadedEmployee, setUploadedEmployee] = useState(false);
  const [uploadedContractor, setUploadedContractor] = useState(false);

  const [exportReportPath, setExportReportPath] = useState(null);

  // top-row file inputs
  const fileInputEmpRef = useRef();
  const fileInputContrRef = useRef();
  const [snack, setSnack] = useState({ open: false, severity: 'info', message: '' });

  // date-range state for top-right controls
  const [startDate, setStartDate] = useState('');
  const [endDate, setEndDate] = useState('');

  // Polling refs for safe scheduling and backoff
  const headcountRef = useRef({ timerId: null, failureCount: 0, isFetching: false });
  const averagesRef = useRef({ timerId: null, failureCount: 0, isFetching: false });


  const [showCenterUploads, setShowCenterUploads] = useState(false);


  // -----------------------
  // HEADCOUNT POLLING ONLY (unchanged)
  // -----------------------
  useEffect(() => {
    let mounted = true;

    const fetchHeadcount = async () => {
      if (!mounted) return;
      if (headcountRef.current.isFetching) return;
      headcountRef.current.isFetching = true;

      try {
        const res = await api.get('/headcount');
        if (!mounted) return;
        const d = res.data;
        if (d && typeof d === 'object') {
          const newCounts = {
            apac: Number(d.apac || 0),
            emea: Number(d.emea || 0),
            laca: Number(d.laca || 0),
            namer: Number(d.namer || 0),
          };
          setCounts(prev => {
            if (
              prev.apac === newCounts.apac &&
              prev.emea === newCounts.emea &&
              prev.laca === newCounts.laca &&
              prev.namer === newCounts.namer
            ) {
              return prev;
            }
            return newCounts;
          });
        } else {
          console.warn('[headcount] unexpected response shape - ignoring', d);
        }
        headcountRef.current.failureCount = 0;
      } catch (err) {
        headcountRef.current.failureCount = (headcountRef.current.failureCount || 0) + 1;
        console.warn('[headcount] fetch failed:', err?.message || err);
      } finally {
        headcountRef.current.isFetching = false;
        const f = headcountRef.current.failureCount || 0;
        const backoffMs = 15000 * Math.pow(2, Math.min(Math.max(f - 1, 0), 4)); // 15s..240s
        headcountRef.current.timerId = setTimeout(fetchHeadcount, backoffMs);
      }
    };

    fetchHeadcount();

    return () => {
      mounted = false;
      if (headcountRef.current.timerId) clearTimeout(headcountRef.current.timerId);
      headcountRef.current.isFetching = false;
    };
  }, []); // run once

  // AVERAGES: use SSE (direct to Python backend) with fallback initial fetch
  useEffect(() => {
    let stopped = false;
    let es = null;
    let backoff = 100000;

    // Allow override via VITE_PY_BACKEND; otherwise assume python at :8000
    const PY_BACKEND = (import.meta.env.VITE_PY_BACKEND || `${window.location.protocol}//${window.location.hostname}:8000`).replace(/\/$/, '');

    const connect = () => {
      if (stopped) return;
      try {
        es = new EventSource(`${PY_BACKEND}/ccure/stream`);
      } catch (err) {
        console.warn('SSE creation failed', err);
        es = null;
      }

      if (!es) {
        initialFetch();
        return;
      }

      es.onopen = () => {
        console.info('[SSE] connected to', `${PY_BACKEND}/ccure/stream`);
        backoff = 1000;
        setAveragesError(null);
      };

      es.onmessage = (evt) => {
        try {
          const payload = JSON.parse(evt.data);
          setAverages(payload);
          setLoadingAverages(false);
          setAveragesError(null);
        } catch (e) {
          console.warn('Failed to parse SSE message', e);
        }
      };

      es.onerror = (err) => {
        console.warn('[SSE] error/closed, attempting reconnect', err);
        try { es.close(); } catch (e) { }
        es = null;
        if (stopped) return;
        setTimeout(() => {
          backoff = Math.min(backoff * 2, 30000);
          connect();
        }, backoff);
      };
    };

    const initialFetch = async () => {
      setLoadingAverages(true);
      setAveragesError(null);
      try {
        const res = await api.get('/ccure/verify?raw=true');
        setAverages(res.data);
        setLoadingAverages(false);
        setAveragesError(null);
      } catch (err) {
        console.warn('initial /ccure/verify?raw=true fetch failed', err);
        setLoadingAverages(false);
        setAveragesError(err);
      }
    };

    initialFetch();
    connect();

    return () => {
      stopped = true;
      if (es) {
        try { es.close(); } catch (e) { }
        es = null;
      }
    };
  }, []);

  // -----------------------
  // Upload helper (updated to use fetch, kept robust)
  // -----------------------
  const handleUpload = async (file, type) => {
    if (!file) return;
    const endpoint = type === 'employee' ? '/upload/active-employees' : '/upload/active-contractors';

    const PY_BACKEND = (import.meta.env.VITE_PY_BACKEND || `${window.location.protocol}//${window.location.hostname}:8000`).replace(/\/$/, '');
    const url = `${PY_BACKEND}${endpoint}`;

    const fd = new FormData();
    fd.append('file', file, file.name);

    setUploading(true);
    setUploadResult(null);
    setUploadError(null);

    try {
      console.info('Uploading to', url, file.name);
      const resp = await fetch(url, {
        method: 'POST',
        body: fd,
      });

      const rawText = await resp.text();
      let data = null;
      try { data = rawText ? JSON.parse(rawText) : null; } catch (e) { data = { raw: rawText }; }

      console.info('Upload response', resp.status, resp.statusText, data);

      if (!resp.ok) {
        throw new Error(`Upload failed HTTP ${resp.status} ${resp.statusText} - ${JSON.stringify(data)}`);
      }

      setUploadResult(data);
      setSnack({ open: true, severity: 'success', message: `Active Sheet Updated successfully: ${file.name}` });

      // mark canonical presence if backend returned detail.canonical_saved
      const saved = data && data.detail && (data.detail.canonical_saved || data.detail.canonical_saved === "");
      if (type === 'employee') setUploadedEmployee(!!saved);
      if (type === 'contractor') setUploadedContractor(!!saved);

      // best-effort refresh of averages/headcount
      try {
        const r1 = await fetch(`${PY_BACKEND}/ccure/verify?raw=true`);
        if (r1.ok) setAverages(await r1.json());
      } catch (e) { console.warn('refresh verify failed', e); }

      try {
        const r2 = await fetch(`${PY_BACKEND}/headcount`);
        if (r2.ok) {
          const d = await r2.json();
          if (d && typeof d === 'object') {
            setCounts({
              apac: Number(d.apac || 0),
              emea: Number(d.emea || 0),
              laca: Number(d.laca || 0),
              namer: Number(d.namer || 0)
            });
          }
        }
      } catch (e) { console.warn('refresh headcount failed', e); }

    } catch (err) {
      console.error('Upload failed', err);
      setUploadError(err);
      setSnack({ open: true, severity: 'error', message: `Upload failed: ${file.name} — ${err.message}` });
    } finally {
      setUploading(false);
    }
  };

  // --- Helpers: find CCURE arrays in 'averages' and generate CSV ---
  const _escapeCsv = (v) => {
    if (v === null || v === undefined) return '';
    if (typeof v === 'object') {
      try { v = JSON.stringify(v); } catch { v = String(v); }
    }
    const s = String(v).replace(/"/g, '""');
    return `"${s}"`;
  };

  // Find candidate arrays inside the averages object that look like CCURE comparison rows
  const findCcureArrays = (obj) => {
    const found = [];
    if (!obj || typeof obj !== 'object') return found;

    const inspect = (parentKey, val) => {
      if (!val) return;
      if (Array.isArray(val) && val.length > 0 && typeof val[0] === 'object') {
        const sample = val[0];
        // heuristic: many ccure rows have ccure_key or EmployeeID or EmpName fields
        if ('ccure_key' in sample || 'EmployeeID' in sample || 'EmpName' in sample) {
          found.push({ key: parentKey, arr: val });
        }
      } else if (typeof val === 'object') {
        for (const k of Object.keys(val)) {
          inspect(parentKey ? `${parentKey}.${k}` : k, val[k]);
        }
      }
    };

    inspect('', obj);
    return found;
  };

  // Build CSV rows with the requested columns:
  // Employees: ccure_key, EmployeeID, EmpName, PersonnelType, Manager_Name, Profile_Disabled, Employee_Status
  // Contractors: ccure_key, EmployeeID, EmpName, VendorCompany, PersonnelType, Manager_Name, Profile_Disabled, Employee_Status
  const generateCcureCompareCSV = (averagesPayload) => {
    if (!averagesPayload || typeof averagesPayload !== 'object') return null;

    const candidates = findCcureArrays(averagesPayload);
    if (!candidates || candidates.length === 0) return null;

    // choose the first plausible array
    const rows = candidates[0].arr;

    if (!Array.isArray(rows) || rows.length === 0) return null;

    const headers = ['ccure_key', 'EmployeeID', 'EmpName', 'VendorCompany', 'PersonnelType', 'Manager_Name', 'Profile_Disabled', 'Employee_Status'];
    const lines = [headers.map(h => _escapeCsv(h)).join(',')];

    const readField = (r, name) => {
      if (!r) return '';
      if (r[name] !== undefined && r[name] !== null) return r[name];
      if (r.raw && typeof r.raw === 'object' && r.raw[name] !== undefined && r.raw[name] !== null) return r.raw[name];
      // some backends put nested object as string in "raw"
      if (typeof r.raw === 'string') {
        try {
          const parsed = JSON.parse(r.raw);
          if (parsed && parsed[name] !== undefined) return parsed[name];
        } catch { }
      }
      return '';
    };

    for (const r of rows) {
      // derive PersonnelType (sometimes present in row or row.raw)
      const personnelType = readField(r, 'PersonnelType') || readField(r, 'Personnel_Type') || readField(r, 'PersonnelTypeName') || '';

      const ccure_key = readField(r, 'ccure_key') || readField(r, 'CcureKey') || readField(r, 'EmployeeID') || '';
      const employeeId = readField(r, 'EmployeeID') || readField(r, 'Employee_Id') || '';
      const empName = readField(r, 'EmpName') || readField(r, 'EmployeeName') || readField(r, 'Name') || '';
      const vendorCompany = readField(r, 'VendorCompany') || readField(r, 'Vendor_Company') || '';
      const managerName = readField(r, 'Manager_Name') || readField(r, 'ManagerName') || '';
      let profileDisabled = readField(r, 'Profile_Disabled');
      if (profileDisabled === true || profileDisabled === false) profileDisabled = String(profileDisabled);
      const employeeStatus = readField(r, 'Employee_Status') || readField(r, 'Status') || '';

      const rowValues = [
        ccure_key,
        employeeId,
        empName,
        vendorCompany,
        personnelType,
        managerName,
        profileDisabled,
        employeeStatus,
      ];

      lines.push(rowValues.map(v => _escapeCsv(v)).join(','));
    }

    const csvContent = lines.join('\n');
    return csvContent;
  };

  // Export: request server to generate compare report and download the xlsx (binary)
  const exportUploadedSheets = async () => {
    setUploading(true);
    try {
      const PY_BACKEND = (import.meta.env.VITE_PY_BACKEND || `${window.location.protocol}//${window.location.hostname}:8000`).replace(/\/$/, '');

      // attempt server-side generation as before
      let genJson = null;
      try {
        const genRes = await fetch(`${PY_BACKEND}/ccure/compare?export=true`, {
          method: 'GET',
        });

        try {
          genJson = await genRes.json();
        } catch (e) {
          const txt = await genRes.text().catch(() => '');
          throw new Error(`Export generation returned non-JSON response: ${txt}`);
        }

        if (!genRes.ok || !genJson || !genJson.report_path) {
          const msg = (genJson && (genJson.detail || genJson.error)) || JSON.stringify(genJson || {});
          console.warn('Server export generation failed or returned unexpected payload:', msg);
          setSnack({ open: true, severity: 'warning', message: 'Server export generation failed; attempting client CSV export' });
        } else {
          // server returned a report_path — attempt to download it
          const reportPath = genJson.report_path;
          setExportReportPath(reportPath);
          setSnack({ open: true, severity: 'success', message: 'Export created — downloading now' });

          try {
            const dlUrl = `${PY_BACKEND}/ccure/report/${encodeURIComponent(reportPath)}`;
            const fileRes = await fetch(dlUrl, { method: 'GET' });

            if (!fileRes.ok) {
              const txt = await fileRes.text().catch(() => '');
              console.warn('Failed to download server report:', txt);
            } else {
              const blob = await fileRes.blob();
              const blobUrl = window.URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = blobUrl;
              a.download = reportPath || 'missing_vs_ccure.xlsx';
              document.body.appendChild(a);
              a.click();
              a.remove();
              window.URL.revokeObjectURL(blobUrl);
            }
          } catch (e) {
            console.warn('Server report download failed:', e);
          }
        }
      } catch (err) {
        // log and fall through to client-side CSV
        console.warn('exportUploadedSheets server call failed:', err);
      }

      // --- Client-side CSV fallback / supplemental export with requested columns ---
      try {
        const csv = generateCcureCompareCSV(averages || {});
        if (csv) {
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          // prefer a descriptive filename
          const fname = `missing_vs_ccure_custom_${(new Date()).toISOString().slice(0, 10)}.csv`;
          a.download = fname;
          document.body.appendChild(a);
          a.click();
          a.remove();
          window.URL.revokeObjectURL(url);
          setSnack({ open: true, severity: 'success', message: 'Custom CCURE CSV downloaded' });
        } else {
          // nothing to export client-side
          setSnack(prev => ({ ...prev, open: true, severity: 'info', message: 'No CCURE rows found in current averages payload for CSV export' }));
        }
      } catch (e) {
        console.error('Client CSV generation failed', e);
        setSnack(prev => ({ ...prev, open: true, severity: 'error', message: `CSV generation failed: ${e?.message || e}` }));
      }

    } catch (err) {
      console.error('exportUploadedSheets error', err);
      setSnack({ open: true, severity: 'error', message: `Export failed: ${err.message || err}` });
    } finally {
      setUploading(false);
    }
  };

  const onChooseEmployeeFile = (e) => { const f = e.target.files && e.target.files[0]; if (f) handleUpload(f, 'employee'); e.target.value = null; };
  const onChooseContractorFile = (e) => { const f = e.target.files && e.target.files[0]; if (f) handleUpload(f, 'contractor'); e.target.value = null; };

  // apply date range to re-fetch /ccure/verify
  const applyDateRange = async () => {
    if (!startDate || !endDate) {
      setSnack({ open: true, severity: 'warning', message: 'Please select start and end dates' });
      return;
    }
    setLoadingAverages(true);
    setAveragesError(null);
    try {
      const res = await api.get(`/ccure/verify?raw=true&start_date=${startDate}&end_date=${endDate}`);
      setAverages(res.data);
      setLoadingAverages(false);
      setSnack({ open: true, severity: 'success', message: 'Averages updated' });
    } catch (err) {
      console.warn('applyDateRange failed', err);
      setLoadingAverages(false);
      setAveragesError(err);
      setSnack({ open: true, severity: 'error', message: 'Failed to update averages' });
    }
  };

  // safe helper for nested averages paths
  const safe = (path, fallback = null) => {
    if (!averages) return fallback;
    try {
      return path.split('.').reduce((a, k) => (a && a[k] !== undefined ? a[k] : fallback), averages);
    } catch {
      return fallback;
    }
  };

  // Derived values (unchanged)
  const ccureActiveEmployees = safe('ccure_reported.employees',
    safe('ccure_active.active_employees',
      safe('ccure_active.ccure_active_employees_reported', null)
    )
  );
  const ccureActiveContractors = safe('ccure_reported.contractors',
    safe('ccure_active.active_contractors',
      safe('ccure_active.ccure_active_contractors_reported', null)
    )
  );

  const headTotalVisited = safe('headcount_attendance_summary.total_visited_today',
    safe('headcount_details.total_visited_today', null)
  );
  const headEmployee = safe('headcount_attendance_summary.employee',
    safe('headcount_details.employee', null)
  );
  const headContractor = safe('headcount_attendance_summary.contractor',
    safe('headcount_details.contractor', null)
  );

  const liveCurrentTotal = safe('live_headcount_region_clients.currently_present_total',
    safe('live_headcount_details.currently_present_total',
      null
    )
  );
  const liveEmp = safe('live_headcount_region_clients.employee',
    safe('live_headcount_details.employee', null)
  );
  const liveContr = safe('live_headcount_region_clients.contractor',
    safe('live_headcount_details.contractor', null)
  );

  const empPct = safe('percentages_vs_ccure.head_employee_pct_vs_ccure_today',
    safe('averages.head_emp_pct_vs_ccure_today', null)
  );
  const conPct = safe('percentages_vs_ccure.head_contractor_pct_vs_ccure_today',
    safe('averages.head_contractor_pct_vs_ccure_today', null)
  );
  const overallPct = safe('percentages_vs_ccure.head_overall_pct_vs_ccure_today',
    safe('averages.headcount_overall_pct_vs_ccure_today', null)
  );

  const avg7 = safe('averages.history_avg_overall_last_7_days',
    safe('averages.avg_headcount_last_7_days',
      safe('averages.avg_headcount_last_7_days_db', null)
    )
  );

  const respDate = safe('date', null);

  const locationAvgsObj = safe('averages.history_avg_by_location_last_7_days',
    safe('history_avg_by_location_last_7_days',
      safe('raw.averages.history_avg_by_location_last_7_days', {})
    )
  );

  const locationAvgsList = React.useMemo(() => {
    if (!locationAvgsObj || typeof locationAvgsObj !== 'object') return [];
    const arr = Object.entries(locationAvgsObj).map(([loc, vals]) => {
      return {
        location: loc,
        avg_employee_last_7_days: vals.avg_employee_last_7_days ?? vals.history_avg_employee_last_7_days ?? vals.avg_employee ?? null,
        avg_contractor_last_7_days: vals.avg_contractor_last_7_days ?? vals.history_avg_contractor_last_7_days ?? vals.avg_contractor ?? null,
        avg_overall_last_7_days: vals.avg_overall_last_7_days ?? vals.history_avg_overall_last_7_days ?? vals.avg_overall ?? null,
        history_days_counted: vals.history_days_counted ?? null
      };
    });
    arr.sort((a, b) => (b.avg_overall_last_7_days ?? -Infinity) - (a.avg_overall_last_7_days ?? -Infinity));
    return arr;
  }, [locationAvgsObj]);

  const globalCount = Number((counts.apac || 0)) + Number((counts.emea || 0)) + Number((counts.laca || 0)) + Number((counts.namer || 0));

  const hideScrollbarSx = {
    overflowY: 'auto',
    '&::-webkit-scrollbar': { width: 0, height: 0 },
    scrollbarWidth: 'none',
    msOverflowStyle: 'none',
  };

  // ---- New: derive user name parts for right-side header display
  const userFullName = auth?.user ? (auth.user.EmployeeName || auth.user.username || '') : '';
  const nameParts = (userFullName || '').toString().split(/\s+/).filter(Boolean);
  const firstName = nameParts[0] || '';
  const restName = nameParts.slice(1).join(' ') || '';

  // Render
  
 // Render
  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', overflow: 'hidden', bgcolor: 'background.default' }}>
      {/* Header */}
      <Box px={2} py={1} sx={{ backgroundColor: 'black', color: '#fff', borderBottom: '4px solid #FFD700', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
        <Box>
          <IconButton component={Link} to="/" sx={{ color: '#FFC72C' }}><HomeIcon fontSize="medium" /></IconButton>

          {/* Reports - requires 'gsoc_reports' */}
          {auth?.hasPermission('gsoc_reports') && (
            <IconButton component={Link} to="/reports" sx={{ color: '#FFC72C', ml: 1 }}>
              <DescriptionIcon fontSize="medium" />
            </IconButton>
          )}

          {/* Device camera link (protected by device_health) */}
          {auth?.hasPermission('device_health') && (
            <IconButton
              component="a"
              href="http://10.138.161.4:3000/dashboard/index.html"
              rel="noopener noreferrer"
              sx={{ color: '#FFC72C', ml: 1 }}
            >
              <i className="fa-solid fa-camera" style={{ fontSize: 20 }} />
            </IconButton>
          )}

          {/* Associate Verification Tool link */}
          {auth?.hasPermission('associate_verify') && (
            <IconButton
              component="a"
              href="http://10.199.22.57:3004/"
              rel="noopener noreferrer"
              sx={{ color: '#FFF', ml: 1 }}
            >
              <i className="bi bi-patch-check"></i>
            </IconButton>
          )}

{auth?.hasPermission('global_duration') && (
  <Tooltip title="Duration Reports">
    <IconButton
      component={RouterLink}
      to="/duration"
      size="large"
      aria-label="Duration Reports"
      sx={{ color: '#FFF', ml: 1 }}
    >
      <TimerIcon />
    </IconButton>
  </Tooltip>
)}

        </Box>

        <Box sx={{ flexGrow: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
          <Box component="img" src="/wu-head-logo.png" alt="WU Logo" sx={{ height: { xs: 30, md: 55 }, mr: 2 }} />
          <Typography variant="h5" sx={{ fontWeight: 'bold', color: 'primary.main' }}>Global Headcount Dashboard</Typography>
        </Box>

        {/* --- RIGHT SIDE: moved Login/User / Logout / Access Manager into header (replaces previous separate block) --- */}
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          {auth?.user ? (
            <>
              {/* Display like "Sonu , Pandey" (first name, comma, rest-of-name) */}
              <Typography variant="body2" sx={{ color: '#fff', fontWeight: 700 }}>
                {firstName}{restName ? ',' : ''} {restName}
              </Typography>

              <Button
                size="small"
                variant="outlined"
                onClick={() => { auth.logout(); window.location.href = '/login'; }}
                sx={{ color: '#fff', borderColor: 'rgba(255,255,255,0.12)', textTransform: 'none' }}
              >
                Logout
              </Button>

              {auth.canGrant && (
                <Button size="small" variant="contained" onClick={() => navigate('/access-manager')} sx={{ ml: 1, textTransform: 'none', fontWeight: 700 }}>
                  Access Manager
                </Button>
              )}
            </>
          ) : (
            <Button size="small" variant="contained" onClick={() => navigate('/login')}>Login</Button>
          )}
        </Box>
      </Box>

      {/* Top row: Uploads | GLOBAL + Region Cards | Date selectors */}
      <Box sx={{ display: 'flex', alignItems: 'center', p: 1, px: 1, gap: 1 }}>
        {/* Left: fixed column with stacked upload/export buttons (aligned left) */}
        <Box sx={{ width: 260, display: 'flex', flexDirection: 'column', gap: 1 }}>
          <input type="file" accept=".xls,.xlsx,.csv" style={{ display: 'none' }} ref={fileInputEmpRef} onChange={onChooseEmployeeFile} />
          {auth?.hasPermission('upload_active_employees') && (
            <Button
              variant="contained"
              size="small"
              startIcon={<UploadFileIcon />}
              onClick={() => fileInputEmpRef.current && fileInputEmpRef.current.click()}
              sx={{ width: '100%', height: 25, textTransform: 'none', fontWeight: 700 }}
            >
              Upload Active Employee Sheet
            </Button>
          )}

          <input type="file" accept=".xls,.xlsx,.csv" style={{ display: 'none' }} ref={fileInputContrRef} onChange={onChooseContractorFile} />
          {auth?.hasPermission('upload_active_contractors') && (
            <Button
              variant="contained"
              size="small"
              startIcon={<UploadFileIcon />}
              onClick={() => fileInputContrRef.current && fileInputContrRef.current.click()}
              sx={{ width: '100%', height: 25, textTransform: 'none', fontWeight: 700 }}
            >
              Upload Active Contractor Sheet
            </Button>
          )}

          {auth?.hasPermission('export_compare') && (
            <Button
              variant="contained"
              size="small"
              startIcon={<DescriptionIcon />}
              onClick={exportUploadedSheets}
              sx={{ width: '100%', height: 25, textTransform: 'none', fontWeight: 700 }}
            >
              Export Comparison → Report
            </Button>
          )}
        </Box>

        {/* Center: flexible, keeps region cards exactly centered on screen */}
        <Box sx={{ flex: 1, display: 'flex', justifyContent: 'center' }}>
          <Box sx={{ display: 'flex', gap: 3, alignItems: 'center', justifyContent: 'center', flexWrap: 'wrap' }}>
            {[
              { key: 'global', label: 'GLOBAL', count: globalCount, url: null },
              { key: 'apac', label: 'APAC', count: counts.apac, url: 'http://10.199.22.57:3000/' },
              { key: 'emea', label: 'EMEA', count: counts.emea, url: 'http://10.199.22.57:3001/' },
              { key: 'laca', label: 'LACA', count: counts.laca, url: 'http://10.199.22.57:3003/' },
              { key: 'namer', label: 'NAMER', count: counts.namer, url: 'http://10.199.22.57:3002/' },
            ].map(region => (
              <Box
                key={region.key}
                onClick={() => {
                  if (region.key === 'global') {
                    const el = document.querySelector('[data-global-left-panel]');
                    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    setSelected('global');
                    return;
                  }
                  // require permission: headcount.<region> OR headcount OR global_access
                  const permCandidates = [`headcount.${region.key}`, 'headcount', 'global_access'];
                  if (!auth.hasPermission(permCandidates)) {
                    // simple UX: alert (could be replaced by nicer toast)
                    setSnack({ open: true, severity: 'warning', message: `Access denied to ${region.label} headcount` });
                    return;
                  }
                  if (region.url) window.location.href = region.url;
                }}
                sx={{
                  cursor: 'pointer',
                  width: 200,
                  height: 88,
                  display: 'flex',
                  flexDirection: 'column',
                  justifyContent: 'center',
                  alignItems: 'center',
                  border: '4px solid rgba(255, 204, 0, 0.89)',
                  borderRadius: 2,
                  boxShadow: 3,
                  bgcolor: 'transparent',
                  '&:hover': { opacity: 0.95 },
                }}
              >
                <Typography variant="subtitle2" sx={{ fontWeight: 'bold', color: '#FFC72C', fontSize: { xs: '0.95rem', md: '1.2rem' } }}>
                  {region.label}
                </Typography>
                <Typography variant="h4" sx={{ fontWeight: 900, fontSize: { xs: '1.2rem', md: '1.6rem' }, color: '#FFFFFF' }}>
                  {region.count ?? 0}
                </Typography>
              </Box>
            ))}
          </Box>
        </Box>

        {/* Right: fixed column for date selectors (aligned right) */}
        <Box sx={{ width: 360, display: 'flex', flexDirection: 'column', gap: 1, alignItems: 'flex-end' }}>
          <Paper sx={{ p: 1, display: 'flex', gap: 1, alignItems: 'center', boxShadow: 1, width: '100%' }}>
            <Box sx={{ display: 'flex', flexDirection: 'column', width: 160 }}>
              <Typography variant="caption" color="text.secondary">Select Start date</Typography>
              <input
                type="date"
                value={startDate}
                onChange={(e) => setStartDate(e.target.value)}
                style={{ width: '100%', height: 34, borderRadius: 4, border: '1px solid rgba(255,255,255,0.06)', padding: 4, background: '#FFCC00', color: 'Black' }}
              />
            </Box>

            <Box sx={{ display: 'flex', flexDirection: 'column', width: 160 }}>
              <Typography variant="caption" color="text.secondary">Select End date</Typography>
              <input
                type="date"
                value={endDate}
                onChange={(e) => setEndDate(e.target.value)}
                style={{ width: '100%', height: 34, borderRadius: 4, border: '1px solid rgba(255,255,255,0.06)', padding: 4, background: '#FFCC00', color: 'Black' }}
              />
            </Box>
          </Paper>

          <Box sx={{ width: '100%', display: 'flex', justifyContent: 'flex-start' }}>
            <Button size="small" variant="contained" onClick={applyDateRange} sx={{ height: 36, textTransform: 'none', fontWeight: 700 }}>
              Apply
            </Button>
          </Box>
        </Box>
      </Box>


      {/* Main: left summary | center map | right averages */}
      <Box sx={{ display: 'flex', flex: 1, overflow: 'hidden' }}>
        {/* Left detail panel */}
        <Box
          data-global-left-panel
          sx={{
            width: { xs: 320, md: 360 },
            minWidth: { md: 320 },
            p: 2,
            bgcolor: 'background.paper',
            borderRight: '1px solid rgba(255,255,255,0.06)',
            display: 'flex',
            flexDirection: 'column',
            ...hideScrollbarSx,
            height: '100%',
          }}
        >
          <Typography variant="h6" sx={{ mb: 1, color: 'primary.main' }}>Live vs CCURE Summary</Typography>

          {loadingAverages ? (
            <Box sx={{ py: 2 }}><LinearProgress /></Box>
          ) : averagesError ? (
            <Alert severity="error">Failed to load CCURE averages</Alert>
          ) : averages ? (
            <>
              <Paper sx={{ p: 2, mb: 2, bgcolor: 'rgba(255,255,255,0.02)' }} elevation={0}>
                <Typography variant="subtitle2" color="text.secondary">CCURE Active (reported)</Typography>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 1, alignItems: 'center' }}>
                  <Box>
                    <Typography variant="h4" sx={{ fontWeight: 800 }}>{ccureActiveEmployees ?? '—'}</Typography>
                    <Typography variant="caption" color="text.secondary">Active Employees</Typography>
                  </Box>
                  <Box sx={{ textAlign: 'right' }}>
                    <Typography variant="h5" sx={{ fontWeight: 800 }}>{ccureActiveContractors ?? '—'}</Typography>
                    <Typography variant="caption" color="text.secondary">Active Contractors</Typography>
                  </Box>
                </Box>
              </Paper>

              <Paper sx={{ p: 2, mb: 2, bgcolor: 'rgba(255,255,255,0.02)' }} elevation={0}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                  <Typography variant="subtitle2" color="text.secondary">Live Today</Typography>
                  <Typography variant="caption" color="text.secondary">{respDate ?? ''}</Typography>
                </Box>

                <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 1 }}>
                  <Box>
                    <Typography variant="h5" sx={{ fontWeight: 800 }}>{headEmployee ?? liveEmp ?? '—'}</Typography>
                    <Typography variant="caption" color="text.secondary">Employee</Typography>
                  </Box>
                  <Box>
                    <Typography variant="h5" sx={{ fontWeight: 800 }}>{headContractor ?? liveContr ?? '—'}</Typography>
                    <Typography variant="caption" color="text.secondary">Contractor</Typography>
                  </Box>
                </Box>

                <Divider sx={{ my: 1 }} />

                <Box>
                  <Typography variant="caption" color="text.secondary">Totals</Typography>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.75 }}>
                    <Typography variant="body2">Attendance total (today)</Typography>
                    <Typography variant="body2" sx={{ fontWeight: 700 }}>{headTotalVisited ?? '—'}</Typography>
                  </Box>

                  <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
                    <Typography variant="body2">Live region total</Typography>
                    <Typography variant="body2" sx={{ fontWeight: 700 }}>{liveCurrentTotal ?? '—'}</Typography>
                  </Box>

                  {safe('headcount_details.total_visited_today', null) != null && (
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
                      <Typography variant="body2">Detail rows total</Typography>
                      <Typography variant="body2" sx={{ fontWeight: 700 }}>{safe('headcount_details.total_visited_today', '—')}</Typography>
                    </Box>
                  )}
                </Box>
              </Paper>

              <Paper sx={{ p: 2, mb: 2, bgcolor: 'rgba(255,255,255,0.02)' }} elevation={0}>
                <Typography variant="subtitle2" color="text.secondary">Percentages vs CCURE</Typography>

                <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 1 }}>
                  <Typography variant="body2">Employees</Typography>
                  <Typography variant="body2" sx={{ fontWeight: 700 }}>{empPct != null ? `${empPct}%` : '—'}</Typography>
                </Box>
                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                  <Typography variant="body2">Contractors</Typography>
                  <Typography variant="body2" sx={{ fontWeight: 700 }}>{conPct != null ? `${conPct}%` : '—'}</Typography>
                </Box>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
                  <Typography variant="body2">Overall</Typography>
                  <Typography variant="body2" sx={{ fontWeight: 700 }}>{overallPct != null ? `${overallPct}%` : '—'}</Typography>
                </Box>

                <Divider sx={{ my: 1 }} />
                <Typography variant="caption" color="text.secondary">Averages</Typography>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 1 }}>
                  <Typography variant="body2">7-day avg headcount</Typography>
                  <Typography variant="body2" sx={{ fontWeight: 700 }}>{avg7 ?? '—'}</Typography>
                </Box>
              </Paper>

              {averages.notes && (
                <Paper sx={{ p: 2, mb: 2, bgcolor: 'rgba(255,255,255,0.01)' }}>
                  <Typography variant="body2" sx={{ mt: 1 }}>{averages.notes}</Typography>
                </Paper>
              )}
            </>
          ) : (
            <Typography variant="body2" color="text.secondary">No data</Typography>
          )}
        </Box>

        {/* Center: map (flex) */}
        <Box sx={{ flex: 1, minWidth: 0, position: 'relative', display: 'flex', flexDirection: 'column' }}>
          <Box sx={{ flex: 1, minHeight: 0 }}>
            <MapChart selected={selected} onClickSite={r => setSelected(r)} initialZoom={1.8} />
          </Box>
        </Box>

        {/* Right side: Location averages panel */}
        <Box
          sx={{
            width: { xs: 320, md: 360 },
            minWidth: { md: 320 },
            borderLeft: '1px solid rgba(255,255,255,0.06)',
            bgcolor: 'background.paper',
            p: 2,
            display: 'flex',
            flexDirection: 'column',
            ...hideScrollbarSx,
            height: '100%',
          }}
        >
          <Typography variant="h6" sx={{ mb: 1, color: 'primary.main' }}>Location Averages</Typography>

          {loadingAverages ? (
            <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', py: 4 }}>
              <CircularProgress />
            </Box>
          ) : averagesError ? (
            <Alert severity="error">Failed to load location averages</Alert>
          ) : locationAvgsList.length === 0 ? (
            <Typography variant="body2" color="text.secondary">No location averages available</Typography>
          ) : (
            <List dense disablePadding sx={{ flex: 1 }}>
              {locationAvgsList.map(item => (
                <ListItem key={item.location} sx={{ alignItems: 'flex-start', py: 1.25, borderBottom: '1px solid rgba(255,255,255,0.03)' }}>
                  <ListItemText
                    primary={
                      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <Typography sx={{ fontWeight: 800 }}>{item.location}</Typography>
                        <Typography variant="body2" sx={{ fontWeight: 800 }}>
                          {item.avg_overall_last_7_days != null ? Math.round(item.avg_overall_last_7_days) : '—'}
                        </Typography>
                      </Box>
                    }
                    secondary={
                      <Box sx={{ display: 'flex', gap: 2, mt: 0.5, flexWrap: 'wrap' }}>
                        <Typography variant="caption" color="text.secondary">Emp: <strong>{item.avg_employee_last_7_days != null ? Math.round(item.avg_employee_last_7_days) : '—'}</strong></Typography>
                        <Typography variant="caption" color="text.secondary">Contr: <strong>{item.avg_contractor_last_7_days != null ? Math.round(item.avg_contractor_last_7_days) : '—'}</strong></Typography>
                        {item.history_days_counted != null && <Typography variant="caption" color="text.secondary">Days: {item.history_days_counted}</Typography>}
                      </Box>
                    }
                    primaryTypographyProps={{ component: 'div' }}
                    secondaryTypographyProps={{ component: 'div' }}
                  />
                </ListItem>
              ))}
            </List>
          )}
        </Box>
      </Box>

      <Snackbar open={snack.open} autoHideDuration={3500} onClose={() => setSnack(prev => ({ ...prev, open: false }))}>
        <Alert severity={snack.severity} onClose={() => setSnack(prev => ({ ...prev, open: false }))}>{snack.message}</Alert>
      </Snackbar>
       
    </Box>
  );
}









// frontend/src/pages/LoginPage.jsx
import React, { useState } from 'react';
import { Box, Paper, TextField, Button, Typography, Alert } from '@mui/material';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

export default function LoginPage() {
  const auth = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [busy, setBusy] = useState(false);
  const [error, setError] = useState('');

  const from = (location.state && location.state.from) || '/';

  const handleSubmit = async (e) => {
    e?.preventDefault();
    setBusy(true);
    setError('');
    const res = await auth.login(username.trim(), password);
    setBusy(false);
    if (res.ok) {
      navigate(from, { replace: true });
    } else {
      setError(res.error || 'Invalid credentials');
    }
  };

  return (
    <Box sx={{
      minHeight: '100vh',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      background: 'linear-gradient(180deg,#0b0b0b,#111)'
    }}>
      <Paper sx={{ width: 420, p: 4, borderRadius: 2, boxShadow: 6 }}>
        <Typography variant="h6" sx={{ mb: 2, fontWeight: 800 }}>Login — Global Page</Typography>
        {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
        <form onSubmit={handleSubmit}>
          <TextField fullWidth label="Username (Employee name or ID)" value={username} onChange={e => setUsername(e.target.value)} sx={{ mb: 2 }} />
          <TextField fullWidth label="Password" type="password" value={password} onChange={e => setPassword(e.target.value)} sx={{ mb: 2 }} />
          <Box sx={{ display: 'flex', gap: 1, justifyContent: 'space-between', alignItems: 'center' }}>
            <Button variant="contained" type="submit" disabled={busy}>{busy ? 'Signing in...' : 'Sign in'}</Button>
            <Button variant="outlined" onClick={() => { setUsername(''); setPassword(''); }}>Clear</Button>
          </Box>
        </form>

        <Typography variant="caption" sx={{ display: 'block', mt: 2, color: 'text.secondary' }}>
          Tip: use backend-registered employee credentials. Admins with grant permissions will see an Access Manager link.
        </Typography>
      </Paper>
    </Box>
  );
}













// // src/pages/ReportsPage.jsx
// import React, { useState } from 'react';
// import {
//   Box, FormControl, InputLabel, Select, OutlinedInput,
//   Checkbox, ListItemText, MenuItem, Button,
//   CircularProgress, Typography, TextField, Tabs, Tab, Grid, Paper, Drawer, IconButton, Divider, List, ListItem, ListItemIcon, Avatar, Collapse
// } from '@mui/material';

// import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
// import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
// import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
// import axios from 'axios';
// import ExcelJS from 'exceljs';
// import * as XLSX from 'xlsx';
// import { useAuth } from '../context/AuthContext';



// import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
// import PlaceIcon from '@mui/icons-material/Place';
// import PeopleIcon from '@mui/icons-material/People';
// import DownloadIcon from '@mui/icons-material/CloudDownload';
// import FilterListIcon from '@mui/icons-material/FilterList';
// // Static lists
// const EMPLOYEE_OPTIONS = [
//   'Vainilaitis, Valdas',
//   'Tomasevic, Kazimez',
//   'Sesickis, Janas',
//   'Valiunas, Sigitas',
//   'JANCUKOVIC, VACLAVA',
//   'Kalpokiene, Alina',
//   'Korkus, Vanda',
//   'Kvaraciejiene, Maryte',
//   'ZNAMEROVSKIS, DARIUS'

// ];


// const REGION_OPTIONS = ['global', 'apac', 'emea', 'laca', 'namer'];
// const LOCATION_MAP = {
//   apac: ['APAC.Default', 'JP.Tokyo', 'PH.Manila', 'MY.Kuala Lumpur'],
//   emea: ['AUT.Vienna', 'DU.Abu Dhab', 'IE.Dublin', 'IT.Rome', 'LT.Vilnius', 'MA.Casablanca', 'RU.Moscow', 'UK.London', 'ES.Madrid'],
//   laca: ['AR.Cordoba', 'CR.Costa Rica Partition', 'MX.Mexico City', 'PE.Lima', 'BR.Sao Paulo', 'PA.Panama City'],
//   namer: ['US.NYC', 'US.FL.Miami', 'USA/Canada Default', 'US.CO.OBS'],
//   global: [] // optional — location select will be disabled when global is chosen
// };



// function formatDisplayDate(date) {
//   const d = new Date(date);
//   const day = d.getDate();
//   const suf = day % 10 === 1 && day !== 11 ? 'st'
//     : day % 10 === 2 && day !== 12 ? 'nd'
//       : day % 10 === 3 && day !== 13 ? 'rd' : 'th';
//   const mon = d.toLocaleString('default', { month: 'long' });
//   return `${day}${suf} ${mon} ${d.getFullYear()}`;
// }



// // helpers: format server-provided ISO as display strings (use UTC getters so Z times are treated as server wall-clock)
// const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
// const pad2 = n => String(n).padStart(2, '0');

// function formatDateFromServerISO(iso) {
//   if (!iso) return '';
//   const dt = new Date(iso);
//   const y = dt.getUTCFullYear();
//   const m = dt.getUTCMonth(); // 0..11
//   const d = dt.getUTCDate();
//   const yrShort = String(y).slice(-2);
//   return `${pad2(d)}-${MONTH_ABBR[m]}-${yrShort}`;         // e.g. "12-Aug-25"
// }

// function formatTimeFromServerISO(iso) {
//   if (!iso) return '';
//   const dt = new Date(iso);
//   let hh = dt.getUTCHours();   // use UTC parts so we trust server wall-clock
//   const mm = dt.getUTCMinutes();
//   const ss = dt.getUTCSeconds();
//   const ampm = hh >= 12 ? 'PM' : 'AM';
//   const hh12 = ((hh + 11) % 12) + 1; // convert 0->12, 13->1 etc.
//   return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;        // e.g. "12:01:24 AM"
// }

// // for DateOnly + Swipe_Time situation: build ISO string where date comes from DateOnly and time from Swipe_Time UTC
// function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
//   // dateOnlyIso = "2025-08-12T00:00:00.000Z"
//   // swipeIso = "1970-01-01T00:01:24.000Z" (time)
//   if (!dateOnlyIso) return '';
//   const datePart = dateOnlyIso.toString().slice(0,10); // "YYYY-MM-DD"
//   if (!swipeIso) {
//     return `${datePart}T00:00:00.000Z`;
//   }
//   const t = new Date(swipeIso);
//   if (!isNaN(t.getTime())) {
//     const hh = pad2(t.getUTCHours());
//     const mm = pad2(t.getUTCMinutes());
//     const ss = pad2(t.getUTCSeconds());
//     return `${datePart}T${hh}:${mm}:${ss}.000Z`;
//   }
//   // fallback if swipeIso is "HH:mm:ss"
//   const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
//   const hh = parts[0] || '00';
//   const mm = parts[1] || '00';
//   const ss = parts[2] || '00';
//   return `${datePart}T${hh}:${mm}:${ss}.000Z`;
// }




// function formatShortRange(fromDate, toDate) {
//   if (!fromDate || !toDate) return '';
//   const f = formatDisplayDate(fromDate); // e.g. "1st August 2025"
//   const t = formatDisplayDate(toDate);   // e.g. "13th August 2025"
//   const [fDay, fMon, fYear] = f.split(' ');
//   const [tDay, tMon, tYear] = t.split(' ');

//   if (fMon === tMon && fYear === tYear) {
//     return `${fDay} to ${tDay} ${fMon}`; // "1st to 13th August"
//   }
//   // different month or year -> show both months
//   return `${fDay} ${fMon} to ${tDay} ${tMon}`;
// }

// // --- helper: build raw report filename per your rules ---

// function buildRawFileName({ region, location, rawSearch, from, to }) {
//   const shortRange = formatShortRange(from, to);
//   const regionPart = (region || '').toUpperCase();
//   const locPart = location ? `-${location.split('.').pop()}` : '';
//   const prefix = rawSearch && rawSearch.toString().trim() ? `${rawSearch.toString().trim()} ` : '';
//   // Keep "Raw report" text exactly as requested
//   const base = `${regionPart}${locPart} Raw report ${shortRange}`;
//   // sanitize for filesystem (remove problematic chars)
//   const safeBase = base.replace(/[\/\\:\*\?"<>\|]+/g, '').replace(/\s+/g, ' ').trim();
//   return `${prefix}${safeBase}.xlsx`;
// }



// export default function ReportsPage() {
//    const auth = useAuth();

//   // --- state ---
//     const [tab, setTab] = useState(0);


//   const [region, setRegion] = useState('emea');
//   const [location, setLocation] = useState('');
//   const [from, setFrom] = useState(null);
//   const [to, setTo] = useState(null);
//   const [showFromCal, setShowFromCal] = useState(false);
//   const [showToCal, setShowToCal] = useState(false);
//   const [selectedEmps, setSelectedEmps] = useState([]);
//   const [loading, setLoading] = useState(false);


//     // helper — convert "YYYY-MM-DD..." (ISO) into a local midnight Date (avoids UTC shift)
//   const isoDateOnlyToLocalDate = (iso) => {
//     if (!iso) return null;
//     const s = iso.toString().slice(0, 10);
//     const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
//     return new Date(y, m - 1, d);
//   };


// // Build a Date that preserves the server-provided wall-clock values.
// // If swipeTime is an ISO (with Z), read UTC components and use them as local values.
// const buildLocalDateFromDateOnlyAndSwipe = (dateOnly, swipeTime) => {
//   if (!dateOnly) return null;

//   // parse YYYY-MM-DD (first 10 chars)
//   const dateStr = dateOnly.toString().slice(0, 10);
//   const [yy, mm, dd] = dateStr.split('-').map(n => parseInt(n, 10));

//   let hh = 0, min = 0, ss = 0;
//   if (swipeTime) {
//     const parsed = new Date(swipeTime);
//     if (!isNaN(parsed.getTime())) {
//       // Use UTC getters so we interpret the ISO(Z) as server wall-clock values
//       hh = parsed.getUTCHours();
//       min = parsed.getUTCMinutes();
//       ss = parsed.getUTCSeconds();
//     } else {
//       // fallback to "HH:mm[:ss]" format parsing
//       const parts = swipeTime.split(':').map(p => parseInt(p, 10));
//       if (parts.length >= 2) {
//         hh = parts[0] || 0;
//         min = parts[1] || 0;
//         ss = parts[2] || 0;
//       }
//     }
//   }

//   // Construct a local Date that has the same displayed Y/M/D HH:MM:SS as the server's values.
//   return new Date(yy, mm - 1, dd, hh, min, ss);
// };



// // returns a server-wall-clock ISO for a row: prefer LocaleMessageTime, else DateOnly+Swipe_Time
// const getServerISO = (r) => {
//   if (!r) return '';
//   if (r.LocaleMessageTime) return r.LocaleMessageTime;
//   if (r.DateOnly) return buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
//   return '';
// };

// // returns YYYY-MM-DD for server wall-clock (used for filtering)
// const getServerYMD = (r) => {
//   const iso = getServerISO(r);
//   if (!iso) return '';
//   return iso.slice(0, 10); // "YYYY-MM-DD"
// };



//   // Handle tab switch (Daily / Raw / Rejection)
//   const handleTabChange = (_, v) => {
//     setTab(v);
//     // reset all filters
//     setRegion('emea');
//     setLocation('');
//     setFrom(null);
//     setTo(null);
//     setSelectedEmps([]);
//   };



//   /** Time Duration Excel generator */
//   const generateTimeDurationExcel = async data => {
//     const wb = new ExcelJS.Workbook();
//     const ws = wb.addWorksheet('Time Duration');

//     // Title row
//     ws.mergeCells('A1:M1');

// ws.getCell('A1').value =
//   `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
      
//     ws.getCell('A1').font = { bold: true, size: 14 };
//     ws.getCell('A1').alignment = { horizontal: 'center' };
//     // Header row
//     const headers = [
//       'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
//       'Partition', 'Text5', 'Year', 'Week', 'Date',
//       'First Swipe', 'Last Swipe', 'Duration', 'Category',
//       'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
//     ];
//     const headerRow = ws.addRow(headers);
//     headerRow.font = { bold: true };
//     headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
//     headerRow.eachCell(c => {
//       c.border = {
//         top: { style: 'thin' }, left: { style: 'thin' },
//         bottom: { style: 'thin' }, right: { style: 'thin' }
//       };
//     });

//     // Columns widths
//     ws.columns = [
//       { key: 'sr', width: 8 },
//       { key: 'name', width: 25 },
//       { key: 'id', width: 15 },
//       { key: 'ptype', width: 18 },
//       { key: 'part', width: 15 },
//       { key: 'txt5', width: 20 },
//       { key: 'year', width: 8 },
//       { key: 'week', width: 6 },
//       { key: 'date', width: 12 },
//       { key: 'first', width: 16 },
//       { key: 'last', width: 16 },
//       { key: 'dur', width: 10 },
//       { key: 'cat', width: 12 },
//       { key: 'dpw', width: 12 },
//       { key: 'vdw', width: 14 },
//       { key: 'cdw', width: 12 },
//       { key: 'def', width: 10 }
//     ];




//     data.forEach((r, idx) => {
//       const first = new Date(r.FirstSwipeTime);
//       const last = new Date(r.LastSwipeTime);
//       const date = new Date(r.ShiftedDate);
//       const row = ws.addRow([
//         idx + 1,
//         r.ObjectName1,
//         r.EmployeeID,
//         r.PersonnelType,
//         r.PartitionName2,
//         r.text5,
//         r.YearNumber,
//         r.WeekNumber,
//         date,
//         first,
//         last,
//         r.DurationHHMM,
//         r.TimeDiffCategory,
//         r.DaysPresentInWeek,
//         r.ViolationDaysInWeek,
//         r.CleanDaysInWeek,
//         r.Defaulter
//       ]);

//       // Date & time formatting
//       row.getCell(9).numFmt = 'dd-mmm-yy';
//       row.getCell(10).numFmt = 'h:mm:ss AM/PM';
//       row.getCell(11).numFmt = 'h:mm:ss AM/PM';

//       row.eachCell(c => {
//         c.border = {
//           top: { style: 'thin' }, left: { style: 'thin' },
//           bottom: { style: 'thin' }, right: { style: 'thin' }
//         };
//         c.alignment = { vertical: 'middle', horizontal: 'left' };
//       });
//     });

//     ws.autoFilter = 'A2:Q2';

//     const buf = await wb.xlsx.writeBuffer();
//     const blob = new Blob([buf], {
//       type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
//     });

//    const filename =
//   `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;


//     const link = document.createElement('a');
//     link.href = URL.createObjectURL(blob);
//     link.download = filename;
//     link.click();
//   };




//   // // --- Excel for Daily Access (unchanged) ---
  
// const generateDailyAccessExcel = async allRows => {
//   const wb = new ExcelJS.Workbook();

//   for (const emp of selectedEmps) {
//     const ws = wb.addWorksheet(emp.substring(0, 31));
//     const headers = [
//       'Date', 'Time', 'Name', 'Contractor ID', 'Card No',
//       'Door Name', 'Message Type', 'Partition', 'Swipe'
//     ];
//     ws.addRow(headers);
//     const hdr = ws.getRow(1);
//     hdr.font = { bold: true };
//     hdr.alignment = { vertical: 'middle', horizontal: 'center' };
//     hdr.eachCell(c => {
//       c.border = {
//         top: { style: 'thin' }, left: { style: 'thin' },
//         bottom: { style: 'thin' }, right: { style: 'thin' }
//       };
//     });

//     ws.columns = [
//       { key: 'date', width: 12 },
//       { key: 'time', width: 12 },
//       { key: 'name', width: 25 },
//       { key: 'id', width: 15 },
//       { key: 'card', width: 15 },
//       { key: 'door', width: 40 },
//       { key: 'msg', width: 15 },
//       { key: 'part', width: 15 },
//       { key: 'swipe', width: 10 }
//     ];

//     const rows = allRows.filter(r => r.ObjectName1 === emp);
//     if (!rows.length) {
//       ws.mergeCells('A2', 'I2');
//       ws.getCell('A2').value = 'There is no swipe records found in Ccure';
//       ws.getCell('A2').alignment = { horizontal: 'center' };
//     } else {
//       rows.forEach(r => {
//         const iso = getServerISO(r); // server wall-clock ISO or ''
//         const dateStr = iso ? formatDateFromServerISO(iso) : '';
//         const timeStr = iso ? formatTimeFromServerISO(iso) : '';

//         const row = ws.addRow([
//           dateStr,
//           timeStr,
//           r.ObjectName1 || '',
//           r.EmployeeID || '',
//           r.CardNumber || '',
//           r.Door || r.ObjectName2 || '',
//           r.AdmitCode || r.Messagetype || '',
//           r.location || '',
//           r.Swipe || r.Direction || ''
//         ]);

//         // treat them as strings to preserve server wall-clock display
//         row.getCell(1).alignment = { horizontal: 'left' };
//         row.getCell(2).alignment = { horizontal: 'left' };

//         row.eachCell(c => {
//           c.border = {
//             top: { style: 'thin' }, left: { style: 'thin' },
//             bottom: { style: 'thin' }, right: { style: 'thin' }
//           };
//           c.alignment = { vertical: 'middle', horizontal: 'left' };
//         });
//       });
//     }
//     ws.autoFilter = 'A1:I1';
//   }

//   const buf = await wb.xlsx.writeBuffer();
//   const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
//   const filename = `Daily Access Report(${formatDisplayDate(from)} to ${formatDisplayDate(to)}).xlsx`;
//   const link = document.createElement('a');
//   link.href = URL.createObjectURL(blob);
//   link.download = filename;
//   link.click();
// };


//   // // --- Excel for Rejection (unchanged except UTC->local fix) ---

// const generateRejectionExcel = async data => {
//   const wb = new ExcelJS.Workbook();
//   const ws = wb.addWorksheet('Rejection');

//   const title = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}`;
//   ws.mergeCells('A1:J1');
//   ws.getCell('A1').value = title;
//   ws.getCell('A1').font = { bold: true, size: 14 };
//   ws.getCell('A1').alignment = { horizontal: 'center' };

//   const headers = [
//     'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
//     'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
//   ];
//   const headerRow = ws.addRow(headers);
//   headerRow.font = { bold: true };
//   headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
//   headerRow.eachCell(c => {
//     c.border = {
//       top: { style: 'thin' }, left: { style: 'thin' },
//       bottom: { style: 'thin' }, right: { style: 'thin' }
//     };
//   });

//   ws.columns = [
//     { key: 'sr', width: 8 },
//     { key: 'date', width: 12 },
//     { key: 'time', width: 12 },
//     { key: 'name', width: 25 },
//     { key: 'id', width: 15 },
//     { key: 'card', width: 15 },
//     { key: 'type', width: 15 },
//     { key: 'door', width: 40 },
//     { key: 'loc', width: 15 },
//     { key: 'swipe', width: 10 }
//   ];

//   data.forEach((r, idx) => {
//     const iso = getServerISO(r);
//     const dateStr = iso ? formatDateFromServerISO(iso) : '';
//     const timeStr = iso ? formatTimeFromServerISO(iso) : '';

//     const row = ws.addRow([
//       idx + 1,
//       dateStr,
//       timeStr,
//       r.ObjectName1 || '',
//       r.EmployeeID || '',
//       r.CardNumber || '',
//       r.Rejection_Type || '',
//       r.Door || r.ObjectName2 || '',
//       r.location || '',
//       r.Direction || r.Swipe || ''
//     ]);

//     row.getCell(2).alignment = { horizontal: 'left' };
//     row.getCell(3).alignment = { horizontal: 'left' };

//     row.eachCell(c => {
//       c.border = {
//         top: { style: 'thin' }, left: { style: 'thin' },
//         bottom: { style: 'thin' }, right: { style: 'thin' }
//       };
//       c.alignment = { vertical: 'middle', horizontal: 'left' };
//     });
//   });

//   // Summary (unchanged but leaves numbers as numbers)
//   const counts = data.reduce((a, r) => {
//     const k = r.Rejection_Type || 'Unknown';
//     a[k] = (a[k] || 0) + 1; return a;
//   }, {});
//   let rowIdx = 3;
//   ws.getCell(rowIdx, 11).value = 'Rejection';
//   ws.getCell(rowIdx, 12).value = 'Count';
//   [11, 12].forEach(c => {
//     const cell = ws.getCell(rowIdx, c);
//     cell.font = { bold: true };
//     cell.alignment = { horizontal: 'center' };
//     cell.border = {
//       top: { style: 'thin' }, left: { style: 'thin' },
//       bottom: { style: 'thin' }, right: { style: 'thin' }
//     };
//   });
//   rowIdx++;
//   Object.entries(counts).forEach(([type, cnt]) => {
//     ws.getCell(rowIdx, 11).value = type;
//     ws.getCell(rowIdx, 12).value = cnt;
//     [11, 12].forEach(c => {
//       const cell = ws.getCell(rowIdx, c);
//       cell.alignment = { horizontal: 'left' };
//       cell.border = {
//         top: { style: 'thin' }, left: { style: 'thin' },
//         bottom: { style: 'thin' }, right: { style: 'thin' }
//       };
//     });
//     rowIdx++;
//   });
//   ws.getCell(rowIdx, 11).value = 'Total';
//   ws.getCell(rowIdx, 12).value = data.length;
//   [11, 12].forEach(c => {
//     const cell = ws.getCell(rowIdx, c);
//     cell.font = { bold: true };
//     cell.alignment = { horizontal: 'left' };
//     cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
//   });

//   // Download
//   const buf = await wb.xlsx.writeBuffer();
//   const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
//   const filename = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}.xlsx`;
//   const link = document.createElement('a');
//   link.href = URL.createObjectURL(blob);
//   link.download = filename;
//   link.click();
// };

//   const [rawSearch, setRawSearch] = useState(''); // search string for Raw report (name or id)
//   const [rawAdmitFilter, setRawAdmitFilter] = useState('all'); // 'all' | 'admit' | 'reject'




// // generateRawExcel(rows, opts)
// const generateRawExcel = async (rows, opts = {}) => {
//   // helper: format time coming from Swipe_Time (handles ISO or "HH:mm[:ss]" fallback)
//   const formatTimeFromSwipe = (swipeIso) => {
//     if (!swipeIso) return '';
//     // try ISO parse first
//     const dt = new Date(swipeIso);
//     if (!isNaN(dt.getTime())) {
//       return formatTimeFromServerISO(swipeIso);
//     }
//     // fallback: parse "HH:mm" or "HH:mm:ss"
//     const parts = ('' + swipeIso).split(':').map(p => parseInt(p || 0, 10));
//     const hh = parts[0] || 0;
//     const mm = parts[1] || 0;
//     const ss = parts[2] || 0;
//     const ampm = hh >= 12 ? 'PM' : 'AM';
//     const hh12 = ((hh + 11) % 12) + 1;
//     return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
//   };

//   // determine which columns to include based on filter
//   const admitFilter = (opts.rawAdmitFilter || 'all').toString().toLowerCase(); // 'all'|'admit'|'reject'

//   // base columns always present
//   const baseHeaders = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber'];
//   // conditional columns
//   const admitCol = 'AdmitCode';
//   const rejCol = 'Rejection_Type';
//   // always include these at end
//   const tailCols = ['Direction','Door'];

//   // build final headers in requested order
//   let headers = [...baseHeaders];
//   if (admitFilter === 'all') {
//     headers.push(admitCol);
//     headers.push(...tailCols);
//     headers.push(rejCol);
//   } else if (admitFilter === 'admit') {
//     // admitted only -> hide Rejection_Type
//     headers.push(admitCol);
//     headers.push(...tailCols);
//   } else if (admitFilter === 'reject') {
//     // rejected only -> hide AdmitCode
//     headers.push(...tailCols);
//     headers.push(rejCol);
//   } else {
//     // defensive fallback - include both
//     headers.push(admitCol);
//     headers.push(...tailCols);
//     headers.push(rejCol);
//   }

//   if (!rows || !rows.length) {
//     // fallback: write an empty workbook with dynamic headers
//     const wbEmpty = XLSX.utils.book_new();
//     const wsEmpty = XLSX.utils.aoa_to_sheet([headers]);
//     XLSX.utils.book_append_sheet(wbEmpty, wsEmpty, 'Raw');
//     const fileNameEmpty = buildRawFileName(opts);
//     XLSX.writeFile(wbEmpty, fileNameEmpty);
//     return;
//   }

//   // Build rows for sheet mapping only included headers
//   const rowsForSheet = rows.map(r => {
//     // Build server-wall-clock ISO for the row (LocaleMessageTime preferred)
//     const iso = getServerISO(r); // LocaleMessageTime || DateOnly+Swipe_Time
//     const dateStr = iso ? formatDateFromServerISO(iso) : '';
//     const timeStr = iso ? formatTimeFromServerISO(iso) : '';
//     const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');

//     // Format DateOnly as DD-MMM-YY (if present), otherwise blank
//     const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';

//     // Format Swipe_Time as h:mm:ss AM/PM — handle ISO or HH:mm fallback
//     const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

//     // Build a full object then pick keys according to headers to control column inclusion order
//     const fullObj = {
//       LocaleMessageTime: localeMsgFormatted,
//       DateOnly: dateOnlyFormatted,
//       Swipe_Time: swipeTimeFormatted,
//       EmployeeID: r.EmployeeID || '',
//       ObjectName1: r.ObjectName1 || '',
//       PersonnelType: r.PersonnelType || '',
//       location: r.location || '',
//       CardNumber: r.CardNumber || '',
//       AdmitCode: r.AdmitCode || r.Messagetype || '',
//       Direction: r.Direction || r.Swipe || '',
//       Door: r.Door || r.ObjectName2 || '',
//       Rejection_Type: r.Rejection_Type || ''
//     };

//     // pick only the requested headers
//     const picked = {};
//     headers.forEach(h => {
//       // ensure we always provide a string/empty when key missing
//       picked[h] = (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '';
//     });
//     return picked;
//   });

//   // create workbook/sheet with ordered headers
//   const ws = XLSX.utils.json_to_sheet(rowsForSheet, { header: headers });
//   const wb = XLSX.utils.book_new();
//   XLSX.utils.book_append_sheet(wb, ws, 'Raw');

//   // build filename per your examples
//   const filename = buildRawFileName(opts);

//   XLSX.writeFile(wb, filename);
// };




// const handleGenerate = async () => {
//   setLoading(true);
//   try {
//     const baseParams = { region, location: location || undefined };

//     // Helper: format dates in local time without timezone conversion for API parameters
//     const formatLocalDate = (date, endOfDay = false) => {
//       const d = new Date(date);
//       if (endOfDay) d.setHours(23, 59, 59, 999);
//       else d.setHours(0, 0, 0, 0);
//       const pad = n => n.toString().padStart(2, '0');
//       return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}` +
//              `T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
//     };

//     // Helper: convert ISO date-only string (YYYY-MM-DD...) into a local midnight Date (avoids UTC shift)
//     const isoDateOnlyToLocalDate = (iso) => {
//       if (!iso) return null;
//       const s = iso.toString().slice(0, 10); // YYYY-MM-DD
//       const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
//       return new Date(y, m - 1, d);
//     };

//     const pad2 = n => n.toString().padStart(2, '0');
//     const toLocalYMD = date => `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`;




//     // // // ----- 0: Daily Access -----
//     if (tab === 0) {
//       const params = {
//         ...baseParams,
//         from: formatLocalDate(from),
//         to: formatLocalDate(to, true),
//         employees: selectedEmps.join(',')
//       };
//       const resp = await axios.get('/api/reports/daily-access', { params });

//       const startDate = new Date(from); startDate.setHours(8, 0, 0, 0);
//       const endDate = new Date(to); endDate.setHours(8, 0, 0, 0);

//       const rows = (resp.data && resp.data.data) || [];
//       const filtered = rows.filter(r => {
//         const dt = new Date(r.LocaleMessageTime);
//         return dt >= startDate && dt < endDate;
//       });

//       await generateDailyAccessExcel(filtered);
//       return;
//     }


//     // ----- 1: Raw -----
//     if (tab === 1) {

// const params = {
//   ...baseParams,
//   startDate: formatLocalDate(from),
//   endDate: formatLocalDate(to, true),
//   admitFilter: rawAdmitFilter  // <-- pass the UI value ('all'|'admit'|'reject')
// };
// const resp = await axios.get('/api/reports/raw', { params });
//       const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
//       const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

//       const rowsSrc = (resp.data && resp.data.data) || [];
//       const rows = rowsSrc.filter(r => {
//         const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
//         return date >= startDate && date <= endDate;
//       });

//       let filtered = rows;
//       if (rawSearch && rawSearch.trim() !== '') {
//         const s = rawSearch.trim().toLowerCase();
//         filtered = rows.filter(r => {
//           const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
//           const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
//           return id.includes(s) || name.includes(s);
//         });
//       }


// // await generateRawExcel(filtered, { region, location, rawSearch, from, to });

// await generateRawExcel(filtered, { region, location, rawSearch, from, to, rawAdmitFilter });


//       return;
//     }




//     // ----- 2: Rejection -----
//     if (tab === 2) {
//       const params = { ...baseParams, startDate: formatLocalDate(from), endDate: formatLocalDate(to, true) };
//       const resp = await axios.get('/api/reports/rejection', { params });

//       const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
//       const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

//       const rowsSrc = (resp.data && resp.data.data) || [];
//       const rows = rowsSrc.filter(r => {
//         const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
//         return date >= startDate && date <= endDate;
//       });

//       await generateRejectionExcel(rows);
//       return;
//     }

//     // ----- 3: EUROC Admit-Reject (single day) -----
//     if (tab === 3) {
//       if (region.toLowerCase() !== 'emea') {
//         alert('EUROC report is only available for region EMEA. Please select EMEA.');
//         return;
//       }
//       if (!from) {
//         alert('Please select a date (From) for EUROC report.');
//         return;
//       }

//       const dateParam = toLocalYMD(new Date(from));
//       const params = { region: 'emea', date: dateParam };
//       const resp = await axios.get('/api/reports/euroc-admit-rejection', { params });
//       const { data } = resp.data || {}; // { admit: [], rejection: [], summary: [] }

//       const wb = new ExcelJS.Workbook();

//       // Admit sheet
//       const admitTitle = `EUROC Admit Report - ${formatDisplayDate(from)}`;
//       const ws1 = wb.addWorksheet('EUROC Admit');
//       ws1.mergeCells('A1:I1');
//       ws1.getCell('A1').value = admitTitle;
//       ws1.getCell('A1').font = { bold: true, size: 14 };
//       ws1.getCell('A1').alignment = { horizontal: 'center' };

//       const admitHeaders = [
//         'Sr. No.', 'Date', 'Time', 'Employee Name',
//         'Access Card No.', 'Personnel Type', 'Door Name', 'Location', 'Swipe'
//       ];
//       const hdrRow1 = ws1.addRow(admitHeaders);
//       hdrRow1.font = { bold: true };
//       hdrRow1.alignment = { vertical: 'middle', horizontal: 'center' };
//       hdrRow1.eachCell(c => {
//         c.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
//       });

//       ws1.columns = [
//         { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
//         { key:'name', width:30 }, { key:'card', width:15 }, { key:'ptype', width:20 },
//         { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
//       ];




// (data.admit || []).forEach((r, idx) => {
//   // Build an ISO that represents server wall-clock datetime (use LocaleMessageTime if provided)
//   let iso;
//   if (r.LocaleMessageTime) {
//     iso = r.LocaleMessageTime; // already an ISO with Z
//   } else if (r.DateOnly) {
//     iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
//   } else {
//     iso = '';
//   }

//   const dateStr = iso ? formatDateFromServerISO(iso) : '';
//   const timeStr = iso ? formatTimeFromServerISO(iso) : '';

//   // Insert formatted strings (not Date objects) — preserves exact server date/time
//   const row = ws1.addRow([
//     idx + 1,
//     dateStr,
//     timeStr,
//     r.ObjectName1 || '',
//     r.CardNumber || '',
//     r.PersonnelType || '',
//     r.Door || r.ObjectName2 || '',
//     r.location || '',
//     r.Direction || ''
//   ]);

//   // Keep formatting for header look — but DO NOT set numFmt expecting Excel date objects
//   row.getCell(2).alignment = { horizontal: 'left' };
//   row.getCell(3).alignment = { horizontal: 'left' };
//   row.eachCell(c => {
//     c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
//     c.alignment = { vertical: 'middle', horizontal: 'left' };
//   });
// });


//       // Rejection sheet
//       const ws2 = wb.addWorksheet('EUROC Rejection');
//       ws2.mergeCells('A1:J1');
//       ws2.getCell('A1').value = `EUROC Rejection Report - ${formatDisplayDate(from)}`;
//       ws2.getCell('A1').font = { bold: true, size: 14 };
//       ws2.getCell('A1').alignment = { horizontal: 'center' };

//       const headerRow2 = ws2.addRow(['Sr. No.', 'Date', 'Time', 'Employee Name', 'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe']);
//       headerRow2.font = { bold: true };
//       headerRow2.alignment = { vertical: 'middle', horizontal: 'center' };
//       headerRow2.eachCell(c => {
//         c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
//       });

//       ws2.columns = [
//         { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
//         { key:'name', width:30 }, { key:'card', width:15 }, { key:'type', width:15 },
//         { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
//       ];

// (data.rejection || []).forEach((r, idx) => {
//   let iso;
//   if (r.LocaleMessageTime) {
//     iso = r.LocaleMessageTime;
//   } else if (r.DateOnly) {
//     iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
//   } else {
//     iso = '';
//   }

//   const dateStr = iso ? formatDateFromServerISO(iso) : '';
//   const timeStr = iso ? formatTimeFromServerISO(iso) : '';

//   const row = ws2.addRow([
//     idx + 1,
//     dateStr,
//     timeStr,
//     r.ObjectName1 || '',
//     r.CardNumber || '',
//     r.Rejection_Type || '',
//     r.Door || '',
//     r.location || '',
//     r.Direction || ''
//   ]);

//   row.getCell(2).alignment = { horizontal: 'left' };
//   row.getCell(3).alignment = { horizontal: 'left' };
//   row.eachCell(c => {
//     c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
//     c.alignment = { vertical: 'middle', horizontal: 'left' };
//   });
// });




//       // Summary block (same as before)
//       const counts = data.summary || [];
//       let startRow = 3;
//       ws2.getCell(startRow, 11).value = 'Rejection';
//       ws2.getCell(startRow, 12).value = 'Count';
//       [11, 12].forEach(col => {
//         const cell = ws2.getCell(startRow, col);
//         cell.font = { bold: true };
//         cell.alignment = { horizontal: 'center' };
//         cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
//       });
//       startRow++;
//       counts.forEach(c => {
//         ws2.getCell(startRow, 11).value = c.Rejection_Type || 'Unknown';
//         ws2.getCell(startRow, 12).value = c.Count || 0;
//         [11, 12].forEach(col => {
//           const cell = ws2.getCell(startRow, col);
//           cell.alignment = { horizontal: 'left' };
//           cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
//         });
//         startRow++;
//       });
//       ws2.getCell(startRow, 11).value = 'Grand Total';
//       ws2.getCell(startRow, 12).value = (data.rejection || []).length;
//       [11, 12].forEach(col => {
//         const cell = ws2.getCell(startRow, col);
//         cell.font = { bold: true };
//         cell.alignment = { horizontal: 'left' };
//         cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
//       });

//       // Download workbook
//       const buf = await wb.xlsx.writeBuffer();
//       const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
//       const filename = `EUROC_Admit_Rejection_${dateParam}.xlsx`;
//       const link = document.createElement('a');
//       link.href = URL.createObjectURL(blob);
//       link.download = filename;
//       link.click();
//       return;
//     }


//     // ----- 4: Time Duration -----
// if (tab === 4) {
//   // require both start & end strictly
//   if (!from || !to) {
//     alert('Please select both Start Date and End Date for Time Duration report.');
//     return;
//   }
//   const startParam = toLocalYMD(new Date(from));
//   const endParam = toLocalYMD(new Date(to));
//   const params = {
//     region,
//     startDate: startParam,
//     endDate: endParam,
//     partition: location ? location.split('.').pop() : 'Default'
//   };
//   const resp = await axios.get('/api/reports/time-duration', { params });
//   await generateTimeDurationExcel(resp.data.data || []);
//   return;
// }



//     // ----- 5: HeadCount / External navigation -----
//     if (tab === 5) {
//       let url = '';

//       if (region === 'laca') {
//         if (!location) url = 'http://10.199.22.57:3003/history';
//         else {
//           const LACA_URLS = {
//             'CR.Costa Rica Partition': 'http://10.199.22.57:3003/partition/CR.Costa%20Rica%20Partition/history',
//             'MX.Mexico City': 'http://10.199.22.57:3003/partition/MX.Mexico%20City/history',
//             'AR.Cordoba': 'http://10.199.22.57:3003/partition/AR.Cordoba/history',
//             'PA.Panama City': 'http://10.199.22.57:3003/partition/PA.Panama%20City/history',
//             'PE.Lima': 'http://10.199.22.57:3003/partition/PE.Lima/history',
//             'BR.Sao Paulo': 'http://10.199.22.57:3003/partition/BR.Sao%20Paulo/history'
//           };
//           url = LACA_URLS[location] || 'http://10.199.22.57:3003/history';
//         }
//       } else if (region === 'namer') {
//         if (!location) url = 'http://10.199.22.57:3002/history';
//         else {
//           const NAMER_URLS = {
//             'US.Denver': 'http://10.199.22.57:3002/partition/US.CO.OBS/history',
//             'US.Miami': 'http://10.199.22.57:3002/partition/US.FL.Miami/history',
//             'US.NYC': 'http://10.199.22.57:3002/partition/US.NYC/history',
//             'US.Austin': 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default/history'
//           };
//           url = NAMER_URLS[location] || 'http://10.199.22.57:3002/history';
//         }
//       } else if (region === 'apac') {
//         if (!location) url = 'http://10.199.22.57:3000/history';
//         else {
//           const APAC_URLS = {
//             'APAC.Default': 'http://10.199.22.57:3000/partition/Pune/history',
//             'MY.Kuala Lumpur': 'http://10.199.22.57:3000/partition/MY.Kuala Lumpur/history',
//             'PH.Manila': 'http://10.199.22.57:3000/partition/PH.Manila/history',
//             'JP.Tokyo': 'http://10.199.22.57:3000/history',
//             'CN.Beijing': 'http://10.199.22.57:3000/history'
         
//           };
//           url = APAC_URLS[location] || 'http://10.199.22.57:3000/history';
//         }
//       } else if (region === 'emea') {
//         if (!location) url = 'http://10.199.22.57:3001/history';
//         else {
//           const EMEA_URLS = {
//             'AUT.Vienna': 'http://10.199.22.57:3001/history',
//             'DU.Abu Dhabi': 'http://10.199.22.57:3001/history',
//             'IE.Dublin': 'http://10.199.22.57:3001/history',
//             'IT.Rome': 'http://10.199.22.57:3001/history',
//             'LT.Vilnius': 'http://10.199.22.57:3001/history',
//             'MA.Casablanca': 'http://10.199.22.57:3001/history',
//             'RU.Moscow': 'http://10.199.22.57:3001/history',
//             'UK.London': 'http://10.199.22.57:3001/history',
//             'ES.Madrid': 'http://10.199.22.57:3001/history'
//           };
//           url = EMEA_URLS[location] || 'http://10.199.22.57:3001/history';
//         }
//       }

//       if (url) window.location.href = url;
//       else alert('Invalid region or location selected.');
//       return;
//     }

//   } catch (err) {
//     console.error(err);
//     alert('Failed to generate report');
//   } finally {
//     setLoading(false);
//   }
// };





// const disabled = loading
//   || !region
//   || (tab === 0 && (!from || !to || selectedEmps.length === 0)) // Daily Access
//   || (tab === 1 && (!from || !to)) // Raw
//   || (tab === 2 && (!from || !to)) // Rejection - require date range
//   || (tab === 3 && !from) // EUROC (single day)
//   || (tab === 4 && (!from || !to));


//   // helper variable to keep navigation special-case consistent
//   const navDisabled = !region || loading;


//   return (
//     <LocalizationProvider dateAdapter={AdapterDateFns}>
//       <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
//         {/* Topbar / Header */}
//         <Box
//           sx={{
//             display: 'flex',
//             alignItems: 'center',
//             gap: 2,
//             px: 3,
//             py: 2,
//             borderBottom: '1px solid rgba(255,204,0,0.08)',
//             background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
//           }}
//         >
//           <Avatar sx={{ bgcolor: '#000', border: '3px solid #FFCC00', width: 56, height: 56 }}>
//             <Typography sx={{ color: '#FFCC00', fontWeight: 900 }}>WU</Typography>
//           </Avatar>

//           <Box sx={{ flex: 1 }}>
//             <Typography variant="h5" sx={{ fontWeight: 900, letterSpacing: 0.6 }}>
//               Global Security Operation Center
//             </Typography>
//             <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
//               Reports & Exports — Secure access, fast insights
//             </Typography>
//           </Box>

//           <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>



// <Button
//   startIcon={<DownloadIcon />}
//   onClick={handleGenerate}
//   // navigation special-case should be tab === 5 (HeadCount)
//   disabled={tab === 5 ? navDisabled : disabled}
//   sx={{
//     bgcolor: '#FFCC00',
//     color: '#000',
//     fontWeight: 800,
//     px: 3,
//     py: 1,
//     borderRadius: 3,
//     boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
//     transformOrigin: 'center',
//     '&:hover': { bgcolor: '#ffd84d', transform: 'translateY(-2px)' }
//   }}
// >
//   {loading ? 'Loading…'
//            : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
// </Button>
            
//           </Box>
//         </Box>

//         {/* Main content: Sidebar + Content */}
//         <Grid container sx={{ px: 3, py: 4 }} spacing={3}>
//           {/* Sidebar */}
//           <Grid item xs={12} md={3}>
//             <Paper
//               elevation={8}
//               sx={{
//                 p: 2.5,
//                 borderRadius: 3,
//                 height: { xs: 'auto', md: 'calc(100vh - 150px)' },
//                 overflow: 'auto',
//                 background: 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015))',
//                 border: '1px solid rgba(255,204,0,0.06)'
//               }}
//             >
//               <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
//                 <Box>
//                   <Typography variant="subtitle1" sx={{ fontWeight: 800, color: '#FFCC00' }}>Filters</Typography>
//                   <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
//                     Narrow down by region, date and employees
//                   </Typography>
//                 </Box>
//                 <IconButton size="small" sx={{ color: '#FFCC00' }}>
//                   <FilterListIcon />
//                 </IconButton>
//               </Box>

//               <Divider sx={{ my: 1, borderColor: 'rgba(255,204,0,0.06)' }} />

//               {/* Region */}
//               <Box sx={{ mt: 1 }}>
//                 <FormControl fullWidth>
//                   <InputLabel sx={{ color: '#FFCC00' }}>Region</InputLabel>
//                   <Select
//                     value={region}
//                     onChange={e => { setRegion(e.target.value); setLocation(''); }}
//                     input={<OutlinedInput label="Region" />}
//                     sx={{
//                       color: '#fff',
//                       '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.24)' }
//                     }}
//                   >
//                     {REGION_OPTIONS.map(r => <MenuItem key={r} value={r}>{r.toUpperCase()}</MenuItem>)}
//                   </Select>
//                 </FormControl>
//               </Box>

//               {/* Location */}
//               <Box sx={{ mt: 2 }}>
//                 <FormControl fullWidth>
//                   <InputLabel sx={{ color: '#FFCC00' }}>Location</InputLabel>
//                   <Select
//                     value={location}
//                     onChange={e => setLocation(e.target.value)}
//                     input={<OutlinedInput label="Location" />}
//                     disabled={!region}
//                     sx={{
//                       color: '#fff',
//                       '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
//                     }}
//                   >
//                     {(LOCATION_MAP[region] || []).map(loc => <MenuItem key={loc} value={loc}>{loc.split('.').pop()}</MenuItem>)}
//                   </Select>
//                 </FormControl>
//               </Box>

//               <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />





//               {/* Employee search (only for Raw tab) */}
//               {/* {tab === 1 && (
//                 <Box sx={{ mt: 2 }}>
//                   <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
//                     Employee (name or ID)
//                   </Typography>
//                   <TextField
//                     fullWidth
//                     placeholder="Type employee name or ID (e.g. 'Jejurkar' or '323471')"
//                     label="Search Employee"
//                     value={rawSearch}
//                     onChange={(e) => setRawSearch(e.target.value)}
//                     sx={{
//                       '& .MuiInputBase-input': { color: '#fff' },
//                       '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
//                     }}
//                     InputLabelProps={{ style: { color: '#FFCC00' } }}
//                   />
//                   <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
//                     Leave empty to export all raw rows for the date range.
//                   </Typography>
//                 </Box>
//               )} */}





// {tab === 1 && (
//   <Box sx={{ mt: 2 }}>
//     <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
//       Employee (name or ID)
//     </Typography>
//     <TextField
//       fullWidth
//       placeholder="Type employee name or ID (e.g. 'Jejurkar' or '323471')"
//       label="Search Employee"
//       value={rawSearch}
//       onChange={(e) => setRawSearch(e.target.value)}
//       sx={{
//         '& .MuiInputBase-input': { color: '#fff' },
//         '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
//       }}
//       InputLabelProps={{ style: { color: '#FFCC00' } }}
//     />
//     <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
//       Leave empty to export all raw rows for the date range.
//     </Typography>

//     {/* --- NEW: Admit/Reject filter --- */}
//     <Box sx={{ mt: 2 }}>
//       <FormControl fullWidth>
//         <InputLabel sx={{ color: '#FFCC00' }}>Admit / Reject</InputLabel>
//         <Select
//           value={rawAdmitFilter}
//           onChange={(e) => setRawAdmitFilter(e.target.value)}
//           input={<OutlinedInput label="Admit / Reject" />}
//           sx={{
//             color: '#fff',
//             '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
//           }}
//         >
//           <MenuItem value="all">All (Admitted + Rejected)</MenuItem>
//           <MenuItem value="admit">Admitted only</MenuItem>
//           <MenuItem value="reject">Rejected only</MenuItem>
//         </Select>
//       </FormControl>
//       <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
//         Default = All.
//       </Typography>
//     </Box>
//   </Box>
// )}


//               {/* Dates */}
//               {tab !== 5 && (
//                 <Box>
//                   <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
//                     Date Range
//                   </Typography>
//                   <Box sx={{ display: 'grid', gap: 1.25 }}>
//                     <TextField
//                       label={tab === 0 ? 'From Date' : 'Start Date'}
//                       value={from ? from.toLocaleDateString() : ''}
//                       readOnly
//                       onClick={() => setShowFromCal(true)}
//                       sx={{
//                         '& .MuiInputBase-input': { color: '#fff' },
//                         '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
//                       }}
//                     />
//                     <TextField
//                       label={tab === 0 ? 'To Date' : 'End Date'}
//                       value={to ? to.toLocaleDateString() : ''}
//                       readOnly
//                       onClick={() => setShowToCal(true)}
//                       sx={{
//                         '& .MuiInputBase-input': { color: '#fff' },
//                         '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
//                       }}
//                     />
//                   </Box>

//                   {/* Static pickers (keeps your existing state handlers) */}
//                   {showFromCal && (
//                     <Box sx={{ mt: 1 }}>
//                       <StaticDatePicker
//                         displayStaticWrapperAs="desktop"
//                         value={from}
//                         onChange={(newValue) => setFrom(newValue)}
//                         onAccept={() => setShowFromCal(false)}
//                         onClose={() => setShowFromCal(false)}
//                         renderInput={(params) => <TextField {...params} />}
//                         views={['year', 'month', 'day']}
//                       />
//                     </Box>
//                   )}
//                   {showToCal && (
//                     <Box sx={{ mt: 1 }}>
//                       <StaticDatePicker
//                         displayStaticWrapperAs="desktop"
//                         value={to}
//                         onChange={(newValue) => setTo(newValue)}
//                         onAccept={() => setShowToCal(false)}
//                         onClose={() => setShowToCal(false)}
//                         renderInput={(params) => <TextField {...params} />}
//                         views={['year', 'month', 'day']}
//                       />
//                     </Box>
//                   )}
//                 </Box>
//               )}

//               <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />

//               {/* Employees (only Daily) */}
//               {tab === 0 && (
//                 <Box>
//                   <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
//                     Employees
//                   </Typography>
//                   <FormControl fullWidth>
//                     <InputLabel sx={{ color: '#FFCC00' }}>Employees</InputLabel>
//                     <Select
//                       multiple
//                       value={selectedEmps}
//                       onChange={e => setSelectedEmps(e.target.value)}
//                       input={<OutlinedInput label="Employees" />}
//                       renderValue={vals => vals.join(', ')}
//                       sx={{
//                         color: '#fff',
//                         '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
//                       }}
//                     >
//                       {EMPLOYEE_OPTIONS.map(n => (
//                         <MenuItem key={n} value={n}>
//                           <Checkbox checked={selectedEmps.includes(n)} />
//                           <ListItemText primary={n} />
//                         </MenuItem>
//                       ))}
//                     </Select>
//                   </FormControl>
//                 </Box>
//               )}

//               {/* Helpful hint */}
//               <Box sx={{ mt: 3, p: 2, borderRadius: 2, background: 'rgba(255,255,255,0.02)' }}>
//                 <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
//                   Tip: For daily exports pick employees & a single day range. For Time Duration choose the required partition via Location.
//                 </Typography>
//               </Box>
//             </Paper>
//           </Grid>

//           {/* Main panel */}
//           <Grid item xs={12} md={9}>
//             <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
//               {/* Tabs (visual only) */}
//               <Paper
//                 elevation={3}
//                 sx={{
//                   px: 2,
//                   py: 1,
//                   borderRadius: 2,
//                   display: 'flex',
//                   alignItems: 'center',
//                   justifyContent: 'space-between',
//                   gap: 2,
//                   border: '1px solid rgba(255,204,0,0.04)'
//                 }}
//               >
//                 <Tabs
//                   value={tab}
//                   onChange={handleTabChange}
//                   sx={{
//                     '& .MuiTab-root': {
//                       textTransform: 'none',
//                       minWidth: 120,
//                       fontWeight: 700,
//                       color: 'rgba(255,255,255,0.8)'
//                     },
//                     '& .Mui-selected': { color: '#FFCC00' }
//                   }}
//                 >
//                   <Tab icon={<CalendarTodayIcon />} label="Daily Access" />
//                   <Tab icon={<PeopleIcon />} label="Raw" />
//                   <Tab icon={<PlaceIcon />} label="Rejection" />
//                   <Tab icon={<PeopleIcon />} label="EUROC Admit-Reject" />

//                   <Tab icon={<CalendarTodayIcon />} label="Time Duration" />
//                   <Tab icon={<PeopleIcon />} label="HeadCount" />

//                 </Tabs>

//                 <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
//                   <Button
//                     variant="text"
//                     startIcon={<FilterListIcon />}
//                     sx={{ color: 'rgba(255,255,255,0.65)', textTransform: 'none' }}
//                     onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}
//                   >
//                     Reset View
//                   </Button>
//                 </Box>
//               </Paper>

//               {/* Action summary + CTA */}
//               <Paper elevation={6} sx={{ p: 3, borderRadius: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 2 }}>
//                 <Box>
//                   <Typography variant="h6" sx={{ fontWeight: 900 }}>Export Center</Typography>
//                   <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.7)' }}>
//                     Selected Region: <strong style={{ color: '#FFCC00' }}>{region.toUpperCase()}</strong> {location ? `• ${location.split('.').pop()}` : ''}
//                   </Typography>
//                   <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
//                     Choose tab, select filters and export reports in Excel.
//                   </Typography>
//                 </Box>

//                 <Box>

// <Button
//   startIcon={loading ? <CircularProgress size={20} /> : <DownloadIcon />}
//   disabled={tab === 5 ? navDisabled : disabled}
//   onClick={handleGenerate}

//                     sx={{
//                       bgcolor: '#FFCC00',
//                       color: '#000',
//                       fontWeight: 900,
//                       px: 4,
//                       py: 1,
//                       borderRadius: 3,
//                       boxShadow: '0 8px 30px rgba(255,204,0,0.22)',
//                       '&:hover': { bgcolor: '#ffd84d', transform: 'translateY(-3px)' }
//                     }}
//                   >

//                      {loading
//     ? 'Loading…'
//     : (tab === 5
//         ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`)
//         : 'Export to Excel')}
// </Button>

//                 </Box>
//               </Paper>

//             </Box>
//           </Grid>

//         </Grid>
//       </Box>
//     </LocalizationProvider>
//   );

// }


























// src/pages/ReportsPage.jsx
import React, { useState } from 'react';
import {
  Box, FormControl, InputLabel, Select, OutlinedInput,
  Checkbox, ListItemText, MenuItem, Button,
  CircularProgress, Typography, TextField, Tabs, Tab, Grid, Paper, IconButton, Divider
} from '@mui/material';

import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import axios from 'axios';
import ExcelJS from 'exceljs';
import * as XLSX from 'xlsx';
import { useAuth } from '../context/AuthContext';

import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import PlaceIcon from '@mui/icons-material/Place';
import PeopleIcon from '@mui/icons-material/People';
import DownloadIcon from '@mui/icons-material/CloudDownload';
import FilterListIcon from '@mui/icons-material/FilterList';
import Avatar from '@mui/material/Avatar';

// Static lists
const EMPLOYEE_OPTIONS = [
  'Vainilaitis, Valdas',
  'Tomasevic, Kazimez',
  'Sesickis, Janas',
  'Valiunas, Sigitas',
  'JANCUKOVIC, VACLAVA',
  'Kalpokiene, Alina',
  'Korkus, Vanda',
  'Kvaraciejiene, Maryte',
  'ZNAMEROVSKIS, DARIUS'
];

const REGION_OPTIONS = ['global', 'apac', 'emea', 'laca', 'namer'];
const LOCATION_MAP = {
  apac: ['APAC.Default', 'JP.Tokyo', 'PH.Manila', 'MY.Kuala Lumpur'],
  emea: ['AUT.Vienna', 'DU.Abu Dhab', 'IE.Dublin', 'IT.Rome', 'LT.Vilnius', 'MA.Casablanca', 'RU.Moscow', 'UK.London', 'ES.Madrid'],
  laca: ['AR.Cordoba', 'CR.Costa Rica Partition', 'MX.Mexico City', 'PE.Lima', 'BR.Sao Paulo', 'PA.Panama City'],
  namer: ['US.NYC', 'US.FL.Miami', 'USA/Canada Default', 'US.CO.OBS'],
  global: []
};

function formatDisplayDate(date) {
  const d = new Date(date);
  const day = d.getDate();
  const suf = day % 10 === 1 && day !== 11 ? 'st'
    : day % 10 === 2 && day !== 12 ? 'nd'
      : day % 10 === 3 && day !== 13 ? 'rd' : 'th';
  const mon = d.toLocaleString('default', { month: 'long' });
  return `${day}${suf} ${mon} ${d.getFullYear()}`;
}

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');

function formatDateFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  const y = dt.getUTCFullYear();
  const m = dt.getUTCMonth(); // 0..11
  const d = dt.getUTCDate();
  const yrShort = String(y).slice(-2);
  return `${pad2(d)}-${MONTH_ABBR[m]}-${yrShort}`;         // e.g. "12-Aug-25"
}

function formatTimeFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  let hh = dt.getUTCHours();   // use UTC parts so we trust server wall-clock
  const mm = dt.getUTCMinutes();
  const ss = dt.getUTCSeconds();
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1;
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;        // e.g. "12:01:24 AM"
}

function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10); // "YYYY-MM-DD"
  if (!swipeIso) {
    return `${datePart}T00:00:00.000Z`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000Z`;
  }
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000Z`;
}

function formatShortRange(fromDate, toDate) {
  if (!fromDate || !toDate) return '';
  const f = formatDisplayDate(fromDate);
  const t = formatDisplayDate(toDate);
  const [fDay, fMon] = f.split(' ');
  const [tDay, tMon] = t.split(' ');

  if (fMon === tMon) {
    return `${fDay} to ${tDay} ${fMon}`;
  }
  return `${fDay} ${fMon} to ${tDay} ${tMon}`;
}

function buildRawFileName({ region, location, rawSearch, from, to }) {
  const shortRange = formatShortRange(from, to);
  const regionPart = (region || '').toUpperCase();
  const locPart = location ? `-${location.split('.').pop()}` : '';
  const prefix = rawSearch && rawSearch.toString().trim() ? `${rawSearch.toString().trim()} ` : '';
  const base = `${regionPart}${locPart} Raw report ${shortRange}`;
  const safeBase = base.replace(/[\/\\:\*\?"<>\|]+/g, '').replace(/\s+/g, ' ').trim();
  return `${prefix}${safeBase}.xlsx`;
}

// returns a server-wall-clock ISO for a row: prefer LocaleMessageTime, else DateOnly+Swipe_Time
const getServerISO = (r) => {
  if (!r) return '';
  if (r.LocaleMessageTime) return r.LocaleMessageTime;
  if (r.DateOnly) return buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  return '';
};

// returns YYYY-MM-DD for server wall-clock (used for filtering)
const getServerYMD = (r) => {
  const iso = getServerISO(r);
  if (!iso) return '';
  return iso.slice(0, 10);
};

// Helper — convert "YYYY-MM-DD..." (ISO) into a local midnight Date (avoids UTC shift)
const isoDateOnlyToLocalDate = (iso) => {
  if (!iso) return null;
  const s = iso.toString().slice(0, 10);
  const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
  return new Date(y, m - 1, d);
};

// Build a Date that preserves the server-provided wall-clock values.
// If swipeTime is an ISO (with Z), read UTC components and use them as local values.
const buildLocalDateFromDateOnlyAndSwipe = (dateOnly, swipeTime) => {
  if (!dateOnly) return null;
  const dateStr = dateOnly.toString().slice(0, 10);
  const [yy, mm, dd] = dateStr.split('-').map(n => parseInt(n, 10));

  let hh = 0, min = 0, ss = 0;
  if (swipeTime) {
    const parsed = new Date(swipeTime);
    if (!isNaN(parsed.getTime())) {
      hh = parsed.getUTCHours();
      min = parsed.getUTCMinutes();
      ss = parsed.getUTCSeconds();
    } else {
      const parts = swipeTime.split(':').map(p => parseInt(p, 10));
      if (parts.length >= 2) {
        hh = parts[0] || 0;
        min = parts[1] || 0;
        ss = parts[2] || 0;
      }
    }
  }
  return new Date(yy, mm - 1, dd, hh, min, ss);
};

export default function ReportsPage() {
  const auth = useAuth();

  // --- state ---
  const [tab, setTab] = useState(0);

  const [region, setRegion] = useState('emea');
  const [location, setLocation] = useState('');
  const [from, setFrom] = useState(null);
  const [to, setTo] = useState(null);
  const [showFromCal, setShowFromCal] = useState(false);
  const [showToCal, setShowToCal] = useState(false);
  const [selectedEmps, setSelectedEmps] = useState([]);
  const [loading, setLoading] = useState(false);

  const [rawSearch, setRawSearch] = useState('');
  const [rawAdmitFilter, setRawAdmitFilter] = useState('all');

  // Handle tab switch (Daily / Raw / Rejection)
  const handleTabChange = (_, v) => {
    setTab(v);
    // reset filters
    setRegion('emea');
    setLocation('');
    setFrom(null);
    setTo(null);
    setSelectedEmps([]);
    setRawSearch('');
    setRawAdmitFilter('all');
  };

  /** Time Duration Excel generator */
  const generateTimeDurationExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Time Duration');

    ws.mergeCells('A1:M1');
    ws.getCell('A1').value =
      `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };

    const headers = [
      'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
      'Partition', 'Text5', 'Year', 'Week', 'Date',
      'First Swipe', 'Last Swipe', 'Duration', 'Category',
      'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'ptype', width: 18 },
      { key: 'part', width: 15 },
      { key: 'txt5', width: 20 },
      { key: 'year', width: 8 },
      { key: 'week', width: 6 },
      { key: 'date', width: 12 },
      { key: 'first', width: 16 },
      { key: 'last', width: 16 },
      { key: 'dur', width: 10 },
      { key: 'cat', width: 12 },
      { key: 'dpw', width: 12 },
      { key: 'vdw', width: 14 },
      { key: 'cdw', width: 12 },
      { key: 'def', width: 10 }
    ];

    data.forEach((r, idx) => {
      const first = new Date(r.FirstSwipeTime);
      const last = new Date(r.LastSwipeTime);
      const date = new Date(r.ShiftedDate);
      const row = ws.addRow([
        idx + 1,
        r.ObjectName1,
        r.EmployeeID,
        r.PersonnelType,
        r.PartitionName2,
        r.text5,
        r.YearNumber,
        r.WeekNumber,
        date,
        first,
        last,
        r.DurationHHMM,
        r.TimeDiffCategory,
        r.DaysPresentInWeek,
        r.ViolationDaysInWeek,
        r.CleanDaysInWeek,
        r.Defaulter
      ]);

      row.getCell(9).numFmt = 'dd-mmm-yy';
      row.getCell(10).numFmt = 'h:mm:ss AM/PM';
      row.getCell(11).numFmt = 'h:mm:ss AM/PM';

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    ws.autoFilter = 'A2:Q2';

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    const filename =
      `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;

    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  // Daily Access Excel
  const generateDailyAccessExcel = async allRows => {
    const wb = new ExcelJS.Workbook();

    for (const emp of selectedEmps) {
      const ws = wb.addWorksheet(emp.substring(0, 31));
      const headers = [
        'Date', 'Time', 'Name', 'Contractor ID', 'Card No',
        'Door Name', 'Message Type', 'Partition', 'Swipe'
      ];
      ws.addRow(headers);
      const hdr = ws.getRow(1);
      hdr.font = { bold: true };
      hdr.alignment = { vertical: 'middle', horizontal: 'center' };
      hdr.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });

      ws.columns = [
        { key: 'date', width: 12 },
        { key: 'time', width: 12 },
        { key: 'name', width: 25 },
        { key: 'id', width: 15 },
        { key: 'card', width: 15 },
        { key: 'door', width: 40 },
        { key: 'msg', width: 15 },
        { key: 'part', width: 15 },
        { key: 'swipe', width: 10 }
      ];

      const rows = allRows.filter(r => r.ObjectName1 === emp);
      if (!rows.length) {
        ws.mergeCells('A2', 'I2');
        ws.getCell('A2').value = 'There is no swipe records found in Ccure';
        ws.getCell('A2').alignment = { horizontal: 'center' };
      } else {
        rows.forEach(r => {
          const iso = getServerISO(r);
          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws.addRow([
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.EmployeeID || '',
            r.CardNumber || '',
            r.Door || r.ObjectName2 || '',
            r.AdmitCode || r.Messagetype || '',
            r.location || '',
            r.Swipe || r.Direction || ''
          ]);

          row.getCell(1).alignment = { horizontal: 'left' };
          row.getCell(2).alignment = { horizontal: 'left' };

          row.eachCell(c => {
            c.border = {
              top: { style: 'thin' }, left: { style: 'thin' },
              bottom: { style: 'thin' }, right: { style: 'thin' }
            };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });
      }
      ws.autoFilter = 'A1:I1';
    }

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const filename = `Daily Access Report(${formatDisplayDate(from)} to ${formatDisplayDate(to)}).xlsx`;
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  // Rejection Excel
  const generateRejectionExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Rejection');

    const title = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}`;
    ws.mergeCells('A1:J1');
    ws.getCell('A1').value = title;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };

    const headers = [
      'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
      'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'date', width: 12 },
      { key: 'time', width: 12 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'card', width: 15 },
      { key: 'type', width: 15 },
      { key: 'door', width: 40 },
      { key: 'loc', width: 15 },
      { key: 'swipe', width: 10 }
    ];

    data.forEach((r, idx) => {
      const iso = getServerISO(r);
      const dateStr = iso ? formatDateFromServerISO(iso) : '';
      const timeStr = iso ? formatTimeFromServerISO(iso) : '';

      const row = ws.addRow([
        idx + 1,
        dateStr,
        timeStr,
        r.ObjectName1 || '',
        r.EmployeeID || '',
        r.CardNumber || '',
        r.Rejection_Type || '',
        r.Door || r.ObjectName2 || '',
        r.location || '',
        r.Direction || r.Swipe || ''
      ]);

      row.getCell(2).alignment = { horizontal: 'left' };
      row.getCell(3).alignment = { horizontal: 'left' };

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    const counts = data.reduce((a, r) => {
      const k = r.Rejection_Type || 'Unknown';
      a[k] = (a[k] || 0) + 1; return a;
    }, {});
    let rowIdx = 3;
    ws.getCell(rowIdx, 11).value = 'Rejection';
    ws.getCell(rowIdx, 12).value = 'Count';
    [11, 12].forEach(c => {
      const cell = ws.getCell(rowIdx, c);
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'center' };
      cell.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });
    rowIdx++;
    Object.entries(counts).forEach(([type, cnt]) => {
      ws.getCell(rowIdx, 11).value = type;
      ws.getCell(rowIdx, 12).value = cnt;
      [11, 12].forEach(c => {
        const cell = ws.getCell(rowIdx, c);
        cell.alignment = { horizontal: 'left' };
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });
      rowIdx++;
    });
    ws.getCell(rowIdx, 11).value = 'Total';
    ws.getCell(rowIdx, 12).value = data.length;
    [11, 12].forEach(c => {
      const cell = ws.getCell(rowIdx, c);
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'left' };
      cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
    });

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const filename = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}.xlsx`;
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  // generateRawExcel
  const generateRawExcel = async (rows, opts = {}) => {
    const formatTimeFromSwipe = (swipeIso) => {
      if (!swipeIso) return '';
      const dt = new Date(swipeIso);
      if (!isNaN(dt.getTime())) {
        return formatTimeFromServerISO(swipeIso);
      }
      const parts = ('' + swipeIso).split(':').map(p => parseInt(p || 0, 10));
      const hh = parts[0] || 0;
      const mm = parts[1] || 0;
      const ss = parts[2] || 0;
      const ampm = hh >= 12 ? 'PM' : 'AM';
      const hh12 = ((hh + 11) % 12) + 1;
      return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
    };

    const admitFilter = (opts.rawAdmitFilter || 'all').toString().toLowerCase();

    const baseHeaders = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber'];
    const admitCol = 'AdmitCode';
    const rejCol = 'Rejection_Type';
    const tailCols = ['Direction','Door'];

    let headers = [...baseHeaders];
    if (admitFilter === 'all') {
      headers.push(admitCol);
      headers.push(...tailCols);
      headers.push(rejCol);
    } else if (admitFilter === 'admit') {
      headers.push(admitCol);
      headers.push(...tailCols);
    } else if (admitFilter === 'reject') {
      headers.push(...tailCols);
      headers.push(rejCol);
    } else {
      headers.push(admitCol);
      headers.push(...tailCols);
      headers.push(rejCol);
    }

    if (!rows || !rows.length) {
      const wbEmpty = XLSX.utils.book_new();
      const wsEmpty = XLSX.utils.aoa_to_sheet([headers]);
      XLSX.utils.book_append_sheet(wbEmpty, wsEmpty, 'Raw');
      const fileNameEmpty = buildRawFileName(opts);
      XLSX.writeFile(wbEmpty, fileNameEmpty);
      return;
    }

    const rowsForSheet = rows.map(r => {
      const iso = getServerISO(r);
      const dateStr = iso ? formatDateFromServerISO(iso) : '';
      const timeStr = iso ? formatTimeFromServerISO(iso) : '';
      const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');
      const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';
      const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

      const fullObj = {
        LocaleMessageTime: localeMsgFormatted,
        DateOnly: dateOnlyFormatted,
        Swipe_Time: swipeTimeFormatted,
        EmployeeID: r.EmployeeID || '',
        ObjectName1: r.ObjectName1 || '',
        PersonnelType: r.PersonnelType || '',
        location: r.location || '',
        CardNumber: r.CardNumber || '',
        AdmitCode: r.AdmitCode || r.Messagetype || '',
        Direction: r.Direction || r.Swipe || '',
        Door: r.Door || r.ObjectName2 || '',
        Rejection_Type: r.Rejection_Type || ''
      };

      const picked = {};
      headers.forEach(h => {
        picked[h] = (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '';
      });
      return picked;
    });

    const ws = XLSX.utils.json_to_sheet(rowsForSheet, { header: headers });
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Raw');

    const filename = buildRawFileName(opts);
    XLSX.writeFile(wb, filename);
  };

  // --- Permission helpers ---
  const exportPermsForTab = () => {
    if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
    if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
    if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
    if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
    if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
    if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
    return ['gsoc_reports'];
  };

  // disabled conditions - UI-level validations (permission gating done separately)
  const disabled = loading
    || !region
    || (tab === 0 && (!from || !to || selectedEmps.length === 0))
    || (tab === 1 && (!from || !to))
    || (tab === 2 && (!from || !to))
    || (tab === 3 && !from)
    || (tab === 4 && (!from || !to));

  const navDisabled = !region || loading;

  const exportAllowed = auth.hasPermission(exportPermsForTab());

  // --- Generate handler with permission check up-front ---
  const handleGenerate = async () => {
    // Permission gating: determine required permission for each tab
    const requirePermissionForTab = () => {
      if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
      if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
      if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
      if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
      if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
      if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
      return ['gsoc_reports'];
    };

    if (!auth.hasPermission(requirePermissionForTab())) {
      alert('You do not have permission to generate this report.');
      return;
    }

    setLoading(true);
    try {
      const baseParams = { region, location: location || undefined };

      // Helper: format dates in local time without timezone conversion for API parameters
      const formatLocalDate = (date, endOfDay = false) => {
        const d = new Date(date);
        if (endOfDay) d.setHours(23, 59, 59, 999);
        else d.setHours(0, 0, 0, 0);
        const pad = n => n.toString().padStart(2, '0');
        return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}` +
               `T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      };

      const toLocalYMD = date => `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`;

      // ----- 0: Daily Access -----
      if (tab === 0) {
        const params = {
          ...baseParams,
          from: formatLocalDate(from),
          to: formatLocalDate(to, true),
          employees: selectedEmps.join(',')
        };
        const resp = await axios.get('/api/reports/daily-access', { params });

        const startDate = new Date(from); startDate.setHours(8, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(8, 0, 0, 0);

        const rows = (resp.data && resp.data.data) || [];
        const filtered = rows.filter(r => {
          const dt = new Date(r.LocaleMessageTime);
          return dt >= startDate && dt < endDate;
        });

        await generateDailyAccessExcel(filtered);
        return;
      }

      // ----- 1: Raw -----
      if (tab === 1) {
        const params = {
          ...baseParams,
          startDate: formatLocalDate(from),
          endDate: formatLocalDate(to, true),
          admitFilter: rawAdmitFilter
        };
        const resp = await axios.get('/api/reports/raw', { params });
        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

        const rowsSrc = (resp.data && resp.data.data) || [];
        const rows = rowsSrc.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          return date >= startDate && date <= endDate;
        });

        let filtered = rows;
        if (rawSearch && rawSearch.trim() !== '') {
          const s = rawSearch.trim().toLowerCase();
          filtered = rows.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            return id.includes(s) || name.includes(s);
          });
        }

        await generateRawExcel(filtered, { region, location, rawSearch, from, to, rawAdmitFilter });
        return;
      }

      // ----- 2: Rejection -----
      if (tab === 2) {
        const params = { ...baseParams, startDate: formatLocalDate(from), endDate: formatLocalDate(to, true) };
        const resp = await axios.get('/api/reports/rejection', { params });

        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

        const rowsSrc = (resp.data && resp.data.data) || [];
        const rows = rowsSrc.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          return date >= startDate && date <= endDate;
        });

        await generateRejectionExcel(rows);
        return;
      }

      // ----- 3: EUROC Admit-Reject (single day) -----
      if (tab === 3) {
        if (region.toLowerCase() !== 'emea') {
          alert('EUROC report is only available for region EMEA. Please select EMEA.');
          return;
        }
        if (!from) {
          alert('Please select a date (From) for EUROC report.');
          return;
        }

        const dateParam = toLocalYMD(new Date(from));
        const params = { region: 'emea', date: dateParam };
        const resp = await axios.get('/api/reports/euroc-admit-rejection', { params });
        const { data } = resp.data || {};

        const wb = new ExcelJS.Workbook();

        // Admit sheet
        const admitTitle = `EUROC Admit Report - ${formatDisplayDate(from)}`;
        const ws1 = wb.addWorksheet('EUROC Admit');
        ws1.mergeCells('A1:I1');
        ws1.getCell('A1').value = admitTitle;
        ws1.getCell('A1').font = { bold: true, size: 14 };
        ws1.getCell('A1').alignment = { horizontal: 'center' };

        const admitHeaders = [
          'Sr. No.', 'Date', 'Time', 'Employee Name',
          'Access Card No.', 'Personnel Type', 'Door Name', 'Location', 'Swipe'
        ];
        const hdrRow1 = ws1.addRow(admitHeaders);
        hdrRow1.font = { bold: true };
        hdrRow1.alignment = { vertical: 'middle', horizontal: 'center' };
        hdrRow1.eachCell(c => {
          c.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
        });

        ws1.columns = [
          { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
          { key:'name', width:30 }, { key:'card', width:15 }, { key:'ptype', width:20 },
          { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
        ];

        (data.admit || []).forEach((r, idx) => {
          let iso;
          if (r.LocaleMessageTime) {
            iso = r.LocaleMessageTime;
          } else if (r.DateOnly) {
            iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
          } else {
            iso = '';
          }

          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws1.addRow([
            idx + 1,
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.CardNumber || '',
            r.PersonnelType || '',
            r.Door || r.ObjectName2 || '',
            r.location || '',
            r.Direction || ''
          ]);

          row.getCell(2).alignment = { horizontal: 'left' };
          row.getCell(3).alignment = { horizontal: 'left' };
          row.eachCell(c => {
            c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        // Rejection sheet
        const ws2 = wb.addWorksheet('EUROC Rejection');
        ws2.mergeCells('A1:J1');
        ws2.getCell('A1').value = `EUROC Rejection Report - ${formatDisplayDate(from)}`;
        ws2.getCell('A1').font = { bold: true, size: 14 };
        ws2.getCell('A1').alignment = { horizontal: 'center' };

        const headerRow2 = ws2.addRow(['Sr. No.', 'Date', 'Time', 'Employee Name', 'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe']);
        headerRow2.font = { bold: true };
        headerRow2.alignment = { vertical: 'middle', horizontal: 'center' };
        headerRow2.eachCell(c => {
          c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });

        ws2.columns = [
          { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
          { key:'name', width:30 }, { key:'card', width:15 }, { key:'type', width:15 },
          { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
        ];

        (data.rejection || []).forEach((r, idx) => {
          let iso;
          if (r.LocaleMessageTime) {
            iso = r.LocaleMessageTime;
          } else if (r.DateOnly) {
            iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
          } else {
            iso = '';
          }

          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws2.addRow([
            idx + 1,
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.CardNumber || '',
            r.Rejection_Type || '',
            r.Door || '',
            r.location || '',
            r.Direction || ''
          ]);

          row.getCell(2).alignment = { horizontal: 'left' };
          row.getCell(3).alignment = { horizontal: 'left' };
          row.eachCell(c => {
            c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        // Summary block
        const counts = data.summary || [];
        let startRow = 3;
        ws2.getCell(startRow, 11).value = 'Rejection';
        ws2.getCell(startRow, 12).value = 'Count';
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.font = { bold: true };
          cell.alignment = { horizontal: 'center' };
          cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });
        startRow++;
        counts.forEach(c => {
          ws2.getCell(startRow, 11).value = c.Rejection_Type || 'Unknown';
          ws2.getCell(startRow, 12).value = c.Count || 0;
          [11, 12].forEach(col => {
            const cell = ws2.getCell(startRow, col);
            cell.alignment = { horizontal: 'left' };
            cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
          });
          startRow++;
        });
        ws2.getCell(startRow, 11).value = 'Grand Total';
        ws2.getCell(startRow, 12).value = (data.rejection || []).length;
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.font = { bold: true };
          cell.alignment = { horizontal: 'left' };
          cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });

        const buf = await wb.xlsx.writeBuffer();
        const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const filename = `EUROC_Admit_Rejection_${dateParam}.xlsx`;
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        return;
      }

      // ----- 4: Time Duration -----
      if (tab === 4) {
        if (!from || !to) {
          alert('Please select both Start Date and End Date for Time Duration report.');
          return;
        }
        const startParam = toLocalYMD(new Date(from));
        const endParam = toLocalYMD(new Date(to));
        const params = {
          region,
          startDate: startParam,
          endDate: endParam,
          partition: location ? location.split('.').pop() : 'Default'
        };
        const resp = await axios.get('/api/reports/time-duration', { params });
        await generateTimeDurationExcel(resp.data.data || []);
        return;
      }

      // ----- 5: HeadCount / External navigation -----
      if (tab === 5) {
        // final permission check (region specific)
        const permCandidates = [`headcount.${region}`, 'headcount', 'global_access'];
        if (!auth.hasPermission(permCandidates)) {
          alert(`You do not have permission to view HeadCount for ${region.toUpperCase()}.`);
          setLoading(false);
          return;
        }

        let url = '';

        if (region === 'laca') {
          if (!location) url = 'http://10.199.22.57:3003/history';
          else {
            const LACA_URLS = {
              'CR.Costa Rica Partition': 'http://10.199.22.57:3003/partition/CR.Costa%20Rica%20Partition/history',
              'MX.Mexico City': 'http://10.199.22.57:3003/partition/MX.Mexico%20City/history',
              'AR.Cordoba': 'http://10.199.22.57:3003/partition/AR.Cordoba/history',
              'PA.Panama City': 'http://10.199.22.57:3003/partition/PA.Panama%20City/history',
              'PE.Lima': 'http://10.199.22.57:3003/partition/PE.Lima/history',
              'BR.Sao Paulo': 'http://10.199.22.57:3003/partition/BR.Sao%20Paulo/history'
            };
            url = LACA_URLS[location] || 'http://10.199.22.57:3003/history';
          }
        } else if (region === 'namer') {
          if (!location) url = 'http://10.199.22.57:3002/history';
          else {
            const NAMER_URLS = {
              'US.Denver': 'http://10.199.22.57:3002/partition/US.CO.OBS/history',
              'US.Miami': 'http://10.199.22.57:3002/partition/US.FL.Miami/history',
              'US.NYC': 'http://10.199.22.57:3002/partition/US.NYC/history',
              'US.Austin': 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default/history'
            };
            url = NAMER_URLS[location] || 'http://10.199.22.57:3002/history';
          }
        } else if (region === 'apac') {
          if (!location) url = 'http://10.199.22.57:3000/history';
          else {
            const APAC_URLS = {
              'APAC.Default': 'http://10.199.22.57:3000/partition/Pune/history',
              'MY.Kuala Lumpur': 'http://10.199.22.57:3000/partition/MY.Kuala Lumpur/history',
              'PH.Manila': 'http://10.199.22.57:3000/partition/PH.Manila/history',
              'JP.Tokyo': 'http://10.199.22.57:3000/history',
              'CN.Beijing': 'http://10.199.22.57:3000/history'
            };
            url = APAC_URLS[location] || 'http://10.199.22.57:3000/history';
          }
        } else if (region === 'emea') {
          if (!location) url = 'http://10.199.22.57:3001/history';
          else {
            const EMEA_URLS = {
              'AUT.Vienna': 'http://10.199.22.57:3001/history',
              'DU.Abu Dhabi': 'http://10.199.22.57:3001/history',
              'IE.Dublin': 'http://10.199.22.57:3001/history',
              'IT.Rome': 'http://10.199.22.57:3001/history',
              'LT.Vilnius': 'http://10.199.22.57:3001/history',
              'MA.Casablanca': 'http://10.199.22.57:3001/history',
              'RU.Moscow': 'http://10.199.22.57:3001/history',
              'UK.London': 'http://10.199.22.57:3001/history',
              'ES.Madrid': 'http://10.199.22.57:3001/history'
            };
            url = EMEA_URLS[location] || 'http://10.199.22.57:3001/history';
          }
        }

        if (url) window.location.href = url;
        else alert('Invalid region or location selected.');
        return;
      }

    } catch (err) {
      console.error(err);
      alert('Failed to generate report');
    } finally {
      setLoading(false);
    }
  };

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
        {/* Topbar / Header */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            px: 3,
            py: 2,
            borderBottom: '1px solid rgba(255,204,0,0.08)',
            background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
          }}
        >
          <Avatar sx={{ bgcolor: '#000', border: '3px solid #FFCC00', width: 56, height: 56 }}>
            <Typography sx={{ color: '#FFCC00', fontWeight: 900 }}>WU</Typography>
          </Avatar>

          <Box sx={{ flex: 1 }}>
            <Typography variant="h5" sx={{ fontWeight: 900, letterSpacing: 0.6 }}>
              Global Security Operation Center
            </Typography>
            <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
              Reports & Exports — Secure access, fast insights
            </Typography>
          </Box>

          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
            <Button
              startIcon={<DownloadIcon />}
              onClick={handleGenerate}
              disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
              sx={{
                bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                color: '#000',
                fontWeight: 800,
                px: 3,
                py: 1,
                borderRadius: 3,
                boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
                transformOrigin: 'center',
                '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-2px)' : 'none' }
              }}
            >
              {loading ? 'Loading…'
                : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
            </Button>
          </Box>
        </Box>

        {/* Main content: Sidebar + Content */}
        <Grid container sx={{ px: 3, py: 4 }} spacing={3}>
          {/* Sidebar */}
          <Grid item xs={12} md={3}>
            <Paper
              elevation={8}
              sx={{
                p: 2.5,
                borderRadius: 3,
                height: { xs: 'auto', md: 'calc(100vh - 150px)' },
                overflow: 'auto',
                background: 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015))',
                border: '1px solid rgba(255,204,0,0.06)'
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
                <Box>
                  <Typography variant="subtitle1" sx={{ fontWeight: 800, color: '#FFCC00' }}>Filters</Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Narrow down by region, date and employees
                  </Typography>
                </Box>
                <IconButton size="small" sx={{ color: '#FFCC00' }}>
                  <FilterListIcon />
                </IconButton>
              </Box>

              <Divider sx={{ my: 1, borderColor: 'rgba(255,204,0,0.06)' }} />

              {/* Region */}
              <Box sx={{ mt: 1 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Region</InputLabel>
                  <Select
                    value={region}
                    onChange={e => { setRegion(e.target.value); setLocation(''); }}
                    input={<OutlinedInput label="Region" />}
                    sx={{
                      color: '#fff',
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.24)' }
                    }}
                  >
                    {REGION_OPTIONS.map(r => <MenuItem key={r} value={r}>{r.toUpperCase()}</MenuItem>)}
                  </Select>
                </FormControl>
              </Box>

              {/* Location */}
              <Box sx={{ mt: 2 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Location</InputLabel>
                  <Select
                    value={location}
                    onChange={e => setLocation(e.target.value)}
                    input={<OutlinedInput label="Location" />}
                    disabled={!region}
                    sx={{
                      color: '#fff',
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                    }}
                  >
                    {(LOCATION_MAP[region] || []).map(loc => <MenuItem key={loc} value={loc}>{loc.split('.').pop()}</MenuItem>)}
                  </Select>
                </FormControl>
              </Box>

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />

              {tab === 1 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employee (name or ID)
                  </Typography>
                  <TextField
                    fullWidth
                    placeholder="Type employee name or ID (e.g. 'Jejurkar' or '323471')"
                    label="Search Employee"
                    value={rawSearch}
                    onChange={(e) => setRawSearch(e.target.value)}
                    sx={{
                      '& .MuiInputBase-input': { color: '#fff' },
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                    }}
                    InputLabelProps={{ style: { color: '#FFCC00' } }}
                  />
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                    Leave empty to export all raw rows for the date range.
                  </Typography>

                  <Box sx={{ mt: 2 }}>
                    <FormControl fullWidth>
                      <InputLabel sx={{ color: '#FFCC00' }}>Admit / Reject</InputLabel>
                      <Select
                        value={rawAdmitFilter}
                        onChange={(e) => setRawAdmitFilter(e.target.value)}
                        input={<OutlinedInput label="Admit / Reject" />}
                        sx={{
                          color: '#fff',
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                        }}
                      >
                        <MenuItem value="all">All (Admitted + Rejected)</MenuItem>
                        <MenuItem value="admit">Admitted only</MenuItem>
                        <MenuItem value="reject">Rejected only</MenuItem>
                      </Select>
                    </FormControl>
                    <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                      Default = All.
                    </Typography>
                  </Box>
                </Box>
              )}

              {/* Dates */}
              {tab !== 5 && (
                <Box>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Date Range
                  </Typography>
                  <Box sx={{ display: 'grid', gap: 1.25 }}>
                    <TextField
                      label={tab === 0 ? 'From Date' : 'Start Date'}
                      value={from ? from.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowFromCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                    <TextField
                      label={tab === 0 ? 'To Date' : 'End Date'}
                      value={to ? to.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowToCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                  </Box>

                  {showFromCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={from}
                        onChange={(newValue) => setFrom(newValue)}
                        onAccept={() => setShowFromCal(false)}
                        onClose={() => setShowFromCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                  {showToCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={to}
                        onChange={(newValue) => setTo(newValue)}
                        onAccept={() => setShowToCal(false)}
                        onClose={() => setShowToCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                </Box>
              )}

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />

              {tab === 0 && (
                <Box>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employees
                  </Typography>
                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Employees</InputLabel>
                    <Select
                      multiple
                      value={selectedEmps}
                      onChange={e => setSelectedEmps(e.target.value)}
                      input={<OutlinedInput label="Employees" />}
                      renderValue={vals => vals.join(', ')}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                      }}
                    >
                      {EMPLOYEE_OPTIONS.map(n => (
                        <MenuItem key={n} value={n}>
                          <Checkbox checked={selectedEmps.includes(n)} />
                          <ListItemText primary={n} />
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              )}

              <Box sx={{ mt: 3, p: 2, borderRadius: 2, background: 'rgba(255,255,255,0.02)' }}>
                <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                  Tip: For daily exports pick employees & a single day range. For Time Duration choose the required partition via Location.
                </Typography>
              </Box>
            </Paper>
          </Grid>

          {/* Main panel */}
          <Grid item xs={12} md={9}>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              <Paper
                elevation={3}
                sx={{
                  px: 2,
                  py: 1,
                  borderRadius: 2,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  gap: 2,
                  border: '1px solid rgba(255,204,0,0.04)'
                }}
              >
                <Tabs
                  value={tab}
                  onChange={handleTabChange}
                  sx={{
                    '& .MuiTab-root': {
                      textTransform: 'none',
                      minWidth: 120,
                      fontWeight: 700,
                      color: 'rgba(255,255,255,0.8)'
                    },
                    '& .Mui-selected': { color: '#FFCC00' }
                  }}
                >
                  <Tab icon={<CalendarTodayIcon />} label="Daily Access" />
                  <Tab icon={<PeopleIcon />} label="Raw" />
                  <Tab icon={<PlaceIcon />} label="Rejection" />
                  <Tab icon={<PeopleIcon />} label="EUROC Admit-Reject" />
                  <Tab icon={<CalendarTodayIcon />} label="Time Duration" />
                  <Tab icon={<PeopleIcon />} label="HeadCount" />
                </Tabs>

                <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                  <Button
                    variant="text"
                    startIcon={<FilterListIcon />}
                    sx={{ color: 'rgba(255,255,255,0.65)', textTransform: 'none' }}
                    onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}
                  >
                    Reset View
                  </Button>
                </Box>
              </Paper>

              <Paper elevation={6} sx={{ p: 3, borderRadius: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 2 }}>
                <Box>
                  <Typography variant="h6" sx={{ fontWeight: 900 }}>Export Center</Typography>
                  <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                    Selected Region: <strong style={{ color: '#FFCC00' }}>{region.toUpperCase()}</strong> {location ? `• ${location.split('.').pop()}` : ''}
                  </Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Choose tab, select filters and export reports in Excel.
                  </Typography>
                </Box>

                <Box>
                  <Button
                    startIcon={loading ? <CircularProgress size={20} /> : <DownloadIcon />}
                    disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
                    onClick={handleGenerate}
                    sx={{
                      bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                      color: '#000',
                      fontWeight: 900,
                      px: 4,
                      py: 1,
                      borderRadius: 3,
                      boxShadow: '0 8px 30px rgba(255,204,0,0.22)',
                      '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-3px)' : 'none' }
                    }}
                  >
                    {loading
                      ? 'Loading…'
                      : (tab === 5
                          ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`)
                          : 'Export to Excel')}
                  </Button>
                </Box>
              </Paper>

            </Box>
          </Grid>

        </Grid>
      </Box>
    </LocalizationProvider>
  );
}








// frontend/src/App.jsx
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import { Box } from '@mui/material';

import GlobalPage   from './pages/GlobalPage.jsx';
import VipPage      from './pages/VipPage.jsx';
import ReportsPage  from './pages/ReportsPage.jsx';
import DurationPage from "./pages/DurationPage";
import { AuthProvider, useAuth } from './context/AuthContext';
import LoginPage from './pages/LoginPage';
import ProtectedRoute from './components/ProtectedRoute';
import AccessManager from './pages/AccessManager';

// Optional: small wrapper to redirect authed users from /login
function LoginGuard() {
  const auth = useAuth();
  if (auth.loading) return null;
  if (auth.user) return <Navigate to="/" replace />;
  return <LoginPage />;
}

export default function App() {
  return (
    <AuthProvider>
      <Routes>
        <Route path="/login" element={<LoginGuard />} />

        <Route path="/" element={
          <ProtectedRoute>
            <GlobalPage />
          </ProtectedRoute>
        } />

        <Route path="/vip" element={
          <ProtectedRoute>
            <VipPage />
          </ProtectedRoute>
        } />

        <Route path="/reports" element={
          <ProtectedRoute>
            <ReportsPage />
          </ProtectedRoute>
        } />

        <Route path="/duration" element={
          <ProtectedRoute permission="global_duration">
            <DurationPage />
          </ProtectedRoute>
        } />

        <Route path="/access-manager" element={
          <ProtectedRoute permission="can_grant">
            <AccessManager />
          </ProtectedRoute>
        } />

        {/* fallback */}
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </AuthProvider>
  );
}








// backend/routes/auth.js
import express from 'express';
import { readFile, writeFile } from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import crypto from 'crypto';

const router = express.Router();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const USERS_FILE = path.resolve(__dirname, '../config/users.json');

// In-memory token->employeeId map (lost on server restart)
const activeTokens = new Map();

async function loadUsers() {
  try {
    const raw = await readFile(USERS_FILE, 'utf8');
    const obj = JSON.parse(raw);
    return obj && Array.isArray(obj.users) ? obj.users : [];
  } catch (err) {
    // If missing file, return empty array
    return [];
  }
}

async function saveUsers(users) {
  const payload = { users };
  await writeFile(USERS_FILE, JSON.stringify(payload, null, 2), 'utf8');
}

function genToken() {
  return crypto.randomBytes(32).toString('hex');
}

function findUser(users, { username, employeeId }) {
  if (employeeId) {
    const byId = users.find(u => String(u.employeeId).toLowerCase() === String(employeeId).toLowerCase());
    if (byId) return byId;
  }
  if (username) {
    const byName = users.find(u => String(u.username).toLowerCase() === String(username).toLowerCase());
    if (byName) return byName;
    // also allow login by exact EmployeeID sent in username field
    const byId2 = users.find(u => String(u.employeeId).toLowerCase() === String(username).toLowerCase());
    if (byId2) return byId2;
  }
  return null;
}

// middleware to require token and attach user object to req.currentUser
async function requireAuth(req, res, next) {
  try {
    const auth = req.headers.authorization || '';
    if (!auth.startsWith('Bearer ')) return res.status(401).json({ detail: 'Missing auth token' });
    const token = auth.slice(7).trim();
    const empId = activeTokens.get(token);
    if (!empId) return res.status(401).json({ detail: 'Invalid or expired token' });

    const users = await loadUsers();
    const user = users.find(u => String(u.employeeId).toLowerCase() === String(empId).toLowerCase());
    if (!user) return res.status(401).json({ detail: 'Invalid token (user not found)' });

    req.currentUser = user;
    req.currentToken = token;
    next();
  } catch (err) {
    next(err);
  }
}

// --- POST /login
// body: { username, password }
router.post('/login', async (req, res, next) => {
  try {
    const { username, password } = req.body || {};
    if (!username || !password) return res.status(400).json({ detail: 'username and password are required' });

    const users = await loadUsers();
    const user = findUser(users, { username });
    if (!user) return res.status(401).json({ detail: 'Invalid credentials' });

    // plain-text compare for prototype. Replace with bcrypt in prod.
    if (String(user.password || '') !== String(password)) return res.status(401).json({ detail: 'Invalid credentials' });

    // generate token and store mapping
    const token = genToken();
    activeTokens.set(token, user.employeeId);

    // Return minimal user object (do not expose password)
    const safeUser = {
      username: user.username,
      employeeId: user.employeeId,
      // you can include additional fields if present
    };

    return res.json({ token, user: safeUser, permissions: user.permissions || {} });
  } catch (err) {
    next(err);
  }
});

// --- GET /me
// header: Authorization: Bearer <token>
router.get('/me', requireAuth, async (req, res, next) => {
  try {
    const user = req.currentUser;
    const safeUser = { username: user.username, employeeId: user.employeeId };
    return res.json({ user: safeUser, permissions: user.permissions || {} });
  } catch (err) {
    next(err);
  }
});

// --- POST /grant
// body: { grantee_employee_id, grantee_name, pages: ['headcount','ert', ...] }
// Only callers with currentUser.permissions.can_grant === true
router.post('/grant', requireAuth, async (req, res, next) => {
  try {
    const caller = req.currentUser;
    if (!caller.permissions || !caller.permissions.can_grant) return res.status(403).json({ detail: 'You do not have grant permission' });

    const { grantee_employee_id, grantee_name, pages } = req.body || {};
    if ((!grantee_employee_id && !grantee_name) || !Array.isArray(pages)) {
      return res.status(400).json({ detail: 'grantee_employee_id or grantee_name and pages[] are required' });
    }

    const users = await loadUsers();

    let grantee = findUser(users, { employeeId: grantee_employee_id, username: grantee_name });

    if (!grantee) {
      // create minimal user record (password blank) — admin should set password later
      grantee = {
        username: grantee_name || (grantee_employee_id ? `emp-${grantee_employee_id}` : 'unknown'),
        employeeId: grantee_employee_id || `unknown-${Date.now()}`,
        password: '',
        permissions: {}
      };
      users.push(grantee);
    }

    if (!grantee.permissions) grantee.permissions = {};
    for (const p of pages) {
      grantee.permissions[p] = true;
    }

    await saveUsers(users);

    // Return updated grantee (sans password)
    const safeGrantee = { username: grantee.username, employeeId: grantee.employeeId, permissions: grantee.permissions };
    return res.json({ ok: true, grantee: safeGrantee });
  } catch (err) {
    next(err);
  }
});

// --- POST /revoke
// body: { grantee_employee_id, grantee_name, pages: ['headcount', ...] }
// Only callers with can_grant
router.post('/revoke', requireAuth, async (req, res, next) => {
  try {
    const caller = req.currentUser;
    if (!caller.permissions || !caller.permissions.can_grant) return res.status(403).json({ detail: 'You do not have grant permission' });

    const { grantee_employee_id, grantee_name, pages } = req.body || {};
    if ((!grantee_employee_id && !grantee_name) || !Array.isArray(pages)) {
      return res.status(400).json({ detail: 'grantee_employee_id or grantee_name and pages[] are required' });
    }

    const users = await loadUsers();
    const grantee = findUser(users, { employeeId: grantee_employee_id, username: grantee_name });
    if (!grantee) return res.status(404).json({ detail: 'Grantee not found' });

    if (!grantee.permissions) grantee.permissions = {};
    for (const p of pages) {
      delete grantee.permissions[p]; // remove key
    }

    await saveUsers(users);

    const safeGrantee = { username: grantee.username, employeeId: grantee.employeeId, permissions: grantee.permissions };
    return res.json({ ok: true, grantee: safeGrantee });
  } catch (err) {
    next(err);
  }
});

// --- GET /list  (debug; returns users without passwords)
router.get('/list', requireAuth, async (req, res, next) => {
  try {
    const users = await loadUsers();
    const safe = users.map(u => ({ username: u.username, employeeId: u.employeeId, permissions: u.permissions || {} }));
    return res.json({ users: safe });
  } catch (err) {
    next(err);
  }
});

export default router;










// C:\Users\W0024618\Desktop\global-page\backend\index.js
import express from 'express';
import cors from 'cors';
import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';
import reportsRouter from './routes/reports.js';
import headcountRouter from './routes/headcount.js';
import vipRouter       from './routes/vip.js';
import authRouter      from './routes/auth.js';   // <-- NEW

const __filename = fileURLToPath(import.meta.url);
const __dirname  = dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3008;

// 1) Middleware
app.use(cors());              // enable CORS for all origins
app.use(express.json());      // parse JSON payloads

// 2) Static Assets (if you have any in ../public)
app.use(express.static(resolve(__dirname, '../public')));

// 3) API Routes
app.use('/api/headcount', headcountRouter);
app.use('/api/vip',       vipRouter);
app.use('/api/reports',   reportsRouter);
app.use('/api/auth',      authRouter);   // <-- NEW

// 4) Health-check endpoint (optional)
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok', uptime: process.uptime() });
});

// 5) Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res
    .status(err.status || 500)
    .json({ error: err.message || 'Internal Server Error' });
});

// 6) Start server
app.listen(PORT, () => {
  console.log(`🌍 Global-backend listening on http://localhost:${PORT}`);
});

