def get_personnel_info(candidate_identifier: object) -> Dict[str, Any]:
    """
    Try to resolve personnel record using a flexible lookup.
    Returns dict with keys: ObjectID (may be None), GUID, Name, EmailAddress, EmployeeEmail, ManagerEmail
    If resolution fails returns empty dict.
    """
    out: Dict[str, Any] = {}
    if candidate_identifier is None:
        return out
    conn = _get_acvscore_conn()
    if conn is None:
        return out

    try:
        cur = conn.cursor()
        sql = """
            SELECT TOP 1 ObjectID, GUID, Name, EmailAddress, ManagerEmail
            FROM ACVSCore.Access.Personnel
            WHERE
              (CAST(ObjectID AS NVARCHAR(200)) = ?)
              OR (GUID = ?)
              OR (CAST(Int1 AS NVARCHAR(200)) = ?)
              OR (Text12 = ?)
              OR (Name = ?)
            ORDER BY ObjectID DESC
        """
        cand = str(candidate_identifier).strip()
        params = (cand, cand, cand, cand, cand)
        cur.execute(sql, params)
        row = cur.fetchone()
        if row:
            # defensive: normalize and produce EmployeeEmail alias
            objid = row[0] if len(row) > 0 else None
            guid = row[1] if len(row) > 1 else None
            name = row[2] if len(row) > 2 else None
            email = row[3] if len(row) > 3 else None
            mgr =  row[4] if len(row) > 4 else None

            out['ObjectID'] = objid
            out['GUID'] = guid
            out['Name'] = name
            out['EmailAddress'] = email
            # add alias so callers that expect EmployeeEmail will find it
            out['EmployeeEmail'] = email
            out['ManagerEmail'] = mgr
    except Exception:
        logging.exception("Failed personnel lookup for candidate: %s", candidate_identifier)
    finally:
        try:
            cur.close()
        except Exception:
            pass
        try:
            conn.close()
        except Exception:
            pass

    return out







def get_person_image_bytes(parent_id) -> Optional[bytes]:
    """
    Query ACVSCore.Access.Images for top image where ParentId ~ parent_id and return raw bytes.
    Handles common ParentId variants (numeric, 'emp:<id>' prefix, GUID-containing).
    Returns None if not found or on error.
    """
    conn = _get_acvscore_conn()
    if conn is None:
        return None
    try:
        cur = conn.cursor()

        # Try 1: exact match (most common)
        sql = """
            SELECT TOP 1 AI.Image
            FROM ACVSCore.Access.Images AI
            WHERE AI.ParentId = ?
              AND DATALENGTH(AI.Image) > 0
            ORDER BY AI.ObjectID DESC
        """
        try:
            cur.execute(sql, (str(parent_id),))
            row = cur.fetchone()
            if row and row[0] is not None:
                try:
                    return bytes(row[0])
                except Exception:
                    return row[0]
        except Exception:
            # swallow per-attempt errors and try fallbacks
            logging.debug("get_person_image_bytes: primary query failed for ParentId=%s", parent_id)

        # Try 2: prefixed parent id (common pattern: 'emp:<id>')
        try:
            pref = f"emp:{str(parent_id)}"
            sql2 = """
                SELECT TOP 1 AI.Image
                FROM ACVSCore.Access.Images AI
                WHERE (AI.ParentId = ?)
                  AND DATALENGTH(AI.Image) > 0
                ORDER BY AI.ObjectID DESC
            """
            cur.execute(sql2, (pref,))
            row = cur.fetchone()
            if row and row[0] is not None:
                try:
                    return bytes(row[0])
                except Exception:
                    return row[0]
        except Exception:
            logging.debug("get_person_image_bytes: prefixed query failed for ParentId=%s", parent_id)

        # Try 3: parent id might be embedded or GUID-like; use LIKE (slow but fallback)
        try:
            s = str(parent_id)
            # basic guard: only use LIKE for short tokens or GUID-like values
            if len(s) <= 64:
                sql3 = """
                    SELECT TOP 1 AI.Image
                    FROM ACVSCore.Access.Images AI
                    WHERE AI.ParentId LIKE '%' + ? + '%'
                      AND DATALENGTH(AI.Image) > 0
                    ORDER BY AI.ObjectID DESC
                """
                cur.execute(sql3, (s,))
                row = cur.fetchone()
                if row and row[0] is not None:
                    try:
                        return bytes(row[0])
                    except Exception:
                        return row[0]
        except Exception:
            logging.debug("get_person_image_bytes: LIKE fallback failed for ParentId=%s", parent_id)

    except Exception:
        logging.exception("Failed to fetch image for ParentId=%s", parent_id)
    finally:
        try:
            cur.close()
        except Exception:
            pass
        try:
            conn.close()
        except Exception:
            pass
    return None















Now Issue is Employee Image and Email is not display here once Review Previous File logic for EMployee inamge and Emial and Fix the image issue..

def get_personnel_info(candidate_identifier: object) -> Dict[str, Any]:
    """
    Try to resolve personnel record using a flexible lookup.
    Returns dict with keys: ObjectID (may be None), GUID, Name, EmailAddress, ManagerEmail
    If resolution fails returns empty dict.
    """
    out: Dict[str, Any] = {}
    if candidate_identifier is None:
        return out
    conn = _get_acvscore_conn()
    if conn is None:
        return out

    try:
        cur = conn.cursor()
        # We'll attempt to match on multiple columns: ObjectID, GUID, Int1, Text12, Name
        # Use parameters (all strings) — SQL will handle mismatched types.
        sql = """
            SELECT TOP 1 ObjectID, GUID, Name, EmailAddress, ManagerEmail
            FROM ACVSCore.Access.Personnel
            WHERE
              (CAST(ObjectID AS NVARCHAR(200)) = ?)
              OR (GUID = ?)
              OR (CAST(Int1 AS NVARCHAR(200)) = ?)
              OR (Text12 = ?)
              OR (Name = ?)
            ORDER BY ObjectID DESC
        """
        cand = str(candidate_identifier).strip()
        params = (cand, cand, cand, cand, cand)
        cur.execute(sql, params)
        row = cur.fetchone()
        if row:
            # columns: ObjectID, GUID, Name, EmailAddress, ManagerEmail
            try:
                out['ObjectID'] = row[0]
                out['GUID'] = row[1]
                out['Name'] = row[2]
                out['EmailAddress'] = row[3]
                out['ManagerEmail'] = row[4]
            except Exception:
                # defensive assignment by index
                out = {
                    'ObjectID': row[0] if len(row) > 0 else None,
                    'GUID': row[1] if len(row) > 1 else None,
                    'Name': row[2] if len(row) > 2 else None,
                    'EmailAddress': row[3] if len(row) > 3 else None,
                    'ManagerEmail': row[4] if len(row) > 4 else None
                }
    except Exception:
        logging.exception("Failed personnel lookup for candidate: %s", candidate_identifier)
    finally:
        try:
            cur.close()
        except Exception:
            pass
        try:
            conn.close()
        except Exception:
            pass

    return out

def get_person_image_bytes(parent_id) -> Optional[bytes]:
    """
    Query ACVSCore.Access.Images for top image where ParentId = parent_id and return raw bytes.
    Returns None if not found or on error.
    """
    conn = _get_acvscore_conn()
    if conn is None:
        return None
    try:
        cur = conn.cursor()
        sql = """
            SELECT TOP 1 AI.Image
            FROM ACVSCore.Access.Images AI
            WHERE AI.ParentId = ?
              AND DATALENGTH(AI.Image) > 0
            ORDER BY AI.ObjectID DESC
        """
        cur.execute(sql, (str(parent_id),))
        row = cur.fetchone()
        if row and row[0] is not None:
            # pyodbc returns buffer/bytearray for varbinary; convert to bytes
            try:
                b = bytes(row[0])
                return b
            except Exception:
                # sometimes row[0] is already bytes-like
                return row[0]
    except Exception:
        logging.exception("Failed to fetch image for ParentId=%s", parent_id)
    finally:
        try:
            cur.close()
        except Exception:
            pass
        try:
            conn.close()
        except Exception:
            pass
    return None

# ---------- New route to serve employee image ----------
# We'll import send_file later where used; define route after app created.

# Try to enable CORS
try:
    from flask_cors import CORS
    has_cors = True
except Exception:
    CORS = None
    has_cors = False

app = Flask(__name__, static_folder=None)
if has_cors:
    CORS(app)
else:
    logging.warning("flask_cors not available; continuing without CORS.")

logging.basicConfig(level=logging.INFO)

# send_file is needed for Excel responses
from flask import send_file
try:
    # optional import; used for styling
    from openpyxl import load_workbook
    from openpyxl.styles import Font, Alignment, Border, Side
    OPENPYXL_AVAILABLE = True
except Exception:
    OPENPYXL_AVAILABLE = False

def _to_python_scalar(x):
    """
    Convert numpy/pandas scalar types to built-in Python types and
    convert NaN-like values to None so JSON is safe.
    """
    try:
        import pandas as _pd
        if isinstance(x, _pd.Timestamp):
            return x.to_pydatetime().isoformat()
    except Exception:
        pass

    try:
        import numpy as _np
        if isinstance(x, _np.generic):
            v = x.item()
            if isinstance(v, float) and _np.isnan(v):
                return None
            return v
    except Exception:
        pass

    try:
        if isinstance(x, float) and math.isnan(x):
            return None
    except Exception:
        pass

    if isinstance(x, (datetime,)):
        return x.isoformat()
    if isinstance(x, (bool, int, str, type(None), float)):
        # convert floats NaN handled above
        return x
    try:
        # fallback to string
        return str(x)
    except Exception:
        return None


_uuid_like_re = re.compile(r'^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$')

def _looks_like_guid(s):
    try:
        if not s or not isinstance(s, str):
            return False
        s = s.strip()
        return bool(_uuid_like_re.match(s)) or s.startswith('name:') or s.startswith('emp:') or s.startswith('uid:')
    except Exception:
        return False







Refer above logic and share me Which part i need to replace here v...


and also share check Frontend details ...
dont make unnecessary changes..






# backend/app.py
from flask import Flask, jsonify, request, send_from_directory, send_file
from datetime import datetime, timedelta, date
from pathlib import Path
import logging
import pandas as pd
import numpy as np
import joblib
import math
import re
import io
import os
import difflib
from typing import Optional, Dict, Any

# project imports (may raise if not present; handled later)
from duration_report import REGION_CONFIG
from config.door_zone import map_door_to_zone, BREAK_ZONES, OUT_OF_OFFICE_ZONE

# trend_runner helpers (some may not exist depending on your version)
try:
    from trend_runner import run_trend_for_date, build_monthly_training, OUTDIR, read_90day_cache, compute_violation_days_map, _strip_uid_prefix as _strip_uid_prefix_tr
except Exception:
    # graceful fallback if some helpers are missing
    try:
        from trend_runner import run_trend_for_date, build_monthly_training, OUTDIR
    except Exception:
        run_trend_for_date = None
        build_monthly_training = None
        OUTDIR = None
    # provide safe stubs for optional helpers used later
    compute_violation_days_map = None
    _strip_uid_prefix_tr = (lambda x: x)

# ---------- Ensure outputs directory exists early ----------
BASE_DIR = Path(__file__).parent.resolve()
DEFAULT_OUTDIR = BASE_DIR / "outputs"
DEFAULT_OUTDIR.mkdir(parents=True, exist_ok=True)

OVERRIDES_FILE = DEFAULT_OUTDIR / "overrides.csv"

# ---------- small helpers ----------
def _slug_city(city: str) -> str:
    if not city:
        return "pune"
    return str(city).strip().lower().replace(" ", "_")

# minimal id normalization helper
def _normalize_id_local(v):
    try:
        if v is None:
            return None
        s = str(v).strip()
        if s == '' or s.lower() in ('nan','none','null','-'):
            return None
        if '.' in s:
            try:
                f = float(s)
                if math.isfinite(f) and f.is_integer():
                    return str(int(f))
            except Exception:
                pass
        return s
    except Exception:
        return None

# ---------- overrides file helpers ----------
def _load_overrides():
    if not OVERRIDES_FILE.exists():
        return {}
    try:
        df = pd.read_csv(OVERRIDES_FILE, dtype=str)
        out = {}
        for _, r in df.iterrows():
            emp = str(r.get('EmployeeID') or r.get('person_uid') or '').strip()
            if not emp:
                continue
            out[emp] = {
                'level': str(r.get('OverrideLevel') or '').strip(),
                'reason': str(r.get('Reason') or '').strip(),
                'ts': str(r.get('Timestamp') or '').strip()
            }
        return out
    except Exception:
        logging.exception("Failed reading overrides file")
        return {}

def _save_override(employee_key, level, reason):
    now = datetime.now().isoformat()
    row = {'EmployeeID': employee_key, 'OverrideLevel': level, 'Reason': reason or '', 'Timestamp': now}
    try:
        if OVERRIDES_FILE.exists():
            df = pd.read_csv(OVERRIDES_FILE, dtype=str)
            df = pd.concat([df, pd.DataFrame([row])], ignore_index=True)
        else:
            df = pd.DataFrame([row])
        df.to_csv(OVERRIDES_FILE, index=False)
        return True
    except Exception:
        logging.exception("Failed to save override")
        return False

# ODBC driver (env or default)
ODBC_DRIVER = os.getenv("ODBC_DRIVER", "ODBC Driver 17 for SQL Server")

# ---------- ACVSCore connection + image helpers ----------
_acvscore_backoff = {"ts": None, "failed": False}
_ACVSCORE_BACKOFF_SECONDS = 20

def _get_acvscore_conn():
    try:
        import pyodbc
    except Exception:
        logging.debug("pyodbc not installed; ACVSCore lookups unavailable.")
        return None

    now = datetime.now().timestamp()
    last = _acvscore_backoff.get("ts")
    if last and _acvscore_backoff.get("failed") and (now - last) < _ACVSCORE_BACKOFF_SECONDS:
        logging.debug("Skipping ACVSCore connection attempt (backoff active).")
        return None

    tried = []
    for region_key, rc in (REGION_CONFIG or {}).items():
        server = rc.get("server")
        user = rc.get("user")
        pwd = rc.get("password")
        if not server:
            continue

        # SQL auth
        if user and pwd:
            tried.append(f"{region_key}@{server}(sql)")
            conn_str = (
                f"DRIVER={{{ODBC_DRIVER}}};SERVER={server};DATABASE=ACVSCore;UID={user};PWD={pwd};TrustServerCertificate=Yes;"
            )
            try:
                conn = pyodbc.connect(conn_str, autocommit=True, timeout=5)
                logging.info("Connected to ACVSCore on server %s using REGION_CONFIG[%s] (sql auth).", server, region_key)
                _acvscore_backoff["ts"] = None
                _acvscore_backoff["failed"] = False
                return conn
            except Exception as e:
                logging.debug("SQL auth to %s failed: %s", server, e)

        # Trusted connection fallback
        tried.append(f"{region_key}@{server}(trusted)")
        conn_str_trusted = (
            f"DRIVER={{{ODBC_DRIVER}}};SERVER={server};DATABASE=ACVSCore;Trusted_Connection=yes;TrustServerCertificate=Yes;"
        )
        try:
            conn = pyodbc.connect(conn_str_trusted, autocommit=True, timeout=5)
            logging.info("Connected to ACVSCore on server %s using REGION_CONFIG[%s] (trusted connection).", server, region_key)
            _acvscore_backoff["ts"] = None
            _acvscore_backoff["failed"] = False
            return conn
        except Exception as e:
            logging.debug("Trusted connection to %s failed: %s", server, e)
            continue

    # fallback to global ACVSCORE_DB_CONFIG if present
    try:
        if 'ACVSCORE_DB_CONFIG' in globals() and isinstance(globals().get('ACVSCORE_DB_CONFIG'), dict):
            cfg = globals().get('ACVSCORE_DB_CONFIG')
            server = cfg.get('server')
            user = cfg.get('user')
            pwd = cfg.get('password')
            database = cfg.get('database', 'ACVSCore')
            tried.append(f"ACVSCORE_DB_CONFIG@{server}")
            try:
                conn_str = (
                    f"DRIVER={{{ODBC_DRIVER}}};SERVER={server};DATABASE={database};UID={user};PWD={pwd};TrustServerCertificate=Yes;"
                )
                conn = pyodbc.connect(conn_str, autocommit=True, timeout=5)
                logging.info("Connected to ACVSCore using ACVSCORE_DB_CONFIG (%s).", server)
                _acvscore_backoff["ts"] = None
                _acvscore_backoff["failed"] = False
                return conn
            except Exception as e:
                logging.debug("ACVSCORE_DB_CONFIG connection failed: %s", e)
    except Exception:
        logging.debug("ACVSCORE_DB_CONFIG fallback not available or failed.")

    _acvscore_backoff["ts"] = now
    _acvscore_backoff["failed"] = True
    logging.error("Failed to connect to ACVSCore. Tried: %s", tried)
    return None

MODELS_DIR = Path(__file__).parent / "models"
_loaded_models = {}
def load_model(name):
    if name in _loaded_models:
        return _loaded_models[name]
    p = MODELS_DIR / f"{name}.joblib"
    if not p.exists():
        return None
    data = joblib.load(p)
    _loaded_models[name] = data
    return data

def get_personnel_info(candidate_identifier: object) -> Dict[str, Any]:
    out: Dict[str, Any] = {}
    if candidate_identifier is None:
        return out
    conn = _get_acvscore_conn()
    if conn is None:
        return out
    try:
        cur = conn.cursor()
        sql = """
            SELECT TOP 1 ObjectID, GUID, Name, EmailAddress, ManagerEmail
            FROM ACVSCore.Access.Personnel
            WHERE
              (CAST(ObjectID AS NVARCHAR(200)) = ?)
              OR (GUID = ?)
              OR (CAST(Int1 AS NVARCHAR(200)) = ?)
              OR (Text12 = ?)
              OR (Name = ?)
            ORDER BY ObjectID DESC
        """
        cand = str(candidate_identifier).strip()
        params = (cand, cand, cand, cand, cand)
        cur.execute(sql, params)
        row = cur.fetchone()
        if row:
            try:
                out['ObjectID'] = row[0]
                out['GUID'] = row[1]
                out['Name'] = row[2]
                out['EmailAddress'] = row[3]
                out['ManagerEmail'] = row[4]
            except Exception:
                out = {
                    'ObjectID': row[0] if len(row) > 0 else None,
                    'GUID': row[1] if len(row) > 1 else None,
                    'Name': row[2] if len(row) > 2 else None,
                    'EmailAddress': row[3] if len(row) > 3 else None,
                    'ManagerEmail': row[4] if len(row) > 4 else None
                }
    except Exception:
        logging.exception("Failed personnel lookup for candidate: %s", candidate_identifier)
    finally:
        try:
            cur.close()
        except Exception:
            pass
        try:
            conn.close()
        except Exception:
            pass

    return out

def get_person_image_bytes(parent_id) -> Optional[bytes]:
    conn = _get_acvscore_conn()
    if conn is None:
        return None
    try:
        cur = conn.cursor()
        sql = """
            SELECT TOP 1 AI.Image
            FROM ACVSCore.Access.Images AI
            WHERE AI.ParentId = ?
              AND DATALENGTH(AI.Image) > 0
            ORDER BY AI.ObjectID DESC
        """
        cur.execute(sql, (str(parent_id),))
        row = cur.fetchone()
        if row and row[0] is not None:
            try:
                b = bytes(row[0])
                return b
            except Exception:
                return row[0]
    except Exception:
        logging.exception("Failed to fetch image for ParentId=%s", parent_id)
    finally:
        try:
            cur.close()
        except Exception:
            pass
        try:
            conn.close()
        except Exception:
            pass
    return None

# ---------- CORS / App setup ----------
try:
    from flask_cors import CORS
    has_cors = True
except Exception:
    CORS = None
    has_cors = False

app = Flask(__name__, static_folder=None)
if has_cors:
    CORS(app)
else:
    logging.warning("flask_cors not available; continuing without CORS.")

logging.basicConfig(level=logging.INFO)

# optional excel styling
try:
    from openpyxl import load_workbook
    from openpyxl.styles import Font, Alignment, Border, Side
    OPENPYXL_AVAILABLE = True
except Exception:
    OPENPYXL_AVAILABLE = False

# ---------- small utilities ----------
def _to_python_scalar(x):
    try:
        import pandas as _pd
        if isinstance(x, _pd.Timestamp):
            return x.to_pydatetime().isoformat()
    except Exception:
        pass
    try:
        import numpy as _np
        if isinstance(x, _np.generic):
            v = x.item()
            if isinstance(v, float) and _np.isnan(v):
                return None
            return v
    except Exception:
        pass
    try:
        if isinstance(x, float) and math.isnan(x):
            return None
    except Exception:
        pass
    if isinstance(x, (datetime,)):
        return x.isoformat()
    if isinstance(x, (bool, int, str, type(None), float)):
        return x
    try:
        return str(x)
    except Exception:
        return None

def format_seconds_to_hms(seconds) -> str:
    """
    Convert seconds (float/int/None) -> HH:MM:SS string.
    Accepts None or non-numeric and returns None.
    """
    try:
        if seconds is None:
            return None
        s = float(seconds)
        if not (s is not None and (s == s) and s >= 0):  # NaN check
            return None
        total = int(round(s))
        hh = total // 3600
        mm = (total % 3600) // 60
        ss = total % 60
        return f"{hh:02d}:{mm:02d}:{ss:02d}"
    except Exception:
        return None


_uuid_like_re = re.compile(r'^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$')
def _looks_like_guid(s):
    try:
        if not s or not isinstance(s, str):
            return False
        s = s.strip()
        return bool(_uuid_like_re.match(s)) or s.startswith('name:') or s.startswith('emp:') or s.startswith('uid:')
    except Exception:
        return False

_PLACEHOLDER_STRS = set(['', 'nan', 'na', 'n/a', '-', '—', '–', 'none', 'null'])
def _is_placeholder_str(s: object) -> bool:
    try:
        if s is None:
            return True
        st = str(s).strip().lower()
        return st in _PLACEHOLDER_STRS
    except Exception:
        return False

def _replace_placeholder_strings(df: pd.DataFrame) -> pd.DataFrame:
    if df is None or df.empty:
        return df
    for col in df.columns:
        try:
            if df[col].dtype == object:
                df[col] = df[col].apply(lambda x: None if (isinstance(x, str) and x.strip().lower() in _PLACEHOLDER_STRS) else x)
        except Exception:
            continue
    return df

_CARD_XML_RE = re.compile(r'<Card>([^<]+)</Card>', re.IGNORECASE | re.DOTALL)
def _extract_card_from_xml_text(txt):
    try:
        if not txt or not isinstance(txt, str):
            return None
        m = _CARD_XML_RE.search(txt)
        if m:
            return m.group(1).strip()
        m2 = re.search(r'CHUID.*?Card.*?[:=]\s*([0-9A-Za-z\-\_]+)', txt, re.IGNORECASE | re.DOTALL)
        if m2:
            return m2.group(1).strip()
    except Exception:
        pass
    return None

def _find_swipe_files(outdir: Path, date_obj: Optional[date] = None, city_slug: Optional[str] = None):
    p = Path(outdir)
    if not p.exists():
        return []
    candidates = []
    if date_obj:
        target = date_obj.strftime("%Y%m%d")
        patterns = [
            f"swipes_*_{target}.csv",
            f"swipes_{city_slug}_*_{target}.csv" if city_slug else None,
            f"swipe_*_{target}.csv",
            f"*_{target}.csv"
        ]
    else:
        patterns = [
            "swipes_*.csv",
            f"swipes_{city_slug}_*.csv" if city_slug else None,
            "swipe_*.csv",
            "swipes_*.csv"
        ]
    seen = set()
    for pat in patterns:
        if not pat:
            continue
        for fp in sorted(p.glob(pat), reverse=True):
            if fp.name not in seen:
                seen.add(fp.name)
                candidates.append(fp)
    if not candidates:
        for fp in sorted(p.glob("*.csv"), reverse=True):
            ln = fp.name.lower()
            if 'swipe' in ln or 'card' in ln or 'locale' in ln or 'localemessagetime' in ln:
                if fp.name not in seen:
                    seen.add(fp.name)
                    candidates.append(fp)
    return candidates

def _resolve_field_from_record(record: dict, candidate_tokens: list):
    if record is None:
        return None
    for key in candidate_tokens:
        if key in record:
            v = record.get(key)
            if v is None:
                continue
            if isinstance(v, float) and math.isnan(v):
                continue
            sval = str(v).strip()
            if sval and not _is_placeholder_str(sval):
                return _to_python_scalar(v)
    lower_keys = {k.lower(): k for k in record.keys()}
    for tok in candidate_tokens:
        tok_l = tok.lower()
        for lk, orig_key in lower_keys.items():
            if tok_l in lk:
                v = record.get(orig_key)
                if v is None:
                    continue
                if isinstance(v, float) and math.isnan(v):
                    continue
                sval = str(v).strip()
                if sval and not _is_placeholder_str(sval):
                    return _to_python_scalar(v)
    card_like = any(tok.lower() in ('cardnumber', 'chuid', 'card') for tok in candidate_tokens)
    if card_like:
        for lk, orig_key in lower_keys.items():
            if 'xml' in lk or 'xmlmessage' in lk or 'xml_msg' in lk or 'msg' in lk or 'value' == lk:
                v = record.get(orig_key)
                if v is None:
                    continue
                try:
                    txt = str(v)
                    extracted = _extract_card_from_xml_text(txt)
                    if extracted and not _is_placeholder_str(extracted):
                        return _to_python_scalar(extracted)
                except Exception:
                    continue
    for k, v in record.items():
        if v is None:
            continue
        if isinstance(v, float) and math.isnan(v):
            continue
        sval = str(v).strip()
        if sval and not _is_placeholder_str(sval):
            return _to_python_scalar(v)
    return None





# def _clean_sample_df(df: pd.DataFrame, max_rows: int = 10):
    if df is None or df.empty:
        return []
    df = df.copy()
    cols_to_fix = [c for c in df.columns if c.endswith('_x') or c.endswith('_y')]
    for c in cols_to_fix:
        base = c[:-2]
        if base in df.columns:
            try:
                df.drop(columns=[c], inplace=True)
            except Exception:
                pass
        else:
            try:
                df.rename(columns={c: base}, inplace=True)
            except Exception:
                pass
    if 'Date' in df.columns:
        try:
            df['Date'] = pd.to_datetime(df['Date'], errors='coerce').dt.date
            df['Date'] = df['Date'].apply(lambda d: d.isoformat() if pd.notna(d) else None)
        except Exception:
            pass
    for dtcol in ('FirstSwipe', 'LastSwipe', 'LocaleMessageTime'):
        if dtcol in df.columns:
            try:
                df[dtcol] = pd.to_datetime(df[dtcol], errors='coerce')
                df[dtcol] = df[dtcol].apply(lambda t: t.to_pydatetime().isoformat() if pd.notna(t) else None)
            except Exception:
                try:
                    df[dtcol] = df[dtcol].astype(str).replace('NaT', None)
                except Exception:
                    pass
    df = df.where(pd.notnull(df), None)
    rows = df.head(max_rows).to_dict(orient='records')
    cleaned = []

    # helper regex to find GUIDs inside text
    GUID_IN_TEXT_RE = re.compile(r'[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}')

    for r in rows:
        out = {}
        # copy existing columns with scalar conversion
        for k, v in r.items():
            out[k] = _to_python_scalar(v)

        # Prefer feature/duration-derived name fields if present in the raw record
        # Candidate tokens in order:
        name_tokens = ['EmployeeName_feat', 'EmployeeName_dur', 'EmployeeName', 'ObjectName1', 'objectname1', 'employee_name', 'name']
        resolved_name = _resolve_field_from_record(r, name_tokens)
        if resolved_name:
            out['EmployeeName'] = resolved_name
        else:
            # if name is placeholder or looks like guid, try to use EmployeeID as fallback name only if no better name
            maybe_name = out.get('EmployeeName')
            emp_id = out.get('EmployeeID') or out.get('EmployeeIdentity') or out.get('person_uid')
            if (maybe_name in (None, '', 'nan')) or (_looks_like_guid(maybe_name) if isinstance(maybe_name, str) else False):
                if emp_id and not _looks_like_guid(emp_id):
                    out['EmployeeName'] = str(emp_id)

        # --- NEW: Ensure EmployeeID surfaced from best candidates (feat/dur/int/text12) ---
        try:
            emp_candidates = ['EmployeeID_feat', 'EmployeeID_dur', 'EmployeeID', 'Int1', 'Text12']
            emp_val = _resolve_field_from_record(r, emp_candidates)
            if emp_val:
                # normalize floats like '320172.0' -> '320172'
                try:
                    s = str(emp_val).strip()
                    if '.' in s:
                        f = float(s)
                        if math.isfinite(f) and f.is_integer():
                            s = str(int(f))
                    emp_val = s
                except Exception:
                    pass
                # avoid GUID-looking values for EmployeeID
                if not _looks_like_guid(str(emp_val)):
                    out['EmployeeID'] = emp_val
        except Exception:
            pass

        # Ensure EmployeeID normalized as string where possible (keep existing logic)
        if 'EmployeeID' in out and isinstance(out['EmployeeID'], str) and _looks_like_guid(out['EmployeeID']):
            out['EmployeeID'] = None

        # Duration: prefer explicit Duration strings, then _dur/_feat, then compute from seconds/minutes
        dur_val = _resolve_field_from_record(r, ['Duration', 'Duration_dur', 'Duration_feat'])
        if dur_val:
            out['Duration'] = str(dur_val)
        else:
            # try DurationSeconds
            ds = r.get('DurationSeconds') if 'DurationSeconds' in r else None
            dm = r.get('DurationMinutes') if 'DurationMinutes' in r else None
            try:
                if ds not in (None, '', 'nan') and not (isinstance(ds, float) and math.isnan(ds)):
                    out['Duration'] = format_seconds_to_hms(float(ds))
                elif dm not in (None, '', 'nan') and not (isinstance(dm, float) and math.isnan(dm)):
                    out['Duration'] = format_seconds_to_hms(float(dm) * 60.0)
            except Exception:
                out['Duration'] = out.get('Duration') or None

        # Also include DurationSeconds/Minutes explicitly when present for front-end use
        if 'DurationSeconds' in r and r.get('DurationSeconds') not in (None, '', 'nan'):
            try:
                out['DurationSeconds'] = float(r.get('DurationSeconds'))
            except Exception:
                out['DurationSeconds'] = _to_python_scalar(r.get('DurationSeconds'))
        if 'DurationMinutes' in r and r.get('DurationMinutes') not in (None, '', 'nan'):
            try:
                out['DurationMinutes'] = float(r.get('DurationMinutes'))
            except Exception:
                out['DurationMinutes'] = _to_python_scalar(r.get('DurationMinutes'))

        # --- NEW: Replace GUIDs inside ViolationExplanation/Explanation using EmployeeID or EmployeeName ---
        try:
            expl = out.get('ViolationExplanation') or out.get('Explanation') or None
            if expl and isinstance(expl, str) and GUID_IN_TEXT_RE.search(expl):
                repl = out.get('EmployeeID') or out.get('EmployeeName') or None
                if repl:
                    out['ViolationExplanation'] = GUID_IN_TEXT_RE.sub(str(repl), expl)
                    out['Explanation'] = out.get('ViolationExplanation')
        except Exception:
            pass

        cleaned.append(out)
    return cleaned

def _clean_sample_df(df: pd.DataFrame,max_rows: int = 100):
    if df is None or df.empty:
        return []
    df = df.copy()
    cols_to_fix = [c for c in df.columns if c.endswith('_x') or c.endswith('_y')]
    for c in cols_to_fix:
        base = c[:-2]
        if base in df.columns:
            try:
                df.drop(columns=[c], inplace=True)
            except Exception:
                pass
        else:
            try:
                df.rename(columns={c: base}, inplace=True)
            except Exception:
                pass
    if 'Date' in df.columns:
        try:
            df['Date'] = pd.to_datetime(df['Date'], errors='coerce').dt.date
            df['Date'] = df['Date'].apply(lambda d: d.isoformat() if pd.notna(d) else None)
        except Exception:
            pass
    for dtcol in ('FirstSwipe', 'LastSwipe', 'LocaleMessageTime'):
        if dtcol in df.columns:
            try:
                df[dtcol] = pd.to_datetime(df[dtcol], errors='coerce')
                df[dtcol] = df[dtcol].apply(lambda t: t.to_pydatetime().isoformat() if pd.notna(t) else None)
            except Exception:
                try:
                    df[dtcol] = df[dtcol].astype(str).replace('NaT', None)
                except Exception:
                    pass
    df = df.where(pd.notnull(df), None)
    rows = df.head(max_rows).to_dict(orient='records')
    cleaned = []

    # helper regex to find GUIDs inside text
    GUID_IN_TEXT_RE = re.compile(r'[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}')

    for r in rows:
        out = {}
        # copy existing columns with scalar conversion
        for k, v in r.items():
            out[k] = _to_python_scalar(v)

        # Prefer feature/duration-derived name fields if present in the raw record
        # Candidate tokens in order:
        name_tokens = ['EmployeeName_feat', 'EmployeeName_dur', 'EmployeeName', 'ObjectName1', 'objectname1', 'employee_name', 'name']
        resolved_name = _resolve_field_from_record(r, name_tokens)
        if resolved_name:
            out['EmployeeName'] = resolved_name
        else:
            # if name is placeholder or looks like guid, try to use EmployeeID as fallback name only if no better name
            maybe_name = out.get('EmployeeName')
            emp_id = out.get('EmployeeID') or out.get('EmployeeIdentity') or out.get('person_uid')
            if (maybe_name in (None, '', 'nan')) or (_looks_like_guid(maybe_name) if isinstance(maybe_name, str) else False):
                if emp_id and not _looks_like_guid(emp_id):
                    out['EmployeeName'] = str(emp_id)

        # --- NEW: Ensure EmployeeID surfaced from best candidates (feat/dur/int/text12) ---
        try:
            emp_candidates = ['EmployeeID_feat', 'EmployeeID_dur', 'EmployeeID', 'Int1', 'Text12']
            emp_val = _resolve_field_from_record(r, emp_candidates)
            if emp_val:
                # normalize floats like '320172.0' -> '320172'
                try:
                    s = str(emp_val).strip()
                    if '.' in s:
                        f = float(s)
                        if math.isfinite(f) and f.is_integer():
                            s = str(int(f))
                    emp_val = s
                except Exception:
                    pass
                # avoid GUID-looking values for EmployeeID
                if not _looks_like_guid(str(emp_val)):
                    out['EmployeeID'] = emp_val
        except Exception:
            pass

        # Ensure EmployeeID normalized as string where possible (keep existing logic)
        if 'EmployeeID' in out and isinstance(out['EmployeeID'], str) and _looks_like_guid(out['EmployeeID']):
            out['EmployeeID'] = None

        # Duration: prefer explicit Duration strings, then _dur/_feat, then compute from seconds/minutes
        dur_val = _resolve_field_from_record(r, ['Duration', 'Duration_dur', 'Duration_feat'])
        if dur_val:
            out['Duration'] = str(dur_val)
        else:
            # try DurationSeconds
            ds = r.get('DurationSeconds') if 'DurationSeconds' in r else None
            dm = r.get('DurationMinutes') if 'DurationMinutes' in r else None
            try:
                if ds not in (None, '', 'nan') and not (isinstance(ds, float) and math.isnan(ds)):
                    out['Duration'] = format_seconds_to_hms(float(ds))
                elif dm not in (None, '', 'nan') and not (isinstance(dm, float) and math.isnan(dm)):
                    out['Duration'] = format_seconds_to_hms(float(dm) * 60.0)
            except Exception:
                out['Duration'] = out.get('Duration') or None

        # Also include DurationSeconds/Minutes explicitly when present for front-end use
        if 'DurationSeconds' in r and r.get('DurationSeconds') not in (None, '', 'nan'):
            try:
                out['DurationSeconds'] = float(r.get('DurationSeconds'))
            except Exception:
                out['DurationSeconds'] = _to_python_scalar(r.get('DurationSeconds'))
        if 'DurationMinutes' in r and r.get('DurationMinutes') not in (None, '', 'nan'):
            try:
                out['DurationMinutes'] = float(r.get('DurationMinutes'))
            except Exception:
                out['DurationMinutes'] = _to_python_scalar(r.get('DurationMinutes'))

        # --- NEW: coalesce CardNumber from feat/dur/raw columns ---
        try:
            card_val = _resolve_field_from_record(r, ['CardNumber_feat', 'CardNumber_dur', 'CardNumber', 'Card', 'CHUID', 'card', 'value', 'xmlmessage'])
            if card_val:
                cs = str(card_val).strip()
                if _looks_like_guid(cs) or _is_placeholder_str(cs):
                    card_val = None
                else:
                    card_val = cs
            out['CardNumber'] = card_val
        except Exception:
            out['CardNumber'] = out.get('CardNumber') or None

        # --- NEW: ensure EmployeeID is normalized also as string and present in out (fallbacks) ---
        try:
            if not out.get('EmployeeID'):
                emp_val2 = _resolve_field_from_record(r, ['EmployeeID_feat', 'EmployeeID_dur', 'EmployeeID', 'Int1', 'Text12'])
                if emp_val2:
                    s = str(emp_val2).strip()
                    try:
                        if '.' in s:
                            f = float(s)
                            if math.isfinite(f) and f.is_integer():
                                s = str(int(f))
                    except Exception:
                        pass
                    if not _looks_like_guid(s) and not _is_placeholder_str(s):
                        out['EmployeeID'] = s
        except Exception:
            pass

        # --- NEW: Replace GUIDs inside ViolationExplanation/Explanation using EmployeeName + EmployeeID if present ---
        try:
            expl = out.get('ViolationExplanation') or out.get('Explanation') or None
            if expl and isinstance(expl, str) and GUID_IN_TEXT_RE.search(expl):
                # compose best display identity: prefer name then id
                name_part = out.get('EmployeeName') or ''
                id_part = out.get('EmployeeID') or ''
                display = None
                if name_part and id_part:
                    display = f"{name_part} ({id_part})"
                elif name_part:
                    display = f"{name_part}"
                elif id_part:
                    display = f"{id_part}"
                if display:
                    out['ViolationExplanation'] = GUID_IN_TEXT_RE.sub(str(display), expl)
                    out['Explanation'] = out.get('ViolationExplanation')
        except Exception:
            pass

        cleaned.append(out)
    return cleaned


# -----------------------
# Routes
# -----------------------
@app.route('/')
def root():
    return "Trend Analysis API — Multi-city"

@app.route('/run', methods=['GET', 'POST'])
def run_trend():
    params = {}
    if request.method == 'GET':
        params = request.args.to_dict()
    else:
        if request.is_json:
            params = request.get_json(force=True) or {}
        else:
            try:
                params = request.form.to_dict() or {}
            except Exception:
                params = {}

    date_str = (params.get('date') or params.get('Date') or '').strip() or None
    start_str = (params.get('start') or params.get('Start') or '').strip() or None
    end_str = (params.get('end') or params.get('End') or '').strip() or None

    dates = []
    try:
        if date_str:
            dt = datetime.strptime(date_str, "%Y-%m-%d").date()
            dates = [dt]
        elif start_str and end_str:
            s = datetime.strptime(start_str, "%Y-%m-%d").date()
            e = datetime.strptime(end_str, "%Y-%m-%d").date()
            if e < s:
                return jsonify({"error":"end must be >= start"}), 400
            cur = s
            while cur <= e:
                dates.append(cur)
                cur = cur + timedelta(days=1)
        else:
            today = datetime.now().date()
            yesterday = today - timedelta(days=1)
            dates = [yesterday, today]
    except Exception as e:
        return jsonify({"error": f"Invalid date format: {e}"}), 400

    regions_param = params.get('regions') or params.get('region') or ''
    if regions_param:
        regions = [r.strip().lower() for r in re.split(r'[;,|]', str(regions_param)) if r.strip()]
    else:
        try:
            regions = [k.lower() for k in list(REGION_CONFIG.keys())]
        except Exception:
            regions = ['apac']

    valid_regions = []
    for r in regions:
        if r in (REGION_CONFIG or {}):
            valid_regions.append(r)
        else:
            logging.debug("Requested region '%s' not in REGION_CONFIG - skipping", r)
    if not valid_regions:
        valid_regions = [k.lower() for k in REGION_CONFIG.keys()] if REGION_CONFIG else ['apac']
    params['_regions_to_run'] = valid_regions

    city_param = params.get('city') or params.get('site') or params.get('site_name') or None
    city_slug = _slug_city(city_param) if city_param else None
    params['_city'] = city_slug

    combined_rows = []
    files = []

    for d in dates:
        try:
            if run_trend_for_date is None:
                raise RuntimeError("run_trend_for_date helper not available in trend_runner")
            try:
                df = run_trend_for_date(d, regions=valid_regions, outdir=str(DEFAULT_OUTDIR), city=city_slug)
            except TypeError:
                try:
                    df = run_trend_for_date(d, outdir=str(DEFAULT_OUTDIR))
                except Exception:
                    # Last-resort: try duration_report fallback if available
                    try:
                        from duration_report import run_for_date as _dr_run_for_date
                        region_results = _dr_run_for_date(d, valid_regions, str(DEFAULT_OUTDIR), city_param)
                        combined_list = []
                        for rkey, res in (region_results or {}).items():
                            try:
                                df_dur = res.get('durations')
                                if df_dur is not None and not df_dur.empty:
                                    combined_list.append(df_dur)
                            except Exception:
                                continue
                        df = pd.concat(combined_list, ignore_index=True) if combined_list else pd.DataFrame()
                    except Exception:
                        raise
        except Exception as e:
            logging.exception("run_trend_for_date failed for %s", d)
            return jsonify({"error": f"runner failed for {d}: {e}"}), 500

        csv_path = DEFAULT_OUTDIR / f"trend_{city_slug}_{d.strftime('%Y%m%d')}.csv"
        if csv_path.exists():
            files.append(csv_path.name)

        if df is None or (hasattr(df, 'empty') and df.empty):
            continue

        try:
            df = _replace_placeholder_strings(df)
        except Exception:
            pass

        if 'IsFlagged' not in df.columns:
            df['IsFlagged'] = False
        if 'Reasons' not in df.columns:
            df['Reasons'] = None

        combined_rows.append(df)

    combined_df = pd.concat(combined_rows, ignore_index=True) if combined_rows else pd.DataFrame()
    combined_df = _replace_placeholder_strings(combined_df)

    try:
        if not combined_df.empty:
            if 'person_uid' in combined_df.columns:
                raw_unique_person_uids = int(combined_df['person_uid'].dropna().astype(str).nunique())
            elif 'EmployeeID' in combined_df.columns:
                raw_unique_person_uids = int(combined_df['EmployeeID'].dropna().astype(str).nunique())
            else:
                raw_unique_person_uids = int(len(combined_df))
        else:
            raw_unique_person_uids = 0
    except Exception:
        raw_unique_person_uids = int(len(combined_df)) if combined_df is not None else 0

    try:
        if not combined_df.empty and 'IsFlagged' in combined_df.columns:
            flagged_df = combined_df[combined_df['IsFlagged'] == True].copy()
        else:
            flagged_df = pd.DataFrame()
    except Exception:
        flagged_df = pd.DataFrame()

    try:
        analysis_count = int(raw_unique_person_uids)
    except Exception:
        analysis_count = int(len(combined_df)) if combined_df is not None else 0

    try:
        flagged_count = int(len(flagged_df))
        flagged_rate_pct = float((flagged_count / analysis_count * 100.0) if analysis_count and analysis_count > 0 else 0.0)
    except Exception:
        flagged_count = int(len(flagged_df))
        flagged_rate_pct = 0.0

    try:
        sample_source = flagged_df if not flagged_df.empty else combined_df
        samples = _clean_sample_df(sample_source.head(10), max_rows=10) if sample_source is not None and not sample_source.empty else []
    except Exception:
        samples = []

    resp = {
        "start_date": dates[0].isoformat() if dates else None,
        "end_date": dates[-1].isoformat() if dates else None,
        "aggregated_rows_total_raw": int(len(combined_df)),
        "aggregated_unique_persons": int(analysis_count),
        "rows": int(analysis_count),
        "flagged_rows": int(flagged_count),
        "flagged_rate_percent": float(flagged_rate_pct),
        "files": files,
        "sample": (samples[:10] if isinstance(samples, list) else samples),
        "reasons_count": {},
        "risk_counts": {},
        "flagged_persons": (samples if samples else []),
        "_raw_unique_person_uids": int(raw_unique_person_uids),
        "regions_run": params.get('_regions_to_run', []),
        "city_used": city_slug
    }

    return jsonify(resp)

@app.route('/latest', methods=['GET'])
def latest_results():
    city_param = request.args.get('city') or request.args.get('site') or 'pune'
    city_slug = _slug_city(city_param)

    p = Path(DEFAULT_OUTDIR)
    csvs = sorted(p.glob(f"trend_{city_slug}_*.csv"), reverse=True)
    if not csvs:
        csvs = sorted(p.glob("trend_*.csv"), reverse=True)
    if not csvs:
        return jsonify({"error": "no outputs found"}), 404
    latest = csvs[0]

    start_date_iso = None
    end_date_iso = None
    try:
        m = re.search(r'(\d{8})', latest.name)
        if m:
            ymd = m.group(1)
            dt = datetime.strptime(ymd, "%Y%m%d").date()
            start_date_iso = dt.isoformat()
            end_date_iso = dt.isoformat()
    except Exception:
        start_date_iso = None
        end_date_iso = None

    try:
        df = pd.read_csv(latest)
    except Exception:
        df = pd.read_csv(latest, dtype=str)

    df = _replace_placeholder_strings(df)

    id_candidates = ['person_uid', 'EmployeeID', 'EmployeeIdentity', 'Int1']
    id_col = next((c for c in id_candidates if c in df.columns), None)

    def _norm_val_for_latest(v):
        try:
            if pd.isna(v):
                return None
        except Exception:
            pass
        if v is None:
            return None
        s = str(v).strip()
        if s == '' or s.lower() == 'nan':
            return None
        try:
            if '.' in s:
                fv = float(s)
                if math.isfinite(fv) and fv.is_integer():
                    s = str(int(fv))
        except Exception:
            pass
        return s

    if id_col is None:
        unique_persons = int(len(df))
    else:
        ids_series = df[id_col].apply(_norm_val_for_latest) if id_col in df.columns else pd.Series([None]*len(df))
        if id_col != 'person_uid' and 'person_uid' in df.columns:
            ids_series = ids_series.fillna(df['person_uid'].astype(str).replace('nan','').replace('None',''))
        unique_persons = int(len(set([x for x in ids_series.unique() if x])))

    sample = _clean_sample_df(df, max_rows=5)
    resp = {
        "file": latest.name,
        "rows_raw": int(len(df)),
        "rows": unique_persons,
        "sample": sample,
        "start_date": start_date_iso,
        "end_date": end_date_iso,
        "city": city_slug
    }
    return jsonify(resp)

@app.route('/record', methods=['GET'])
def get_record():
    q = request.args.get('employee_id') or request.args.get('person_uid')
    include_unflagged = str(request.args.get('include_unflagged', '')).lower() in ('1', 'true', 'yes')
    city_param = request.args.get('city') or request.args.get('site') or 'pune'
    city_slug = _slug_city(city_param)

    p = Path(DEFAULT_OUTDIR)
    csvs = sorted(p.glob(f"trend_{city_slug}_*.csv"), reverse=True)
    if not csvs:
        csvs = sorted(p.glob("trend_*.csv"), reverse=True)
    if not csvs:
        return jsonify({'aggregated_rows': [], 'raw_swipe_files': [], 'raw_swipes': []}), 200

    df_list = []
    for fp in csvs:
        try:
            tmp = pd.read_csv(fp, parse_dates=['Date', 'FirstSwipe', 'LastSwipe'])
        except Exception:
            try:
                tmp = pd.read_csv(fp, dtype=str)
                if 'Date' in tmp.columns:
                    tmp['Date'] = pd.to_datetime(tmp['Date'], errors='coerce').dt.date
            except Exception:
                continue
        df_list.append(tmp)
    if not df_list:
        return jsonify({'aggregated_rows': [], 'raw_swipe_files': [], 'raw_swipes': []}), 200
    df = pd.concat(df_list, ignore_index=True)

    df = _replace_placeholder_strings(df)

    if q is None:
        cleaned = _clean_sample_df(df, max_rows=10)
        return jsonify({'aggregated_rows': cleaned, 'raw_swipe_files': [], 'raw_swipes': []}), 200

    q_str = str(q).strip()
    def normalize_series(s):
        if s is None:
            return pd.Series([''] * len(df))
        s = s.fillna('').astype(str).str.strip()
        def _norm_val(v):
            if not v:
                return ''
            try:
                if '.' in v:
                    fv = float(v)
                    if fv.is_integer():
                        return str(int(fv))
            except Exception:
                pass
            return v
        return s.map(_norm_val)

    found_mask = pd.Series(False, index=df.index)
    if 'EmployeeID' in df.columns:
        emp_series = normalize_series(df['EmployeeID'])
        found_mask = found_mask | (emp_series == q_str)
    if 'person_uid' in df.columns:
        uid_series = normalize_series(df['person_uid'])
        found_mask = found_mask | (uid_series == q_str)
    if 'Int1' in df.columns and not found_mask.any():
        int1_series = normalize_series(df['Int1'])
        found_mask = found_mask | (int1_series == q_str)

    if not found_mask.any():
        try:
            q_numeric = float(q_str)
            if 'EmployeeID' in df.columns:
                emp_numeric = pd.to_numeric(df['EmployeeID'], errors='coerce')
                found_mask = found_mask | (emp_numeric == q_numeric)
            if 'Int1' in df.columns and not found_mask.any():
                int_numeric = pd.to_numeric(df['Int1'], errors='coerce')
                found_mask = found_mask | (int_numeric == q_numeric)
        except Exception:
            pass

    matched = df[found_mask].copy()
    if matched.empty:
        return jsonify({'aggregated_rows': [], 'raw_swipe_files': [], 'raw_swipes': []}), 200

    cleaned_matched = _clean_sample_df(matched, max_rows=len(matched))



    # enrich aggregated rows (email, image, violation days, explanation)
    try:
        try:
            # lazy import from trend_runner (avoid import-time circular issues)
            from trend_runner import compute_violation_days_map, _strip_uid_prefix as _strip_uid_prefix_tr
            violation_map = compute_violation_days_map(str(DEFAULT_OUTDIR), 90, datetime.now().date())
        except Exception:
            violation_map = {}
            _strip_uid_prefix_tr = (lambda x: x)
    except Exception:
        violation_map = {}
        _strip_uid_prefix_tr = (lambda x: x)

    matched_indexed = matched.reset_index(drop=True)
  

    # more robust candidate resolution + explanation/email/image enrichment
    GUID_IN_TEXT_RE = re.compile(
        r'[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}'
    )

    for idx_c, cleaned in enumerate(cleaned_matched):
        candidate_row = None
        try:
            # 1) try exact matches by person_uid, EmployeeID, EmployeeName
            if cleaned.get('person_uid') and 'person_uid' in matched_indexed.columns:
                mr = matched_indexed[matched_indexed['person_uid'].astype(str).str.strip() == str(cleaned['person_uid']).strip()]
                if not mr.empty:
                    candidate_row = mr.iloc[0].to_dict()

            if candidate_row is None and cleaned.get('EmployeeID') and 'EmployeeID' in matched_indexed.columns:
                mr = matched_indexed[matched_indexed['EmployeeID'].astype(str).str.strip() == str(cleaned['EmployeeID']).strip()]
                if not mr.empty:
                    candidate_row = mr.iloc[0].to_dict()

            if candidate_row is None and cleaned.get('EmployeeName') and 'EmployeeName' in matched_indexed.columns:
                mr = matched_indexed[matched_indexed['EmployeeName'].astype(str).str.strip().str.lower() == str(cleaned['EmployeeName']).strip().lower()]
                if not mr.empty:
                    candidate_row = mr.iloc[0].to_dict()

            # 2) try other useful columns (CardNumber, EmployeeIdentity, Int1, Text12, ObjectIdentity1, ObjectID)
            if candidate_row is None and not matched_indexed.empty:
                for ccol in ('CardNumber', 'EmployeeIdentity', 'Int1', 'Text12', 'ObjectIdentity1', 'ObjectID', 'GUID'):
                    if ccol in matched_indexed.columns and cleaned.get(ccol) not in (None, '', 'nan'):
                        mr = matched_indexed[matched_indexed[ccol].astype(str).str.strip() == str(cleaned.get(ccol)).strip()]
                        if not mr.empty:
                            candidate_row = mr.iloc[0].to_dict()
                            break

            # 3) last resort - take the first matched row (if any)
            if candidate_row is None and not matched_indexed.empty:
                candidate_row = matched_indexed.iloc[0].to_dict()
        except Exception:
            candidate_row = None

        # Build Explanation: prefer explicit Explanation, else build from Reasons
        violation_expl = None
        try:
            if candidate_row:
                violation_expl = candidate_row.get('Explanation') or candidate_row.get('explanation') or None

            if not violation_expl:
                reasons = cleaned.get('Reasons') or (candidate_row.get('Reasons') if candidate_row else None)
                if reasons:
                    parts = [p.strip() for p in re.split(r'[;,\|]', str(reasons)) if p.strip()]
                    mapped = []
                    for p in parts:
                        try:
                            if 'SCENARIO_EXPLANATIONS' in globals() and p in SCENARIO_EXPLANATIONS:
                                mapped.append(SCENARIO_EXPLANATIONS[p](candidate_row or {}))
                            else:
                                mapped.append(p.replace("_", " ").replace(">=", "≥"))
                        except Exception:
                            mapped.append(p)
                    violation_expl = " ".join(mapped) if mapped else None

            # Replace GUIDS that appear inside longer text with a human name (if available)
            if violation_expl:
                try:
                    # prefer candidate_row name, then cleaned name
                    emp_name_for_expl = None
                    if candidate_row:
                        emp_name_for_expl = candidate_row.get('EmployeeName') or candidate_row.get('employee_name') or candidate_row.get('ObjectName1')
                    if not emp_name_for_expl:
                        emp_name_for_expl = cleaned.get('EmployeeName')
                    if emp_name_for_expl:
                        violation_expl = GUID_IN_TEXT_RE.sub(str(emp_name_for_expl), str(violation_expl))
                except Exception:
                    pass
        except Exception:
            violation_expl = None

        # Violation days lookup (unchanged logic)
        try:
            candidates = []
            for k in ('EmployeeID', 'person_uid', 'EmployeeIdentity', 'CardNumber', 'Int1', 'Text12'):
                if cleaned.get(k) not in (None, '', 'nan'):
                    candidates.append(cleaned.get(k))
            if candidate_row:
                for k in ('EmployeeID','person_uid','EmployeeIdentity','CardNumber','Int1','Text12'):
                    if candidate_row.get(k) not in (None,'','nan'):
                        candidates.append(candidate_row.get(k))
            vdays = 0
            if violation_map:
                for c in candidates:
                    if c is None:
                        continue
                    n = _normalize_id_local(c)
                    if n and n in violation_map:
                        vdays = int(violation_map.get(n, 0))
                        break
                    try:
                        stripped = _strip_uid_prefix_tr(str(n))
                        if stripped != n and stripped in violation_map:
                            vdays = int(violation_map.get(stripped, 0))
                            break
                    except Exception:
                        pass
        except Exception:
            vdays = 0

        # personnel lookup (try many tokens)
        personnel_info = {}
        try:
            lookup_candidates = []
            if candidate_row:
                for k in ('EmployeeObjID','EmployeeObjId','EmployeeIdentity','ObjectID','GUID','EmployeeID','Int1','Text12','EmployeeName'):
                    if candidate_row.get(k) not in (None,'','nan'):
                        lookup_candidates.append(candidate_row.get(k))
            for k in ('EmployeeID','person_uid','EmployeeName'):
                if cleaned.get(k) not in (None,'','nan'):
                    lookup_candidates.append(cleaned.get(k))

            # try each candidate till we get a useful personnel_info
            for cand in lookup_candidates:
                if cand is None:
                    continue
                try:
                    info = get_personnel_info(cand)
                    if info and (info.get('ObjectID') is not None or info.get('EmailAddress') is not None or info.get('ManagerEmail') is not None):
                        personnel_info = info
                        break
                except Exception:
                    continue

            # Extra fallback: if still empty and cleaned has EmployeeID, attempt lookup explicitly by EmployeeID
            if not personnel_info:
                try:
                    cand = cleaned.get('EmployeeID') or cleaned.get('EmployeeIdentity')
                    if cand:
                        info = get_personnel_info(cand)
                        if info and (info.get('ObjectID') is not None or info.get('EmailAddress') is not None):
                            personnel_info = info
                except Exception:
                    pass
        except Exception:
            personnel_info = {}

        # Attach computed fields
        try:
            cleaned['ViolationDaysLast90'] = int(vdays or 0)
            cleaned['ViolationExplanation'] = violation_expl
            cleaned['Explanation'] = violation_expl or cleaned.get('ViolationExplanation') or None

            # Ensure EmployeeName is present (prefer cleaned, then candidate_row, then personnel_info Name)
            try:
                if (not cleaned.get('EmployeeName')) or _looks_like_guid(cleaned.get('EmployeeName')):
                    if candidate_row and candidate_row.get('EmployeeName') and not _looks_like_guid(candidate_row.get('EmployeeName')):
                        cleaned['EmployeeName'] = candidate_row.get('EmployeeName')
                    elif personnel_info and personnel_info.get('Name'):
                        cleaned['EmployeeName'] = personnel_info.get('Name')
                # final pass: remove any GUIDs remaining in Explanation
                if cleaned.get('Explanation') and GUID_IN_TEXT_RE.search(str(cleaned.get('Explanation'))):
                    ename = cleaned.get('EmployeeName') or ''
                    cleaned['Explanation'] = GUID_IN_TEXT_RE.sub(str(ename), str(cleaned.get('Explanation')))
            except Exception:
                pass

            # Populate email from personnel_info OR candidate_row OR common columns in matched_indexed
            if personnel_info:
                cleaned['EmployeeObjID'] = personnel_info.get('ObjectID')
                cleaned['EmployeeEmail'] = personnel_info.get('EmailAddress')
                cleaned['ManagerEmail'] = personnel_info.get('ManagerEmail')
            else:
                # try to pick an email-like column from candidate_row
                if not cleaned.get('EmployeeEmail') and candidate_row:
                    for fk in ('Email', 'EmailAddress', 'EmployeeEmail', 'WorkEmail', 'EMail'):
                        if candidate_row.get(fk) not in (None, '', 'nan'):
                            cleaned['EmployeeEmail'] = candidate_row.get(fk)
                            break
                # final attempt: look in matched_indexed columns (if candidate_row didn't have it)
                if not cleaned.get('EmployeeEmail'):
                    for col in ('Email', 'EmailAddress', 'EmployeeEmail', 'WorkEmail', 'EMail'):
                        if col in matched_indexed.columns:
                            try:
                                val = matched_indexed.iloc[0].get(col)
                                if val not in (None, '', 'nan'):
                                    cleaned['EmployeeEmail'] = val
                                    break
                            except Exception:
                                continue

            # image resolution: prefer personnel_info.ObjectID, then candidate_row.ObjectID/EmployeeObjID, otherwise None
            try:
                img_obj = None
                if personnel_info and personnel_info.get('ObjectID') is not None:
                    img_obj = personnel_info.get('ObjectID')
                elif candidate_row:
                    for k in ('EmployeeObjID','EmployeeObjId','ObjectID','ObjectIdentity1'):
                        if candidate_row.get(k) not in (None, '', 'nan'):
                            img_obj = candidate_row.get(k)
                            break
                if img_obj:
                    cleaned['imageUrl'] = f"/employee/{img_obj}/image"
                    try:
                        b = get_person_image_bytes(img_obj)
                        cleaned['HasImage'] = True if b else False
                    except Exception:
                        cleaned['HasImage'] = False
                else:
                    cleaned['imageUrl'] = None
                    cleaned['HasImage'] = False
            except Exception:
                cleaned['imageUrl'] = None
                cleaned['HasImage'] = False

            # ensure EmployeeID surfaced if present in candidate_row
            if not cleaned.get('EmployeeID') and candidate_row:
                for k in ('EmployeeID','Int1','Text12','EmployeeIdentity'):
                    if candidate_row.get(k) not in (None, '', 'nan'):
                        cleaned['EmployeeID'] = candidate_row.get(k)
                        break
        except Exception:
            pass



    # Build raw_swipes timeline by scanning swipe files
    raw_files = set()
    raw_swipes_out = []
    seen_swipe_keys = set()
    def _append_swipe(out_row, source_name):
        key = (
            out_row.get('Date') or '',
            out_row.get('Time') or '',
            (out_row.get('Door') or '').strip(),
            (out_row.get('Direction') or '').strip(),
            (out_row.get('CardNumber') or out_row.get('Card') or '').strip()
        )
        if key in seen_swipe_keys:
            return
        seen_swipe_keys.add(key)
        out_row['_source'] = source_name
        raw_swipes_out.append(out_row)

    # collate scan dates
    dates_to_scan = set()
    for _, agg_row in matched.iterrows():
        try:
            if 'Date' in agg_row and pd.notna(agg_row['Date']):
                try:
                    d = pd.to_datetime(agg_row['Date']).date()
                    dates_to_scan.add(d)
                except Exception:
                    pass
            for col in ('FirstSwipe','LastSwipe'):
                if col in agg_row and pd.notna(agg_row[col]):
                    try:
                        d = pd.to_datetime(agg_row[col]).date()
                        dates_to_scan.add(d)
                    except Exception:
                        pass
        except Exception:
            continue
    if not dates_to_scan:
        dates_to_scan = {None}

    for d in dates_to_scan:
        candidates = _find_swipe_files(DEFAULT_OUTDIR, date_obj=d, city_slug=city_slug)
        for fp in candidates:
            raw_files.add(fp.name)
            try:
                try:
                    raw_df = pd.read_csv(fp, parse_dates=['LocaleMessageTime'])
                except Exception:
                    raw_df = pd.read_csv(fp, dtype=str)
            except Exception:
                continue

            raw_df = _replace_placeholder_strings(raw_df)
            cols_lower = {c.lower(): c for c in raw_df.columns}
            tcol = cols_lower.get('localemessagetime') or cols_lower.get('messagetime') or cols_lower.get('timestamp') or cols_lower.get('time') or None
            emp_col = cols_lower.get('int1') or cols_lower.get('employeeid') or cols_lower.get('employeeidentity') or cols_lower.get('employee_id') or None
            name_col = cols_lower.get('employeename') or cols_lower.get('objectname1') or cols_lower.get('employee_name') or None
            card_col = cols_lower.get('cardnumber') or cols_lower.get('card') or cols_lower.get('chuid') or cols_lower.get('value') or None
            door_col = cols_lower.get('door') or cols_lower.get('doorname') or cols_lower.get('door_name') or None
            dir_col = cols_lower.get('direction') or cols_lower.get('directionname') or cols_lower.get('direction_name') or None
            note_col = cols_lower.get('rejection_type') or cols_lower.get('note') or cols_lower.get('source') or None
            person_uid_col = cols_lower.get('person_uid')

            mask = pd.Series(False, index=raw_df.index)
            if person_uid_col and person_uid_col in raw_df.columns:
                mask = mask | (raw_df[person_uid_col].astype(str).str.strip() == str(q).strip())
            if emp_col and emp_col in raw_df.columns:
                mask = mask | (raw_df[emp_col].astype(str).str.strip() == str(q).strip())
            if not mask.any() and emp_col and emp_col in raw_df.columns:
                try:
                    q_numeric = float(q)
                    emp_numeric = pd.to_numeric(raw_df[emp_col], errors='coerce')
                    mask = mask | (emp_numeric == q_numeric)
                except Exception:
                    pass
            if not mask.any() and name_col and name_col in raw_df.columns:
                mask = mask | (raw_df[name_col].astype(str).str.strip().str.lower() == str(q).strip().lower())

            if not mask.any():
                continue

            filtered = raw_df[mask].copy()
            if filtered.empty:
                continue

            if tcol and tcol in filtered.columns:
                try:
                    filtered[tcol] = pd.to_datetime(filtered[tcol], errors='coerce')
                except Exception:
                    pass

            if tcol and tcol in filtered.columns:
                filtered = filtered.sort_values(by=tcol)
                filtered['_prev_ts'] = filtered[tcol].shift(1)
                try:
                    filtered['_swipe_gap_seconds'] = (filtered[tcol] - filtered['_prev_ts']).dt.total_seconds().fillna(0).astype(float)
                except Exception:
                    filtered['_swipe_gap_seconds'] = 0.0
                try:
                    cur_dates = filtered[tcol].dt.date
                    prev_dates = cur_dates.shift(1)
                    day_start_mask = (prev_dates != cur_dates) | (filtered['_prev_ts'].isna())
                    filtered.loc[day_start_mask, '_swipe_gap_seconds'] = 0.0
                except Exception:
                    pass
            else:
                filtered['_swipe_gap_seconds'] = 0.0

            try:
                if door_col and door_col in filtered.columns:
                    if dir_col and dir_col in filtered.columns:
                        # careful: apply needs column names from raw_df
                        filtered['_zone'] = filtered.apply(lambda rr: map_door_to_zone(rr.get(door_col), rr.get(dir_col)), axis=1)
                    else:
                        filtered['_zone'] = filtered[door_col].apply(lambda dv: map_door_to_zone(dv, None))
                else:
                    filtered['_zone'] = filtered.get('PartitionName2', None)
            except Exception:
                filtered['_zone'] = None

            for _, r in filtered.iterrows():
                out = {}
                out['EmployeeName'] = _to_python_scalar(r.get(name_col)) if name_col and name_col in filtered.columns else _to_python_scalar(matched.iloc[0].get('EmployeeName') if not matched.empty else q)
                emp_val = None
                if emp_col and emp_col in filtered.columns:
                    emp_val = _to_python_scalar(r.get(emp_col))
                else:
                    for cand in ('Int1','Text12','EmployeeID','EmployeeIdentity','empid','id'):
                        if cand.lower() in cols_lower:
                            emp_val = _to_python_scalar(r.get(cols_lower[cand.lower()]))
                            if emp_val not in (None,'','nan'):
                                break
                    if emp_val in (None,'','nan'):
                        emp_val = _to_python_scalar(matched.iloc[0].get('EmployeeID') if not matched.empty else None)
                if emp_val is not None:
                    try:
                        s = str(emp_val).strip()
                        if '.' in s:
                            f = float(s)
                            if math.isfinite(f) and f.is_integer():
                                s = str(int(f))
                        if _looks_like_guid(s) or _is_placeholder_str(s):
                            emp_val = None
                        else:
                            emp_val = s
                    except Exception:
                        if _looks_like_guid(emp_val):
                            emp_val = None
                out['EmployeeID'] = emp_val

                card_val = None
                if card_col and card_col in filtered.columns:
                    card_val = _to_python_scalar(r.get(card_col))
                else:
                    for cand in ('CardNumber','CHUID','Card','card_no','cardnum','value','xmlmessage'):
                        if cand.lower() in cols_lower:
                            card_val = _to_python_scalar(r.get(cols_lower[cand.lower()]))
                            if card_val not in (None,'','nan'):
                                break
                    if card_val in (None,'','nan'):
                        card_val = _to_python_scalar(matched.iloc[0].get('CardNumber') if not matched.empty else None)
                if card_val is not None:
                    try:
                        cs = str(card_val).strip()
                        if _looks_like_guid(cs) or _is_placeholder_str(cs):
                            card_val = None
                        else:
                            card_val = cs
                    except Exception:
                        card_val = None
                out['CardNumber'] = card_val
                out['Card'] = card_val

                if tcol and tcol in filtered.columns:
                    ts = r.get(tcol)
                    try:
                        ts_py = pd.to_datetime(ts)
                        out['Date'] = ts_py.date().isoformat()
                        out['Time'] = ts_py.time().isoformat()
                        out['LocaleMessageTime'] = ts_py.isoformat()
                    except Exception:
                        txt = str(r.get(tcol))
                        out['Date'] = txt[:10]
                        out['Time'] = txt[11:19] if len(txt) >= 19 else txt
                        out['LocaleMessageTime'] = txt
                else:
                    out['Date'] = None
                    out['Time'] = None
                    out['LocaleMessageTime'] = None

                out['SwipeGapSeconds'] = float(r.get('_swipe_gap_seconds')) if '_swipe_gap_seconds' in r else 0.0
                out['SwipeGap'] = format_seconds_to_hms(out['SwipeGapSeconds'])
                out['Door'] = _to_python_scalar(r.get(door_col)) if (door_col and door_col in filtered.columns) else None
                out['Direction'] = _to_python_scalar(r.get(dir_col)) if (dir_col and dir_col in filtered.columns) else _to_python_scalar(r.get('Direction')) if 'Direction' in r else None
                out['Note'] = _to_python_scalar(r.get(note_col)) if (note_col and note_col in filtered.columns) else None
                try:
                    out['Zone'] = _to_python_scalar(r.get('_zone')) if '_zone' in r else map_door_to_zone(out['Door'], out['Direction'])
                except Exception:
                    out['Zone'] = None
                out['PartitionName2'] = _to_python_scalar(r.get('PartitionName2')) if 'PartitionName2' in filtered.columns else None
                out['_source_file'] = fp.name
                _append_swipe(out, fp.name)

    return jsonify({
        "aggregated_rows": cleaned_matched,
        "raw_swipe_files": sorted(list(raw_files)),
        "raw_swipes": raw_swipes_out
    }), 200

@app.route('/record/export', methods=['GET'])
def export_record_excel():
    q = request.args.get('employee_id') or request.args.get('person_uid')
    date_str = request.args.get('date')
    city_param = request.args.get('city') or request.args.get('site') or 'pune'
    city_slug = _slug_city(city_param)

    if not q:
        return jsonify({"error":"employee_id or person_uid is required"}), 400

    p = Path(DEFAULT_OUTDIR)
    files_to_scan = []
    if date_str:
        try:
            dd = pd.to_datetime(date_str).date()
            files_to_scan = _find_swipe_files(DEFAULT_OUTDIR, date_obj=dd, city_slug=city_slug)
        except Exception:
            return jsonify({"error":"invalid date format, expected YYYY-MM-DD"}), 400
    else:
        files_to_scan = _find_swipe_files(DEFAULT_OUTDIR, date_obj=None, city_slug=city_slug)

    if not files_to_scan:
        return jsonify({"error":"no raw swipe files found for requested date / outputs"}), 404

    all_rows = []
    for fp in files_to_scan:
        try:
            raw_df = pd.read_csv(fp, dtype=str, parse_dates=['LocaleMessageTime'])
        except Exception:
            try:
                raw_df = pd.read_csv(fp, dtype=str)
            except Exception:
                continue

        raw_df = _replace_placeholder_strings(raw_df)
        cols_lower = {c.lower(): c for c in raw_df.columns}
        tcol = cols_lower.get('localemessagetime') or cols_lower.get('messagetime') or cols_lower.get('timestamp') or cols_lower.get('time') or None
        emp_col = cols_lower.get('int1') or cols_lower.get('employeeid') or cols_lower.get('employeeidentity') or cols_lower.get('employee_id') or None
        name_col = cols_lower.get('employeename') or cols_lower.get('objectname1') or cols_lower.get('employee_name') or None
        card_col = cols_lower.get('cardnumber') or cols_lower.get('card') or cols_lower.get('chuid') or cols_lower.get('value') or None
        door_col = cols_lower.get('door') or cols_lower.get('doorname') or cols_lower.get('door_name') or None
        dir_col = cols_lower.get('direction') or cols_lower.get('directionname') or cols_lower.get('direction_name') or None
        note_col = cols_lower.get('rejection_type') or cols_lower.get('note') or cols_lower.get('source') or None
        person_uid_col = cols_lower.get('person_uid')

        mask = pd.Series(False, index=raw_df.index)
        if person_uid_col and person_uid_col in raw_df.columns:
            mask = mask | (raw_df[person_uid_col].astype(str).str.strip() == str(q).strip())
        if emp_col and emp_col in raw_df.columns:
            mask = mask | (raw_df[emp_col].astype(str).str.strip() == str(q).strip())
        if not mask.any() and emp_col and emp_col in raw_df.columns:
            try:
                q_numeric = float(q)
                emp_numeric = pd.to_numeric(raw_df[emp_col], errors='coerce')
                mask = mask | (emp_numeric == q_numeric)
            except Exception:
                pass
        if not mask.any() and name_col and name_col in raw_df.columns:
            mask = mask | (raw_df[name_col].astype(str).str.strip().str.lower() == str(q).strip().lower())

        if not mask.any():
            continue

        filtered = raw_df[mask].copy()
        if filtered.empty:
            continue

        if tcol and tcol in filtered.columns:
            try:
                filtered[tcol] = pd.to_datetime(filtered[tcol], errors='coerce')
            except Exception:
                pass

        if tcol and tcol in filtered.columns:
            filtered = filtered.sort_values(by=tcol)
            filtered['_prev_ts'] = filtered[tcol].shift(1)
            try:
                filtered['_swipe_gap_seconds'] = (filtered[tcol] - filtered['_prev_ts']).dt.total_seconds().fillna(0).astype(float)
            except Exception:
                filtered['_swipe_gap_seconds'] = 0.0
        else:
            filtered['_swipe_gap_seconds'] = 0.0

        try:
            if door_col and door_col in filtered.columns:
                if dir_col and dir_col in filtered.columns:
                    filtered['_zone'] = filtered.apply(lambda rr: map_door_to_zone(rr.get(door_col), rr.get(dir_col)), axis=1)
                else:
                    filtered['_zone'] = filtered[door_col].apply(lambda dv: map_door_to_zone(dv, None))
            else:
                filtered['_zone'] = filtered.get('PartitionName2', None)
        except Exception:
            filtered['_zone'] = None

        for _, r in filtered.iterrows():
            row = {}
            row['EmployeeName'] = _to_python_scalar(r.get(name_col)) if (name_col and name_col in filtered.columns) else None
            emp_val = None
            if emp_col and emp_col in filtered.columns:
                emp_val = _to_python_scalar(r.get(emp_col))
            else:
                for cand in ('int1','text12','employeeid','employee_identity','employeeidentity'):
                    if cand in cols_lower and cols_lower[cand] in filtered.columns:
                        emp_val = _to_python_scalar(r.get(cols_lower[cand]))
                        if emp_val:
                            break
            row['EmployeeID'] = emp_val
            row['Card'] = _to_python_scalar(r.get(card_col)) if (card_col and card_col in filtered.columns) else None

            if tcol and tcol in filtered.columns:
                ts = r.get(tcol)
                try:
                    ts_py = pd.to_datetime(ts)
                    row['Date'] = ts_py.date().isoformat()
                    row['Time'] = ts_py.time().isoformat()
                    row['LocaleMessageTime'] = ts_py.isoformat()
                except Exception:
                    txt = str(r.get(tcol))
                    row['Date'] = txt[:10]
                    row['Time'] = txt[11:19] if len(txt) >= 19 else None
                    row['LocaleMessageTime'] = txt
            else:
                row['Date'] = None
                row['Time'] = None
                row['LocaleMessageTime'] = None

            row['SwipeGapSeconds'] = float(r.get('_swipe_gap_seconds')) if '_swipe_gap_seconds' in r else 0.0
            row['SwipeGap'] = format_seconds_to_hms(row['SwipeGapSeconds'])
            row['Door'] = _to_python_scalar(r.get(door_col)) if (door_col and door_col in filtered.columns) else None
            row['Direction'] = _to_python_scalar(r.get(dir_col)) if (dir_col and dir_col in filtered.columns) else None
            row['Note'] = _to_python_scalar(r.get(note_col)) if (note_col and note_col in filtered.columns) else None
            try:
                zone_val = r.get('_zone') if '_zone' in r else None
                if zone_val is None:
                    zone_val = map_door_to_zone(row['Door'], row['Direction'])
                row['Zone'] = _to_python_scalar(zone_val)
            except Exception:
                row['Zone'] = None
            row['PartitionName2'] = _to_python_scalar(r.get('PartitionName2')) if 'PartitionName2' in filtered.columns else None
            row['_source_file'] = fp.name
            all_rows.append(row)

    if not all_rows:
        return jsonify({"error":"no swipe rows matched the requested employee/date"}), 404

    df_out = pd.DataFrame(all_rows)
    details_cols = ['EmployeeName','EmployeeID','Door','Direction','Zone','Date','LocaleMessageTime','SwipeGapSeconds','PartitionName2','_source_file']
    timeline_cols = ['EmployeeName','EmployeeID','Card','Date','Time','SwipeGapSeconds','Door','Direction','Zone','Note','_source_file']

    details_df = df_out[[c for c in details_cols if c in df_out.columns]].copy()
    timeline_df = df_out[[c for c in timeline_cols if c in df_out.columns]].copy()

    output = io.BytesIO()
    try:
        with pd.ExcelWriter(output, engine='openpyxl') as writer:
            details_df.to_excel(writer, sheet_name='Details — Evidence', index=False)
            timeline_df.to_excel(writer, sheet_name='Swipe timeline', index=False)
            writer.save()
            output.seek(0)
    except Exception as e:
        logging.exception("Failed to create Excel: %s", e)
        return jsonify({"error":"failed to create excel"}), 500

    if OPENPYXL_AVAILABLE:
        try:
            wb = load_workbook(output)
            thin = Side(border_style="thin", color="000000")
            thick = Side(border_style="medium", color="000000")
            for ws in wb.worksheets:
                header = ws[1]
                for cell in header:
                    cell.font = Font(bold=True)
                    cell.alignment = Alignment(horizontal="center", vertical="center")
                    cell.border = Border(top=thick, left=thick, right=thick, bottom=thick)
                for row in ws.iter_rows(min_row=2, max_row=ws.max_row, min_col=1, max_col=ws.max_column):
                    for cell in row:
                        cell.alignment = Alignment(horizontal="center", vertical="center")
                        cell.border = Border(top=thin, left=thin, right=thin, bottom=thin)
                for col in ws.columns:
                    max_len = 0
                    col_letter = col[0].column_letter
                    for cell in col:
                        try:
                            v = str(cell.value) if cell.value is not None else ""
                        except Exception:
                            v = ""
                        if len(v) > max_len:
                            max_len = len(v)
                    width = min(max(10, max_len + 2), 50)
                    ws.column_dimensions[col_letter].width = width
            out2 = io.BytesIO()
            wb.save(out2)
            out2.seek(0)
            return send_file(out2, as_attachment=True,
                             download_name=f"evidence_{str(q).replace(' ','_')}_{date_str or 'all'}.xlsx",
                             mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
        except Exception:
            logging.exception("Excel styling failed, returning raw file")
            output.seek(0)
            return send_file(output, as_attachment=True,
                             download_name=f"evidence_{str(q).replace(' ','_')}_{date_str or 'all'}.xlsx",
                             mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
    else:
        output.seek(0)
        return send_file(output, as_attachment=True,
                         download_name=f"evidence_{str(q).replace(' ','_')}_{date_str or 'all'}.xlsx",
                         mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

@app.route('/swipes/<filename>', methods=['GET'])
def download_swipes(filename):
    fp = DEFAULT_OUTDIR / filename
    if not fp.exists():
        return jsonify({"error":"file not found"}), 404
    return send_from_directory(str(DEFAULT_OUTDIR), filename, as_attachment=True)

@app.route('/train', methods=['GET'])
def build_training_endpoint():
    end_date_str = request.args.get('end_date')
    months = int(request.args.get('months') or 3)
    min_unique = int(request.args.get('min_unique') or 1000)
    try:
        if end_date_str:
            end_date = datetime.strptime(end_date_str, "%Y-%m-%d").date()
        else:
            end_date = datetime.now().date()
    except Exception as e:
        return jsonify({"error": f"invalid end_date: {e}"}), 400

    try:
        if build_monthly_training is None:
            raise RuntimeError("build_monthly_training not available")
        csv_path = build_monthly_training(end_date=end_date, months=months, min_unique_employees=min_unique, outdir=str(DEFAULT_OUTDIR))
        if csv_path is None:
            return jsonify({"error":"no training CSV produced (no data)"}), 500
        return jsonify({"training_csv": str(csv_path)})
    except Exception as e:
        logging.exception("build_monthly_training failed")
        return jsonify({"error": str(e)}), 500

# chatbot helpers (kept mostly as-is)
try:
    from trend_runner import _read_past_trend_csvs, _normalize_id_val, SCENARIO_EXPLANATIONS
except Exception:
    _read_past_trend_csvs = None
    _normalize_id_val = None
    SCENARIO_EXPLANATIONS = {}

def _load_latest_trend_df(outdir: Path, city: str = "pune"):
    city_slug = _slug_city(city)
    csvs = sorted(outdir.glob(f"trend_{city_slug}_*.csv"), reverse=True)
    if not csvs:
        csvs = sorted(outdir.glob("trend_*.csv"), reverse=True)
    if not csvs:
        return None, None
    latest = csvs[0]
    try:
        df = pd.read_csv(latest)
    except Exception:
        df = pd.read_csv(latest, dtype=str)
    df = _replace_placeholder_strings(df)
    return df, latest.name

def _find_person_rows(identifier: str, days: int = 90, outdir: Path = DEFAULT_OUTDIR):
    if _normalize_id_val:
        norm = _normalize_id_val(identifier)
    else:
        norm = str(identifier).strip()
        if '.' in norm:
            try:
                f = float(norm)
                if f.is_integer():
                    norm = str(int(f))
            except Exception:
                pass
    today = datetime.now().date()
    try:
        if _read_past_trend_csvs:
            past = _read_past_trend_csvs(str(outdir), days, today)
        else:
            files = sorted(Path(outdir).glob("trend_pune_*.csv"), reverse=True)
            dfs = []
            cutoff = today - timedelta(days=days)
            for fp in files:
                try:
                    tmp = pd.read_csv(fp, parse_dates=['Date'])
                    tmp['Date'] = pd.to_datetime(tmp['Date'], errors='coerce').dt.date
                    tmp = tmp[tmp['Date'].apply(lambda d: d is not None and d >= cutoff and d <= today)]
                    dfs.append(tmp)
                except Exception:
                    try:
                        tmp = pd.read_csv(fp, dtype=str)
                        if 'Date' in tmp.columns:
                            tmp['Date'] = pd.to_datetime(tmp['Date'], errors='coerce').dt.date
                            tmp = tmp[tmp['Date'].apply(lambda d: d is not None and d >= cutoff and d <= today)]
                            dfs.append(tmp)
                    except Exception:
                        continue
            past = pd.concat(dfs, ignore_index=True) if dfs else pd.DataFrame()
    except Exception:
        past = pd.DataFrame()

    if past is None or past.empty:
        return pd.DataFrame()

    past = _replace_placeholder_strings(past)
    match_mask = pd.Series(False, index=past.index)
    for col in ('EmployeeID','person_uid','EmployeeIdentity','CardNumber','Int1','Text12'):
        if col in past.columns:
            try:
                match_mask = match_mask | (past[col].astype(str).fillna('').str.strip() == str(norm).strip())
            except Exception:
                continue

    if not match_mask.any():
        try:
            qnum = float(norm)
            for col in ('EmployeeID','Int1'):
                if col in past.columns:
                    try:
                        numcol = pd.to_numeric(past[col], errors='coerce')
                        match_mask = match_mask | (numcol == qnum)
                    except Exception:
                        continue
        except Exception:
            pass

    if not match_mask.any() and 'EmployeeName' in past.columns:
        names = past['EmployeeName'].dropna().astype(str).unique().tolist()
        close = difflib.get_close_matches(str(identifier), names, n=5, cutoff=0.7)
        if close:
            match_mask = match_mask | past['EmployeeName'].astype(str).isin(close)

    return past[match_mask].copy()

def _explain_scenario_code(code):
    if not code:
        return None
    code = str(code).strip()
    if code in SCENARIO_EXPLANATIONS:
        try:
            fn = SCENARIO_EXPLANATIONS.get(code)
            try:
                txt = fn({})
                return txt
            except Exception:
                return code.replace("_", " ").replace(">= ", "≥ ")
        except Exception:
            return code.replace("_", " ").replace(">= ", "≥ ")
    return code.replace("_", " ").replace(">=", "≥")

def _map_score_to_label_fallback(score: float):
    try:
        s = float(score)
    except Exception:
        return (0.0, "Low")
    if s >= 0.75:
        return (s, "High")
    if s >= 0.4:
        return (s, "Medium")
    return (s, "Low")

@app.route('/chatbot/query', methods=['POST'])
def chatbot_query():
    payload = request.get_json(force=True)
    q = (payload.get('q') or '').strip()
    if not q:
        return jsonify({"error":"query text 'q' required"}), 400
    lang = payload.get('lang')
    q_l = q.lower().strip()

    if re.search(r"\bwho is (high|low) risk\b", q_l) or re.search(r"\b(high|low) risk (people|persons|people) (today)?\b", q_l):
        want = 'high' if 'high' in q_l else 'low' if 'low' in q_l else None
        df, fname = _load_latest_trend_df(DEFAULT_OUTDIR)
        if df is None:
            return jsonify({"answer": "No trend data available.", "evidence": []})
        if 'RiskLevel' not in df.columns:
            if 'RiskScore' in df.columns:
                def _map_rs(s):
                    try:
                        if pd.isna(s):
                            return 'Low'
                    except Exception:
                        pass
                    try:
                        if 'map_score_to_label' in globals() and callable(globals().get('map_score_to_label')):
                            try:
                                return globals().get('map_score_to_label')(float(s))[1]
                            except Exception:
                                pass
                        return _map_score_to_label_fallback(float(s))[1]
                    except Exception:
                        return 'Low'
                df['RiskLevel'] = df['RiskScore'].apply(lambda s: _map_rs(s))
            else:
                df['RiskLevel'] = df.get('RiskLevel', 'Low')
        if want == 'high':
            sel = df[df['RiskLevel'].astype(str).str.lower() == 'high']
        elif want == 'low':
            sel = df[df['RiskLevel'].astype(str).str.lower() == 'low']
        else:
            sel = df
        names = sel['EmployeeName'].dropna().astype(str).unique().tolist()
        if not names:
            ans = f"No {want} risk persons found in the latest data." if want else "No persons found."
            return jsonify({"answer": ans, "evidence": []})
        else:
            ans = f"{want.capitalize()} risk persons today: " + ", ".join(names[:40])
            sample = _clean_sample_df(sel.head(10), max_rows=10)
            return jsonify({"answer": ans, "evidence": sample})

    m = re.match(r".*\bexplain\s+([A-Za-z0-9_\-]+)\b.*", q_l)
    if m:
        code = m.group(1).strip()
        explanation = _explain_scenario_code(code)
        ans = f"Explanation for '{code}': {explanation}"
        return jsonify({"answer": ans, "evidence": []})

    if 'trend details' in q_l or 'top reasons' in q_l or 'trend details for today' in q_l:
        df, fname = _load_latest_trend_df(DEFAULT_OUTDIR)
        if df is None:
            return jsonify({"answer":"No trend data available.","evidence":[]})
        if 'Reasons' in df.columns:
            reasons = {}
            for v in df['Reasons'].dropna().astype(str):
                for part in re.split(r'[;,\|]', v):
                    key = part.strip()
                    if key and not _is_placeholder_str(key):
                        reasons[key] = reasons.get(key, 0) + 1
            top = sorted(reasons.items(), key=lambda x: x[1], reverse=True)[:10]
            if not top:
                return jsonify({"answer":"No reason counts available today.","evidence":[]})
            ans = "Top reasons today: " + ", ".join([f"{k} ({c})" for k,c in top])
            sample = []
            try:
                top_reasons = [k for k,_ in top]
                mask = df['Reasons'].astype(str).apply(lambda s: any(tr in s for tr in top_reasons))
                sample_df = df[mask].head(10)
                sample = _clean_sample_df(sample_df, max_rows=10)
            except Exception:
                sample = []
            return jsonify({"answer": ans, "evidence": sample})

    m = re.match(r".*\bshow (?:me )?([A-Za-z0-9\-\:\s]+?) (?:for )?(?:last )?(\d+)\s*days\b", q_l)
    if not m:
        m = re.match(r".*\b(show|display)\s+(?:me\s+)?([A-Za-z0-9\-\:\s]+?)\s+last\s+(\d+)\s*days\b", q_l)
    if m:
        if len(m.groups()) == 2:
            identifier, days = m.group(1).strip(), int(m.group(2))
        else:
            identifier = m.group(1).strip()
            days = int(m.group(2))
        rows = _find_person_rows(identifier, days=days, outdir=DEFAULT_OUTDIR)
        if rows is None or rows.empty:
            return jsonify({"answer": f"No records found for '{identifier}' in last {days} days.", "evidence": []})
        flagged = rows[rows.get('IsFlagged', False) == True] if 'IsFlagged' in rows.columns else pd.DataFrame()
        flagged_count = int(len(flagged))
        total_days = int(len(rows))
        latest_row = rows.sort_values('Date', ascending=False).iloc[0].to_dict()
        name = latest_row.get('EmployeeName') or latest_row.get('person_uid') or latest_row.get('EmployeeID')
        ans = f"Found {total_days} day(s) for {name} in the last {days} days. Flagged days: {flagged_count}."
        sample = _clean_sample_df(rows.sort_values('Date', ascending=False).head(10), max_rows=10)
        return jsonify({"answer": ans, "evidence": sample})

    if 'present today' in q_l or 'who is present today' in q_l:
        df, fname = _load_latest_trend_df(DEFAULT_OUTDIR)
        if df is None:
            return jsonify({"answer":"No trend data available.","evidence":[]})
        if 'PresentToday' in df.columns:
            present = df[df['PresentToday'] == True]
            names = present['EmployeeName'].dropna().unique().tolist()
            ans = f"Present today: {', '.join(names[:40]) if names else 'None'}"
            sample = _clean_sample_df(present.head(10), max_rows=10)
            return jsonify({"answer": ans, "evidence": sample})
        else:
            return jsonify({"answer":"PresentToday field not available in latest trends.","evidence":[]})

    hint = "I can answer: 'Who is high risk today', 'Who is low risk today', 'Show me <EmployeeID|Name> last 90 days', 'Explain <scenario_code>', 'Trend details for today — top reasons'."
    return jsonify({"answer": f"I can help with trend & risk questions. I recognized: {q}. Try: {hint}", "evidence":[]})

# @app.route('/employee/<empid>/image', methods=['GET'])
# def serve_employee_image(empid):
#     if empid is None:
#         return jsonify({"error": "employee id required"}), 400
#     try:
#         img_bytes = get_person_image_bytes(empid)
#         if not img_bytes:
#             return jsonify({"error": "no image found"}), 404
#         header = img_bytes[:8]
#         content_type = 'application/octet-stream'
#         if len(header) >= 2 and header[0] == 0xFF and header[1] == 0xD8:
#             content_type = 'image/jpeg'
#         elif header.startswith(b'\x89PNG\r\n\x1a\n'):
#             content_type = 'image/png'
#         bio = io.BytesIO(img_bytes)
#         bio.seek(0)
#         return send_file(bio, mimetype=content_type)
#     except Exception:
#         logging.exception("Error serving image for employee %s", empid)
#         return jsonify({"error": "failed to serve image"}), 500

@app.route('/employee/<empid>/image', methods=['GET'])
def serve_employee_image(empid):
    if empid is None:
        return jsonify({"error": "employee id required"}), 400
    try:
        img_bytes = get_person_image_bytes(empid)
        # If no image found, return a small inline SVG placeholder so <img> can still render
        if not img_bytes:
            svg = (
                '<svg xmlns="http://www.w3.org/2000/svg" width="160" height="160">'
                '<rect fill="#eef2f7" width="100%" height="100%"/>'
                '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#64748b" font-size="18">'
                'No image</text></svg>'
            )
            bio = io.BytesIO(svg.encode('utf-8'))
            bio.seek(0)
            resp = send_file(bio, mimetype='image/svg+xml')
            # avoid aggressive caching of placeholder
            resp.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
            return resp

        # detect content type heuristically (jpeg/png)
        header = img_bytes[:8] if isinstance(img_bytes, (bytes, bytearray)) else bytes(img_bytes)[:8]
        content_type = 'application/octet-stream'
        try:
            if len(header) >= 2 and header[0] == 0xFF and header[1] == 0xD8:
                content_type = 'image/jpeg'
            elif header.startswith(b'\x89PNG\r\n\x1a\n'):
                content_type = 'image/png'
            elif header.startswith(b'BM'):
                content_type = 'image/bmp'
            else:
                # fallback: try to detect common image signatures, otherwise serve as octet-stream
                content_type = 'application/octet-stream'
        except Exception:
            content_type = 'application/octet-stream'

        bio = io.BytesIO(img_bytes if isinstance(img_bytes, (bytes, bytearray)) else bytes(img_bytes))
        bio.seek(0)
        resp = send_file(bio, mimetype=content_type)
        # small caching is ok for real images
        resp.headers['Cache-Control'] = 'private, max-age=300'
        return resp
    except Exception:
        logging.exception("Error serving image for employee %s", empid)
        return jsonify({"error": "failed to serve image"}), 500



# run
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8002, debug=True)








  <!doctype html>
  <html>

  <head>
    <meta charset="utf-8" />
    <title>Behaviour Analysis — Dashboard</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- React + ReactDOM + Babel (quick prototyping) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Flatpickr -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="style.css">
  </head>

  <body>
    <div id="root"></div>

    <script type="text/babel">
      (function () {
        const { useState, useEffect, useRef } = React;

        // CHANGE IF YOUR API HOST DIFFERS
        const API_BASE = "http://localhost:8002";

        // --- Region / Location mapping copied from backend/duration_report.REGION_CONFIG (friendly / UI names) ---
        // Keep the keys lowercase to match backend region keys.
        const REGION_OPTIONS = {
          "apac": {
            label: "APAC",
            // Friendly names used by backend normalisation (duration_report) for APAC
            partitions: ["Pune", "Quezon City", "Taguig City", "MY.Kuala Lumpur", "IN.HYD", "SG.Singapore"]
          },
          "emea": {
            label: "EMEA",
            partitions: ["LT.Vilnius", "IT.Rome", "UK.London", "IE.DUblin", "DU.Abu Dhab", "ES.Madrid"]
          },
          "laca": {
            label: "LACA",
            partitions: ["AR.Cordoba", "BR.Sao Paulo", "CR.Costa Rica Partition", "PA.Panama City", "PE.Lima", "MX.Mexico City"]
          },
          "namer": {
            label: "NAMER",
            // show friendly names to the user, but we map them to backend partition tokens before sending
            partitions: ["Denver", "Austin Texas", "Miami", "New York"]
          }
        };

        // Map from UI-friendly location label -> backend search token (used for &city=)
        // For APAC, friendly labels match backend PartitionName2 normalised values so they map to themselves.
        // For NAMER, backend normalisation sets PartitionName2 to tokens like "US.CO.OBS", "USA/Canada Default" etc.
        const LOCATION_QUERY_VALUE = {
          "apac": {
            "Pune": "Pune",
            "Quezon City": "Quezon City",
            "Taguig City": "Taguig City",
            "MY.Kuala Lumpur": "MY.Kuala Lumpur",
            "IN.HYD": "IN.HYD",
            "SG.Singapore": "SG.Singapore"
          },
          "namer": {
            // friendly->backend tokens (this matches the backend duration_report normalisation)
            "Denver": "US.CO.OBS",
            "Austin Texas": "USA/Canada Default",
            "Miami": "US.FL.Miami",
            "New York": "US.NYC"
          },
          // default passthrough for other regions (if needed)
          "emea": {},
          "laca": {}
        };

        // Map risk text/colors (same as backend map_score_to_label buckets)
        const RISK_COLORS = {
          "Low": "#10b981",
          "Low Medium": "#86efac",
          "Medium": "#facc15",
          "Medium High": "#fb923c",
          "High": "#ef4444"
        };
        const RISK_LABELS = ["Low", "Low Medium", "Medium", "Medium High", "High"];

        // (rest unchanged) Explanations...
        const SCENARIO_EXPLANATIONS = {
          "long_gap_>=4.5h": "Long gap between swipes (>=4.5 hours).",
          "short_duration_<4h": "Short total presence (<4 hours).",
          "coffee_badging": "Multiple short swipes — possible coffee badging.",
          "low_swipe_count_<=2": "Very few swipes recorded for day (<=2).",
          "single_door": "Single door used during day.",
          "only_in": "Only IN events present.",
          "only_out": "Only OUT events present.",
          "overtime_>=10h": "Overtime (>=10 hours).",
          "very_long_duration_>=16h": "Very long presence (>=16 hours).",
          "unusually_high_swipes": "Unusually high number of swipes vs history.",
          "repeated_short_breaks": "Multiple short breaks in day.",
          "multiple_location_same_day": "Multiple locations used same day.",
          "weekend_activity": "Activity on weekend.",
          "repeated_rejection_count": "Multiple rejections.",
          "badge_sharing_suspected": "Same card used by multiple persons on same day.",
          "early_arrival_before_06": "First swipe earlier than 06:00.",
          "late_exit_after_22": "Last swipe after 22:00.",
          "shift_inconsistency": "Duration inconsistent with historical shift.",
          "trending_decline": "Historical trending decline.",
          "consecutive_absent_days": "Consecutive absent days historically.",
          "high_variance_duration": "High variance in durations historically.",
          "short_duration_on_high_presence_days": "Short duration despite high typical presence.",
          "swipe_overlap": "Swipes overlapping other users (possible tailgating).",
          "shortstay_longout_repeat": "Short in -> long out -> short return pattern."
        };

        // small utilities
        function pad(n) { return n.toString().padStart(2, '0'); }
        function formatDateISO(d) {
          if (!d) return "";
          const dt = (d instanceof Date) ? d : new Date(d);
          return dt.getFullYear() + "-" + pad(dt.getMonth() + 1) + "-" + pad(dt.getDate());
        }
        function safeDateDisplay(val) {
          if (!val && val !== 0) return "";
          try {
            const d = (val instanceof Date) ? val : new Date(val);
            if (isNaN(d.getTime())) return String(val);
            return d.toLocaleString();
          } catch (e) {
            return String(val);
          }
        }

        function sanitizeName(row) {
    if (!row) return "";
    // prefer feature/duration versions if present
    return row.EmployeeName_feat || row.EmployeeName_dur || row.EmployeeName || row.ObjectName1 || row.objectname1 || row.employee_name || row.person_uid || "";
  }


        function downloadCSV(rows, filename) {
          if (!rows || !rows.length) { alert("No rows to export"); return; }
          var cols = Object.keys(rows[0]);
          var lines = [cols.join(",")];
          rows.forEach(function (r) {
            var row = cols.map(function (c) {
              var v = (r[c] === undefined || r[c] === null) ? "" : String(r[c]).replace(/\n/g, ' ');
              return JSON.stringify(v);
            }).join(",");
            lines.push(row);
          });
          var blob = new Blob([lines.join("\n")], { type: 'text/csv' });
          var url = URL.createObjectURL(blob);
          var a = document.createElement('a'); a.href = url; a.download = filename || 'export.csv'; a.click(); URL.revokeObjectURL(url);
        }

        // duration formatting helper
        function formatSecondsToHmsJS(seconds) {
          if (seconds === null || seconds === undefined || seconds === '') return "-";
          const n = Number(seconds);
          if (isNaN(n) || !isFinite(n)) return "-";
          const s = Math.max(0, Math.floor(n));
          const hh = Math.floor(s / 3600);
          const mm = Math.floor((s % 3600) / 60);
          const ss = s % 60;
          return pad(hh) + ":" + pad(mm) + ":" + pad(ss);
        }

        // ----- Day-boundary helpers -----
        // Use 2AM boundary for Pune (backend shift logic uses -2h shift for Pune)
        const DAY_BOUNDARY_HOUR = 2;

        function logicalDateForTs(dt, boundaryHour = DAY_BOUNDARY_HOUR) {
          if (!dt || !(dt instanceof Date) || isNaN(dt.getTime())) return null;
          const hour = dt.getHours();
          const year = dt.getFullYear();
          const month = dt.getMonth();
          const day = dt.getDate();
          const out = new Date(year, month, day, 0, 0, 0, 0);
          if (hour < boundaryHour) {
            out.setDate(out.getDate() - 1);
          }
          const y = out.getFullYear();
          const m = String(out.getMonth() + 1).padStart(2, '0');
          const d = String(out.getDate()).padStart(2, '0');
          return `${y}-${m}-${d}`;
        }

        function makeLocalDateFromRow(r) {
          try {
            if (!r) return null;

            if (r.LocaleMessageTime) {
              const t = new Date(r.LocaleMessageTime);
              if (!isNaN(t.getTime())) return t;
            }
          } catch (e) {}

          function toInt(v, fallback = 0) {
            const n = Number(v);
            return Number.isFinite(n) ? n : fallback;
          }

          try {
            if (r.Date && r.Time) {
              const dateStr = String(r.Date).slice(0, 10).replace(/\//g, '-');
              const dateParts = dateStr.split('-').map(p => toInt(p, NaN));
              if (dateParts.length === 3 && !isNaN(dateParts[0])) {
                const year = dateParts[0];
                const month = dateParts[1];
                const day = dateParts[2];

                const timeRaw = String(r.Time).split(/[.+Z ]/)[0];
                const timeParts = timeRaw.split(':').map(p => toInt(p, 0));
                const hh = timeParts[0] || 0;
                const mm = timeParts[1] || 0;
                const ss = timeParts[2] || 0;

                return new Date(year, month - 1, day, hh, mm, ss, 0);
              }
            }
          } catch (e) {}

          try {
            if (r.Date) {
              const parts = String(r.Date).slice(0, 10).replace(/\//g, '-').split('-');
              if (parts.length === 3) {
                const y = toInt(parts[0], NaN);
                const m = toInt(parts[1], NaN);
                const d = toInt(parts[2], NaN);
                if (!isNaN(y)) return new Date(y, m - 1, d, 0, 0, 0, 0);
              }
            }
          } catch (e) {}

          return null;
        }

        // App component
        function App() {
          var yesterday = new Date();
          yesterday.setDate(yesterday.getDate() - 1);

          const [dateFrom, setDateFrom] = useState(formatDateISO(yesterday));
          const [dateTo, setDateTo] = useState(formatDateISO(new Date()));
          const [loading, setLoading] = useState(false);
          const [summary, setSummary] = useState({ rows: 0, flagged_rows: 0, files: [], end_date: null });
          const [rows, setRows] = useState([]);
          const [reasonsCount, setReasonsCount] = useState({});
          const [riskCounts, setRiskCounts] = useState({ "Low": 0, "Low Medium": 0, "Medium": 0, "Medium High": 0, "High": 0 });
          const [filterText, setFilterText] = useState("");
          const [page, setPage] = useState(1);
          const [selectedReason, setSelectedReason] = useState("");
          const [reasonFilterText, setReasonFilterText] = useState("");
          const [modalRow, setModalRow] = useState(null);
          const [modalDetails, setModalDetails] = useState(null);
          const [modalLoading, setModalLoading] = useState(false);
          const [selectedRiskFilter, setSelectedRiskFilter] = useState("");

          // New: region & location
          const [selectedRegion, setSelectedRegion] = useState("apac"); // default APAC
          const [selectedLocation, setSelectedLocation] = useState("All locations"); // default no city filter

          const pageSize = 25;
          const chartRef = useRef(null);
          const chartInst = useRef(null);

          const fromRef = useRef(null);
          const toRef = useRef(null);
          const fromFp = useRef(null);
          const toFp = useRef(null);

          // Chat state
          const [chatOpen, setChatOpen] = useState(false);
          const [chatMessages, setChatMessages] = useState([]);
          const [chatInput, setChatInput] = useState("");
          const [chatLoading, setChatLoading] = useState(false);

          useEffect(function () {
            if (window.flatpickr && fromRef.current && toRef.current) {
              try { if (fromFp.current) fromFp.current.destroy(); } catch (e) { }
              try { if (toFp.current) toFp.current.destroy(); } catch (e) { }
              fromFp.current = window.flatpickr(fromRef.current, {
                dateFormat: "Y-m-d",
                defaultDate: dateFrom,
                allowInput: true,
                onChange: function (selectedDates, str) {
                  if (selectedDates && selectedDates.length) {
                    const iso = formatDateISO(selectedDates[0]);
                    setDateFrom(iso);
                    try { if (toFp.current) toFp.current.set('minDate', iso); } catch (e) { }
                    if (dateTo && new Date(iso) > new Date(dateTo)) {
                      setDateTo(iso);
                      try { if (toFp.current) toFp.current.setDate(iso, true); } catch (e) { }
                    }
                  }
                }
              });
              toFp.current = window.flatpickr(toRef.current, {
                dateFormat: "Y-m-d",
                defaultDate: dateTo,
                allowInput: true,
                onChange: function (selectedDates, str) {
                  if (selectedDates && selectedDates.length) {
                    const iso = formatDateISO(selectedDates[0]);
                    setDateTo(iso);
                    try { if (fromFp.current) fromFp.current.set('maxDate', iso); } catch (e) { }
                    if (dateFrom && new Date(iso) < new Date(dateFrom)) {
                      setDateFrom(iso);
                      try { if (fromFp.current) fromFp.current.setDate(iso, true); } catch (e) { }
                    }
                  }
                }
              });
              try { if (fromFp.current) fromFp.current.set('maxDate', dateTo); if (toFp.current) toFp.current.set('minDate', dateFrom); } catch (e) { }
            }
            loadLatest();
            return function () { try { if (fromFp.current) fromFp.current.destroy(); } catch (e) { } try { if (toFp.current) toFp.current.destroy(); } catch (e) { } };
            // eslint-disable-next-line
          }, []);

          useEffect(function () {
            try { if (fromFp.current && dateFrom) fromFp.current.setDate(dateFrom, false); } catch (e) { }
            try { if (toFp.current && dateTo) toFp.current.setDate(dateTo, false); } catch (e) { }
            try { if (fromFp.current) fromFp.current.set('maxDate', dateTo); } catch (e) { }
            try { if (toFp.current) toFp.current.set('minDate', dateFrom); } catch (e) { }
          }, [dateFrom, dateTo]);

          // When region changes, reset location to "All locations"
          useEffect(() => {
            setSelectedLocation("All locations");
          }, [selectedRegion]);

          async function runForRange() {
            setLoading(true);
            setRows([]);
            setSummary({ rows: 0, flagged_rows: 0, files: [], end_date: null });
            setReasonsCount({});
            setRiskCounts({ "Low": 0, "Low Medium": 0, "Medium": 0, "Medium High": 0, "High": 0 });
            try {
              const start = encodeURIComponent(dateFrom);
              const end = encodeURIComponent(dateTo);
              // include selected region & city if provided
              let url = API_BASE + "/run?start=" + start + "&end=" + end + "&full=true";
              if (selectedRegion) {
                url += "&region=" + encodeURIComponent(selectedRegion);
              }
              if (selectedLocation && selectedLocation !== "All locations") {
                // send backend-aware partition token (use mapping)
                const mapForRegion = LOCATION_QUERY_VALUE[selectedRegion] || {};
                const queryCity = mapForRegion[selectedLocation] || selectedLocation;
                url += "&city=" + encodeURIComponent(queryCity);
              }
              let r = await fetch(url, { method: 'GET' });
              if (!r.ok) { const txt = await r.text(); throw new Error("API returned " + r.status + ": " + txt); }
              let js = await r.json();

              const totalRows = (typeof js.aggregated_unique_persons === 'number') ? js.aggregated_unique_persons
                              : (typeof js.rows === 'number') ? js.rows : 0;
              const totalFlagged = (typeof js.flagged_rows === 'number') ? js.flagged_rows : 0;
              const files = js.files || [];

              const sample = Array.isArray(js.flagged_persons) && js.flagged_persons.length ? js.flagged_persons
                  : (Array.isArray(js.sample) ? js.sample : []);
              setRows(sample);

              setSummary({ rows: totalRows, flagged_rows: totalFlagged, files: files, end_date: formatDateISO(new Date(dateTo)) });

              if (js.reasons_count && Object.keys(js.reasons_count).length > 0) {
                setReasonsCount(js.reasons_count);
              } else {
                computeReasonsAndRisks(sample);
              }
              if (js.risk_counts && Object.keys(js.risk_counts).length > 0) {
                const all = { "Low":0,"Low Medium":0,"Medium":0,"Medium High":0,"High":0 };
                Object.keys(js.risk_counts).forEach(k => { all[k] = js.risk_counts[k]; });
                setRiskCounts(all);
              } else {
                computeReasonsAndRisks(sample);
              }
              setPage(1);
            } catch (err) {
              alert("Error: " + err.message);
              console.error(err);
            } finally {
              setLoading(false);
            }
          }

          function pushChatMessage(msg) {
            setChatMessages(prev => [...prev, msg]);
            setTimeout(() => {
              const el = document.querySelector('.chat-body');
              if (el) el.scrollTop = el.scrollHeight;
            }, 50);
          }

          function computeReasonsAndRisks(dataRows) {
            var counts = {};
            var rcounts = { "Low": 0, "Low Medium": 0, "Medium": 0, "Medium High": 0, "High": 0 };
            (dataRows || []).forEach(function (r) {
              const reasonsField = r.Reasons || r.DetectedScenarios || r.Detected || null;
              if (reasonsField) {
                var parts = String(reasonsField).split(";").map(function (s) { return s.trim(); }).filter(Boolean);
                parts.forEach(function (p) { counts[p] = (counts[p] || 0) + 1; });
              }
              var rl = getRiskLabelForRow(r);
              if (rl && rcounts[rl] !== undefined) {
                rcounts[rl] += 1;
              } else if (rl) {
                rcounts[rl] = (rcounts[rl] || 0) + 1;
              } else {
                rcounts["Low"] += 1;
              }
            });
            setReasonsCount(counts);
            setRiskCounts(rcounts);
          }

          async function loadLatest() {
            setLoading(true);
            try {
              // run for yesterday (to match backend's default behaviour)
              var d = new Date();
              d.setDate(d.getDate() - 1);
              var yesterday = formatDateISO(d);
              setDateFrom(yesterday);
              setDateTo(yesterday);

              const start = encodeURIComponent(yesterday);
              const end = encodeURIComponent(yesterday);
              let url = API_BASE + "/run?start=" + start + "&end=" + end + "&full=true";
              if (selectedRegion) {
                url += "&region=" + encodeURIComponent(selectedRegion);
              }
              if (selectedLocation && selectedLocation !== "All locations") {
                const mapForRegion = LOCATION_QUERY_VALUE[selectedRegion] || {};
                const queryCity = mapForRegion[selectedLocation] || selectedLocation;
                url += "&city=" + encodeURIComponent(queryCity);
              }
              let r = await fetch(url, { method: 'GET' });
              if (!r.ok) { const txt = await r.text(); throw new Error("API returned " + r.status + ": " + txt); }
              let js = await r.json();

              const totalRows = (typeof js.aggregated_unique_persons === 'number') ? js.aggregated_unique_persons
                              : (typeof js.rows === 'number') ? js.rows : 0;
              const totalFlagged = (typeof js.flagged_rows === 'number') ? js.flagged_rows : 0;
              const files = js.files || [];

              const sample = Array.isArray(js.sample) ? js.sample : (Array.isArray(js.flagged_persons) ? js.flagged_persons : []);
              setRows(sample);
              setSummary({ rows: totalRows, flagged_rows: totalFlagged, files: files, end_date: yesterday });

              if (js.reasons_count && Object.keys(js.reasons_count).length > 0) {
                setReasonsCount(js.reasons_count);
              } else {
                computeReasonsAndRisks(sample);
              }
              if (js.risk_counts && Object.keys(js.risk_counts).length > 0) {
                const all = { "Low":0,"Low Medium":0,"Medium":0,"Medium High":0,"High":0 };
                Object.keys(js.risk_counts).forEach(k => { all[k] = js.risk_counts[k]; });
                setRiskCounts(all);
              } else {
                computeReasonsAndRisks(sample);
              }
              setPage(1);
            } catch (err) {
              alert("Error: " + err.message);
              console.error(err);
            } finally {
              setLoading(false);
            }
          }

          function getRiskLabelForRow(r) {
            if (!r) return null;
            var rl = r.RiskLevel || r.Risk || null;
            if (rl) return String(rl);
            if (r.RiskScore !== undefined && r.RiskScore !== null) {
              const mapNum = { 1: "Low", 2: "Low Medium", 3: "Medium", 4: "Medium High", 5: "High" };
              return mapNum[String(r.RiskScore)] || null;
            }
            if (r.AnomalyScore !== undefined && r.AnomalyScore !== null) {
              if (r.AnomalyScore >= 5) return "High";
              if (r.AnomalyScore >= 4) return "Medium High";
              if (r.AnomalyScore >= 3) return "Medium";
              if (r.AnomalyScore >= 2) return "Low Medium";
              return "Low";
            }
            return null;
          }

          function buildChart(rcounts) {
            var labels = RISK_LABELS;
            var values = labels.map(l => rcounts && rcounts[l] ? rcounts[l] : 0);
            var colors = labels.map(l => {
              if (selectedRiskFilter) {
                return (l === selectedRiskFilter) ? RISK_COLORS[l] : '#e6edf3';
              } else {
                return RISK_COLORS[l] || '#cccccc';
              }
            });

            var ctx = chartRef.current && chartRef.current.getContext ? chartRef.current.getContext('2d') : null;
            if (!ctx) return;
            try { if (chartInst.current) chartInst.current.destroy(); } catch (e) { }

            chartInst.current = new Chart(ctx, {
              type: 'line',
              data: {
                labels: labels,
                datasets: [{
                  label: 'Flagged by Risk Level',
                  data: values,
                  borderColor: '#2563eb',
                  backgroundColor: 'rgba(37,99,235,0.2)',
                  fill: true,
                  tension: 0.3,
                  pointBackgroundColor: colors,
                  pointRadius: 5,
                  pointHoverRadius: 7
                }]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  tooltip: {
                    callbacks: {
                      label: function (context) {
                        return context.parsed.y + ' cases';
                      }
                    }
                  }
                },
                onClick: function (evt, elements) {
                  if (elements && elements.length > 0) {
                    var idx = elements[0].index;
                    var label = this.data.labels[idx];
                    handleRiskBarClick(label);
                  }
                },
                scales: {
                  y: { beginAtZero: true, ticks: { precision: 0 } }
                }
              }
            });

          }

          useEffect(function () {
            buildChart(riskCounts);
          }, [riskCounts, selectedRiskFilter]);

          // Filtering & pagination
          var filtered = (rows || []).filter(function (r) {
            var hay = (sanitizeName(r) + " " + (r.EmployeeID || "") + " " + (r.CardNumber || "") + " " + (r.Reasons || r.DetectedScenarios || "")).toLowerCase();
            var textOk = !filterText || hay.indexOf(filterText.toLowerCase()) !== -1;
            var reasonOk = !selectedReason || (r.Reasons && ((";" + String(r.Reasons) + ";").indexOf(selectedReason) !== -1)) || (r.DetectedScenarios && ((";" + String(r.DetectedScenarios) + ";").indexOf(selectedReason) !== -1));
            var riskOk = true;
            if (selectedRiskFilter) {
              var rl = getRiskLabelForRow(r);
              if (!rl) { riskOk = false; }
              else riskOk = (String(rl) === String(selectedRiskFilter));
            }
            return textOk && reasonOk && riskOk;
          })
          .sort(function(a, b) {
            var va = Number(a.ViolationDaysLast90 || a.ViolationDaysLast_90 || 0);
            var vb = Number(b.ViolationDaysLast90 || b.ViolationDaysLast_90 || 0);
            if (isNaN(va)) va = 0;
            if (isNaN(vb)) vb = 0;
            if (vb !== va) return vb - va;
            return (sanitizeName(a) || "").localeCompare(sanitizeName(b) || "");
          });

          var totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
          var pageRows = filtered.slice((page - 1) * pageSize, page * pageSize);

          function exportFiltered() { downloadCSV(filtered, "trend_filtered_export.csv"); }

          function onReasonClick(reason) {
            if (!reason) { setSelectedReason(""); return; }
            if (selectedReason === reason) setSelectedReason(""); else setSelectedReason(reason);
            setPage(1);
          }

          async function openEvidence(row) {
            setModalRow(row);
            setModalDetails(null);
            setModalLoading(true);
            try {
              const q = encodeURIComponent(row.EmployeeID || row.person_uid || "");
              const resp = await fetch(API_BASE + "/record?employee_id=" + q);
              if (!resp.ok) { const txt = await resp.text(); throw new Error("record failed: " + resp.status + " - " + txt); }
              const js = await resp.json();
              const details = { aggregated_rows: js.aggregated_rows || [], raw_swipe_files: js.raw_swipe_files || [], raw_swipes: js.raw_swipes || [] };
              setModalDetails(details);
            } catch (e) {
              alert("Failed loading details: " + e.message);
              console.error(e);
            } finally { setModalLoading(false); }
          }

          function closeModal() { setModalRow(null); setModalDetails(null); }

          // helper to render overlap
          function renderOverlapCell(r) {
            var ov = r.OverlapWith || r.swipe_overlap || r.overlap_with || null;
            if (ov && typeof ov === 'string') {
              var parts = ov.split(";").map(function (s) { return s.trim(); }).filter(Boolean);
              if (parts.length === 0) return <span className="muted">—</span>;
              return <span className="pill" title={ov}>{parts.length} overlap</span>;
            }
            return <span className="muted">—</span>;
          }

          function renderReasonChips(reasonText) {
            if (!reasonText) return <span className="muted">—</span>;
            const parts = String(reasonText).split(";").map(s => s.trim()).filter(Boolean);
            return parts.map((p, idx) => (<span key={idx} className="pill" title={SCENARIO_EXPLANATIONS[p] || p}>{p}</span>));
          }

          function renderReasonExplanations(reasonText) {
            if (!reasonText) return <div className="muted">No flags</div>;
            const parts = String(reasonText).split(";").map(s => s.trim()).filter(Boolean);
            return (
              <div>
                {parts.map((p, idx) => (
                  <div key={idx} className="why-item" style={{ marginBottom: 8 }}>
                    <b>{p}</b>
                    <div className="small">{SCENARIO_EXPLANATIONS[p] || "No explanation available."}</div>
                  </div>
                ))}
              </div>
            );
          }

          async function sendChat(qText, opts={top_k:5}) {
            if (!qText || !qText.toString().trim()) return;
            const text = qText.toString().trim();
            pushChatMessage({who:'user', text});
            setChatInput("");
            setChatLoading(true);
            try {
              const payload = Object.assign({q: text}, opts);
              const resp = await fetch(API_BASE + "/chatbot/query", {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });
              if (!resp.ok) {
                const t = await resp.text().catch(()=>'');
                throw new Error("Server: " + resp.status + " " + t);
              }
              const js = await resp.json();
              const answer = js.answer || js.answer_text || js.result || "No answer returned.";
              const evidence = Array.isArray(js.evidence) ? js.evidence : (js.evidence ? [js.evidence] : []);
              pushChatMessage({who:'bot', text: answer, evidence});
            } catch (err) {
              pushChatMessage({who:'bot', text: "Error: " + err.message, evidence: []});
              console.error("chat error", err);
            } finally {
              setChatLoading(false);
              setTimeout(() => {
                const el = document.querySelector('.chat-body');
                if (el) el.scrollTop = el.scrollHeight;
              }, 80);
            }
          }

          const QUICK_PROMPTS = [
            "Who is high risk today",
            "Who is low risk today",
            "Show me 320172 last 90 days",
            "Trend details for today — top reasons",
            "Explain repeated_short_breaks"
          ];
          function useQuickPrompt(q) {
            setChatOpen(true);
            sendChat(q);
          }

          // Swipe timeline rendering uses DAY_BOUNDARY_HOUR
          function renderSwipeTimeline(details, modalRow) {
            if (!details || !details.raw_swipes || details.raw_swipes.length === 0) {
              return <div className="muted">No raw swipe evidence available (person not flagged or raw file missing).</div>;
            }

            const all = details.raw_swipes.map(r => {
              const obj = Object.assign({}, r);
              try { obj.__ts = makeLocalDateFromRow(obj); } catch (e) { obj.__ts = null; }

              let gap = null;
              if (obj.SwipeGapSeconds !== undefined && obj.SwipeGapSeconds !== null) {
                gap = Number(obj.SwipeGapSeconds);
                if (isNaN(gap)) gap = null;
              } else if (obj.SwipeGap) {
                try {
                  const parts = String(obj.SwipeGap).split(':').map(p => Number(p));
                  if (parts.length === 3 && parts.every(p => !isNaN(p))) gap = parts[0]*3600 + parts[1]*60 + parts[2];
                } catch (e) { gap = null; }
              }
              obj.__gap = gap;
              obj.__zone_l = String((obj.Zone || '')).toLowerCase();
              const ts = obj.__ts;
              obj.__logical_date = ts ? logicalDateForTs(ts, DAY_BOUNDARY_HOUR) : (obj.Date ? String(obj.Date).slice(0,10) : null);
              return obj;
            }).sort((a, b) => {
              if (a.__ts && b.__ts) return a.__ts - b.__ts;
              if (a.__ts) return -1;
              if (b.__ts) return 1;
              const ka = (a.Date || '') + ' ' + (a.Time || '');
              const kb = (b.Date || '') + ' ' + (b.Time || '');
              return ka.localeCompare(kb);
            });

            const flags = new Array(all.length).fill(null).map(() => ({ dayStart: false, outReturn: false }));
            for (let i = 0; i < all.length; i++) {
              const cur = all[i];
              const prev = all[i - 1];
              const curDate = cur.__logical_date || (cur.Date ? String(cur.Date).slice(0,10) : null);
              const prevDate = prev ? (prev.__logical_date || (prev.Date ? String(prev.Date).slice(0,10) : null)) : null;
              if (!prev || prevDate !== curDate) flags[i].dayStart = true;
            }

            const OUT_RETURN_GAP_SECONDS = 60 * 60;
            for (let i = 0; i < all.length - 1; i++) {
              const a = all[i], b = all[i + 1];
              const aZone = a.__zone_l || ''; const bZone = b.__zone_l || ''; const bGap = b.__gap || 0;
              if (aZone.includes('out of office') || aZone.includes('out_of_office') || aZone.includes('out of')) {
                if (!bZone.includes('out of office') && (bGap >= OUT_RETURN_GAP_SECONDS || (bGap === null && aZone.includes('out')))) {
                  flags[i].outReturn = true; flags[i + 1].outReturn = true;
                }
              }
            }

            for (let i = 0; i < all.length; i++) {
              if (flags[i].dayStart) {
                all[i].__gap = 0;
              }
            }

            return (
              <div className="table-scroll">
                <table className="evidence-table" role="table" aria-label="Swipe timeline">
                  <thead>
                    <tr>
                      <th>Employee Name</th>
                      <th>Employee ID</th>
                      <th>Card</th>
                      <th>Date</th>
                      <th>Time</th>
                      <th>SwipeGap</th>
                      <th>Door</th>
                      <th>Direction</th>
                      <th>Zone</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    {all.map((rObj, idx) => {
                      const r = rObj || {};
                      const g = (r.__gap !== undefined && r.__gap !== null) ? Number(r.__gap) : null;
                      const isDayStart = flags[idx].dayStart;
                      const gapFormatted = (isDayStart)
                        ? formatSecondsToHmsJS(0)
                        : (
                            (r.SwipeGap && String(r.SwipeGap).trim())
                              ? String(r.SwipeGap)
                              : (g !== null && g !== undefined)
                                ? formatSecondsToHmsJS(g)
                                : "-"
                          );
                      const displayDate = r.__logical_date || (r.Date ? String(r.Date).slice(0,10) : '-');
                      const displayTime = r.Time || (r.__ts ? r.__ts.toTimeString().slice(0,8) : '-');
                      const cls = [];
                      if (isDayStart) cls.push('row-day-start');
                      if (flags[idx].outReturn) cls.push('row-out-return');
                      const rowStyle = isDayStart ? { background: '#e6ffed' } : {};
                      let extraNote = "";
                      try {
                        const originalDate = r.Date ? String(r.Date).slice(0,10) : null;
                        const logical = r.__logical_date || null;
                        if (originalDate && logical && originalDate !== logical) {
                          extraNote = `Orig: ${originalDate}`;
                          if ((String(r.Direction || '').toLowerCase().indexOf('out') !== -1)) {
                            extraNote += " — Out";
                          }
                        }
                      } catch (e) { extraNote = ""; }

                      return (
                        <tr key={idx} className={cls.join(' ')} style={rowStyle}>
                          <td className="small">{r.EmployeeName || '-'}</td>
                          <td className="small">{r.EmployeeID || '-'}</td>
                          <td className="small">{r.CardNumber || r.Card || '-'}</td>
                          <td className="small">{displayDate}</td>
                          <td className="small">{displayTime}</td>
                          <td className="small">{gapFormatted}</td>
                          <td className="small" style={{ minWidth: 160 }}>{r.Door || '-'}</td>
                          <td className="small">{r.Direction || '-'}</td>
                          <td className="small">{r.Zone || '-'}</td>
                          <td className="small">{r.Note || '-'}{r._source ? <span className="muted"> ({r._source})</span> : null}
                            {extraNote ? <div className="muted" style={{fontSize:11, marginTop:4}}>{extraNote}</div> : null}
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            );
          }

          function handleRiskBarClick(label) {
            if (!label) return;
            if (selectedRiskFilter === label) {
              setSelectedRiskFilter("");
            } else {
              setSelectedRiskFilter(label);
            }
            setPage(1);
          }

          function clearRiskFilter() {
            setSelectedRiskFilter("");
          }

          var rowsCount = (summary && typeof summary.rows === 'number') ? summary.rows : (rows ? rows.length : 0);
          var flaggedCount = (summary && typeof summary.flagged_rows === 'number') ? summary.flagged_rows : (rows ? rows.filter(function (r) { return !!(r.Reasons || r.DetectedScenarios); }).length : 0);
          var flaggedPct = rowsCount ? Math.round((flaggedCount * 100) / (rowsCount || 1)) : 0;

          // helper to get display label for current region
          function regionDisplayLabel(key) {
            if (!key) return '';
            return (REGION_OPTIONS[key] && REGION_OPTIONS[key].label) ? REGION_OPTIONS[key].label : key.toUpperCase();
          }

          return (
            <div className="container" aria-live="polite">
              {loading && (
                <div className="spinner-overlay" role="status" aria-label="Loading">
                  <div className="spinner-box">
                    <div className="spinner" />
                    <div style={{ fontWeight: 700 }}>Loading…</div>
                  </div>
                </div>
              )}

              <div className="topbar" role="banner">
                <div className="wu-brand" aria-hidden={false}>
                  <div className="wu-logo">WU</div>
                  <div className="title-block">
                    <h1>Western Union — Trend Analysis</h1>
                    <p style={{ margin: 0, fontSize: 13 }}>
                      {regionDisplayLabel(selectedRegion)} {selectedLocation && selectedLocation !== "All locations" ? "— " + selectedLocation : ""}
                    </p>
                  </div>
                </div>

                <div className="header-actions" role="region" aria-label="controls">
                  <div className="control">
                    <label className="small" htmlFor="fromDate">From</label>
                    <input id="fromDate" ref={fromRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                  </div>

                  <div className="control">
                    <label className="small" htmlFor="toDate">To</label>
                    <input id="toDate" ref={toRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                  </div>

                  <button className="btn-primary" onClick={runForRange} disabled={loading}>Run</button>
                  <button className="btn-ghost" onClick={loadLatest} disabled={loading}>Load latest</button>
                </div>
              </div>

              <div className="card-shell">
                <div className="cards" aria-hidden={loading}>
                  <div className="card" title="Rows analysed">
                    <div className="card-content">
                      <div className="card-text">
                        <h3>{(rowsCount !== undefined && rowsCount !== null) ? rowsCount.toLocaleString() : 0}</h3>
                        <p>Rows analysed</p>
                      </div>
                    </div>
                  </div>
                  <div className="card card-flagged" title="Flagged rows">
                    <div className="card-content">
                      <div className="card-text">
                        <h3>{(flaggedCount !== undefined && flaggedCount !== null) ? flaggedCount.toLocaleString() : 0}</h3>
                        <p>Flagged rows</p>
                      </div>
                    </div>
                  </div>
                  <div className="card card-rate" title="Flagged rate">
                    <div className="card-content">
                      <div className="card-text">
                        <h3>{flaggedPct}%</h3>
                        <p>Flagged rate</p>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="main">
                  <div className="left">
                    <div className="chart-wrap" aria-label="Risk level chart">
                      <canvas ref={chartRef}></canvas>
                    </div>

                    <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginTop: 6 }}>
                      <input placeholder="Search name, employee id, card or reason..." value={filterText} onChange={function (e) { setFilterText(e.target.value); setPage(1); }} style={{ flex: 1, padding: 10, borderRadius: 6, border: '1px solid #e6edf3' }} />
                      <div className="muted">Showing {filtered.length} / {rows.length} rows</div>
                      <button className="small-button" onClick={exportFiltered}>Export filtered</button>
                      {selectedRiskFilter ? <button className="small-button" onClick={clearRiskFilter}>Clear risk filter</button> : null}
                    </div>

                    <div style={{ marginTop: 10 }} className="table-scroll" role="region" aria-label="results table">
                      <table>
                        <thead>
                          <tr>
                            <th>Employee</th>
                            <th className="small">ID</th>
                            <th className="small">Card</th>
                            <th className="small">Date</th>
                            <th className="small">Duration</th>
                            <th className="small">ViolationDaysLast90</th>
                            <th className="small">Reasons</th>
                            <th className="small">Evidence</th>
                          </tr>
                        </thead>
                        <tbody>
                          {pageRows.map(function (r, idx) {
                            var empName = sanitizeName(r);
                            var displayDate = safeDateDisplay(r.DisplayDate || r.Date || r.FirstSwipe || r.LastSwipe);
                            // var durText = r.Duration || (r.DurationMinutes ? Math.round(r.DurationMinutes) + " min" : (r.DurationSeconds ? formatSecondsToHmsJS(r.DurationSeconds) : ""));
                          var durText = r.Duration
                            || (r.DurationSeconds ? formatSecondsToHmsJS(Number(r.DurationSeconds)) 
                            : (r.DurationMinutes ? formatSecondsToHmsJS(Number(r.DurationMinutes) * 60) : ""));

                          
                            var flagged = r.Reasons && String(r.Reasons).trim();
                            return (
                              <tr key={idx} className={flagged ? "flagged-row" : ""}>
                                <td className="row-click" onClick={function () { openEvidence(r); }}>{empName || <span className="muted">—</span>}</td>
                                <td className="small">{r.EmployeeID || ""}</td>
                                <td className="small">{r.CardNumber || ""}</td>
                                <td className="small">{displayDate}</td>
                                <td className="small">{durText}</td>
                                <td className="small">
                                  {(r.ViolationDaysLast90 !== undefined && r.ViolationDaysLast90 !== null && r.ViolationDaysLast90 !== "")
                                    ? (Number(r.ViolationDaysLast90).toString())
                                    : ((r.ViolationDaysLast_90 !== undefined && r.ViolationDaysLast_90 !== null && r.ViolationDaysLast_90 !== "")
                                        ? String(r.ViolationDaysLast_90)
                                        : ((r.ViolationDays !== undefined && r.ViolationDays !== null) ? String(r.ViolationDays) : "")
                                      )
                                  }
                                </td>
                                <td className="small">{renderReasonChips(r.Reasons || r.DetectedScenarios)}</td>
                                <td className="small">
                                  <button className="evidence-btn" onClick={function () { openEvidence(r); }}>Evidence</button>
                                </td>
                              </tr>
                            );
                          })}
                        </tbody>
                      </table>
                    </div>

                    <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginTop: 10 }}>
                      <button onClick={function () { setPage(function (p) { return Math.max(1, p - 1); }); }} disabled={page <= 1}>Prev</button>
                      <div className="muted">Page {page} / {totalPages}</div>
                      <button onClick={function () { setPage(function (p) { return Math.min(totalPages, p + 1); }); }} disabled={page >= totalPages}>Next</button>
                    </div>
                  </div>

                  <aside className="right" aria-label="side panel">

                    {/* NEW: Region & Location controls */}
                    <div className="sidebar-section" style={{ marginBottom: 12 }}>
                      <strong>Risk filters</strong>
                      <div className="small muted" style={{ marginTop: 6 }}>Select Region and Location to scope the run.</div>

                      <div style={{ display: 'flex', gap: 8, marginTop: 8, alignItems: 'center' }}>
                        <div style={{ flex: 1 }}>
                          <label className="small">Region</label>
                          <select
                            value={selectedRegion}
                            onChange={(e) => { setSelectedRegion(e.target.value); setPage(1); }}
                            style={{ width: '100%', padding: '6px 8px', borderRadius: 6, border: '1px solid #e2e8f0' }}
                          >
                            {Object.keys(REGION_OPTIONS).map(k => (
                              <option key={k} value={k}>{REGION_OPTIONS[k].label}</option>
                            ))}
                          </select>
                        </div>

                        <div style={{ flex: 1 }}>
                          <label className="small">Location</label>
                          <select
                            value={selectedLocation}
                            onChange={(e) => { setSelectedLocation(e.target.value); setPage(1); }}
                            style={{ width: '100%', padding: '6px 8px', borderRadius: 6, border: '1px solid #e2e8f0' }}
                          >
                            <option key="__all" value="All locations">All locations</option>
                            {(REGION_OPTIONS[selectedRegion] && REGION_OPTIONS[selectedRegion].partitions || []).map(loc => (
                              <option key={loc} value={loc}>{loc}</option>
                            ))}
                          </select>
                        </div>
                      </div>
                    </div>

                    {/* existing risk chips */}
                    <div className="sidebar-section">
                      <div className="risk-filter-list" style={{ marginTop: 8 }}>
                        {RISK_LABELS.map((lab) => {
                          const cnt = (riskCounts && riskCounts[lab]) ? riskCounts[lab] : 0;
                          const active = selectedRiskFilter === lab;
                          return (
                            <div key={lab} role="button" tabIndex={0} aria-pressed={active} className={"risk-chip " + (active ? "active" : "")} onClick={function () { handleRiskBarClick(lab); }} onKeyDown={function (e) { if (e.key === 'Enter' || e.key === ' ') { handleRiskBarClick(lab); } }}>
                              <div style={{ width: 10, height: 10, borderRadius: 999, background: RISK_COLORS[lab], boxShadow: '0 2px 6px rgba(0,0,0,0.08)' }}></div>
                              <div style={{ fontSize: 13 }}>{lab} <span className="muted" style={{ marginLeft: 6 }}>({cnt})</span></div>
                            </div>
                          );
                        })}
                      </div>

                      <div style={{ marginTop: 8 }}>
                        <button className="small-button" onClick={clearRiskFilter}>Clear risk filter</button>
                      </div>
                    </div>

                    <div className="sidebar-section" style={{ marginTop: 12 }}>
                      <strong>Top reasons summary</strong>
                      <div className="small muted" style={{ marginTop: 6 }}>Click a reason to filter the table by that reason. Click again to clear.</div>

                      <div style={{ marginTop: 8, display: 'flex', gap: 8 }}>
                        <input placeholder="Filter reason list..." value={reasonFilterText} onChange={function (e) { setReasonFilterText(e.target.value); }} style={{ flex: 1, padding: '6px 8px', borderRadius: 6, border: '1px solid #e2e8f0' }} />
                        <button className="small-button" onClick={function () { setSelectedReason(''); setReasonFilterText(''); }}>Clear</button>
                      </div>

                      <div style={{ marginTop: 8, maxHeight: 320, overflow: 'auto' }}>
                        {Object.keys(reasonsCount).length === 0 && <div className="muted">No flags found</div>}
                        {Object.entries(reasonsCount).sort(function (a, b) { return b[1] - a[1]; }).filter(function (kv) {
                          var name = kv[0];
                          if (!reasonFilterText) return true;
                          return name.toLowerCase().indexOf(reasonFilterText.toLowerCase()) !== -1;
                        }).slice(0, 50).map(function (kv) {
                          var name = kv[0], count = kv[1];
                          var active = selectedReason === name;
                          return (
                            <div key={name} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 8, marginBottom: 6 }}>
                              <button className={"chip " + (active ? "active" : "")} style={{ textAlign: 'left', flex: 1 }} onClick={function () { onReasonClick(name); }}>
                                {name}
                              </button>
                              <div style={{ minWidth: 48, textAlign: 'right' }} className="small"><b>{count}</b></div>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  </aside>
                </div>
              </div>

              {modalRow &&
                <div className="modal" onClick={closeModal}>
                  <div className="modal-inner" onClick={function (e) { e.stopPropagation(); }}>
                    <div className="modal-header">
                      <div className="header-content">
                        <div className="header-icon">
                          <i className="bi bi-clipboard2-data-fill"></i>
                        </div>
                        <div className="header-text">
                          <h3>Details — Evidence</h3>
                          <div className="header-subtitle small">Evidence & explanation for selected row</div>
                        </div>
                      </div>
                      <button className="close-btn" onClick={closeModal}>
                        <i className="bi bi-x-lg"></i>
                        Close
                      </button>
                    </div>
                    <div className="modal-body">
                      {modalLoading && (
                        <div className="loading-state">
                          <div className="loading-spinner"></div>
                          <span>Loading evidence…</span>
                        </div>
                      )}
                      <div className="modal-top" role="region" aria-label="evidence summary">
                        <div className="image-section">
                          <div className="image-container">
                            <div className="multi-color-border">
                              <div className="color-ring color-1"></div>
                              <div className="color-ring color-2"></div>
                              <div className="color-ring color-3"></div>
                              <div className="color-ring color-4"></div>
                              <div className="image-content">
                                {(modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows.length > 0) ? (
                                  (() => {
                                    const md = modalDetails.aggregated_rows[0];
                                    if (md && md.imageUrl) {
                                      return (
                                      
                                      
                                  <img
  className="modal-image"
  src={API_BASE + md.imageUrl}
  alt="Employee"
  onError={(e) => {
    try {
      // prevent infinite loop
      e.target.onerror = null;
      // swap to an inline SVG placeholder so the element still displays (keeps layout stable)
      const svg = '<svg xmlns="http://www.w3.org/2000/svg" width="160" height="160">'
                + '<rect fill="#eef2f7" width="100%" height="100%"/>'
                + '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#64748b" font-size="18">'
                + 'No image</text></svg>';
      e.target.src = 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
      // hide the fallback placeholder element (nextSibling) if present
      if (e.target.nextSibling) e.target.nextSibling.style.display = 'none';
    } catch (err) {
      // worst-case: hide broken image and show fallback placeholder already in DOM
      e.target.style.display = 'none';
      if (e.target.nextSibling) e.target.nextSibling.style.display = 'flex';
    }
  }}
/>

                                      );
                                    } else {
                                      return <div className="modal-image-placeholder">No image</div>;
                                    }
                                  })()
                                ) : (
                                  <div className="modal-image-placeholder">
                                    <i className="bi bi-person-square"></i>
                                    <span>No image</span>
                                  </div>
                                )}
                              </div>
                            </div>
                          </div>
                        </div>

                        <div className="modal-details">
                          <div className="details-header">
                            <div className="emp-info">
                              <div className="emp-name">
                                {sanitizeName(modalRow) || "—"}
                                <span
                                  className="risk-badge"
                                  style={{
                                    marginLeft: "12px",
                                    background:
                                      RISK_COLORS[modalRow.RiskLevel] ||
                                      RISK_COLORS[getRiskLabelForRow(modalRow)] ||
                                      RISK_COLORS["Low"],
                                  }}
                                >
                                  {modalRow.RiskLevel ||
                                    (modalRow.RiskScore ? "Score " + modalRow.RiskScore : "Low")}
                                </span>
                              </div>
                              <div className="emp-badge">
                                <i className="bi bi-person-badge"></i>
                                ID: {modalRow.EmployeeID || "—"}
                              </div>
                            </div>
                          </div>
                          <div className="details-grid">
                            <div className="detail-item">
                              <div className="detail-icon">
                                <i className="bi bi-credit-card"></i>
                              </div>
                              <div className="detail-content">
                                <label>Card Number</label>
                                <span>{modalRow.CardNumber || "—"}</span>
                              </div>
                            </div>
                            <div className="detail-item">
                              <div className="detail-icon">
                                <i className="bi bi-envelope"></i>
                              </div>
                              <div className="detail-content">
                                <label>Email</label>
                                <span>
                                  {(modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0] && modalDetails.aggregated_rows[0].EmployeeEmail)
                                    ? modalDetails.aggregated_rows[0].EmployeeEmail
                                    : <span className="muted">—</span>}
                                </span>
                              </div>
                            </div>
                            <div className="detail-item">
                              <div className="detail-icon">
                                <i className="bi bi-calendar-date"></i>
                              </div>
                              <div className="detail-content">
                                <label>Date</label>
                                <span>{safeDateDisplay(modalRow.DisplayDate || modalRow.Date || modalRow.FirstSwipe)}</span>
                              </div>
                            </div>
                            <div className="detail-item">
                              <div className="detail-icon">
                                <i className="bi bi-clock"></i>
                              </div>
                              <div className="detail-content">
                                <label>Duration</label>
                                <span className="duration-badge">
                                  {modalRow.Duration || (modalRow.DurationMinutes ? Math.round(modalRow.DurationMinutes) + " min" : "—")}
                                </span>
                              </div>
                              <div style={{ marginTop: 8, textAlign: 'right' }}>
                                <div className="muted">Violation days (90d)</div>
                                <div style={{ fontWeight: 700 }}>
                                  {(modalRow.ViolationDaysLast90 !== undefined && modalRow.ViolationDaysLast90 !== null)
                                    ? modalRow.ViolationDaysLast90
                                    : 0}
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>

                        <div className="modal-reasons">
                          <div className="explanation-section" style={{ marginTop: 12 }}>
                            <div style={{ fontWeight: 700 }}>Explanation</div>
                            <div style={{
                              marginTop: 8,
                              maxHeight: 160,
                              overflow: 'auto',
                              background: '#fff',
                              border: '1px solid #eef2f7',
                              padding: 8,
                              borderRadius: 6
                            }}>
                            { (modalRow.Explanation || modalRow.ViolationExplanation)
    ? <div style={{ whiteSpace: 'pre-wrap' }}>{modalRow.Explanation || modalRow.ViolationExplanation}</div>
    : <div className="muted">No explanation provided.</div> }

                            </div>
                          </div>
                          <div className="reasons-section">
                            <div className="section-title">
                              <i className="bi bi-list-check"></i>
                              Reasons Flagged
                            </div>
                            <div className="reasons-list">
                              {renderReasonChips(modalRow.Reasons || modalRow.DetectedScenarios)}
                            </div>
                          </div>
                        </div>
                      </div>

                      <div className="evidence-section">
                        <div className="section-header">
                          <i className="bi bi-folder2-open"></i>
                          <h4>Available Evidence Files</h4>
                        </div>
                        <div className="files-container">
                          {modalDetails && modalDetails.raw_swipe_files && modalDetails.raw_swipe_files.length > 0 ? (
                            <div className="files-list">
                              {modalDetails.raw_swipe_files.map((f, i) => (
                                <div key={i} className="file-item">
                                  <i className="bi bi-file-earmark-text"></i>
                                  <span className="file-name">{f}</span>
                                  <button
                                    className="download-btn"
                                    onClick={function () { window.location = API_BASE + "/swipes/" + encodeURIComponent(f); }}
                                  >
                                    <i className="bi bi-download"></i>
                                    Download
                                  </button>
                                </div>
                              ))}
                            </div>
                          ) : (
                            <div className="no-files">
                              <i className="bi bi-folder-x"></i>
                              <span>No raw swipe files found for this person/date.</span>
                            </div>
                          )}
                        </div>
                      </div>

                      <div className="timeline-section">
                        <div className="section-header">
                          <i className="bi bi-clock-history"></i>
                          <h4>Swipe Timeline</h4>
                          <span className="subtitle">Filtered for this person/date</span>
                        </div>
                        <div className="timeline-content">
                          {modalDetails ? renderSwipeTimeline(modalDetails, modalRow) : (
                            <div className="loading-timeline">
                              <i className="bi bi-hourglass-split"></i>
                              <span>Evidence not loaded yet.</span>
                            </div>
                          )}
                        </div>
                      </div>

                      <div className="raw-json-section">
                        <label className="toggle-label">
                          <input
                            type="checkbox"
                            id="showraw"
                            onChange={function (e) {
                              const el = document.getElementById('rawpayload');
                              if (el) el.style.display = e.target.checked ? 'block' : 'none';
                            }}
                          />
                          <span className="toggle-slider"></span>
                          <span className="toggle-text">
                            <i className="bi bi-code-slash"></i>
                            Show raw aggregated JSON
                          </span>
                        </label>
                        <div id="rawpayload" className="raw-json" style={{display:'none'}}>
                          <pre>{JSON.stringify(modalRow, null, 2)}</pre>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              }

              <button className="chat-fab" title="Ask Trend Details (Ask Me )" onClick={() => setChatOpen(true)} aria-label="Open chat">
                <span className="meta-icon"><img src="chat-bot.png" alt=""/></span>
              </button>

            
              {chatOpen && (
                <div className="chat-modal" role="dialog" aria-modal="true" aria-label="Trend Chatbot">
                  <div className="chat-header">
                    <div style={{display:'flex', alignItems:'center', gap:8}}>
                      <div style={{width:36,height:36, borderRadius:8, background:'#', display:'flex', alignItems:'center', justifyContent:'center', color:'#2563eb', fontWeight:800}}><img src="chat-bot.png" alt=""  style={{width:36,height:36, }}/></div>
                      <div>
                        <div className="title">Ask me — Trend Details</div>
                        <div style={{fontSize:12, opacity:0.85}}>Ask trend & risk questions</div>
                      </div>
                    </div>
                    <div style={{marginLeft:'auto'}}>
                      <button className="small-button bot-close" onClick={() => { setChatOpen(false); }}>Close</button>
                    </div>
                  </div>

                  <div className="chat-body">
                    {chatMessages.length === 0 && (
                      <div style={{color:'#64748b', fontSize:13}}>
                        Hi — ask about trends (e.g. "Who is high risk today"). Use the quick prompts below.
                      </div>
                    )}
                    {chatMessages.map((m, i) => (
                      <div key={i} style={{display:'block'}}>
                        <div className={"chat-bubble " + (m.who === 'user' ? 'user' : 'bot')}>
                          {m.text}
                          {m.who === 'bot' && m.evidence && m.evidence.length > 0 && (
                            <div className="chat-evidence">
                              <strong>Evidence</strong>
                              <div style={{marginTop:6}}>{m.evidence.slice(0,5).map((e,j)=>(<div key={j}>{typeof e === 'string' ? e : JSON.stringify(e)}</div>))}</div>
                            </div>
                          )}
                        </div>
                      </div>
                    ))}

                    {chatLoading && <div className="chat-loading" style={{marginTop:6}}>Thinking…</div>}
                    <div style={{marginTop:8}} className="quick-prompts" aria-hidden={chatLoading}>
                      {QUICK_PROMPTS.map((q,idx)=>(
                        <button key={idx} onClick={()=>useQuickPrompt(q)} disabled={chatLoading}>{q}</button>
                      ))}
                    </div>
                  </div>

                  <div className="chat-input-row">
                    <input
                      className="chat-input"
                      placeholder="Type a question, e.g. 'Who is high risk today'…"
                      value={chatInput}
                      onChange={(e)=>setChatInput(e.target.value)}
                      onKeyDown={(e)=>{ if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChat(chatInput); } }}
                    />
                    <button className="chat-send-btn" onClick={()=>sendChat(chatInput)} disabled={chatLoading}>Send</button>
                  </div>
                </div>
              )}

            </div>
          );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
      })();
    </script>
  </body>
  </html>
