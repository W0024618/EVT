// updated dailyAccessReportEMEA in backend/services/reportService.js
export async function dailyAccessReportEMEA({ from, to, employees = '' }) {
  const pool = await getPool('emea');
  const req  = pool.request();

  req.input('fromDate', sql.Date, from);
  req.input('toDate',   sql.Date, to);
  // accept comma separated list of names or IDs (nullable / empty allowed)
  const employeesParam = (employees && String(employees).trim()) ? String(employees).trim() : null;
  req.input('employees', sql.NVarChar(sql.MAX), employeesParam);

  const query = `
-- employees CSV is passed in @employees (e.g. 'Vainilaitis, Valdas,32345')
-- If @employees is NULL or empty -> no employee filter applied.
DECLARE @empCSV NVARCHAR(MAX) = @employees;

;WITH EmpList AS (
  SELECT LTRIM(RTRIM(value)) AS emp
  FROM STRING_SPLIT(ISNULL(@empCSV,''), ',')
  WHERE LTRIM(RTRIM(value)) <> ''
),

SwipeData AS (
  SELECT
    t1.ObjectName1,
    t1.ObjectName2,
    t1.Messagetype,
    t2.Text12       AS EmployeeID,       -- contractor id stored here for contractors
    t3.Name         AS PersonnelType,
    t1.PartitionName2 AS location,

    /* true LOCAL time = UTC + offset */
    CAST(
      DATEADD(
        MINUTE,
        t1.MessageLocaleOffset,
        t1.MessageUTC
      ) AS datetime2(3)
    ) AS LocaleMessageTime,

    CASE
      WHEN t5_dir.Value = 'InDirection'  THEN 'IN'
      WHEN t5_dir.Value = 'OutDirection' THEN 'OUT'
      ELSE 'Unknown'
    END AS Swipe,

    t5_card.Value AS CardNumber,
    -- numeric employee id
    CAST(t2.Int1 AS NVARCHAR(50)) AS NumericEmployeeID
  FROM ACVSUJournal_00011028.dbo.ACVSUJournalLog AS t1
  INNER JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  INNER JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID
  LEFT JOIN ACVSUJournal_00011027.dbo.ACVSUJournalLogxmlShred AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID
    AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournal_00011028.dbo.ACVSUJournalLogxmlShred AS t5_card
    ON t1.XmlGUID = t5_card.GUID
    AND t5_card.Value NOT IN ('InDirection','OutDirection')
    AND t5_card.Value NOT LIKE '%[^0-9]%'
    AND t5_card.Value IS NOT NULL
    AND LTRIM(RTRIM(t5_card.Value)) <> ''
  WHERE
    /* local‐time window:
         >= 08:00 on fromDate
         AND <  08:00 on the day after toDate */
    DATEADD(HOUR, 8, CAST(@fromDate AS DATETIME))
      <= DATEADD(MINUTE, t1.MessageLocaleOffset, t1.MessageUTC)
    AND DATEADD(MINUTE, t1.MessageLocaleOffset, t1.MessageUTC)
      < DATEADD(
          HOUR,
          8,
          DATEADD(DAY, 1, CAST(@toDate AS DATETIME))
        )

    /* EMPLOYEE FILTER:
       - If @empCSV is NULL/empty => no filter
       - Else match if any emp value equals ObjectName1 OR Text12 OR Int1 (as string)
    */
    AND (
      @empCSV IS NULL
      OR LTRIM(RTRIM(@empCSV)) = ''
      OR EXISTS (
        SELECT 1 FROM EmpList e
        WHERE e.emp = t1.ObjectName1
           OR e.emp = t2.Text12
           OR e.emp = CAST(t2.Int1 AS NVARCHAR(50))
      )
    )
)
SELECT
  ObjectName1,
  ObjectName2,
  Messagetype,
  PersonnelType,
  EmployeeID,
  location,
  Swipe,
  CardNumber,
  LocaleMessageTime
FROM SwipeData
ORDER BY LocaleMessageTime;
`;

  const { recordset } = await req.query(query);
  return recordset;
}









  const [newEmployee, setNewEmployee] = useState(''); // text field for adding name or ID


{tab === 0 && (
  <Box>
    <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
      Employees
    </Typography>

    {/* Add employee by name or ID */}
    <Box sx={{ display: 'flex', gap: 1, mb: 1 }}>
      <TextField
        fullWidth
        placeholder="Add name or ID (e.g. 'Vainilaitis, Valdas' or '323471')"
        value={newEmployee}
        onChange={(e) => setNewEmployee(e.target.value)}
        sx={{
          '& .MuiInputBase-input': { color: '#fff' },
          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
        }}
        InputLabelProps={{ style: { color: '#FFCC00' } }}
      />
      <Button
        variant="contained"
        onClick={() => {
          const v = (newEmployee || '').toString().trim();
          if (!v) return;
          if (!selectedEmps.includes(v)) {
            setSelectedEmps(prev => [...prev, v]);
          }
          setNewEmployee('');
        }}
        sx={{
          bgcolor: '#FFCC00',
          color: '#000',
          fontWeight: 800,
          px: 2,
          '&:hover': { bgcolor: '#ffd84d' }
        }}
      >
        Add
      </Button>
    </Box>

    <FormControl fullWidth>
      <InputLabel sx={{ color: '#FFCC00' }}>Employees</InputLabel>

      {/*
        show static suggestions + any newly added items (so the UI displays items
        that don't exist in EMPLOYEE_OPTIONS but are already selected)
      */}
      <Select
        multiple
        value={selectedEmps}
        onChange={e => setSelectedEmps(e.target.value)}
        input={<OutlinedInput label="Employees" />}
        renderValue={vals => vals.join(', ')}
        sx={{
          color: '#fff',
          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
        }}
      >
        {[
          ...EMPLOYEE_OPTIONS,
          ...selectedEmps.filter(s => !EMPLOYEE_OPTIONS.includes(s))
        ].map(n => (
          <MenuItem key={n} value={n}>
            <Checkbox checked={selectedEmps.includes(n)} />
            <ListItemText primary={n} />
          </MenuItem>
        ))}
      </Select>
    </FormControl>
  </Box>
)}

















Check below Both file line by line and check logic for DailyAccess Report 
so we want to Update logic for Daily access report only ..


For Daily access Employee List is hard coded 
so if i want to add more Employee in this list add Option for add more Employee List 
using thier Employee id or Contractor ID .
Update only for Daily Access report carefully and fix the issue carfully

//C:\Users\W0024618\Desktop\global-page\backend\services\reportService.js

 import { getPool, sql } from '../config/dbConfig.js';

export async function rawReport(region, { startDate, endDate, location, admitFilter = 'all' }) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const pool = await getPool(region);
  const req = pool.request();

  // Accept NULL for location to mean "all partitions in this region DB"
  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;

  req.input('location', sql.NVarChar(200), locationParam);
  req.input('startDate', sql.Date, startDate);
  req.input('endDate', sql.Date, endDate);
  req.input('admitFilter', sql.NVarChar(20), String(admitFilter || 'all'));

  const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    -- message types we consider
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    -- location optional filter
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    -- admit/reject filter: 'all' | 'admit' | 'reject' (case-insensitive)
    AND (
      UPPER(ISNULL(@admitFilter,'all')) = 'ALL'
      OR (UPPER(@admitFilter) = 'ADMIT'  AND t1.MessageType = 'CardAdmitted')
      OR (UPPER(@admitFilter) = 'REJECT' AND t1.MessageType = 'CardRejected')
    )
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM CombinedQuery
ORDER BY LocaleMessageTime ASC;
`;

  const { recordset } = await req.query(query);
  return recordset;
}





export async function rejectionReport(region, { startDate, endDate, location } = {}) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const pool = await getPool(region);
  const req = pool.request();

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;

  req.input('location', sql.NVarChar(200), locationParam);
  req.input('startDate', sql.Date, startDate);
  req.input('endDate', sql.Date, endDate);

  const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType = 'CardRejected'
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
),
Unified AS (
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Lost'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Clearance'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type IN ('CardDisabled','Disabled')
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Stolen'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Expired'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'PIN'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'UnknownCard'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'SiteCode'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'NotActivated'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'FacilityCode'
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM Unified
ORDER BY LocaleMessageTime DESC;
`;

  const { recordset } = await req.query(query);
  return recordset;
}




// //C:\Users\W0024618\Desktop\global-page\backend\services\reportService.js

export async function dailyAccessReportEMEA({ from, to }) {
  const pool = await getPool('emea');
  const req  = pool.request();

  req.input('fromDate', sql.Date, from);
  req.input('toDate',   sql.Date, to);

  const query = `
WITH SwipeData AS (
  SELECT
    t1.ObjectName1,
    t1.ObjectName2,
    t1.Messagetype,
    t2.Text12       AS EmployeeID,
    t3.Name         AS PersonnelType,
    t1.PartitionName2 AS location,

    /* true LOCAL time = UTC + offset */
    CAST(
      DATEADD(
        MINUTE,
        t1.MessageLocaleOffset,
        t1.MessageUTC
      ) AS datetime2(3)
    ) AS LocaleMessageTime,

    CASE
      WHEN t5_dir.Value = 'InDirection'  THEN 'IN'
      WHEN t5_dir.Value = 'OutDirection' THEN 'OUT'
      ELSE 'Unknown'
    END AS Swipe,

    t5_card.Value AS CardNumber
  FROM ACVSUJournal_00011028.dbo.ACVSUJournalLog AS t1
  INNER JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  INNER JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID
  LEFT JOIN ACVSUJournal_00011027.dbo.ACVSUJournalLogxmlShred AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID
    AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournal_00011028.dbo.ACVSUJournalLogxmlShred AS t5_card
    ON t1.XmlGUID = t5_card.GUID
    AND t5_card.Value NOT IN ('InDirection','OutDirection')
    AND t5_card.Value NOT LIKE '%[^0-9]%'
    AND t5_card.Value IS NOT NULL
    AND LTRIM(RTRIM(t5_card.Value)) <> ''

  WHERE
    /* local‐time window:
         >= 08:00 on fromDate
         AND <  08:00 on the day after toDate */
    DATEADD(HOUR, 8, CAST(@fromDate AS DATETIME))
      <= DATEADD(MINUTE, t1.MessageLocaleOffset, t1.MessageUTC)
    AND DATEADD(MINUTE, t1.MessageLocaleOffset, t1.MessageUTC)
      < DATEADD(
          HOUR,
          8,
          DATEADD(DAY, 1, CAST(@toDate AS DATETIME))
        )

    AND t1.ObjectName1 IN (
    'Vainilaitis, Valdas',
  'Tomasevic, Kazimez',
  'Sesickis, Janas',
  'Valiunas, Sigitas',
  'JANCUKOVIC, VACLAVA',
  'Kalpokiene, Alina',
  'Korkus, Vanda',
  'Kvaraciejiene, Maryte',
  'ZNAMEROVSKIS, DARIUS'

    )
)
SELECT
  ObjectName1,
  ObjectName2,
  Messagetype,
  PersonnelType,
  EmployeeID,
  location,
  Swipe,
  CardNumber,
  LocaleMessageTime
FROM SwipeData
ORDER BY LocaleMessageTime;`;


  const { recordset } = await req.query(query);
  return recordset;
}



/**
 * In-vs-Out Report (parameterized) — groups by employee & month
 */
export async function inOutReport(region, { year, month, doors }) {
  const pool = await getPool(region);
  const req  = pool.request();

  req.input('TargetYear',  sql.Int, year);
  req.input('TargetMonth', sql.Int, month);
  doors.forEach((d, i) => req.input(`door${i}`, sql.NVarChar, d));
  const doorList = doors.map((_, i) => `@door${i}`).join(',');

  const query = `
WITH CombinedQuery AS (
  SELECT
    DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
    t1.ObjectName1,
    t1.PartitionName2    AS location,
    t5_card.CardNumber,
    t5_dir.value         AS Direction,
    CASE
      WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
      ELSE CAST(t2.Int1 AS NVARCHAR)
    END                    AS EmployeeID,
    t3.Name               AS PersonnelType
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID
    AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml AS t_xml
    ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard
    ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  WHERE
    YEAR(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetYear
    AND MONTH(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetMonth
    AND t1.ObjectName2 IN (${doorList})
)
SELECT
  FORMAT(LocaleMessageTime,'yyyy-MM')    AS Month,
  ObjectName1                           AS EmployeeName,
  EmployeeID,
  PersonnelType,
  location,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)  AS In_Count,
  SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS Out_Count,
  COUNT(*)                                                 AS TotalSwipes,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)
  - SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS InOut_Difference
FROM CombinedQuery
GROUP BY FORMAT(LocaleMessageTime,'yyyy-MM'),
         ObjectName1, EmployeeID, PersonnelType, location
ORDER BY Month DESC, EmployeeName;
`;

  const { recordset } = await req.query(query);
  return recordset;
}



/**
 * Time Duration Report (parameterized by region, partition, startDate)
 */
export async function timeDurationReport(region, { partition = 'Default', startDate }) {
  const pool = await getPool(region);
  const req  = pool.request();

  // bind inputs
  const fullPartition = `${region.toUpperCase()}.${partition}`;
  req.input('partition', sql.NVarChar, fullPartition);
  req.input('startDate', sql.Date, startDate);

  const query = `

SELECT 
    t1.[ObjectName1],
    t1.[ObjectName2],
    t1.[PartitionName2],
    CASE
        WHEN t2.[Int1] = 0 THEN t2.[Text12]
        ELSE CAST(t2.[Int1] AS NVARCHAR)
    END AS EmployeeID,
    t3.[Name] AS PersonnelType,
    t2.text5,
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    DATEADD(HOUR, -2, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) AS AdjustedMessageTime
INTO 
    #CombinedEmployeeData
FROM 
    [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] AS t1
INNER JOIN 
    [ACVSCore].[Access].[Personnel] AS t2
    ON t1.ObjectIdentity1 = t2.GUID
INNER JOIN 
    [ACVSCore].[Access].[PersonnelType] AS t3
    ON t2.[PersonnelTypeId] = t3.[ObjectID];

-- Step 2: Daily duration per employee
WITH DailyDurations AS (
    SELECT 
        [ObjectName1],
        PersonnelType,
        EmployeeID,
        [PartitionName2],
        text5,
        CONVERT(DATE, AdjustedMessageTime) AS ShiftedDate,
        DATEPART(WEEK, AdjustedMessageTime) AS WeekNumber,
        DATEPART(YEAR, AdjustedMessageTime) AS YearNumber,
        MIN(LocaleMessageTime) AS FirstSwipeTime,
        MAX(LocaleMessageTime) AS LastSwipeTime,
        DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) AS DurationMinutes,
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) / 60 AS NVARCHAR), 2)
        + ':' +
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) % 60 AS NVARCHAR), 2) AS DurationHHMM,
        CASE 
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 5 THEN '<5mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 10 THEN '<10mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 20 THEN '<20mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 30 THEN '<30mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 60 THEN '<1hr'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 120 THEN 'Less than <2hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 180 THEN 'Less than <3hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 240 THEN 'Less than <4hrs'
            ELSE '4+ hrs'
        END AS TimeDiffCategory
    FROM 
        #CombinedEmployeeData



  WHERE CONVERT(DATE, AdjustedMessageTime) >= @startDate

   AND [PartitionName2] = 'APAC.Default'
        AND PersonnelType IN ('Employee', 'Terminated Personnel')
    GROUP BY 
        [ObjectName1], EmployeeID, PersonnelType, text5, [PartitionName2],
        CONVERT(DATE, AdjustedMessageTime),
        DATEPART(WEEK, AdjustedMessageTime),
        DATEPART(YEAR, AdjustedMessageTime)
),

-- Step 3: Weekly summary
WeeklySummary AS (
    SELECT 
        EmployeeID,
        [ObjectName1],
        PersonnelType,
        text5,
        [PartitionName2],
        YearNumber,
        WeekNumber,
        COUNT(DISTINCT ShiftedDate) AS DaysPresentInWeek,
        SUM(CASE WHEN DurationMinutes < 240 THEN 1 ELSE 0 END) AS ViolationDaysInWeek
    FROM 
        DailyDurations
    GROUP BY 
        EmployeeID, [ObjectName1], PersonnelType, text5, [PartitionName2], YearNumber, WeekNumber
)

-- Step 4: Final output with daily duration, category, and defaulter flag
SELECT 
    dd.EmployeeID,
    dd.ObjectName1,
    dd.PersonnelType,
    dd.text5,
    dd.PartitionName2,
    dd.YearNumber,
    dd.WeekNumber,
    dd.ShiftedDate,
    dd.FirstSwipeTime,
    dd.LastSwipeTime,
    dd.DurationHHMM,
    dd.TimeDiffCategory,
    ws.DaysPresentInWeek,
    ws.ViolationDaysInWeek,
    (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) AS CleanDaysInWeek,
    CASE
        WHEN (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) < 3 THEN 'Yes'
        ELSE 'No'
    END AS Defaulter
FROM 
    DailyDurations dd
JOIN 
    WeeklySummary ws
    ON dd.EmployeeID = ws.EmployeeID
    AND dd.WeekNumber = ws.WeekNumber
    AND dd.YearNumber = ws.YearNumber
ORDER BY 
    dd.YearNumber DESC, dd.WeekNumber DESC, dd.EmployeeID, dd.ShiftedDate;
  `;

  const { recordset } = await req.query(query);
  return recordset;
}


//EUROC 




export async function eurocAdmitRejectionReport(region, { reportDate }) {
  const pool = await getPool(region);
  const req  = pool.request();

  // enforce location LT.Vilnius (as requested)
  req.input('location', sql.NVarChar, 'LT.Vilnius');
  // reportDate should be YYYY-MM-DD or Date — bind as sql.Date
  req.input('reportDate', sql.Date, reportDate);

  const query = `
/*
  Approach:
  1) Build CombinedQuery as a CTE and SELECT INTO #Combined (materialize)
  2) Build #Admits (with ROW_NUMBER) and #Rejections from #Combined
  3) Return three resultsets: admits (rn=1), rejections (all), summary (counts)
*/

WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    AND t1.PartitionName2 = @location
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @reportDate
)

-- materialize CombinedQuery into a temp table
SELECT
  LocaleMessageTime,
  CONVERT(date, LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  MessageType
INTO #Combined
FROM CombinedQuery;

-- create admits with row number (first admit per employee)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  ROW_NUMBER() OVER (PARTITION BY ISNULL(EmployeeID, CardNumber) ORDER BY LocaleMessageTime ASC) AS rn
INTO #Admits
FROM #Combined
WHERE MessageType = 'CardAdmitted'
  AND PersonnelType = 'Employee';

-- create rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
INTO #Rejections
FROM #Combined
WHERE MessageType = 'CardRejected';

-- resultset 1: admits (only rn = 1)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Admits
WHERE rn = 1
ORDER BY LocaleMessageTime ASC;

-- resultset 2: rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Rejections
ORDER BY LocaleMessageTime ASC;

-- resultset 3: summary counts by Rejection_Type
SELECT
  ISNULL(Rejection_Type, 'Unknown') AS Rejection_Type,
  COUNT(*) AS CountVal
FROM #Rejections
GROUP BY ISNULL(Rejection_Type, 'Unknown')
ORDER BY CountVal DESC;

-- cleanup temp tables (optional — they scope to the session and will go away automatically,
-- but good practice to drop)
DROP TABLE IF EXISTS #Admits;
DROP TABLE IF EXISTS #Rejections;
DROP TABLE IF EXISTS #Combined;
`;

  const result = await req.query(query);
  // result.recordsets is an array of resultsets
  const recordsets = result.recordsets || [];
  const admitRows = (recordsets[0] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const rejectRows = (recordsets[1] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Rejection_Type: r.Rejection_Type,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const summaryRows = (recordsets[2] || []).map(r => ({ Rejection_Type: r.Rejection_Type, Count: r.CountVal }));

  return { admit: admitRows, rejection: rejectRows, summary: summaryRows };
}






















// src/pages/ReportsPage.jsx
import React, { useState } from 'react';
import {
  Box, FormControl, InputLabel, Select, OutlinedInput,
  Checkbox, ListItemText, MenuItem, Button,
  CircularProgress, Typography, TextField, Tabs, Tab, Grid, Paper, IconButton, Divider
} from '@mui/material';

import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import axios from 'axios';
import ExcelJS from 'exceljs';
import * as XLSX from 'xlsx';
import { useAuth } from '../context/AuthContext';

import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import PlaceIcon from '@mui/icons-material/Place';
import PeopleIcon from '@mui/icons-material/People';
import DownloadIcon from '@mui/icons-material/CloudDownload';
import FilterListIcon from '@mui/icons-material/FilterList';
import Avatar from '@mui/material/Avatar';

// Static lists
const EMPLOYEE_OPTIONS = [
  'Vainilaitis, Valdas',
  'Tomasevic, Kazimez',
  'Sesickis, Janas',
  'Valiunas, Sigitas',
  'JANCUKOVIC, VACLAVA',
  'Kalpokiene, Alina',
  'Korkus, Vanda',
  'Kvaraciejiene, Maryte',
  'ZNAMEROVSKIS, DARIUS'
];

const REGION_OPTIONS = ['global', 'apac', 'emea', 'laca', 'namer'];
const LOCATION_MAP = {
  apac: ['APAC.Default', 'JP.Tokyo', 'PH.Manila', 'MY.Kuala Lumpur'],
  emea: ['AUT.Vienna', 'DU.Abu Dhab', 'IE.Dublin', 'IT.Rome', 'LT.Vilnius', 'MA.Casablanca', 'RU.Moscow', 'UK.London', 'ES.Madrid'],
  laca: ['AR.Cordoba', 'CR.Costa Rica Partition', 'MX.Mexico City', 'PE.Lima', 'BR.Sao Paulo', 'PA.Panama City'],
  namer: ['US.NYC', 'US.FL.Miami', 'USA/Canada Default', 'US.CO.OBS'],
  global: []
};

function formatDisplayDate(date) {
  const d = new Date(date);
  const day = d.getDate();
  const suf = day % 10 === 1 && day !== 11 ? 'st'
    : day % 10 === 2 && day !== 12 ? 'nd'
      : day % 10 === 3 && day !== 13 ? 'rd' : 'th';
  const mon = d.toLocaleString('default', { month: 'long' });
  return `${day}${suf} ${mon} ${d.getFullYear()}`;
}

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');

function formatDateFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  const y = dt.getUTCFullYear();
  const m = dt.getUTCMonth(); // 0..11
  const d = dt.getUTCDate();
  const yrShort = String(y).slice(-2);
  return `${pad2(d)}-${MONTH_ABBR[m]}-${yrShort}`;         // e.g. "12-Aug-25"
}

function formatTimeFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  let hh = dt.getUTCHours();   // use UTC parts so we trust server wall-clock
  const mm = dt.getUTCMinutes();
  const ss = dt.getUTCSeconds();
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1;
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;        // e.g. "12:01:24 AM"
}

function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10); // "YYYY-MM-DD"
  if (!swipeIso) {
    return `${datePart}T00:00:00.000Z`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000Z`;
  }
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000Z`;
}

function formatShortRange(fromDate, toDate) {
  if (!fromDate || !toDate) return '';
  const f = formatDisplayDate(fromDate);
  const t = formatDisplayDate(toDate);
  const [fDay, fMon] = f.split(' ');
  const [tDay, tMon] = t.split(' ');

  if (fMon === tMon) {
    return `${fDay} to ${tDay} ${fMon}`;
  }
  return `${fDay} ${fMon} to ${tDay} ${tMon}`;
}

function buildRawFileName({ region, location, rawSearch, from, to }) {
  const shortRange = formatShortRange(from, to);
  const regionPart = (region || '').toUpperCase();
  const locPart = location ? `-${location.split('.').pop()}` : '';
  const prefix = rawSearch && rawSearch.toString().trim() ? `${rawSearch.toString().trim()} ` : '';
  const base = `${regionPart}${locPart} Raw report ${shortRange}`;
  const safeBase = base.replace(/[\/\\:\*\?"<>\|]+/g, '').replace(/\s+/g, ' ').trim();
  return `${prefix}${safeBase}.xlsx`;
}

// returns a server-wall-clock ISO for a row: prefer LocaleMessageTime, else DateOnly+Swipe_Time
const getServerISO = (r) => {
  if (!r) return '';
  if (r.LocaleMessageTime) return r.LocaleMessageTime;
  if (r.DateOnly) return buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  return '';
};

// returns YYYY-MM-DD for server wall-clock (used for filtering)
const getServerYMD = (r) => {
  const iso = getServerISO(r);
  if (!iso) return '';
  return iso.slice(0, 10);
};

// Helper — convert "YYYY-MM-DD..." (ISO) into a local midnight Date (avoids UTC shift)
const isoDateOnlyToLocalDate = (iso) => {
  if (!iso) return null;
  const s = iso.toString().slice(0, 10);
  const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
  return new Date(y, m - 1, d);
};

// Build a Date that preserves the server-provided wall-clock values.
// If swipeTime is an ISO (with Z), read UTC components and use them as local values.
const buildLocalDateFromDateOnlyAndSwipe = (dateOnly, swipeTime) => {
  if (!dateOnly) return null;
  const dateStr = dateOnly.toString().slice(0, 10);
  const [yy, mm, dd] = dateStr.split('-').map(n => parseInt(n, 10));

  let hh = 0, min = 0, ss = 0;
  if (swipeTime) {
    const parsed = new Date(swipeTime);
    if (!isNaN(parsed.getTime())) {
      hh = parsed.getUTCHours();
      min = parsed.getUTCMinutes();
      ss = parsed.getUTCSeconds();
    } else {
      const parts = swipeTime.split(':').map(p => parseInt(p, 10));
      if (parts.length >= 2) {
        hh = parts[0] || 0;
        min = parts[1] || 0;
        ss = parts[2] || 0;
      }
    }
  }
  return new Date(yy, mm - 1, dd, hh, min, ss);
};

export default function ReportsPage() {
  const auth = useAuth();

  // --- state ---
  const [tab, setTab] = useState(0);

  const [region, setRegion] = useState('emea');
  const [location, setLocation] = useState('');
  const [from, setFrom] = useState(null);
  const [to, setTo] = useState(null);
  const [showFromCal, setShowFromCal] = useState(false);
  const [showToCal, setShowToCal] = useState(false);
  const [selectedEmps, setSelectedEmps] = useState([]);
  const [loading, setLoading] = useState(false);

  const [rawSearch, setRawSearch] = useState('');
  const [rawAdmitFilter, setRawAdmitFilter] = useState('all');

  // Handle tab switch (Daily / Raw / Rejection)
  const handleTabChange = (_, v) => {
    setTab(v);
    // reset filters
    setRegion('emea');
    setLocation('');
    setFrom(null);
    setTo(null);
    setSelectedEmps([]);
    setRawSearch('');
    setRawAdmitFilter('all');
  };

  /** Time Duration Excel generator */
  const generateTimeDurationExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Time Duration');

    ws.mergeCells('A1:M1');
    ws.getCell('A1').value =
      `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };

    const headers = [
      'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
      'Partition', 'Text5', 'Year', 'Week', 'Date',
      'First Swipe', 'Last Swipe', 'Duration', 'Category',
      'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'ptype', width: 18 },
      { key: 'part', width: 15 },
      { key: 'txt5', width: 20 },
      { key: 'year', width: 8 },
      { key: 'week', width: 6 },
      { key: 'date', width: 12 },
      { key: 'first', width: 16 },
      { key: 'last', width: 16 },
      { key: 'dur', width: 10 },
      { key: 'cat', width: 12 },
      { key: 'dpw', width: 12 },
      { key: 'vdw', width: 14 },
      { key: 'cdw', width: 12 },
      { key: 'def', width: 10 }
    ];

    data.forEach((r, idx) => {
      const first = new Date(r.FirstSwipeTime);
      const last = new Date(r.LastSwipeTime);
      const date = new Date(r.ShiftedDate);
      const row = ws.addRow([
        idx + 1,
        r.ObjectName1,
        r.EmployeeID,
        r.PersonnelType,
        r.PartitionName2,
        r.text5,
        r.YearNumber,
        r.WeekNumber,
        date,
        first,
        last,
        r.DurationHHMM,
        r.TimeDiffCategory,
        r.DaysPresentInWeek,
        r.ViolationDaysInWeek,
        r.CleanDaysInWeek,
        r.Defaulter
      ]);

      row.getCell(9).numFmt = 'dd-mmm-yy';
      row.getCell(10).numFmt = 'h:mm:ss AM/PM';
      row.getCell(11).numFmt = 'h:mm:ss AM/PM';

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    ws.autoFilter = 'A2:Q2';

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    const filename =
      `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;

    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  // Daily Access Excel
  const generateDailyAccessExcel = async allRows => {
    const wb = new ExcelJS.Workbook();

    for (const emp of selectedEmps) {
      const ws = wb.addWorksheet(emp.substring(0, 31));
      const headers = [
        'Date', 'Time', 'Name', 'Contractor ID', 'Card No',
        'Door Name', 'Message Type', 'Partition', 'Swipe'
      ];
      ws.addRow(headers);
      const hdr = ws.getRow(1);
      hdr.font = { bold: true };
      hdr.alignment = { vertical: 'middle', horizontal: 'center' };
      hdr.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });

      ws.columns = [
        { key: 'date', width: 12 },
        { key: 'time', width: 12 },
        { key: 'name', width: 25 },
        { key: 'id', width: 15 },
        { key: 'card', width: 15 },
        { key: 'door', width: 40 },
        { key: 'msg', width: 15 },
        { key: 'part', width: 15 },
        { key: 'swipe', width: 10 }
      ];

      const rows = allRows.filter(r => r.ObjectName1 === emp);
      if (!rows.length) {
        ws.mergeCells('A2', 'I2');
        ws.getCell('A2').value = 'There is no swipe records found in Ccure';
        ws.getCell('A2').alignment = { horizontal: 'center' };
      } else {
        rows.forEach(r => {
          const iso = getServerISO(r);
          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws.addRow([
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.EmployeeID || '',
            r.CardNumber || '',
            r.Door || r.ObjectName2 || '',
            r.AdmitCode || r.Messagetype || '',
            r.location || '',
            r.Swipe || r.Direction || ''
          ]);

          row.getCell(1).alignment = { horizontal: 'left' };
          row.getCell(2).alignment = { horizontal: 'left' };

          row.eachCell(c => {
            c.border = {
              top: { style: 'thin' }, left: { style: 'thin' },
              bottom: { style: 'thin' }, right: { style: 'thin' }
            };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });
      }
      ws.autoFilter = 'A1:I1';
    }

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const filename = `Daily Access Report(${formatDisplayDate(from)} to ${formatDisplayDate(to)}).xlsx`;
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  // Rejection Excel
  const generateRejectionExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Rejection');

    const title = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}`;
    ws.mergeCells('A1:J1');
    ws.getCell('A1').value = title;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };

    const headers = [
      'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
      'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'date', width: 12 },
      { key: 'time', width: 12 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'card', width: 15 },
      { key: 'type', width: 15 },
      { key: 'door', width: 40 },
      { key: 'loc', width: 15 },
      { key: 'swipe', width: 10 }
    ];

    data.forEach((r, idx) => {
      const iso = getServerISO(r);
      const dateStr = iso ? formatDateFromServerISO(iso) : '';
      const timeStr = iso ? formatTimeFromServerISO(iso) : '';

      const row = ws.addRow([
        idx + 1,
        dateStr,
        timeStr,
        r.ObjectName1 || '',
        r.EmployeeID || '',
        r.CardNumber || '',
        r.Rejection_Type || '',
        r.Door || r.ObjectName2 || '',
        r.location || '',
        r.Direction || r.Swipe || ''
      ]);

      row.getCell(2).alignment = { horizontal: 'left' };
      row.getCell(3).alignment = { horizontal: 'left' };

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    const counts = data.reduce((a, r) => {
      const k = r.Rejection_Type || 'Unknown';
      a[k] = (a[k] || 0) + 1; return a;
    }, {});
    let rowIdx = 3;
    ws.getCell(rowIdx, 11).value = 'Rejection';
    ws.getCell(rowIdx, 12).value = 'Count';
    [11, 12].forEach(c => {
      const cell = ws.getCell(rowIdx, c);
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'center' };
      cell.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });
    rowIdx++;
    Object.entries(counts).forEach(([type, cnt]) => {
      ws.getCell(rowIdx, 11).value = type;
      ws.getCell(rowIdx, 12).value = cnt;
      [11, 12].forEach(c => {
        const cell = ws.getCell(rowIdx, c);
        cell.alignment = { horizontal: 'left' };
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });
      rowIdx++;
    });
    ws.getCell(rowIdx, 11).value = 'Total';
    ws.getCell(rowIdx, 12).value = data.length;
    [11, 12].forEach(c => {
      const cell = ws.getCell(rowIdx, c);
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'left' };
      cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
    });

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const filename = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}.xlsx`;
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  // generateRawExcel
  const generateRawExcel = async (rows, opts = {}) => {
    const formatTimeFromSwipe = (swipeIso) => {
      if (!swipeIso) return '';
      const dt = new Date(swipeIso);
      if (!isNaN(dt.getTime())) {
        return formatTimeFromServerISO(swipeIso);
      }
      const parts = ('' + swipeIso).split(':').map(p => parseInt(p || 0, 10));
      const hh = parts[0] || 0;
      const mm = parts[1] || 0;
      const ss = parts[2] || 0;
      const ampm = hh >= 12 ? 'PM' : 'AM';
      const hh12 = ((hh + 11) % 12) + 1;
      return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
    };

    const admitFilter = (opts.rawAdmitFilter || 'all').toString().toLowerCase();

    const baseHeaders = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber'];
    const admitCol = 'AdmitCode';
    const rejCol = 'Rejection_Type';
    const tailCols = ['Direction','Door'];

    let headers = [...baseHeaders];
    if (admitFilter === 'all') {
      headers.push(admitCol);
      headers.push(...tailCols);
      headers.push(rejCol);
    } else if (admitFilter === 'admit') {
      headers.push(admitCol);
      headers.push(...tailCols);
    } else if (admitFilter === 'reject') {
      headers.push(...tailCols);
      headers.push(rejCol);
    } else {
      headers.push(admitCol);
      headers.push(...tailCols);
      headers.push(rejCol);
    }

    if (!rows || !rows.length) {
      const wbEmpty = XLSX.utils.book_new();
      const wsEmpty = XLSX.utils.aoa_to_sheet([headers]);
      XLSX.utils.book_append_sheet(wbEmpty, wsEmpty, 'Raw');
      const fileNameEmpty = buildRawFileName(opts);
      XLSX.writeFile(wbEmpty, fileNameEmpty);
      return;
    }

    const rowsForSheet = rows.map(r => {
      const iso = getServerISO(r);
      const dateStr = iso ? formatDateFromServerISO(iso) : '';
      const timeStr = iso ? formatTimeFromServerISO(iso) : '';
      const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');
      const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';
      const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

      const fullObj = {
        LocaleMessageTime: localeMsgFormatted,
        DateOnly: dateOnlyFormatted,
        Swipe_Time: swipeTimeFormatted,
        EmployeeID: r.EmployeeID || '',
        ObjectName1: r.ObjectName1 || '',
        PersonnelType: r.PersonnelType || '',
        location: r.location || '',
        CardNumber: r.CardNumber || '',
        AdmitCode: r.AdmitCode || r.Messagetype || '',
        Direction: r.Direction || r.Swipe || '',
        Door: r.Door || r.ObjectName2 || '',
        Rejection_Type: r.Rejection_Type || ''
      };

      const picked = {};
      headers.forEach(h => {
        picked[h] = (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '';
      });
      return picked;
    });

    const ws = XLSX.utils.json_to_sheet(rowsForSheet, { header: headers });
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Raw');

    const filename = buildRawFileName(opts);
    XLSX.writeFile(wb, filename);
  };

  // --- Permission helpers ---
  const exportPermsForTab = () => {
    if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
    if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
    if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
    if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
    if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
    if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
    return ['gsoc_reports'];
  };

  // disabled conditions - UI-level validations (permission gating done separately)
  const disabled = loading
    || !region
    || (tab === 0 && (!from || !to || selectedEmps.length === 0))
    || (tab === 1 && (!from || !to))
    || (tab === 2 && (!from || !to))
    || (tab === 3 && !from)
    || (tab === 4 && (!from || !to));

  const navDisabled = !region || loading;

  const exportAllowed = auth.hasPermission(exportPermsForTab());

  // --- Generate handler with permission check up-front ---
  const handleGenerate = async () => {
    // Permission gating: determine required permission for each tab
    const requirePermissionForTab = () => {
      if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
      if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
      if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
      if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
      if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
      if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
      return ['gsoc_reports'];
    };

    if (!auth.hasPermission(requirePermissionForTab())) {
      alert('You do not have permission to generate this report.');
      return;
    }

    setLoading(true);
    try {
      const baseParams = { region, location: location || undefined };

      // Helper: format dates in local time without timezone conversion for API parameters
      const formatLocalDate = (date, endOfDay = false) => {
        const d = new Date(date);
        if (endOfDay) d.setHours(23, 59, 59, 999);
        else d.setHours(0, 0, 0, 0);
        const pad = n => n.toString().padStart(2, '0');
        return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}` +
               `T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      };

      const toLocalYMD = date => `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`;

      // ----- 0: Daily Access -----
      if (tab === 0) {
        const params = {
          ...baseParams,
          from: formatLocalDate(from),
          to: formatLocalDate(to, true),
          employees: selectedEmps.join(',')
        };
        const resp = await axios.get('/api/reports/daily-access', { params });

        const startDate = new Date(from); startDate.setHours(8, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(8, 0, 0, 0);

        const rows = (resp.data && resp.data.data) || [];
        const filtered = rows.filter(r => {
          const dt = new Date(r.LocaleMessageTime);
          return dt >= startDate && dt < endDate;
        });

        await generateDailyAccessExcel(filtered);
        return;
      }

      // ----- 1: Raw -----
      if (tab === 1) {
        const params = {
          ...baseParams,
          startDate: formatLocalDate(from),
          endDate: formatLocalDate(to, true),
          admitFilter: rawAdmitFilter
        };
        const resp = await axios.get('/api/reports/raw', { params });
        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

        const rowsSrc = (resp.data && resp.data.data) || [];
        const rows = rowsSrc.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          return date >= startDate && date <= endDate;
        });

        let filtered = rows;
        if (rawSearch && rawSearch.trim() !== '') {
          const s = rawSearch.trim().toLowerCase();
          filtered = rows.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            return id.includes(s) || name.includes(s);
          });
        }

        await generateRawExcel(filtered, { region, location, rawSearch, from, to, rawAdmitFilter });
        return;
      }

      // ----- 2: Rejection -----
      if (tab === 2) {
        const params = { ...baseParams, startDate: formatLocalDate(from), endDate: formatLocalDate(to, true) };
        const resp = await axios.get('/api/reports/rejection', { params });

        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

        const rowsSrc = (resp.data && resp.data.data) || [];
        const rows = rowsSrc.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          return date >= startDate && date <= endDate;
        });

        await generateRejectionExcel(rows);
        return;
      }

      // ----- 3: EUROC Admit-Reject (single day) -----
      if (tab === 3) {
        if (region.toLowerCase() !== 'emea') {
          alert('EUROC report is only available for region EMEA. Please select EMEA.');
          return;
        }
        if (!from) {
          alert('Please select a date (From) for EUROC report.');
          return;
        }

        const dateParam = toLocalYMD(new Date(from));
        const params = { region: 'emea', date: dateParam };
        const resp = await axios.get('/api/reports/euroc-admit-rejection', { params });
        const { data } = resp.data || {};

        const wb = new ExcelJS.Workbook();

        // Admit sheet
        const admitTitle = `EUROC Admit Report - ${formatDisplayDate(from)}`;
        const ws1 = wb.addWorksheet('EUROC Admit');
        ws1.mergeCells('A1:I1');
        ws1.getCell('A1').value = admitTitle;
        ws1.getCell('A1').font = { bold: true, size: 14 };
        ws1.getCell('A1').alignment = { horizontal: 'center' };

        const admitHeaders = [
          'Sr. No.', 'Date', 'Time', 'Employee Name',
          'Access Card No.', 'Personnel Type', 'Door Name', 'Location', 'Swipe'
        ];
        const hdrRow1 = ws1.addRow(admitHeaders);
        hdrRow1.font = { bold: true };
        hdrRow1.alignment = { vertical: 'middle', horizontal: 'center' };
        hdrRow1.eachCell(c => {
          c.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
        });

        ws1.columns = [
          { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
          { key:'name', width:30 }, { key:'card', width:15 }, { key:'ptype', width:20 },
          { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
        ];

        (data.admit || []).forEach((r, idx) => {
          let iso;
          if (r.LocaleMessageTime) {
            iso = r.LocaleMessageTime;
          } else if (r.DateOnly) {
            iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
          } else {
            iso = '';
          }

          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws1.addRow([
            idx + 1,
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.CardNumber || '',
            r.PersonnelType || '',
            r.Door || r.ObjectName2 || '',
            r.location || '',
            r.Direction || ''
          ]);

          row.getCell(2).alignment = { horizontal: 'left' };
          row.getCell(3).alignment = { horizontal: 'left' };
          row.eachCell(c => {
            c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        // Rejection sheet
        const ws2 = wb.addWorksheet('EUROC Rejection');
        ws2.mergeCells('A1:J1');
        ws2.getCell('A1').value = `EUROC Rejection Report - ${formatDisplayDate(from)}`;
        ws2.getCell('A1').font = { bold: true, size: 14 };
        ws2.getCell('A1').alignment = { horizontal: 'center' };

        const headerRow2 = ws2.addRow(['Sr. No.', 'Date', 'Time', 'Employee Name', 'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe']);
        headerRow2.font = { bold: true };
        headerRow2.alignment = { vertical: 'middle', horizontal: 'center' };
        headerRow2.eachCell(c => {
          c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });

        ws2.columns = [
          { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
          { key:'name', width:30 }, { key:'card', width:15 }, { key:'type', width:15 },
          { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
        ];

        (data.rejection || []).forEach((r, idx) => {
          let iso;
          if (r.LocaleMessageTime) {
            iso = r.LocaleMessageTime;
          } else if (r.DateOnly) {
            iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
          } else {
            iso = '';
          }

          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws2.addRow([
            idx + 1,
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.CardNumber || '',
            r.Rejection_Type || '',
            r.Door || '',
            r.location || '',
            r.Direction || ''
          ]);

          row.getCell(2).alignment = { horizontal: 'left' };
          row.getCell(3).alignment = { horizontal: 'left' };
          row.eachCell(c => {
            c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        // Summary block
        const counts = data.summary || [];
        let startRow = 3;
        ws2.getCell(startRow, 11).value = 'Rejection';
        ws2.getCell(startRow, 12).value = 'Count';
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.font = { bold: true };
          cell.alignment = { horizontal: 'center' };
          cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });
        startRow++;
        counts.forEach(c => {
          ws2.getCell(startRow, 11).value = c.Rejection_Type || 'Unknown';
          ws2.getCell(startRow, 12).value = c.Count || 0;
          [11, 12].forEach(col => {
            const cell = ws2.getCell(startRow, col);
            cell.alignment = { horizontal: 'left' };
            cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
          });
          startRow++;
        });
        ws2.getCell(startRow, 11).value = 'Grand Total';
        ws2.getCell(startRow, 12).value = (data.rejection || []).length;
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.font = { bold: true };
          cell.alignment = { horizontal: 'left' };
          cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });

        const buf = await wb.xlsx.writeBuffer();
        const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const filename = `EUROC_Admit_Rejection_${dateParam}.xlsx`;
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        return;
      }

      // ----- 4: Time Duration -----
      if (tab === 4) {
        if (!from || !to) {
          alert('Please select both Start Date and End Date for Time Duration report.');
          return;
        }
        const startParam = toLocalYMD(new Date(from));
        const endParam = toLocalYMD(new Date(to));
        const params = {
          region,
          startDate: startParam,
          endDate: endParam,
          partition: location ? location.split('.').pop() : 'Default'
        };
        const resp = await axios.get('/api/reports/time-duration', { params });
        await generateTimeDurationExcel(resp.data.data || []);
        return;
      }

      // ----- 5: HeadCount / External navigation -----
      if (tab === 5) {
        // final permission check (region specific)
        const permCandidates = [`headcount.${region}`, 'headcount', 'global_access'];
        if (!auth.hasPermission(permCandidates)) {
          alert(`You do not have permission to view HeadCount for ${region.toUpperCase()}.`);
          setLoading(false);
          return;
        }

        let url = '';

        if (region === 'laca') {
          if (!location) url = 'http://10.199.22.57:3003/history';
          else {
            const LACA_URLS = {
              'CR.Costa Rica Partition': 'http://10.199.22.57:3003/partition/CR.Costa%20Rica%20Partition/history',
              'MX.Mexico City': 'http://10.199.22.57:3003/partition/MX.Mexico%20City/history',
              'AR.Cordoba': 'http://10.199.22.57:3003/partition/AR.Cordoba/history',
              'PA.Panama City': 'http://10.199.22.57:3003/partition/PA.Panama%20City/history',
              'PE.Lima': 'http://10.199.22.57:3003/partition/PE.Lima/history',
              'BR.Sao Paulo': 'http://10.199.22.57:3003/partition/BR.Sao%20Paulo/history'
            };
            url = LACA_URLS[location] || 'http://10.199.22.57:3003/history';
          }
        } else if (region === 'namer') {
          if (!location) url = 'http://10.199.22.57:3002/history';
          else {
            const NAMER_URLS = {
              'US.Denver': 'http://10.199.22.57:3002/partition/US.CO.OBS/history',
              'US.Miami': 'http://10.199.22.57:3002/partition/US.FL.Miami/history',
              'US.NYC': 'http://10.199.22.57:3002/partition/US.NYC/history',
              'US.Austin': 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default/history'
            };
            url = NAMER_URLS[location] || 'http://10.199.22.57:3002/history';
          }
        } else if (region === 'apac') {
          if (!location) url = 'http://10.199.22.57:3000/history';
          else {
            const APAC_URLS = {
              'APAC.Default': 'http://10.199.22.57:3000/partition/Pune/history',
              'MY.Kuala Lumpur': 'http://10.199.22.57:3000/partition/MY.Kuala Lumpur/history',
              'PH.Manila': 'http://10.199.22.57:3000/partition/PH.Manila/history',
              'JP.Tokyo': 'http://10.199.22.57:3000/history',
              'CN.Beijing': 'http://10.199.22.57:3000/history'
            };
            url = APAC_URLS[location] || 'http://10.199.22.57:3000/history';
          }
        } else if (region === 'emea') {
          if (!location) url = 'http://10.199.22.57:3001/history';
          else {
            const EMEA_URLS = {
              'AUT.Vienna': 'http://10.199.22.57:3001/history',
              'DU.Abu Dhabi': 'http://10.199.22.57:3001/history',
              'IE.Dublin': 'http://10.199.22.57:3001/history',
              'IT.Rome': 'http://10.199.22.57:3001/history',
              'LT.Vilnius': 'http://10.199.22.57:3001/history',
              'MA.Casablanca': 'http://10.199.22.57:3001/history',
              'RU.Moscow': 'http://10.199.22.57:3001/history',
              'UK.London': 'http://10.199.22.57:3001/history',
              'ES.Madrid': 'http://10.199.22.57:3001/history'
            };
            url = EMEA_URLS[location] || 'http://10.199.22.57:3001/history';
          }
        }

        if (url) window.location.href = url;
        else alert('Invalid region or location selected.');
        return;
      }

    } catch (err) {
      console.error(err);
      alert('Failed to generate report');
    } finally {
      setLoading(false);
    }
  };

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
        {/* Topbar / Header */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            px: 3,
            py: 2,
            borderBottom: '1px solid rgba(255,204,0,0.08)',
            background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
          }}
        >
          <Avatar sx={{ bgcolor: '#000', border: '3px solid #FFCC00', width: 56, height: 56 }}>
            <Typography sx={{ color: '#FFCC00', fontWeight: 900 }}>WU</Typography>
          </Avatar>

          <Box sx={{ flex: 1 }}>
            <Typography variant="h5" sx={{ fontWeight: 900, letterSpacing: 0.6 }}>
              Global Security Operation Center
            </Typography>
            <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
              Reports & Exports — Secure access, fast insights
            </Typography>
          </Box>

          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
            <Button
              startIcon={<DownloadIcon />}
              onClick={handleGenerate}
              disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
              sx={{
                bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                color: '#000',
                fontWeight: 800,
                px: 3,
                py: 1,
                borderRadius: 3,
                boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
                transformOrigin: 'center',
                '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-2px)' : 'none' }
              }}
            >
              {loading ? 'Loading…'
                : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
            </Button>
          </Box>
        </Box>

        {/* Main content: Sidebar + Content */}
        <Grid container sx={{ px: 3, py: 4 }} spacing={3}>
          {/* Sidebar */}
          <Grid item xs={12} md={3}>
            <Paper
              elevation={8}
              sx={{
                p: 2.5,
                borderRadius: 3,
                height: { xs: 'auto', md: 'calc(100vh - 150px)' },
                overflow: 'auto',
                background: 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015))',
                border: '1px solid rgba(255,204,0,0.06)'
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
                <Box>
                  <Typography variant="subtitle1" sx={{ fontWeight: 800, color: '#FFCC00' }}>Filters</Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Narrow down by region, date and employees
                  </Typography>
                </Box>
                <IconButton size="small" sx={{ color: '#FFCC00' }}>
                  <FilterListIcon />
                </IconButton>
              </Box>

              <Divider sx={{ my: 1, borderColor: 'rgba(255,204,0,0.06)' }} />

              {/* Region */}
              <Box sx={{ mt: 1 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Region</InputLabel>
                  <Select
                    value={region}
                    onChange={e => { setRegion(e.target.value); setLocation(''); }}
                    input={<OutlinedInput label="Region" />}
                    sx={{
                      color: '#fff',
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.24)' }
                    }}
                  >
                    {REGION_OPTIONS.map(r => <MenuItem key={r} value={r}>{r.toUpperCase()}</MenuItem>)}
                  </Select>
                </FormControl>
              </Box>

              {/* Location */}
              <Box sx={{ mt: 2 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Location</InputLabel>
                  <Select
                    value={location}
                    onChange={e => setLocation(e.target.value)}
                    input={<OutlinedInput label="Location" />}
                    disabled={!region}
                    sx={{
                      color: '#fff',
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                    }}
                  >
                    {(LOCATION_MAP[region] || []).map(loc => <MenuItem key={loc} value={loc}>{loc.split('.').pop()}</MenuItem>)}
                  </Select>
                </FormControl>
              </Box>

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />

              {tab === 1 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employee (name or ID)
                  </Typography>
                  <TextField
                    fullWidth
                    placeholder="Type employee name or ID (e.g. 'Jejurkar' or '323471')"
                    label="Search Employee"
                    value={rawSearch}
                    onChange={(e) => setRawSearch(e.target.value)}
                    sx={{
                      '& .MuiInputBase-input': { color: '#fff' },
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                    }}
                    InputLabelProps={{ style: { color: '#FFCC00' } }}
                  />
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                    Leave empty to export all raw rows for the date range.
                  </Typography>

                  <Box sx={{ mt: 2 }}>
                    <FormControl fullWidth>
                      <InputLabel sx={{ color: '#FFCC00' }}>Admit / Reject</InputLabel>
                      <Select
                        value={rawAdmitFilter}
                        onChange={(e) => setRawAdmitFilter(e.target.value)}
                        input={<OutlinedInput label="Admit / Reject" />}
                        sx={{
                          color: '#fff',
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                        }}
                      >
                        <MenuItem value="all">All (Admitted + Rejected)</MenuItem>
                        <MenuItem value="admit">Admitted only</MenuItem>
                        <MenuItem value="reject">Rejected only</MenuItem>
                      </Select>
                    </FormControl>
                    <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                      Default = All.
                    </Typography>
                  </Box>
                </Box>
              )}

              {/* Dates */}
              {tab !== 5 && (
                <Box>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Date Range
                  </Typography>
                  <Box sx={{ display: 'grid', gap: 1.25 }}>
                    <TextField
                      label={tab === 0 ? 'From Date' : 'Start Date'}
                      value={from ? from.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowFromCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                    <TextField
                      label={tab === 0 ? 'To Date' : 'End Date'}
                      value={to ? to.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowToCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                  </Box>

                  {showFromCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={from}
                        onChange={(newValue) => setFrom(newValue)}
                        onAccept={() => setShowFromCal(false)}
                        onClose={() => setShowFromCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                  {showToCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={to}
                        onChange={(newValue) => setTo(newValue)}
                        onAccept={() => setShowToCal(false)}
                        onClose={() => setShowToCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                </Box>
              )}

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />

              {tab === 0 && (
                <Box>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employees
                  </Typography>
                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Employees</InputLabel>
                    <Select
                      multiple
                      value={selectedEmps}
                      onChange={e => setSelectedEmps(e.target.value)}
                      input={<OutlinedInput label="Employees" />}
                      renderValue={vals => vals.join(', ')}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                      }}
                    >
                      {EMPLOYEE_OPTIONS.map(n => (
                        <MenuItem key={n} value={n}>
                          <Checkbox checked={selectedEmps.includes(n)} />
                          <ListItemText primary={n} />
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              )}

              <Box sx={{ mt: 3, p: 2, borderRadius: 2, background: 'rgba(255,255,255,0.02)' }}>
                <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                  Tip: For daily exports pick employees & a single day range. For Time Duration choose the required partition via Location.
                </Typography>
              </Box>
            </Paper>
          </Grid>

          {/* Main panel */}
          <Grid item xs={12} md={9}>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              <Paper
                elevation={3}
                sx={{
                  px: 2,
                  py: 1,
                  borderRadius: 2,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  gap: 2,
                  border: '1px solid rgba(255,204,0,0.04)'
                }}
              >
                <Tabs
                  value={tab}
                  onChange={handleTabChange}
                  sx={{
                    '& .MuiTab-root': {
                      textTransform: 'none',
                      minWidth: 120,
                      fontWeight: 700,
                      color: 'rgba(255,255,255,0.8)'
                    },
                    '& .Mui-selected': { color: '#FFCC00' }
                  }}
                >
                  <Tab icon={<CalendarTodayIcon />} label="Daily Access" />
                  <Tab icon={<PeopleIcon />} label="Raw" />
                  <Tab icon={<PlaceIcon />} label="Rejection" />
                  <Tab icon={<PeopleIcon />} label="EUROC Admit-Reject" />
                  <Tab icon={<CalendarTodayIcon />} label="Time Duration" />
                  <Tab icon={<PeopleIcon />} label="HeadCount" />
                </Tabs>

                <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                  <Button
                    variant="text"
                    startIcon={<FilterListIcon />}
                    sx={{ color: 'rgba(255,255,255,0.65)', textTransform: 'none' }}
                    onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}
                  >
                    Reset View
                  </Button>
                </Box>
              </Paper>

              <Paper elevation={6} sx={{ p: 3, borderRadius: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 2 }}>
                <Box>
                  <Typography variant="h6" sx={{ fontWeight: 900 }}>Export Center</Typography>
                  <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                    Selected Region: <strong style={{ color: '#FFCC00' }}>{region.toUpperCase()}</strong> {location ? `• ${location.split('.').pop()}` : ''}
                  </Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Choose tab, select filters and export reports in Excel.
                  </Typography>
                </Box>

                <Box>
                  <Button
                    startIcon={loading ? <CircularProgress size={20} /> : <DownloadIcon />}
                    disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
                    onClick={handleGenerate}
                    sx={{
                      bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                      color: '#000',
                      fontWeight: 900,
                      px: 4,
                      py: 1,
                      borderRadius: 3,
                      boxShadow: '0 8px 30px rgba(255,204,0,0.22)',
                      '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-3px)' : 'none' }
                    }}
                  >
                    {loading
                      ? 'Loading…'
                      : (tab === 5
                          ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`)
                          : 'Export to Excel')}
                  </Button>
                </Box>
              </Paper>

            </Box>
          </Grid>

        </Grid>
      </Box>
    </LocalizationProvider>
  );
}





























