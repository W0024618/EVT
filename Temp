// backend/config/dbConfig.js
import sql from 'mssql';

// shared options
const commonOpts = {
  options: {
    encrypt: true,
    trustServerCertificate: true
  },
  requestTimeout: 300000,
  connectionTimeout: 30000,
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  }
};

// lowercase keys only
const regions = {
  apac: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUPNQ0986V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  },
  emea: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUFRA0986V',
    database: 'ACVSUJournal_00011028',
    ...commonOpts
  },
  laca: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUSJO0986V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  },
  namer: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUDEN0891V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  }
};

// cache of connected pools by key: `${regionKey}_${database}`
const pools = {};

/**
 * Parse DB name for trailing numeric suffix: "<base>_<digits>"
 */
function parseDbWithNumericSuffix(dbName) {
  if (!dbName || typeof dbName !== 'string') return null;
  const m = dbName.match(/^(.*?_)(\d+)$/);
  if (!m) return null;
  const base = m[1];
  const numStr = m[2];
  const num = parseInt(numStr, 10);
  return { base, num, width: numStr.length };
}

function buildDbName(parsed, targetNum) {
  const padded = String(targetNum).padStart(parsed.width, '0');
  return `${parsed.base}${padded}`;
}

/**
 * Create/return (cached) a connected pool for the supplied region config object,
 * overriding the database name if overrideDatabase is provided.
 */
async function ensurePoolForDatabase(regionKey, cfg, overrideDatabase) {
  const dbName = overrideDatabase || cfg.database;
  const cacheKey = `${regionKey}_${dbName}`;
  if (pools[cacheKey]) {
    try {
      // if pool exists but marked disconnected, attempt reconnect
      if (pools[cacheKey]._connected === false) {
        pools[cacheKey] = await new sql.ConnectionPool({ ...cfg, database: dbName }).connect();
      }
      return pools[cacheKey];
    } catch (e) {
      delete pools[cacheKey];
    }
  }

  const poolCfg = { ...cfg, database: dbName };
  const pool = await new sql.ConnectionPool(poolCfg).connect();
  pools[cacheKey] = pool;
  return pool;
}

/**
 * Backwards-compatible: return pool for configured (primary) DB for regionKey.
 */
export async function getPool(regionKey) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) throw new Error(`Unknown region: ${regionKey}`);
  return ensurePoolForDatabase(key, cfg, cfg.database);
}

/**
 * Return list of candidate DB NAMES for a region (primary, primary-1, ..., up to maxBackups)
 * This function does NOT create connections; it's cheap and deterministic.
 *
 * @param {string} regionKey
 * @param {number} maxBackups  how many previous DBs to include (default 4)
 * @returns {string[]} array of database names (primary first)
 */
export function getRegionDbNames(regionKey, maxBackups = 4) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) throw new Error(`Unknown region: ${regionKey}`);

  const parsed = parseDbWithNumericSuffix(cfg.database);
  if (!parsed) {
    return [cfg.database];
  }

  const nums = [];
  for (let i = 0; i <= maxBackups; i++) {
    const n = parsed.num - i;
    if (n > 0) nums.push(n);
  }
  const dbNames = nums.map(n => buildDbName(parsed, n));
  return dbNames;
}

/**
 * Connect (sequentially) to the given dbNames for the region and return the pools.
 * This connects only to the requested dbNames and caches them.
 *
 * @param {string} regionKey
 * @param {string[]} dbNames
 * @returns {Promise<sql.ConnectionPool[]>}
 */
export async function getPoolsForDbNames(regionKey, dbNames = []) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) throw new Error(`Unknown region: ${regionKey}`);

  const createdPools = [];
  for (const db of dbNames) {
    try {
      const p = await ensurePoolForDatabase(key, cfg, db);
      createdPools.push(p);
    } catch (err) {
      // compact log only
      // eslint-disable-next-line no-console
      console.warn(`Failed to connect to ${db} for region ${key}:`, err && err.message ? err.message : String(err));
    }
  }

  // If nothing connected, fallback to primary configured DB (ensured)
  if (createdPools.length === 0) {
    const primary = await ensurePoolForDatabase(key, cfg, cfg.database);
    return [primary];
  }
  return createdPools;
}

/**
 * Old function signature: returns pools for primary + previous 4 (but does NOT eagerly connect them).
 * For backwards compatibility - we connect only to primary and return [primary] (to avoid accidental heavy connects).
 * If caller actually needs multiple pools they should call getPoolsForDbNames(getRegionDbNames(...)).
 */
export async function getRegionPools(regionKey) {
  // For safety and backwards compatibility we only return primary pool here.
  // New code should use getRegionDbNames + getPoolsForDbNames to control which DBs to open.
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) throw new Error(`Unknown region: ${regionKey}`);
  const primary = await ensurePoolForDatabase(key, cfg, cfg.database);
  return [primary];
}

/**
 * Convenience: returns the first available pool among primary db (backwards-compatible).
 */
export async function getAnyPool(regionKey) {
  const arr = await getRegionPools(regionKey);
  if (arr && arr.length) return arr[0];
  return getPool(regionKey);
}

export { sql, regions };











// backend/services/reportService.js
import { getPool, getRegionDbNames, getPoolsForDbNames, sql, regions } from '../config/dbConfig.js';

/**
 * Small helper to retrieve a human DB name for a pool
 */
function safePoolDbName(pool) {
  try {
    if (!pool) return 'unknown';
    return (pool.config && pool.config.database) ? pool.config.database : 'unknown';
  } catch (e) {
    return 'unknown';
  }
}

/**
 * Query strategy:
 * - For small ranges (<= 31 days) we try primary DB first; if it returns any rows we use that (fast path).
 *   If primary returns nothing we check previous DBs one-by-one until we find rows.
 * - For larger ranges (> 31 days) we query up to `maxBackups+1` DBs sequentially, collecting rows from each.
 *
 * buildReq(req) => returns query string and is expected to bind inputs to req before returning the SQL.
 *
 * This function deliberately queries pools sequentially (not Promise.all) to avoid connection explosion.
 */
async function queryAcrossRegionPoolsSmart(region, buildReq, { startDate = null, endDate = null, maxBackups = 4 } = {}) {
  if (!region) throw new Error('region required');

  // compute candidate DB names (primary, primary-1, ...)
  const dbNames = getRegionDbNames(region, maxBackups);

  // decide mode based on date range length
  let mode = 'small'; // default fast-path mode
  if (startDate && endDate) {
    const s = new Date(startDate);
    const e = new Date(endDate);
    const days = Math.ceil((e - s) / (1000 * 60 * 60 * 24));
    if (days > 31) mode = 'large';
  }

  const allRows = [];

  // For small ranges: try primary first and accept fast if it returns any rows.
  if (mode === 'small') {
    // Try primary DB only first (fast)
    const primaryName = dbNames[0];
    try {
      const pools = await getPoolsForDbNames(region, [primaryName]);
      const pool = pools && pools[0];
      if (pool) {
        try {
          const req = pool.request();
          req.timeout = 300000;
          const q = buildReq(req);
          const res = await req.query(q);
          const rows = (res && res.recordset) ? res.recordset : [];
          if (rows && rows.length) {
            // got results from primary -> fast return
            allRows.push(...rows);
            return allRows;
          }
          // else fall through to check previous DBs sequentially
        } catch (err) {
          // log compactly and continue to previous DBs
          // eslint-disable-next-line no-console
          console.warn(`Query failed on pool (db=${primaryName}) for region ${region}:`, err && err.message ? err.message : String(err));
        }
      }
    } catch (err) {
      // eslint-disable-next-line no-console
      console.warn('primary pool connection failed:', err && err.message ? err.message : String(err));
    }

    // Primary had no rows or failed -> check previous DBs one-by-one until first successful set
    for (let i = 1; i < dbNames.length; i++) {
      const dbn = dbNames[i];
      try {
        const pools = await getPoolsForDbNames(region, [dbn]);
        const pool = pools && pools[0];
        if (!pool) continue;
        const req = pool.request();
        req.timeout = 300000;
        const q = buildReq(req);
        const res = await req.query(q);
        const rows = (res && res.recordset) ? res.recordset : [];
        if (rows && rows.length) {
          allRows.push(...rows);
          // stop at first DB with rows (fast)
          break;
        }
      } catch (err) {
        // eslint-disable-next-line no-console
        console.warn(`Query failed on pool (db=${dbn}) for region ${region}:`, err && err.message ? err.message : String(err));
      }
    }

    return allRows;
  }

  // For large ranges: query up to maxBackups+1 DBs sequentially and aggregate results
  for (let i = 0; i < dbNames.length; i++) {
    const dbn = dbNames[i];
    try {
      const pools = await getPoolsForDbNames(region, [dbn]);
      const pool = pools && pools[0];
      if (!pool) continue;
      const req = pool.request();
      req.timeout = 300000;
      const q = buildReq(req);
      const res = await req.query(q);
      const rows = (res && res.recordset) ? res.recordset : [];
      if (rows && rows.length) {
        allRows.push(...rows);
      }
    } catch (err) {
      // eslint-disable-next-line no-console
      console.warn(`Query failed on pool (db=${dbn}) for region ${region}:`, err && err.message ? err.message : String(err));
    }
  }

  return allRows;
}

// ------------------------- light-weight functions -------------------------

export async function listLocations(region) {
  if (!region) throw new Error('region required');
  const pool = await getPool(region);
  const req = pool.request();
  const q = `SELECT DISTINCT PartitionName2 FROM ACVSUJournalLog WHERE PartitionName2 IS NOT NULL ORDER BY PartitionName2`;
  const { recordset } = await req.query(q);
  return (recordset || []).map(r => r.PartitionName2).filter(Boolean);
}

export async function searchEmployees(region = 'emea', q = '') {
  const pool = await getPool(region);
  const req = pool.request();
  const like = `%${q}%`;
  req.input('q', sql.NVarChar(200), like);

  const query = `
    SELECT TOP (200)
      CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR(50)) END AS EmployeeID,
      ISNULL(t2.Text1, '') AS Name
    FROM ACVSCore.Access.Personnel AS t2
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId = t3.ObjectID
    WHERE (t2.Text1 LIKE @q) OR (CAST(t2.Int1 AS NVARCHAR(50)) LIKE @q) OR (t2.Text12 LIKE @q)
    ORDER BY t2.Text1;
  `;
  const { recordset } = await req.query(query);
  return (recordset || []).map(r => ({ EmployeeID: r.EmployeeID, Name: r.Name }));
}

// ------------------------- rawReport (smart) -------------------------

export async function rawReport(region, { startDate, endDate, location, admitFilter = 'all' }) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;
  const admitFilterParam = String(admitFilter || 'all');

  const buildReq = (req) => {
    req.input('location', sql.NVarChar(200), locationParam);
    req.input('startDate', sql.Date, startDate);
    req.input('endDate', sql.Date, endDate);
    req.input('admitFilter', sql.NVarChar(20), admitFilterParam);

    const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    AND (
      UPPER(ISNULL(@admitFilter,'all')) = 'ALL'
      OR (UPPER(@admitFilter) = 'ADMIT'  AND t1.MessageType = 'CardAdmitted')
      OR (UPPER(@admitFilter) = 'REJECT' AND t1.MessageType = 'CardRejected')
    )
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM CombinedQuery
ORDER BY LocaleMessageTime ASC;
`;
    return query;
  };

  // smart query: if small range prefer fast path
  const rows = await queryAcrossRegionPoolsSmart(region, buildReq, { startDate, endDate, maxBackups: 4 });
  // ensure global ordering
  rows.sort((a, b) => {
    const ta = new Date(a.LocaleMessageTime || a.DateOnly || 0).getTime();
    const tb = new Date(b.LocaleMessageTime || b.DateOnly || 0).getTime();
    return ta - tb;
  });
  return rows;
}

// ------------------------- rejectionReport (smart) -------------------------

export async function rejectionReport(region, { startDate, endDate, location } = {}) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;

  const buildReq = (req) => {
    req.input('location', sql.NVarChar(200), locationParam);
    req.input('startDate', sql.Date, startDate);
    req.input('endDate', sql.Date, endDate);

    const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType = 'CardRejected'
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
),
Unified AS (
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Lost'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Clearance'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type IN ('CardDisabled','Disabled')
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Stolen'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Expired'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'PIN'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'UnknownCard'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'SiteCode'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'NotActivated'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'FacilityCode'
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM Unified
ORDER BY LocaleMessageTime DESC;
`;
    return query;
  };

  const rows = await queryAcrossRegionPoolsSmart(region, buildReq, { startDate, endDate, maxBackups: 4 });
  rows.sort((a, b) => {
    const ta = new Date(a.LocaleMessageTime || a.DateOnly || 0).getTime();
    const tb = new Date(b.LocaleMessageTime || b.DateOnly || 0).getTime();
    return tb - ta;
  });
  return rows;
}

// ------------------------- dailyAccessReportEMEA (smart per-DB) -------------------------

export async function dailyAccessReportEMEA({ from, to, employees = '' }) {
  const region = 'emea';
  const employeesParam = (employees && String(employees).trim()) ? String(employees).trim() : null;
  const startDate = from;
  const endDate = to;

  const buildReq = (req) => {
    req.input('fromDate', sql.Date, startDate);
    req.input('toDate', sql.Date, endDate);
    req.input('employees', sql.NVarChar(sql.MAX), employeesParam);

    const query = `...`; // Keep the same SQL as your original dailyAccessReportEMEA (omitted here for brevity)
    // ** Insert your full SQL string here exactly as in original code **
    return query;
  };

  // small-range strategy applies (daily ranges typically small)
  const rows = await queryAcrossRegionPoolsSmart(region, buildReq, { startDate, endDate, maxBackups: 4 });
  rows.sort((a, b) => {
    const ta = new Date(a.LocaleMessageTime || 0).getTime();
    const tb = new Date(b.LocaleMessageTime || 0).getTime();
    return ta - tb;
  });
  return rows;
}

// ------------------------- other reports (kept single-pool or smart as appropriate) -------------------------

export async function inOutReport(region, { year, month, doors }) {
  const pool = await getPool(region);
  const req = pool.request();
  req.timeout = 300000;

  req.input('TargetYear', sql.Int, year);
  req.input('TargetMonth', sql.Int, month);
  doors.forEach((d, i) => req.input(`door${i}`, sql.NVarChar, d));
  const doorList = doors.map((_, i) => `@door${i}`).join(',');

  const query = `
    /* same SQL as your existing inOutReport - unchanged */
  `;

  const { recordset } = await req.query(query);
  return recordset;
}

export async function timeDurationReport(region, { partition = 'Default', startDate }) {
  // timeDurationReport often queries a partition and multiple days; we treat as large-range
  const buildReq = (req) => {
    req.input('partition', sql.NVarChar, `${region.toUpperCase()}.${partition}`);
    req.input('startDate', sql.Date, startDate);

    const query = `
      /* same SQL as your existing timeDurationReport - unchanged */
    `;
    return query;
  };

  const rows = await queryAcrossRegionPoolsSmart(region, buildReq, { startDate, endDate: null, maxBackups: 4 });
  // ordering/stable sort (same as before)
  rows.sort((a, b) => {
    const keyA = `${a.YearNumber || 0}-${a.WeekNumber || 0}-${a.EmployeeID || ''}-${(a.ShiftedDate || '')}`;
    const keyB = `${b.YearNumber || 0}-${b.WeekNumber || 0}-${b.EmployeeID || ''}-${(b.ShiftedDate || '')}`;
    return keyB.localeCompare(keyA);
  });
  return rows;
}

export async function eurocAdmitRejectionReport(region, { reportDate }) {
  if (!region) throw new Error('region required');
  if (!reportDate) throw new Error('reportDate required');

  // for this report we want data for a single date (small), so smart logic will try primary first
  const buildReq = (req) => {
    req.input('location', sql.NVarChar, 'LT.Vilnius');
    req.input('reportDate', sql.Date, reportDate);
    const query = `/* same SQL as your previous eurocAdmitRejectionReport but without DB prefixes */`;
    return query;
  };

  // We'll perform sequential per-db execution because this query returns multiple resultsets.
  // Try primary first, fallback to previous DBs if needed (same philosophy)
  const dbNames = getRegionDbNames(region, 4);
  const admitRows = [];
  const rejectRows = [];
  const summaryMap = {};

  // try sequentially until at least one DB yields non-empty admit OR reject
  for (let i = 0; i < dbNames.length; i++) {
    const dbn = dbNames[i];
    try {
      const pools = await getPoolsForDbNames(region, [dbn]);
      const pool = pools && pools[0];
      if (!pool) continue;
      const req = pool.request();
      req.timeout = 300000;
      // bind inputs on the request as buildReq expects
      req.input('location', sql.NVarChar, 'LT.Vilnius');
      req.input('reportDate', sql.Date, reportDate);

      const q = `
        /* paste your euroc SQL here (without DB prefixes) */
      `;
      const result = await req.query(q);
      const recordsets = result.recordsets || [];
      const admits = (recordsets[0] || []).map(r => ({ ...r }));
      const rejects = (recordsets[1] || []).map(r => ({ ...r }));
      const summary = (recordsets[2] || []).map(r => ({ Rejection_Type: r.Rejection_Type, Count: r.CountVal }));

      if (admits.length) admitRows.push(...admits);
      if (rejects.length) rejectRows.push(...rejects);
      summary.forEach(s => { summaryMap[s.Rejection_Type] = (summaryMap[s.Rejection_Type] || 0) + (s.Count || 0); });

      // if we got any rows (admit or reject), stop here to be fast
      if (admits.length || rejects.length) break;
    } catch (err) {
      // eslint-disable-next-line no-console
      console.warn(`euroc query failed on db=${dbn}:`, err && err.message ? err.message : String(err));
    }
  }

  admitRows.sort((a, b) => new Date(a.LocaleMessageTime || 0) - new Date(b.LocaleMessageTime || 0));
  rejectRows.sort((a, b) => new Date(a.LocaleMessageTime || 0) - new Date(b.LocaleMessageTime || 0));
  const summaryRows = Object.entries(summaryMap).map(([k, v]) => ({ Rejection_Type: k, Count: v }));

  return { admit: admitRows, rejection: rejectRows, summary: summaryRows };
}





















// C:\Users\W0024618\Desktop\global-page\frontend\src\pages\ReportsPage.jsx
import React, { useState, useEffect, useRef } from 'react';
import {
  Box, FormControl, InputLabel, Select, OutlinedInput,
  Checkbox, ListItemText, MenuItem, Button,
  CircularProgress, Typography, TextField, Tabs, Tab, Grid, Paper, IconButton, Divider, Autocomplete
} from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import axios from 'axios';
import ExcelJS from 'exceljs';
import * as XLSX from 'xlsx';
import { useAuth } from '../context/AuthContext';

import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import PlaceIcon from '@mui/icons-material/Place';
import PeopleIcon from '@mui/icons-material/People';
import DownloadIcon from '@mui/icons-material/CloudDownload';
import FilterListIcon from '@mui/icons-material/FilterList';
import Avatar from '@mui/material/Avatar';
import { generateDailyAccessExcelFromRows } from './DailyAccessReport';

// Static lists
const EMPLOYEE_OPTIONS = [
  'Vainilaitis, Valdas',
  'Tomasevic, Kazimez',
  'Sesickis, Janas',
  'Valiunas, Sigitas',
  'JANCUKOVIC, VACLAVA',
  'Kalpokiene, Alina',
  'Korkus, Vanda',
  'Kvaraciejiene, Maryte',
  'ZNAMEROVSKIS, DARIUS',
  'Dovgialo, Liucija'
];

const REGION_OPTIONS = ['global', 'apac', 'emea', 'laca', 'namer'];
const LOCATION_MAP = {
  apac: ['APAC.Default', 'JP.Tokyo', 'PH.Manila', 'MY.Kuala Lumpur','IN.HYD'],
  emea: ['AUT.Vienna', 'DU.Abu Dhab', 'IE.Dublin', 'IT.Rome', 'LT.Vilnius', 'MA.Casablanca', 'RU.Moscow', 'UK.London', 'ES.Madrid'],
  laca: ['AR.Cordoba', 'CR.Costa Rica Partition', 'MX.Mexico City', 'PE.Lima', 'BR.Sao Paulo', 'PA.Panama City'],
  namer: ['US.NYC', 'US.FL.Miami', 'USA/Canada Default', 'US.CO.OBS','US.Denver'],
  global: []
};

function formatDisplayDate(date) {
  if (!date) return '';
  const d = new Date(date);
  const day = d.getDate();
  const suf = day % 10 === 1 && day !== 11 ? 'st'
    : day % 10 === 2 && day !== 12 ? 'nd'
      : day % 10 === 3 && day !== 13 ? 'rd' : 'th';
  const mon = d.toLocaleString('default', { month: 'long' });
  return `${day}${suf} ${mon} ${d.getFullYear()}`;
}

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');



 // ---------- helpers for Excel formatting ----------
  const HEADER_FILL = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFCCE8FF' } }; // light blue
  const THIN_BORDER = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
  const THICK_BORDER = { top: { style: 'thick' }, left: { style: 'thick' }, bottom: { style: 'thick' }, right: { style: 'thick' } };

  function hideGridLines(ws) {
    try {
      ws.views = [{ showGridLines: false }];
    } catch (e) { /* ignore */ }
  }

  function applyHeaderStyles(row) {
    row.eachCell(cell => {
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.fill = HEADER_FILL;
      cell.border = THICK_BORDER;
    });
  }

  function applyThinBordersToWorksheet(ws, headerRowIndex = 1) {
    ws.eachRow((row, rIdx) => {
      row.eachCell(cell => {
        // skip header row (we already applied thick border)
        if (rIdx === headerRowIndex) return;
        // ensure border exists
        cell.border = THIN_BORDER;
        if (!cell.alignment) cell.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });
  }

  function autosizeColumns(ws) {
    // simple heuristic: compute max text length per column
    const colCount = ws.columnCount || (ws._columns && ws._columns.length) || 0;
    for (let c = 1; c <= colCount; c++) {
      let maxLen = 10; // minimal
      ws.eachRow((row) => {
        const cell = row.getCell(c);
        const v = cell && cell.value !== undefined && cell.value !== null ? String(cell.value) : '';
        if (v.length > maxLen) maxLen = v.length;
      });
      // width heuristic: a little padding, cap to reasonable value
      const width = Math.min(60, Math.max(10, Math.ceil(maxLen * 1.2)));
      try {
        ws.getColumn(c).width = width;
      } catch (e) { /* ignore if impossible */ }
    }
  }
  // ---------- end helpers ----------




// --- Helper functions (unchanged from your original) ---
function _extractServerDateTimeParts(iso) {
  if (!iso) return null;
  const s = String(iso);
  let datePart = '', timePart = '';
  if (s.includes('T')) {
    [datePart, timePart] = s.split('T');
  } else if (s.includes(' ')) {
    [datePart, timePart] = s.split(' ');
  } else {
    return null;
  }
  datePart = datePart.slice(0, 10);
  timePart = (timePart || '').replace(/Z|[+-]\d{2}:\d{2}$/, '').replace(/\.\d+$/, '');
  const dParts = datePart.split('-').map(p => parseInt(p, 10));
  const tParts = timePart.split(':').map(p => parseInt(p || '0', 10));
  return {
    year: dParts[0] || 0,
    month: dParts[1] || 0,
    day: dParts[2] || 0,
    hour: tParts[0] || 0,
    minute: tParts[1] || 0,
    second: tParts[2] || 0
  };
}

function formatDateFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  const y = dt.getUTCFullYear();
  const m = dt.getUTCMonth(); // 0..11
  const d = dt.getUTCDate();
  const yrShort = String(y).slice(-2);
  return `${pad2(d)}-${MONTH_ABBR[m]}-${yrShort}`;         // e.g. "12-Aug-25"
}

function formatTimeFromServerISO(iso) {
  if (!iso) return '';
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const hh = p.hour;
  const mm = p.minute || 0;
  const ss = p.second || 0;
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1;
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
}

function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10);
  if (!swipeIso) {
    return `${datePart}T00:00:00.000`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000`;
  }
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000`;
}

const getServerISO = (r) => {
  if (!r) return '';
  if (r.LocaleMessageTime) return r.LocaleMessageTime;
  if (r.DateOnly) return buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  return '';
};

const getServerYMD = (r) => {
  const iso = getServerISO(r);
  if (!iso) return '';
  return iso.slice(0, 10);
};

const isoDateOnlyToLocalDate = (iso) => {
  if (!iso) return null;
  const s = iso.toString().slice(0, 10);
  const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
  return new Date(y, m - 1, d);
};

const buildLocalDateFromDateOnlyAndSwipe = (dateOnly, swipeTime) => {
  if (!dateOnly) return null;
  const dateStr = dateOnly.toString().slice(0, 10);
  const [yy, mm, dd] = dateStr.split('-').map(n => parseInt(n, 10));

  let hh = 0, min = 0, ss = 0;
  if (swipeTime) {
    const parsed = new Date(swipeTime);
    if (!isNaN(parsed.getTime())) {
      hh = parsed.getUTCHours();
      min = parsed.getUTCMinutes();
      ss = parsed.getUTCSeconds();
    } else {
      const parts = swipeTime.split(':').map(p => parseInt(p, 10));
      if (parts.length >= 2) {
        hh = parts[0] || 0;
        min = parts[1] || 0;
        ss = parts[2] || 0;
      }
    }
  }
  return new Date(yy, mm - 1, dd, hh, min, ss);
};

export default function ReportsPage() {
  const auth = useAuth();

  // --- state ---
  const [tab, setTab] = useState(0);

  // default region now set to 'emea' for initial tab 0 behavior
  const [region, setRegion] = useState('emea');
  const [location, setLocation] = useState('LT.Vilnius');
  const [from, setFrom] = useState(null);
  const [to, setTo] = useState(null);
  const [showFromCal, setShowFromCal] = useState(false);
  const [showToCal, setShowToCal] = useState(false);
  const [selectedEmps, setSelectedEmps] = useState([]);
  const [loading, setLoading] = useState(false);
  const [generatingMessage, setGeneratingMessage] = useState('');

  const [rawSearch, setRawSearch] = useState('');
  const [rawAdmitFilter, setRawAdmitFilter] = useState('all');
  const [newEmployee, setNewEmployee] = useState('');

  const [availableLocations, setAvailableLocations] = useState([]);
  const [selectedLocations, setSelectedLocations] = useState([]);
  const [rawEmpOptions, setRawEmpOptions] = useState([]);
  const [selectedRawEmps, setSelectedRawEmps] = useState([]);
  const empQueryRef = useRef(null);

  // Provide region options depending on tab
  const regionOptionsForTab = () => {
    if (tab === 0) return ['emea'];            // Daily Access -> only EMEA
    if (tab === 3) return ['emea'];            // EUROC -> only EMEA
    if (tab === 4) return ['apac'];            // Time Duration -> only APAC
    if (tab === 6) return ['namer'];           // Denver -> NAMER
    return REGION_OPTIONS;                     // default (Raw, Rejection, HeadCount, etc.)
  };

  // Provide location options depending on tab & region
  const locationOptionsForTab = (r) => {
    const rr = r || region;
    if (tab === 0) return ['LT.Vilnius']; // Daily Access -> only Vilnius
    if (tab === 6) return ['US.Denver']; // Denver -> Denver only
    if (tab === 3) {
      // EUROC -> show full EMEA location list (allow multi-selection)
      return availableLocations.length ? availableLocations : (LOCATION_MAP['emea'] || []);
    }
    if (tab === 4) {
      // Time Duration -> show APAC location list strictly
      return availableLocations.length ? availableLocations : (LOCATION_MAP['apac'] || []);
    }
    if (tab === 1) {
      return availableLocations.length ? availableLocations : (LOCATION_MAP[rr] || []);
    }
    // default
    return availableLocations.length ? availableLocations : (LOCATION_MAP[rr] || []);
  };

  // fetch availableLocations for the currently selected region (runs on region change)
  useEffect(() => {
    let mounted = true;
    const load = async () => {
      setAvailableLocations([]);
      if (!region) return;
      const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];

      try {
        if (region === 'global') {
          const promises = MULTI_REGIONS.map(r => fetchLocationsForRegion(r));
          const results = await Promise.all(promises);
          const merged = results.flat();
          if (!mounted) return;
          setAvailableLocations(Array.from(new Set(merged)).sort());
        } else {
          const list = await fetchLocationsForRegion(region);
          if (!mounted) return;
          setAvailableLocations(Array.from(new Set(list)).sort());
        }
      } catch (err) {
        console.error('load locations error', err);
        // fallback to static map
        const key = (region || '').toLowerCase();
        setAvailableLocations((LOCATION_MAP[key] || []).slice());
      }
    };

    // always attempt to fetch when region is set (EUROC & Time Duration need real lists)
    if (region) {
      load();
    } else {
      setAvailableLocations([]);
    }

    return () => { mounted = false; };
  }, [region, tab]);

  // Helper: fetch locations for a single region key (backend endpoint: GET /api/locations?region=apac)
  const fetchLocationsForRegion = async (r) => {
    try {
      if (!r) return [];
      const resp = await axios.get('/api/locations', { params: { region: r } });
      const listRaw = (resp.data && (resp.data.data || resp.data)) || [];
      const list = Array.isArray(listRaw)
        ? listRaw.map(item => {
            if (typeof item === 'string') return item;
            return item.PartitionName2 || item.partition || item.location || item.name || (item.label ? item.label : null);
          }).filter(Boolean)
        : [];
      if (!list.length) {
        const key = (r || '').toLowerCase();
        return (LOCATION_MAP[key] || []).slice();
      }
      return Array.from(new Set(list)).sort();
    } catch (e) {
      console.warn('fetchLocationsForRegion error', r, e);
      const key = (r || '').toLowerCase();
      return (LOCATION_MAP[key] || []).slice();
    }
  };

  // Handle tab switch (Daily / Raw / Rejection / etc.)
  const handleTabChange = (_, v) => {
    setTab(v);

    // Reset shared filters
    setFrom(null);
    setTo(null);
    setSelectedEmps([]);
    setRawSearch('');
    setRawAdmitFilter('all');
    setSelectedLocations([]);
    setSelectedRawEmps([]);
    setNewEmployee('');
    setRawEmpOptions([]);
    setGeneratingMessage('');

    // Default region/location per tab (as requested)
    if (v === 0) {         // Daily Access -> EMEA + Vilnius
      setRegion('emea');
      setLocation('LT.Vilnius');
    } else if (v === 1) {  // Raw -> keep default region (emea) but let user change
      setRegion('emea');
      setLocation('');
    } else if (v === 2) {  // Rejection -> default emea
      setRegion('emea');
      setLocation('');
    } else if (v === 3) {  // EUROC -> EMEA only, allow multi locations
      setRegion('emea');
      setLocation(''); // user chooses 0..n locations (none => all)
    } else if (v === 4) {  // Time Duration -> APAC only
      setRegion('apac');
      setLocation('');
    } else if (v === 5) {  // HeadCount -> default emea
      setRegion('emea');
      setLocation('');
    } else if (v === 6) {  // Denver -> NAMER + Denver
      setRegion('namer');
      setLocation('US.Denver');
    }
  };



  const generateTimeDurationExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Time Duration');

    hideGridLines(ws);

    ws.mergeCells('A1:M1');
    ws.getCell('A1').value =
      `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center', vertical: 'middle' };
    ws.getRow(1).height = 22;

    const headers = [
      'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
      'Partition', 'Text5', 'Year', 'Week', 'Date',
      'First Swipe', 'Last Swipe', 'Duration', 'Category',
      'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
    ];
    const headerRow = ws.addRow(headers);
    applyHeaderStyles(headerRow);

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'ptype', width: 18 },
      { key: 'part', width: 15 },
      { key: 'txt5', width: 20 },
      { key: 'year', width: 8 },
      { key: 'week', width: 6 },
      { key: 'date', width: 12 },
      { key: 'first', width: 16 },
      { key: 'last', width: 16 },
      { key: 'dur', width: 10 },
      { key: 'cat', width: 12 },
      { key: 'dpw', width: 12 },
      { key: 'vdw', width: 14 },
      { key: 'cdw', width: 12 },
      { key: 'def', width: 10 }
    ];

    data.forEach((r, idx) => {
      const first = r.FirstSwipeTime ? new Date(r.FirstSwipeTime) : null;
      const last = r.LastSwipeTime ? new Date(r.LastSwipeTime) : null;
      const date = r.ShiftedDate ? new Date(r.ShiftedDate) : null;
      const row = ws.addRow([
        idx + 1,
        r.ObjectName1,
        r.EmployeeID,
        r.PersonnelType,
        r.PartitionName2,
        r.text5,
        r.YearNumber,
        r.WeekNumber,
        date,
        first,
        last,
        r.DurationHHMM,
        r.TimeDiffCategory,
        r.DaysPresentInWeek,
        r.ViolationDaysInWeek,
        r.CleanDaysInWeek,
        r.Defaulter
      ]);

      if (date) row.getCell(9).numFmt = 'dd-mmm-yy';
      if (first) row.getCell(10).numFmt = 'h:mm:ss AM/PM';
      if (last) row.getCell(11).numFmt = 'h:mm:ss AM/PM';

      row.eachCell(c => {
        c.border = THIN_BORDER;
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    // apply autosize
    autosizeColumns(ws);

    ws.autoFilter = 'A2:Q2';

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    const filename =
      `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;

    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };






  
const generateRejectionExcel = async data => {
  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Rejection');

  const GRAY_FILL = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };

  // hide gridlines
  hideGridLines(ws);

  // --- Prepare layout: skip first row and first column (A) ---
  ws.addRow([]); // row 1 (blank)

  // Title in row 2, columns B..K (10 headers -> B..K)
  const title = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}`;
  ws.addRow([null]); // ensure row 2 exists
  ws.mergeCells('B2:K2');
  ws.getCell('B2').value = title;
  ws.getCell('B2').font = { bold: true, size: 14 };
  ws.getCell('B2').alignment = { horizontal: 'center', vertical: 'middle' };
  ws.getRow(2).height = 22;
  // style merged title cells (B2..K2)
  for (let c = 2; c <= 11; c++) {
    const cell = ws.getCell(2, c);
    cell.fill = GRAY_FILL;
    cell.font = { bold: true, size: 14 };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.border = THICK_BORDER;
  }

  // Headers in row 3 (we add a row where first element null keeps column A blank)
  const headers = [
    'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
    'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
  ];
  const headerRow = ws.addRow([null, ...headers]); // this will be row 3
  headerRow.height = 20;
  headerRow.eachCell((cell, colNumber) => {
    // colNumber counts across the entire row including the null at col A; header cells are cols 2..11
    if (colNumber >= 2 && colNumber <= 11) {
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.fill = GRAY_FILL;
      cell.border = THICK_BORDER;
    }
  });

  // setup columns widths (A blank column + 10 content columns B..K)
  ws.columns = [
    { key: 'blankA', width: 3 }, // column A (skipped)
    { key: 'sr', width: 8 },     // B
    { key: 'date', width: 12 },  // C
    { key: 'time', width: 12 },  // D
    { key: 'name', width: 30 },  // E
    { key: 'id', width: 15 },    // F
    { key: 'card', width: 18 },  // G
    { key: 'type', width: 18 },  // H
    { key: 'door', width: 40 },  // I
    { key: 'loc', width: 18 },   // J
    { key: 'swipe', width: 12 }  // K
  ];

  // Column alignment sets (absolute column indices)
  // With blank A, the content cols shift by +1: Sr -> 2, Date -> 3, ..., Swipe -> 11
  const centerCols = new Set([2,3,4,5,6,7,8,10,11]); // Sr,Date,Time,Name,ID,Card,Type,Location,Swipe
  const leftCols = new Set([9]); // Door Name only (I)

  // Add data rows (starting from row 4)
  data.forEach((r, idx) => {
    const iso = getServerISO(r);
    const dateStr = iso ? formatDateFromServerISO(iso) : (r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '');
    const timeStr = iso ? formatTimeFromServerISO(iso) : (r.Swipe_Time ? formatTimeFromServerISO(r.Swipe_Time) : '');

    const rowVals = [
      null, // column A blank
      idx + 1,
      dateStr,
      timeStr,
      r.ObjectName1 || '',
      r.EmployeeID || '',
      r.CardNumber || '',
      r.Rejection_Type || '',
      r.Door || r.ObjectName2 || '',
      r.location || '',
      r.Direction || r.Swipe || ''
    ];
    const row = ws.addRow(rowVals);

    row.eachCell((cell, colNumber) => {
      // only style cells inside B..K
      if (colNumber >= 2 && colNumber <= 11) {
        cell.border = THIN_BORDER;
        const horiz = leftCols.has(colNumber) ? 'left' : (centerCols.has(colNumber) ? 'center' : 'left');
        cell.alignment = { vertical: 'middle', horizontal: horiz };
      }
    });
  });

  // Apply thick outside border around header + data (columns B..K)
  const headerRowIndex = 3;
  const firstDataRow = headerRowIndex; // include header when constructing outer border
  const lastDataRow = ws.lastRow ? ws.lastRow.number : headerRowIndex;
  const firstCol = 2; // column B
  const lastCol = 11; // column K

  for (let r = firstDataRow; r <= lastDataRow; r++) {
    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(r, c);
      if (!cell.border) cell.border = THIN_BORDER;
      const border = {
        top: (r === firstDataRow) ? { style: 'thick' } : (cell.border.top || { style: 'thin' }),
        bottom: (r === lastDataRow) ? { style: 'thick' } : (cell.border.bottom || { style: 'thin' }),
        left: (c === firstCol) ? { style: 'thick' } : (cell.border.left || { style: 'thin' }),
        right: (c === lastCol) ? { style: 'thick' } : (cell.border.right || { style: 'thin' })
      };
      cell.border = border;
    }
  }

  // ---------- Summary block placed to the RIGHT of the table ----------
  // We'll leave one blank column after the last data column, then place summary (2 columns wide)
  const summaryStartCol = lastCol + 2; // skip one column after Swipe
  const summaryTitleRow = headerRowIndex + 1; // place summary title starting near header (row 4)
  const summaryHdrRow = summaryTitleRow + 1;

  // Build counts by Rejection_Type
  const countsMap = {};
  data.forEach(r => {
    const key = (r.Rejection_Type || 'Unknown').toString();
    countsMap[key] = (countsMap[key] || 0) + 1;
  });
  const countEntries = Object.entries(countsMap);

  // Summary title (merged across two summary columns)
  const colLetter = (c => {
    // helper to convert 1-indexed col number to letter(s)
    let n = c, s = '';
    while (n > 0) {
      const m = (n - 1) % 26;
      s = String.fromCharCode(65 + m) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  });
  const sA = colLetter(summaryStartCol);
  const sB = colLetter(summaryStartCol + 1);
  ws.mergeCells(`${sA}${summaryTitleRow}:${sB}${summaryTitleRow}`);
  ws.getCell(`${sA}${summaryTitleRow}`).value = 'Summary';
  ws.getCell(`${sA}${summaryTitleRow}`).font = { bold: true };
  ws.getCell(`${sA}${summaryTitleRow}`).alignment = { horizontal: 'center', vertical: 'middle' };
  ws.getCell(`${sA}${summaryTitleRow}`).fill = GRAY_FILL;
  ws.getCell(`${sA}${summaryTitleRow}`).border = THICK_BORDER;
  ws.getCell(`${sB}${summaryTitleRow}`).fill = GRAY_FILL;
  ws.getCell(`${sB}${summaryTitleRow}`).border = THICK_BORDER;

  // Header row for summary - NOW using THICK_BORDER for header columns
  ws.getCell(summaryHdrRow, summaryStartCol).value = 'Rejection';
  ws.getCell(summaryHdrRow, summaryStartCol + 1).value = 'Count';
  [summaryStartCol, summaryStartCol + 1].forEach(c => {
    const cell = ws.getCell(summaryHdrRow, c);
    cell.font = { bold: true };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.fill = GRAY_FILL;
    // <<== make header cells have thick outside border as requested
    cell.border = THICK_BORDER;
  });

  // Summary detail rows (start below summaryHdrRow)
  let cur = summaryHdrRow + 1;
  countEntries.forEach(([type, cnt]) => {
    ws.getCell(cur, summaryStartCol).value = type;
    ws.getCell(cur, summaryStartCol + 1).value = cnt;
    ws.getCell(cur, summaryStartCol).alignment = { horizontal: 'left', vertical: 'middle' };
    ws.getCell(cur, summaryStartCol + 1).alignment = { horizontal: 'center', vertical: 'middle' };
    ws.getCell(cur, summaryStartCol).border = THIN_BORDER;
    ws.getCell(cur, summaryStartCol + 1).border = THIN_BORDER;
    cur++;
  });

  // Grand Total row - make Grand Total cells bold + thick border
  const grandTotal = data.length || 0;
  ws.getCell(cur, summaryStartCol).value = 'Grand Total';
  ws.getCell(cur, summaryStartCol + 1).value = grandTotal;
  [summaryStartCol, summaryStartCol + 1].forEach(c => {
    const cell = ws.getCell(cur, c);
    cell.font = { bold: true };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.fill = GRAY_FILL;
    // <<== make grand total cells have thick outside border as requested
    cell.border = THICK_BORDER;
  });

  // Apply thick outside border for summary block (this will preserve header/grandTotal thick borders)
  for (let r = summaryTitleRow; r <= cur; r++) {
    for (let c = summaryStartCol; c <= summaryStartCol + 1; c++) {
      const cell = ws.getCell(r, c);
      if (!cell.border) cell.border = THIN_BORDER;
      const border = {
        top: (r === summaryTitleRow) ? { style: 'thick' } : (cell.border.top || { style: 'thin' }),
        bottom: (r === cur) ? { style: 'thick' } : (cell.border.bottom || { style: 'thin' }),
        left: (c === summaryStartCol) ? { style: 'thick' } : (cell.border.left || { style: 'thin' }),
        right: (c === (summaryStartCol + 1)) ? { style: 'thick' } : (cell.border.right || { style: 'thin' })
      };
      cell.border = border;
    }
  }

  // Final workbook buffer & download (filename)
  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const filename = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}.xlsx`;
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
};




  function buildRawFileName(opts = {}) {
    const safe = s => (s === undefined || s === null) ? '' : String(s).replace(/[\/\\:?<>|"]/g, '_').trim();
    const regionPart = opts.region ? safe(opts.region).toUpperCase() : 'RAW';
    const locationPart = opts.location ? `_${safe(opts.location).replace('.', '_')}` : '';
    const admitPart = opts.rawAdmitFilter ? `_${safe(opts.rawAdmitFilter)}` : '';
    const searchPart = opts.rawSearch ? `_${safe(opts.rawSearch).replace(/\s+/g, '_')}` : '';
    const formatDateForName = d => {
      if (!d) return '';
      try {
        if (d instanceof Date) return `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}`;
        const dt = new Date(d);
        if (!isNaN(dt.getTime())) return `${dt.getFullYear()}${pad2(dt.getMonth()+1)}${pad2(dt.getDate())}`;
      } catch (e) { /* ignore */ }
      return safe(d).slice(0,10).replace(/[-\s:]/g,'');
    };

    const fromPart = opts.from ? `_from_${formatDateForName(opts.from)}` : '';
    const toPart   = opts.to   ? `_to_${formatDateForName(opts.to)}` : '';
    const filename = `Raw_${regionPart}${locationPart}${fromPart}${toPart}${admitPart}${searchPart}.xlsx`;
    return filename;
  }



 const generateRawExcel = async (rows, opts = {}) => {
    const formatTimeFromSwipe = (swipeIso) => {
      if (!swipeIso) return '';
      const dt = new Date(swipeIso);
      if (!isNaN(dt.getTime())) {
        return formatTimeFromServerISO(swipeIso);
      }
      const parts = ('' + swipeIso).split(':').map(p => parseInt(p || 0, 10));
      const hh = parts[0] || 0;
      const mm = parts[1] || 0;
      const ss = parts[2] || 0;
      const ampm = hh >= 12 ? 'PM' : 'AM';
      const hh12 = ((hh + 11) % 12) + 1;
      return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
    };

    const admitFilter = (opts.rawAdmitFilter || 'all').toString().toLowerCase();

    const baseHeaders = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber'];
    const admitCol = 'AdmitCode';
    const rejCol = 'Rejection_Type';
    const tailCols = ['Direction','Door'];

    let headers = [...baseHeaders];
    if (admitFilter === 'all') {
      headers.push(admitCol, ...tailCols, rejCol);
    } else if (admitFilter === 'admit') {
      headers.push(admitCol, ...tailCols);
    } else if (admitFilter === 'reject') {
      headers.push(...tailCols, rejCol);
    } else {
      headers.push(admitCol, ...tailCols, rejCol);
    }

    // If no rows, still create workbook with header row
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Raw');
    hideGridLines(ws);

    // header
    const hdr = ws.addRow(headers);
    applyHeaderStyles(hdr);

    if (rows && rows.length) {
      rows.forEach(r => {
        const iso = getServerISO(r);
        const dateStr = iso ? formatDateFromServerISO(iso) : '';
        const timeStr = iso ? formatTimeFromServerISO(iso) : '';
        const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');
        const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';
        const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

        const fullObj = {
          LocaleMessageTime: localeMsgFormatted,
          DateOnly: dateOnlyFormatted,
          Swipe_Time: swipeTimeFormatted,
          EmployeeID: r.EmployeeID || '',
          ObjectName1: r.ObjectName1 || '',
          PersonnelType: r.PersonnelType || '',
          location: r.location || '',
          CardNumber: r.CardNumber || '',
          AdmitCode: r.AdmitCode || r.Messagetype || '',
          Direction: r.Direction || r.Swipe || '',
          Door: r.Door || r.ObjectName2 || '',
          Rejection_Type: r.Rejection_Type || ''
        };

        const rowVals = headers.map(h => (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '');
        const added = ws.addRow(rowVals);
        added.eachCell(c => {
          c.border = THIN_BORDER;
          c.alignment = { vertical: 'middle', horizontal: 'left' };
        });
      });
    }

    // autosize
    autosizeColumns(ws);

    const filename = buildRawFileName(opts);
    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };




  const exportPermsForTab = () => {
    if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
    if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
    if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
    if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
    if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
    if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
    if (tab === 6) return ['gsoc_reports.denver_monthly', 'gsoc_reports'];
    return ['gsoc_reports'];
  };

  const disabled = loading
    || (tab !== 6 && !region)
    || (tab === 0 && (!from || !to || selectedEmps.length === 0))
    || (tab === 1 && (!from || !to))
    || (tab === 2 && (!from || !to))
    || (tab === 3 && !from)
    || (tab === 4 && (!from || !to));

  const navDisabled = (tab !== 6 && !region) || loading;
  const exportAllowed = auth.hasPermission(exportPermsForTab());

  // Format helpers used in handleGenerate (copied from your file)
  const formatLocalDate = (date, endOfDay = false) => {
    const d = new Date(date);
    if (endOfDay) d.setHours(23, 59, 59, 999);
    else d.setHours(0, 0, 0, 0);
    const pad = n => n.toString().padStart(2, '0');
    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}` +
           `T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  };

  const toLocalYMD = date => `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`;

  const handleGenerate = async () => {
    const requirePermissionForTab = () => {
      if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
      if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
      if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
      if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
      if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
      if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
      if (tab === 6) return ['gsoc_reports.denver_monthly', 'gsoc_reports'];
      return ['gsoc_reports'];
    };

    if (!auth.hasPermission(requirePermissionForTab())) {
      alert('You do not have permission to generate this report.');
      return;
    }

    // set user-visible generating message (different per tab)
    const messages = {
      0: 'Generating Daily Access report...',
      1: 'Generating Raw report...',
      2: 'Generating Rejection report...',
      3: 'Generating EUROC Admit-Reject report...',
      4: 'Generating Time Duration report...',
      5: 'Opening HeadCount...',
      6: 'Generating Denver Attendance report...'
    };
    setGeneratingMessage(messages[tab] || 'Generating report...');
    setLoading(true);

    try {
      const baseParams = { region, location: location || undefined };

      // ----- 0: Daily Access -----
      if (tab === 0) {
        const fromDateOnly = `${from.getFullYear()}-${pad2(from.getMonth() + 1)}-${pad2(from.getDate())}`;
        const toDateOnly = `${to.getFullYear()}-${pad2(to.getMonth() + 1)}-${pad2(to.getDate())}`;

        const params = {
          ...baseParams,
          from: fromDateOnly,
          to: toDateOnly,
          employees: selectedEmps.join(',')
        };
        const resp = await axios.get('/api/reports/daily-access', { params });
        const rows = (resp.data && resp.data.data) || [];
        await generateDailyAccessExcelFromRows(rows, { from: fromDateOnly, to: toDateOnly, selectedEmps, region });
        return;
      }

      // ----- 1: Raw -----
      if (tab === 1) {
        const startISO = formatLocalDate(from);
        const endISO = formatLocalDate(to, true);
        const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];
        const requests = [];
        const pushReq = (r, locationParam = undefined) => {
          const params = { startDate: startISO, endDate: endISO, admitFilter: rawAdmitFilter };
          if (r) params.region = r;
          if (locationParam) params.location = locationParam;
          requests.push(axios.get('/api/reports/raw', { params }));
        };

        if (region === 'global') {
          if (selectedLocations && selectedLocations.length) {
            const regionMap = {};
            selectedLocations.forEach(loc => {
              const parts = String(loc).split('.');
              const rKey = (parts[0] || '').toString().toLowerCase();
              regionMap[rKey] = regionMap[rKey] || [];
              regionMap[rKey].push(loc);
            });
            Object.entries(regionMap).forEach(([rKey, locs]) => {
              const isKnown = MULTI_REGIONS.includes(rKey);
              if (isKnown) {
                locs.forEach(loc => pushReq(rKey, loc));
              } else {
                locs.forEach(loc => pushReq(undefined, loc));
              }
            });
          } else {
            MULTI_REGIONS.forEach(r => pushReq(r));
          }
        } else {
          if (selectedLocations && selectedLocations.length) {
            selectedLocations.forEach(loc => pushReq(region, loc));
          } else {
            pushReq(region);
          }
        }

        let rowsSrcCombined = [];
        try {
          if (!requests.length) {
            pushReq(region === 'global' ? MULTI_REGIONS[0] : region);
          }
          const responses = await Promise.all(requests);
          rowsSrcCombined = responses.flatMap(r => (r.data && (r.data.data || r.data)) || []);
        } catch (err) {
          console.error('raw fetch error', err);
          throw err;
        }

        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

        const rows = rowsSrcCombined.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          if (!date) return false;
          return (date >= startDate && date <= endDate);
        });

        let filtered = rows;
        if (rawSearch && rawSearch.trim() !== '') {
          const s = rawSearch.trim().toLowerCase();
          filtered = filtered.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            return id.includes(s) || name.includes(s);
          });
        }

        if (selectedRawEmps && selectedRawEmps.length) {
          const setSel = new Set(selectedRawEmps.map(x => String(x).toLowerCase()));
          filtered = filtered.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            return setSel.has(id) || setSel.has(name) || selectedRawEmps.some(sel => id.includes(String(sel).toLowerCase()) || name.includes(String(sel).toLowerCase()));
          });
        }

        const keySet = new Set();
        const deduped = [];
        filtered.forEach(r => {
          const key = `${getServerISO(r)}|${r.EmployeeID}|${r.Door}|${r.CardNumber}`;
          if (!keySet.has(key)) {
            keySet.add(key);
            deduped.push(r);
          }
        });

        await generateRawExcel(deduped, { region, location: selectedLocations && selectedLocations.join(',') || location, rawSearch, from, to, rawAdmitFilter });
        return;
      }

      // ----- 2: Rejection -----
      if (tab === 2) {
        const params = { ...baseParams, startDate: formatLocalDate(from), endDate: formatLocalDate(to, true) };
        const resp = await axios.get('/api/reports/rejection', { params });
        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);
        const rowsSrc = (resp.data && resp.data.data) || [];
        const rows = rowsSrc.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          return date >= startDate && date <= endDate;
        });
        await generateRejectionExcel(rows);
        return;
      }

      // ----- 3: EUROC Admit-Reject (single day) -----
      if (tab === 3) {
        if (region.toLowerCase() !== 'emea') {
          alert('EUROC report is only available for region EMEA. Please select EMEA.');
          return;
        }
        if (!from) {
          alert('Please select a date (From) for EUROC report.');
          return;
        }

        // If user selected specific locations (selectedLocations) then pass them to backend as comma separated
        const dateParam = toLocalYMD(new Date(from));
        const params = { region: 'emea', date: dateParam };
        if (selectedLocations && selectedLocations.length) params.locations = selectedLocations.join(',');
        const resp = await axios.get('/api/reports/euroc-admit-rejection', { params });
        const { data } = resp.data || {};

        // ---------- EUROC Admit-Reject generation (updated formatting) ----------
        {
          const wb = new ExcelJS.Workbook();

          // common constants
          const GRAY_FILL_LOCAL = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };

          // helper: convert 1-index col num to letter
          const colLetterLocal = (c => {
            let n = c, s = '';
            while (n > 0) {
              const m = (n - 1) % 26;
              s = String.fromCharCode(65 + m) + s;
              n = Math.floor((n - 1) / 26);
            }
            return s;
          });

          // --- helper to build a formatted sheet ---
          function createFormattedSheet(sheetName, titleText, headers, rowsData) {
            const ws = wb.addWorksheet(sheetName);
            hideGridLines(ws);

            // Skip first row
            ws.addRow([]);

            // Title (row 2) merged across content columns (content will start at col B)
            const contentCols = headers.length; // number of content columns
            const startCol = 2; // B
            const endCol = startCol + contentCols - 1;
            const startLetter = colLetterLocal(startCol);
            const endLetter = colLetterLocal(endCol);

            // ensure row 2 exists
            ws.addRow([null]);
            ws.mergeCells(`${startLetter}2:${endLetter}2`);
            ws.getCell(`${startLetter}2`).value = titleText;
            ws.getCell(`${startLetter}2`).font = { bold: true, size: 14 };
            ws.getCell(`${startLetter}2`).alignment = { horizontal: 'center', vertical: 'middle' };
            ws.getRow(2).height = 22;

            // style merged title cells (thick border + gray fill)
            for (let c = startCol; c <= endCol; c++) {
              const cell = ws.getCell(2, c);
              cell.fill = GRAY_FILL_LOCAL;
              cell.font = { bold: true, size: 14 };
              cell.alignment = { horizontal: 'center', vertical: 'middle' };
              cell.border = THICK_BORDER;
            }

            // Header row (row 3) - insert with a null at col A so column A remains blank
            const headerRow = ws.addRow([null, ...headers]);
            headerRow.height = 20;
            headerRow.eachCell((cell, colNumber) => {
              if (colNumber >= startCol && colNumber <= endCol) {
                cell.font = { bold: true };
                cell.alignment = { horizontal: 'center', vertical: 'middle' };
                cell.fill = GRAY_FILL_LOCAL;
                cell.border = THICK_BORDER;
              }
            });

            // set columns (include blank A)
            const cols = [{ key: 'blankA', width: 3 }];
            headers.forEach(h => cols.push({ key: h.replace(/\s+/g, '').toLowerCase(), width: 18 }));
            ws.columns = cols;

            // All data columns center aligned (including "Door Name")
            const centerCols = new Set();
            for (let c = startCol; c <= endCol; c++) centerCols.add(c);

            // Data rows start at row 4
            (rowsData || []).forEach((r, idx) => {
              // map row values in same order as headers
              const vals = headers.map(h => {
                // pick common fields or fallback to empty
                const key = h.toString();
                if (/Sr\.?\s*No/i.test(key)) return idx + 1;
                if (/Date/i.test(key)) {
                  // prefer formatted date if available
                  const iso = getServerISO(r);
                  return iso ? formatDateFromServerISO(iso) : (r.DateOnly || '');
                }
                if (/Time/i.test(key)) {
                  const iso = getServerISO(r);
                  return iso ? formatTimeFromServerISO(iso) : (r.Swipe_Time || r.Direction || '');
                }
                if (/Employee Name/i.test(key)) return r.ObjectName1 || r.EmployeeName || '';
                if (/Employee ID/i.test(key)) return r.EmployeeID || '';
                if (/Access Card/i.test(key)) return r.CardNumber || r.Card || r.CardNo || '';
                if (/Rejection Type/i.test(key)) return r.Rejection_Type || r.RejectType || '';
                if (/Personnel Type/i.test(key)) return r.PersonnelType || '';
                if (/Door Name/i.test(key)) return r.Door || r.ObjectName2 || '';
                if (/Location/i.test(key)) return r.location || '';
                if (/Swipe/i.test(key)) return r.Direction || r.Swipe || '';
                return (r[key] !== undefined && r[key] !== null) ? r[key] : '';
              });

              // prepend null for column A
              const row = ws.addRow([null, ...vals]);

              row.eachCell((cell, colNumber) => {
                if (colNumber >= startCol && colNumber <= endCol) {
                  cell.border = THIN_BORDER;
                  cell.alignment = { vertical: 'middle', horizontal: (centerCols.has(colNumber) ? 'center' : 'left') };
                }
              });
            });

            // apply thick outside border around header + data (B..end)
            const headerRowIndex = 3;
            const firstDataRow = headerRowIndex;
            const lastDataRow = ws.lastRow ? ws.lastRow.number : headerRowIndex;
            for (let r = firstDataRow; r <= lastDataRow; r++) {
              for (let c = startCol; c <= endCol; c++) {
                const cell = ws.getCell(r, c);
                if (!cell.border) cell.border = THIN_BORDER;
                const border = {
                  top: (r === firstDataRow) ? { style: 'thick' } : (cell.border.top || { style: 'thin' }),
                  bottom: (r === lastDataRow) ? { style: 'thick' } : (cell.border.bottom || { style: 'thin' }),
                  left: (c === startCol) ? { style: 'thick' } : (cell.border.left || { style: 'thin' }),
                  right: (c === endCol) ? { style: 'thick' } : (cell.border.right || { style: 'thin' })
                };
                cell.border = border;
              }
            }

            // return metadata so caller can add a summary block to the right
            return { ws, startCol, endCol, headerRowIndex, lastDataRow };
          }

          // Build admit sheet
          const admitHeaders = [
            'Sr. No.', 'Date', 'Time', 'Employee Name',
            'Access Card No.', 'Personnel Type', 'Door Name', 'Location', 'Swipe'
          ];
          const admitRows = (data && data.admit) ? (data.admit.map(r => r)) : [];
          const admitMeta = createFormattedSheet('EUROC Admit', `EUROC Admit Report - ${formatDisplayDate(from)}`, admitHeaders, admitRows);

          // Build rejection sheet
          const rejHeaders = [
            'Sr. No.', 'Date', 'Time', 'Employee Name', 'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
          ];
          const rejRows = (data && data.rejection) ? (data.rejection.map(r => r)) : [];
          const rejMeta = createFormattedSheet('EUROC Rejection', `EUROC Rejection Report - ${formatDisplayDate(from)}`, rejHeaders, rejRows);

          // ---------- Summary placement & formatting (same style as Rejection) ----------
          // We'll add a summary block on the REJECTION sheet (rejMeta) to the right of the table
          (function addSummaryToRejectionSheet() {
            const ws2 = rejMeta.ws;
            const lastCol = rejMeta.endCol;
            const summaryStartCol = lastCol + 2; // skip one blank column after Swipe
            const summaryTitleRow = rejMeta.headerRowIndex + 1; // one row below header (row 4)
            const summaryHdrRow = summaryTitleRow + 1;

            // Build counts map
            const countsMap = {};
            if (data && Array.isArray(data.summary) && data.summary.length) {
              (data.summary || []).forEach(c => {
                const key = c.Rejection_Type || c.rejectionType || 'Unknown';
                const cnt = (typeof c.Count === 'number') ? c.Count : c.count || 0;
                countsMap[key] = (countsMap[key] || 0) + cnt;
              });
            }
            // fallback: if summary empty, compute from rejection rows
            if (Object.keys(countsMap).length === 0) {
              (rejRows || []).forEach(r => {
                const k = (r.Rejection_Type || 'Unknown').toString();
                countsMap[k] = (countsMap[k] || 0) + 1;
              });
            }
            const entries = Object.entries(countsMap);

            const sA = colLetterLocal(summaryStartCol);
            const sB = colLetterLocal(summaryStartCol + 1);
            ws2.mergeCells(`${sA}${summaryTitleRow}:${sB}${summaryTitleRow}`);
            ws2.getCell(`${sA}${summaryTitleRow}`).value = 'Summary';
            ws2.getCell(`${sA}${summaryTitleRow}`).font = { bold: true };
            ws2.getCell(`${sA}${summaryTitleRow}`).alignment = { horizontal: 'center', vertical: 'middle' };
            ws2.getCell(`${sA}${summaryTitleRow}`).fill = GRAY_FILL_LOCAL;
            ws2.getCell(`${sA}${summaryTitleRow}`).border = THICK_BORDER;
            ws2.getCell(`${sB}${summaryTitleRow}`).fill = GRAY_FILL_LOCAL;
            ws2.getCell(`${sB}${summaryTitleRow}`).border = THICK_BORDER;

            // header row for summary (use THICK_BORDER on header cells)
            ws2.getCell(summaryHdrRow, summaryStartCol).value = 'Rejection';
            ws2.getCell(summaryHdrRow, summaryStartCol + 1).value = 'Count';
            [summaryStartCol, summaryStartCol + 1].forEach(c => {
              const cell = ws2.getCell(summaryHdrRow, c);
              cell.font = { bold: true };
              cell.alignment = { horizontal: 'center', vertical: 'middle' };
              cell.fill = GRAY_FILL_LOCAL;
              cell.border = THICK_BORDER;
            });

            // detail rows
            let cur = summaryHdrRow + 1;
            entries.forEach(([type, cnt]) => {
              ws2.getCell(cur, summaryStartCol).value = type;
              ws2.getCell(cur, summaryStartCol + 1).value = cnt;
              ws2.getCell(cur, summaryStartCol).alignment = { horizontal: 'left', vertical: 'middle' };
              ws2.getCell(cur, summaryStartCol + 1).alignment = { horizontal: 'center', vertical: 'middle' };
              ws2.getCell(cur, summaryStartCol).border = THIN_BORDER;
              ws2.getCell(cur, summaryStartCol + 1).border = THIN_BORDER;
              cur++;
            });

            // grand total (make thick border & gray fill)
            const total = (rejRows || []).length;
            ws2.getCell(cur, summaryStartCol).value = 'Grand Total';
            ws2.getCell(cur, summaryStartCol + 1).value = total;
            [summaryStartCol, summaryStartCol + 1].forEach(c => {
              const cell = ws2.getCell(cur, c);
              cell.font = { bold: true };
              cell.alignment = { horizontal: 'center', vertical: 'middle' };
              cell.fill = GRAY_FILL_LOCAL;
              cell.border = THICK_BORDER;
            });

            // enforce thick outside border for the entire summary block
            for (let r = summaryTitleRow; r <= cur; r++) {
              for (let c = summaryStartCol; c <= summaryStartCol + 1; c++) {
                const cell = ws2.getCell(r, c);
                if (!cell.border) cell.border = THIN_BORDER;
                const border = {
                  top: (r === summaryTitleRow) ? { style: 'thick' } : (cell.border.top || { style: 'thin' }),
                  bottom: (r === cur) ? { style: 'thick' } : (cell.border.bottom || { style: 'thin' }),
                  left: (c === summaryStartCol) ? { style: 'thick' } : (cell.border.left || { style: 'thin' }),
                  right: (c === (summaryStartCol + 1)) ? { style: 'thick' } : (cell.border.right || { style: 'thin' })
                };
                cell.border = border;
              }
            }
          })();

          // write file
          const buf = await wb.xlsx.writeBuffer();
          const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
          const filename = `EUROC_Admit_Rejection_${dateParam}.xlsx`;
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = filename;
          link.click();
        }

        return;
      }

      // ----- 4: Time Duration -----
      if (tab === 4) {
        if (!from || !to) {
          alert('Please select both Start Date and End Date for Time Duration report.');
          return;
        }
        const startParam = toLocalYMD(new Date(from));
        const endParam = toLocalYMD(new Date(to));
        const params = {
          region,
          startDate: startParam,
          endDate: endParam,
          partition: location ? location.split('.').pop() : 'Default'
        };
        const resp = await axios.get('/api/reports/time-duration', { params });
        await generateTimeDurationExcel(resp.data.data || []);
        return;
      }

     //       // ----- 5: HeadCount / External navigation -----
      if (tab === 5) {
        // final permission check (region specific)
        const permCandidates = [`headcount.${region}`, 'headcount', 'global_access'];
        if (!auth.hasPermission(permCandidates)) {
          alert(`You do not have permission to view HeadCount for ${region.toUpperCase()}.`);
          setLoading(false);
          return;
        }

        let url = '';

        if (region === 'laca') {
          if (!location) url = 'http://10.199.22.57:3003/history';
          else {
            const LACA_URLS = {
              'CR.Costa Rica Partition': 'http://10.199.22.57:3003/partition/CR.Costa%20Rica%20Partition/history',
              'MX.Mexico City': 'http://10.199.22.57:3003/partition/MX.Mexico%20City/history',
              'AR.Cordoba': 'http://10.199.22.57:3003/partition/AR.Cordoba/history',
              'PA.Panama City': 'http://10.199.22.57:3003/partition/PA.Panama%20City/history',
              'PE.Lima': 'http://10.199.22.57:3003/partition/PE.Lima/history',
              'BR.Sao Paulo': 'http://10.199.22.57:3003/partition/BR.Sao%20Paulo/history'
            };
            url = LACA_URLS[location] || 'http://10.199.22.57:3003/history';
          }
        } else if (region === 'namer') {
          if (!location) url = 'http://10.199.22.57:3002/history';
          else {
            const NAMER_URLS = {
              'US.Denver': 'http://10.199.22.57:3002/partition/US.CO.OBS/history',
              'US.Miami': 'http://10.199.22.57:3002/partition/US.FL.Miami/history',
              'US.NYC': 'http://10.199.22.57:3002/partition/US.NYC/history',
              'US.Austin': 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default/history'
            };
            url = NAMER_URLS[location] || 'http://10.199.22.57:3002/history';
          }
        } else if (region === 'apac') {
          if (!location) url = 'http://10.199.22.57:3000/history';
          else {
            const APAC_URLS = {
              'APAC.Default': 'http://10.199.22.57:3000/partition/Pune/history',
              'IN.HYD':'http://10.199.22.57:3000/partition/IN.HYD/history',
              'MY.Kuala Lumpur': 'http://10.199.22.57:3000/partition/MY.Kuala Lumpur/history',
              'PH.Manila': 'http://10.199.22.57:3000/partition/PH.Manila/history',
              'JP.Tokyo': 'http://10.199.22.57:3000/history',
              'CN.Beijing': 'http://10.199.22.57:3000/history'
            };
            url = APAC_URLS[location] || 'http://10.199.22.57:3000/history';
          }
        } else if (region === 'emea') {
          if (!location) url = 'http://10.199.22.57:3001/history';
          else {
            const EMEA_URLS = {
              'AUT.Vienna': 'http://10.199.22.57:3001/history',
              'DU.Abu Dhabi': 'http://10.199.22.57:3001/history',
              'IE.Dublin': 'http://10.199.22.57:3001/history',
              'IT.Rome': 'http://10.199.22.57:3001/history',
              'LT.Vilnius': 'http://10.199.22.57:3001/history',
              'MA.Casablanca': 'http://10.199.22.57:3001/history',
              'RU.Moscow': 'http://10.199.22.57:3001/history',
              'UK.London': 'http://10.199.22.57:3001/history',
              'ES.Madrid': 'http://10.199.22.57:3001/history'
            };
            url = EMEA_URLS[location] || 'http://10.199.22.57:3001/history';
          }
        }

        if (url) window.location.href = url;
        else alert('Invalid region or location selected.');
        return;
      }


      // ----- Denver Monthly (tab 6) -----
      if (tab === 6) {
        let useYear = null;
        let useMonth = null;
        if (from) {
          const d = new Date(from);
          useYear = d.getFullYear();
          useMonth = d.getMonth() + 1;
        } else {
          const dt = new Date();
          dt.setDate(1); dt.setHours(0,0,0,0);
          dt.setMonth(dt.getMonth() - 1);
          useYear = dt.getFullYear();
          useMonth = dt.getMonth() + 1;
        }

        try {
          const resp = await axios.get('/api/reports/denver-attendance', {
            params: { year: useYear, month: useMonth },
            responseType: 'blob'
          });

          let filename = `denver_attendance_${useYear}${String(useMonth).padStart(2,'0')}.xlsx`;
          const cd = resp.headers['content-disposition'];
          if (cd) {
            const m = cd.match(/filename\*?=(?:UTF-8'')?["']?([^;"']+)/);
            if (m && m[1]) filename = decodeURIComponent(m[1]);
          }

          const blob = new Blob([resp.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
          const link = document.createElement('a');
          link.href = window.URL.createObjectURL(blob);
          link.download = filename;
          link.click();
        } catch (err) {
          console.error('Denver attendance download error', err);
          let msg = 'Failed to download Denver attendance report';
          if (err?.response?.data) {
            msg += `: ${err.response?.data?.detail || err.message || JSON.stringify(err.response.data)}`;
          } else if (err?.message) {
            msg += `: ${err.message}`;
          }
          alert(msg);
        }
        return;
      }

    } catch (err) {
      console.error('handleGenerate error:', err);
      let msg = 'Failed to generate report';
      if (err?.response?.data) {
        const d = err.response.data;
        const serverMsg = (typeof d === 'string') ? d
                          : (d.error || d.message || JSON.stringify(d));
        msg += `: ${serverMsg}`;
      } else if (err?.message) {
        msg += `: ${err.message}`;
      }
      alert(msg);
    } finally {
      setLoading(false);
      setGeneratingMessage('');
    }
  };

  // --- UI render ---
  const regionOptions = regionOptionsForTab();
  const locationOptions = locationOptionsForTab();

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
        {/* Topbar / Header */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            px: 3,
            py: 2,
            borderBottom: '1px solid rgba(255,204,0,0.08)',
            background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
          }}
        >
          <Avatar sx={{ bgcolor: '#000', border: '3px solid #FFCC00', width: 56, height: 56 }}>
            <Typography sx={{ color: '#FFCC00', fontWeight: 900 }}>WU</Typography>
          </Avatar>

          <Box sx={{ flex: 1 }}>
            <Typography variant="h5" sx={{ fontWeight: 900, letterSpacing: 0.6 }}>
              Global Security Operation Center
            </Typography>
            <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
              Reports & Exports  Secure access, fast insights
            </Typography>
          </Box>

          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
            <Button
              startIcon={<DownloadIcon />}
              onClick={handleGenerate}
              disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
              sx={{
                bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                color: '#000',
                fontWeight: 800,
                px: 3,
                py: 1,
                borderRadius: 3,
                boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
                transformOrigin: 'center',
                '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-2px)' : 'none' }
              }}
            >
              {loading ? 'Loading' : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
            </Button>
          </Box>
        </Box>

        {/* Generating banner */}
        {generatingMessage && (
          <Box sx={{ px: 3, py: 1, bgcolor: 'rgba(255,255,255,0.02)', borderBottom: '1px solid rgba(255,204,0,0.04)', display: 'flex', alignItems: 'center', gap: 2 }}>
            <CircularProgress size={20} />
            <Typography variant="body2" sx={{ color: '#FFCC00', fontWeight: 700 }}>{generatingMessage}</Typography>
          </Box>
        )}

        {/* Main content */}
        <Grid container sx={{ px: 3, py: 4 }} spacing={3}>
          <Grid item xs={12} md={3}>
            <Paper elevation={8} sx={{ p: 2.5, borderRadius: 3, height: { xs: 'auto', md: 'calc(100vh - 150px)' }, overflow: 'auto', background: 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015))', border: '1px solid rgba(255,204,0,0.06)' }}>
              <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
                <Box>
                  <Typography variant="subtitle1" sx={{ fontWeight: 800, color: '#FFCC00' }}>Filters</Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Narrow down by region, date and employees
                  </Typography>
                </Box>
                <IconButton size="small" sx={{ color: '#FFCC00' }}>
                  <FilterListIcon />
                </IconButton>
              </Box>

              <Divider sx={{ my: 1, borderColor: 'rgba(255,204,0,0.06)' }} />

              {/* Region - show per-tab region options */}
              {regionOptions.length > 0 && (
                <Box sx={{ mt: 1 }}>
                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Region</InputLabel>
                    <Select
                      value={region}
                      onChange={e => { setRegion(e.target.value); setLocation(''); }}
                      input={<OutlinedInput label="Region" />}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.24)' }
                      }}
                    >
                      {regionOptions.map(r => <MenuItem key={r} value={r}>{r.toUpperCase()}</MenuItem>)}
                    </Select>
                  </FormControl>
                </Box>
              )}

              {/* Location */}
              <Box sx={{ mt: 2 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Location</InputLabel>

                  {/* RAW (tab 1) keeps multi Autocomplete */}
                  {tab === 1 ? (
                    <Autocomplete
                      multiple
                      freeSolo={false}
                      options={availableLocations}
                      value={selectedLocations}
                      onChange={(e, v) => setSelectedLocations(v)}
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          placeholder="Choose 0..n locations (leave empty = all)"
                          InputLabelProps={{ style: { color: '#FFCC00' } }}
                          sx={{
                            '& .MuiInputBase-input': { color: '#fff' },
                            '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                          }}
                        />
                      )}
                      getOptionLabel={(opt) => String(opt)}
                      isOptionEqualToValue={(opt, val) => opt === val}
                      disabled={!region}
                    />
                  ) : null}

                  {/* EUROC (tab 3) -> multi-select Autocomplete of EMEA locations */}
                  {tab === 3 ? (
                    <Autocomplete
                      multiple
                      freeSolo={false}
                      options={availableLocations.length ? availableLocations : (LOCATION_MAP['emea'] || [])}
                      value={selectedLocations}
                      onChange={(e, v) => setSelectedLocations(v)}
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          placeholder="Select 0..n locations (leave empty = all EMEA)"
                          InputLabelProps={{ style: { color: '#FFCC00' } }}
                          sx={{
                            '& .MuiInputBase-input': { color: '#fff' },
                            '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                          }}
                        />
                      )}
                      getOptionLabel={(opt) => String(opt)}
                      isOptionEqualToValue={(opt, val) => opt === val}
                      disabled={!region}
                    />
                  ) : null}

                  {/* For Time Duration (tab 4) and others (including Denver tab 6), single-select */}
                  {tab !== 1 && tab !== 3 && tab !== 6 && (
                    <Select
                      value={location}
                      onChange={e => setLocation(e.target.value)}
                      input={<OutlinedInput label="Location" />}
                      disabled={(regionOptions.length === 0)}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                      }}
                    >
                      { (locationOptions && locationOptions.length) ? locationOptions.map(loc => (
                          <MenuItem key={loc} value={loc}>
                            {String(loc).split('.').pop()}
                          </MenuItem>
                        ))
                        : ((LOCATION_MAP[region] || []).map(loc => (
                          <MenuItem key={loc} value={loc}>{String(loc).split('.').pop()}</MenuItem>
                        )))
                      }
                    </Select>
                  )}

                  {/* Denver (tab 6) - single select but only Denver */}
                  {tab === 6 && (
                    <Select
                      value={location}
                      onChange={e => setLocation(e.target.value)}
                      input={<OutlinedInput label="Location" />}
                      disabled={false}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                      }}
                    >
                      <MenuItem value="US.Denver">Denver</MenuItem>
                    </Select>
                  )}
                </FormControl>
              </Box>

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />

              {/* Employee input area (Daily and Raw) */}
              {tab === 1 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employee (name or ID)  multiple
                  </Typography>

                  <Autocomplete
                    multiple
                    freeSolo
                    filterSelectedOptions
                    options={rawEmpOptions}
                    value={selectedRawEmps}
                    onChange={(e, v) => setSelectedRawEmps(v)}
                    onInputChange={async (e, value, reason) => {
                      if (empQueryRef.current) clearTimeout(empQueryRef.current);
                      if (!value || value.length < 2) {
                        empQueryRef.current = setTimeout(() => setRawEmpOptions([]), 150);
                        return;
                      }
                      empQueryRef.current = setTimeout(async () => {
                        try {
                          const params = { q: value };
                          if (region && region !== 'global') params.region = region;
                          const resp = await axios.get('/api/employees', { params });
                          const raw = (resp.data && (resp.data.data || resp.data)) || [];
                          const normalized = Array.isArray(raw) ? raw.map(item => {
                            if (typeof item === 'string') return item;
                            const id = item.EmployeeID || item.id || item.NumericEmployeeID || item.Employee || '';
                            const name = item.Name || item.name || item.ObjectName1 || '';
                            if (name && id) return `${name} (${id})`;
                            if (id) return String(id);
                            if (name) return String(name);
                            return JSON.stringify(item);
                          }) : [];
                          setRawEmpOptions(Array.from(new Set(normalized)));
                        } catch (err) {
                          console.warn('employee suggestions error', err);
                          setRawEmpOptions([]);
                        }
                      }, 300);
                    }}
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        placeholder="Type name or ID (2+ chars)  select multiple"
                        InputLabelProps={{ style: { color: '#FFCC00' } }}
                        sx={{
                          '& .MuiInputBase-input': { color: '#fff' },
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                        }}
                      />
                    )}
                    getOptionLabel={(opt) => (typeof opt === 'string' ? opt : (opt.label || opt.name || String(opt)))}
                    renderOption={(props, option) => <li {...props}>{typeof option === 'string' ? option : (option.label || option.name || String(option))}</li>}
                    ListboxProps={{ style: { maxHeight: 240 } }}
                  />

                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                    Leave empty to export all raw rows for the date range. Type 2+ chars to get suggestions for employee names or IDs.
                  </Typography>

                  <Box sx={{ mt: 2 }}>
                    <FormControl fullWidth>
                      <InputLabel sx={{ color: '#FFCC00' }}>Admit / Reject</InputLabel>
                      <Select
                        value={rawAdmitFilter}
                        onChange={(e) => setRawAdmitFilter(e.target.value)}
                        input={<OutlinedInput label="Admit / Reject" />}
                        sx={{
                          color: '#fff',
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                        }}
                      >
                        <MenuItem value="all">All (Admitted + Rejected)</MenuItem>
                        <MenuItem value="admit">Admitted only</MenuItem>
                        <MenuItem value="reject">Rejected only</MenuItem>
                      </Select>
                    </FormControl>
                    <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                      Default = All.
                    </Typography>
                  </Box>
                </Box>
              )}

              {/* Dates (shown for all tabs except external navigation tab 5) */}
              {tab !== 5 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Date Range
                  </Typography>
                  <Box sx={{ display: 'grid', gap: 1.25 }}>
                    <TextField
                      label={tab === 0 ? 'From Date' : 'Start Date'}
                      value={from ? from.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowFromCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                    <TextField
                      label={tab === 0 ? 'To Date' : 'End Date'}
                      value={to ? to.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowToCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                  </Box>

                  {showFromCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={from}
                        onChange={(newValue) => setFrom(newValue)}
                        onAccept={() => setShowFromCal(false)}
                        onClose={() => setShowFromCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                  {showToCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={to}
                        onChange={(newValue) => setTo(newValue)}
                        onAccept={() => setShowToCal(false)}
                        onClose={() => setShowToCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                </Box>
              )}

              {/* Daily employees block */}
              {tab === 0 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employees
                  </Typography>

                  <Box sx={{ display: 'flex', gap: 1, mb: 1 }}>
                    <TextField
                      fullWidth
                      placeholder="Add name or ID (e.g. 'Vainilaitis, Valdas' or '323471')"
                      value={newEmployee}
                      onChange={(e) => setNewEmployee(e.target.value)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                      InputLabelProps={{ style: { color: '#FFCC00' } }}
                    />
                    <Button
                      variant="contained"
                      onClick={() => {
                        const v = (newEmployee || '').toString().trim();
                        if (!v) return;
                        if (!selectedEmps.includes(v)) {
                          setSelectedEmps(prev => [...prev, v]);
                        }
                        setNewEmployee('');
                      }}
                      sx={{
                        bgcolor: '#FFCC00',
                        color: '#000',
                        fontWeight: 800,
                        px: 2,
                        '&:hover': { bgcolor: '#ffd84d' }
                      }}
                    >
                      Add
                    </Button>
                  </Box>

                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Employees</InputLabel>

                    <Select
                      multiple
                      value={selectedEmps}
                      onChange={e => setSelectedEmps(e.target.value)}
                      input={<OutlinedInput label="Employees" />}
                      renderValue={vals => vals.join(', ')}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                      }}
                    >
                      {[
                        ...EMPLOYEE_OPTIONS,
                        ...selectedEmps.filter(s => !EMPLOYEE_OPTIONS.includes(s))
                      ].map(n => (
                        <MenuItem key={n} value={n}>
                          <Checkbox checked={selectedEmps.includes(n)} />
                          <ListItemText primary={n} />
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              )}

              <Box sx={{ mt: 3, p: 2, borderRadius: 2, background: 'rgba(255,255,255,0.02)' }}>
                <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                  Tip: For daily exports pick employees & a single day range. For Time Duration choose the required partition via Location.
                </Typography>
              </Box>
            </Paper>
          </Grid>

          {/* Main panel */}
          <Grid item xs={12} md={9}>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              <Paper elevation={3} sx={{ px: 2, py: 1, borderRadius: 2, display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 2, border: '1px solid rgba(255,204,0,0.04)' }}>
                <Tabs value={tab} onChange={handleTabChange} sx={{ '& .MuiTab-root': { textTransform: 'none', minWidth: 120, fontWeight: 700, color: 'rgba(255,255,255,0.8)' }, '& .Mui-selected': { color: '#FFCC00' } }}>
                  <Tab icon={<CalendarTodayIcon />} label="Daily Access" />
                  <Tab icon={<PeopleIcon />} label="Raw" />
                  <Tab icon={<PlaceIcon />} label="Rejection" />
                  <Tab icon={<PeopleIcon />} label="EUROC Admit-Reject" />
                  <Tab icon={<CalendarTodayIcon />} label="Time Duration" />
                  <Tab icon={<PeopleIcon />} label="HeadCount" />
                  <Tab icon={<PeopleIcon />} label="Denver Monthly" />
                </Tabs>

                <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                  <Button variant="text" startIcon={<FilterListIcon />} sx={{ color: 'rgba(255,255,255,0.65)', textTransform: 'none' }} onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}>
                    Reset View
                  </Button>
                </Box>
              </Paper>

              <Paper elevation={6} sx={{ p: 3, borderRadius: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 2 }}>
                <Box>
                  <Typography variant="h6" sx={{ fontWeight: 900 }}>Export Center</Typography>
                  <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                    Selected Region: <strong style={{ color: '#FFCC00' }}>{region ? region.toUpperCase() : ''}</strong> {location ? ` ${location.split('.').pop() === 'Denver' ? 'Denver' : location.split('.').pop()}` : ''}
                  </Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Choose tab, select filters and export reports in Excel.
                  </Typography>
                </Box>

                <Box>
                  <Button
                    startIcon={loading ? <CircularProgress size={20} /> : <DownloadIcon />}
                    disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
                    onClick={handleGenerate}
                    sx={{
                      bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                      color: '#000',
                      fontWeight: 900,
                      px: 4,
                      py: 1,
                      borderRadius: 3,
                      boxShadow: '0 8px 30px rgba(255,204,0,0.22)',
                      '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-3px)' : 'none' }
                    }}
                  >
                    {loading
                      ? 'Loading'
                      : (tab === 5
                          ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`)
                          : 'Export to Excel')}
                  </Button>
                </Box>
              </Paper>
            </Box>
          </Grid>
        </Grid>
      </Box>
    </LocalizationProvider>
  );
}




