//C:\Users\W0024618\Desktop\global-page\frontend\src\pages\DailyAccessReport.jsx

import ExcelJS from 'exceljs';

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');

function _extractServerDateTimeParts(iso) {
  if (!iso) return null;
  const s = String(iso);
  let datePart = '', timePart = '';
  if (s.includes('T')) {
    [datePart, timePart] = s.split('T');
  } else if (s.includes(' ')) {
    [datePart, timePart] = s.split(' ');
  } else {
    return null;
  }
  datePart = datePart.slice(0, 10);
  timePart = (timePart || '').replace(/Z|[+-]\d{2}:\d{2}$/, '').replace(/\.\d+$/, '');
  const dParts = datePart.split('-').map(p => parseInt(p, 10));
  const tParts = timePart.split(':').map(p => parseInt(p || '0', 10));
  return {
    year: dParts[0] || 0,
    month: dParts[1] || 0,
    day: dParts[2] || 0,
    hour: tParts[0] || 0,
    minute: tParts[1] || 0,
    second: tParts[2] || 0
  };
}

function formatDateFromServerISO_forDaily(iso) {
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const mon = MONTH_ABBR[(p.month - 1) || 0];
  return `${pad2(p.day)}-${mon}-${String(p.year).slice(-2)}`;
}

function formatTimeFromServerISO_forDaily(iso) {
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const hh = p.hour;
  const mm = p.minute || 0;
  const ss = p.second || 0;
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1;
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
}

// Helper used to produce the server "ISO-like" string if row only has DateOnly+Swipe_Time.
// This mirrors your existing buildISOFromDateOnlyAndSwipe behavior but returns an ISO-like string
function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10);
  if (!swipeIso) {
    return `${datePart}T00:00:00.000`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000`;
  }
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000`;
}

/**
 * Generate Daily Access Excel using server-provided literal wall-clock strings.
 * rows: array of objects from backend
 * opts: { from, to, selectedEmps, region }
 */
export async function generateDailyAccessExcelFromRows(rows = [], opts = {}) {
  const { from, to, selectedEmps = [], region = 'emea' } = opts;
  const wb = new ExcelJS.Workbook();

  // group rows by ObjectName1 (employee)
  for (const emp of selectedEmps) {
    const ws = wb.addWorksheet(emp.substring(0, 31));
    const headers = ['Date', 'Time', 'Name', 'Contractor ID', 'Card No', 'Door Name', 'Message Type', 'Partition', 'Swipe'];
    ws.addRow(headers);
    const hdr = ws.getRow(1);
    hdr.font = { bold: true };
    hdr.alignment = { vertical: 'middle', horizontal: 'center' };
    hdr.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'date', width: 12 },
      { key: 'time', width: 12 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'card', width: 15 },
      { key: 'door', width: 40 },
      { key: 'msg', width: 20 },
      { key: 'part', width: 15 },
      { key: 'swipe', width: 10 }
    ];

    const rowsForEmp = rows.filter(r => r.ObjectName1 === emp);
    if (!rowsForEmp.length) {
      ws.mergeCells('A2:I2');
      ws.getCell('A2').value = 'There is no swipe records found in Ccure';
      ws.getCell('A2').alignment = { horizontal: 'center' };
    } else {
      rowsForEmp.forEach(r => {
        // prefer server-provided formatted string field `LocaleMessageTime`
        // if backend returns DateOnly+Swipe_Time, build a pseudo-ISO from them
        let isoText = '';
        if (r.LocaleMessageTime) {
          isoText = r.LocaleMessageTime; // should be "YYYY-MM-DD HH:MM:SS.mmm" (string)
        } else if (r.LocaleMessageTimeStr) {
          isoText = r.LocaleMessageTimeStr;
        } else if (r.DateOnly) {
          isoText = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
        }

        // Use the simple formatter that interprets the string as literal wall-clock parts
        const dateStr = isoText ? formatDateFromServerISO_forDaily(isoText) : '';
        const timeStr = isoText ? formatTimeFromServerISO_forDaily(isoText) : '';

        // Normalize message type text: e.g. "CardAdmitted" -> "Card Admitted"
        const rawMsg = (r.AdmitCode || r.Messagetype || '').toString();
        const msgFormatted = rawMsg ? rawMsg.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/\s+/g, ' ').trim() : '';

        const row = ws.addRow([
          dateStr,
          timeStr,
          r.ObjectName1 || '',
          r.EmployeeID || '',
          r.CardNumber || '',
          r.Door || r.ObjectName2 || '',
          msgFormatted,
          r.location || '',
          r.Swipe || r.Direction || ''
        ]);

        row.getCell(1).alignment = { horizontal: 'left' };
        row.getCell(2).alignment = { horizontal: 'left' };
        row.eachCell(c => {
          c.border = {
            top: { style: 'thin' }, left: { style: 'thin' },
            bottom: { style: 'thin' }, right: { style: 'thin' }
          };
          c.alignment = { vertical: 'middle', horizontal: 'left' };
        });
      });
    }

    ws.autoFilter = 'A1:I1';
  }

  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const filename = `Daily Access Report(${from ? from : ''} to ${to ? to : ''}).xlsx`;
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
}

export default {
  generateDailyAccessExcelFromRows
};





