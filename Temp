check Below file 


                if row:
                    try:
                        out["ObjectID"] = row[0] if len(row) > 0 else None
                        out["GUID"] = row[1] if len(row) > 1 else None
                        out["Name"] = row[2] if len(row) > 2 else None

                        # try a few column positions/names for email; map to consistent keys
                        email_val = None
                        # row[3] used before — keep it if present
                        if len(row) > 3:
                            email_val = row[3]
                        # if email is still falsy try alternative columns if present (some DBs have different columns)
                        if not email_val and len(row) > 4:
                            email_val = row[4]  # maybe EMail or WorkEmail in some schemas

                        # normalise empty -> None
                        if email_val is None or (isinstance(email_val, str) and email_val.strip() == ""):
                            email_val = None

                        # set multiple aliases so callers can find an email under various names
                        out["EmailAddress"] = email_val or None
                        out["EmployeeEmail"] = email_val or None
                        out["Email"] = email_val or None
                        out["WorkEmail"] = email_val or None

                        # ManagerEmail if available
                        out["ManagerEmail"] = row[4] if len(row) > 4 else None

                        logging.info(
                            "get_personnel_info: found ObjectID=%s Email=%s for candidate=%s",
                            out.get("ObjectID"),
                            out.get("Email"),
                            candidate_identifier,
                        )
                    except Exception:
                        logging.exception("get_personnel_info: failed parsing DB row")

    finally:


here we got indentaion error fix this error and share me fully updateed file so i can easily swapm each other

# backend/employeeimage.py


from __future__ import annotations
import logging
import os
import base64
from pathlib import Path
from typing import Optional, Dict, Any

# optional imports (handled gracefully)
try:
    import pyodbc
except Exception:
    pyodbc = None

# optional region configuration (if available)
try:
    from duration_report import REGION_CONFIG
except Exception:
    REGION_CONFIG = {}

ODBC_DRIVER = os.getenv("ODBC_DRIVER", "ODBC Driver 17 for SQL Server")
DEFAULT_OUTDIR = Path(__file__).resolve().parent / "outputs"
DEFAULT_OUTDIR.mkdir(parents=True, exist_ok=True)

# uuid-like regex (optional)
try:
    import re

    _uuid_like_re = re.compile(
        r'^[0-9A-Fa-f]{8}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{12}$'
    )
except Exception:
    _uuid_like_re = None


def _looks_like_guid(s: object) -> bool:
    try:
        if s is None:
            return False
        st = str(s).strip()
        if not st:
            return False
        if _uuid_like_re:
            if _uuid_like_re.match(st):
                return True
        # support legacy prefixes used in some pipelines
        lower = st.lower()
        if lower.startswith("emp:") or lower.startswith("uid:") or lower.startswith("name:"):
            return True
        return False
    except Exception:
        return False


def _strip_person_uid_prefix(token: object) -> Optional[str]:
    if token is None:
        return None
    try:
        s = str(token).strip()
        if not s:
            return None
        if ":" in s:
            prefix, rest = s.split(":", 1)
            if prefix.lower() in ("emp", "uid", "name"):
                rest = rest.strip()
                if rest:
                    return rest
        return s
    except Exception:
        return None


# ACVSCore connection backoff state (module-level)
_acvscore_backoff = {"ts": None, "failed": False}
_ACVSCORE_BACKOFF_SECONDS = 20


def _get_acvscore_conn(timeout: int = 5):
    """
    Try to connect to ACVSCore using REGION_CONFIG. Returns pyodbc.Connection or None.
    Respects a short backoff to avoid repeated noisy attempts.
    """
    try:
        import time
        now = time.time()
        last = _acvscore_backoff.get("ts")
        if last and _acvscore_backoff.get("failed") and (now - last) < _ACVSCORE_BACKOFF_SECONDS:
            logging.debug("ACVSCore backoff active.")
            return None
    except Exception:
        # if something goes wrong in time/backoff handling, continue attempting connection
        pass

    if pyodbc is None:
        logging.debug("pyodbc not installed - ACVSCore lookup unavailable.")
        return None

    tried = []
    for rkey, rc in (REGION_CONFIG or {}).items():
        server = rc.get("server")
        user = rc.get("user")
        pwd = rc.get("password")
        if not server:
            continue

        # 1) SQL auth (if credentials present)
        if user and pwd:
            tried.append(f"{rkey}@{server}(sql)")
            conn_str = (
                f"DRIVER={{{ODBC_DRIVER}}};"
                f"SERVER={server};DATABASE=ACVSCore;UID={user};PWD={pwd};"
                "TrustServerCertificate=Yes;"
            )
            try:
                conn = pyodbc.connect(conn_str, autocommit=True, timeout=timeout)
                logging.info("Connected to ACVSCore on %s using SQL auth (region %s).", server, rkey)
                _acvscore_backoff["failed"] = False
                _acvscore_backoff["ts"] = None
                return conn
            except Exception:
                logging.debug("SQL auth to %s failed", server)

        # 2) Trusted connection fallback
        tried.append(f"{rkey}@{server}(trusted)")
        conn_str_trusted = (
            f"DRIVER={{{ODBC_DRIVER}}};"
            f"SERVER={server};DATABASE=ACVSCore;Trusted_Connection=yes;"
            "TrustServerCertificate=Yes;"
        )
        try:
            conn = pyodbc.connect(conn_str_trusted, autocommit=True, timeout=timeout)
            logging.info("Connected to ACVSCore on %s using trusted connection (region %s).", server, rkey)
            _acvscore_backoff["failed"] = False
            _acvscore_backoff["ts"] = None
            return conn
        except Exception:
            logging.debug("Trusted connection to %s failed", server)
            continue

    # mark failure & set backoff timestamp
    try:
        import time
        _acvscore_backoff["ts"] = time.time()
        _acvscore_backoff["failed"] = True
    except Exception:
        pass

    logging.error("Failed ACVSCore connection attempts: %s", tried)
    return None


def get_personnel_info(candidate_identifier: object) -> Dict[str, Any]:
    """
    Lookup personnel in ACVSCore.Access.Personnel. Returns dict or {} on failure/unavailable.
    Keys commonly returned: ObjectID, GUID, Name, EmailAddress, EmployeeEmail, ManagerEmail
    """
    out: Dict[str, Any] = {}
    if candidate_identifier is None:
        return out

    conn = _get_acvscore_conn()
    if conn is None:
        logging.debug("get_personnel_info: ACVSCore unavailable.")
        return out

    cur = None
    try:
        cur = conn.cursor()
        sql = """
            SELECT TOP 1 ObjectID, GUID, Name, EmailAddress, ManagerEmail
            FROM ACVSCore.Access.Personnel
            WHERE
              (CAST(ObjectID AS NVARCHAR(200)) = ?)
              OR (GUID = ?)
              OR (CAST(Int1 AS NVARCHAR(200)) = ?)
              OR (Text12 = ?)
              OR (Name = ?)
            ORDER BY ObjectID DESC
        """
        cand = str(candidate_identifier).strip()
        cand_guid = cand if _looks_like_guid(cand) else None
        params = (cand, cand_guid, cand, cand, cand)
        cur.execute(sql, params)
        row = cur.fetchone()


        

                if row:
                    try:
                        out["ObjectID"] = row[0] if len(row) > 0 else None
                        out["GUID"] = row[1] if len(row) > 1 else None
                        out["Name"] = row[2] if len(row) > 2 else None

                        # try a few column positions/names for email; map to consistent keys
                        email_val = None
                        # row[3] used before — keep it if present
                        if len(row) > 3:
                            email_val = row[3]
                        # if email is still falsy try alternative columns if present (some DBs have different columns)
                        if not email_val and len(row) > 4:
                            email_val = row[4]  # maybe EMail or WorkEmail in some schemas

                        # normalise empty -> None
                        if email_val is None or (isinstance(email_val, str) and email_val.strip() == ""):
                            email_val = None

                        # set multiple aliases so callers can find an email under various names
                        out["EmailAddress"] = email_val or None
                        out["EmployeeEmail"] = email_val or None
                        out["Email"] = email_val or None
                        out["WorkEmail"] = email_val or None

                        # ManagerEmail if available
                        out["ManagerEmail"] = row[4] if len(row) > 4 else None

                        logging.info(
                            "get_personnel_info: found ObjectID=%s Email=%s for candidate=%s",
                            out.get("ObjectID"),
                            out.get("Email"),
                            candidate_identifier,
                        )
                    except Exception:
                        logging.exception("get_personnel_info: failed parsing DB row")

    finally:
        try:
            if cur is not None:
                cur.close()
        except Exception:
            pass
        try:
            conn.close()
        except Exception:
            pass

    return out


def get_person_image_bytes(parent_id) -> Optional[bytes]:
    """
    Retrieve an employee image by parent_id:
      1) DB (ACVSCore.Access.Images) - if available
      2) Filesystem under outputs/images, outputs, repo/images, repo root, cwd
      3) Base64 text files (.b64/.txt)
    Returns bytes or None.

    NOTE: This function will attempt to resolve the incoming identifier to Personnel.ObjectID/GUID
    via get_personnel_info() and try those values as ParentId in Images as a fallback.
    """
    if parent_id is None:
        return None

    # Attempt DB lookup first (best-effort)
    try:
        conn = _get_acvscore_conn()
        if conn is not None:
            cur = None
            try:
                cur = conn.cursor()
                sql = """
                    SELECT TOP 1 AI.Image
                    FROM ACVSCore.Access.Images AI
                    WHERE AI.ParentId = ?
                      AND DATALENGTH(AI.Image) > 0
                    ORDER BY AI.ObjectID DESC
                """
                raw_pid = str(parent_id).strip()
                cand_parent_ids = [raw_pid]
                stripped = _strip_person_uid_prefix(raw_pid)
                if stripped and stripped != raw_pid:
                    cand_parent_ids.append(stripped)
                # integer/float fallback forms
                try:
                    if stripped and "." in stripped:
                        f = float(stripped)
                        if f.is_integer():
                            cand_parent_ids.append(str(int(f)))
                except Exception:
                    pass
                try:
                    if stripped and stripped.isdigit():
                        cand_parent_ids.append(f"emp_{stripped}")
                except Exception:
                    pass

                # --- NEW: attempt to resolve candidate -> Personnel.ObjectID / GUID and append ---
                try:
                    pinfo = get_personnel_info(raw_pid) or {}
                    if pinfo:
                        obj = pinfo.get("ObjectID")
                        guid = pinfo.get("GUID")
                        # add objectid/guid as strings (preserve order: prefer ObjectID first)
                        if obj is not None:
                            obj_s = str(obj).strip()
                            if obj_s:
                                cand_parent_ids.append(obj_s)
                        if guid:
                            guid_s = str(guid).strip()
                            if guid_s:
                                cand_parent_ids.append(guid_s)
                except Exception:
                    logging.debug("get_person_image_bytes: personnel resolution failed for %s", raw_pid)

                # dedupe preserving order
                seen = set()
                cand_parent_ids = [x for x in cand_parent_ids if x and (not (x in seen or seen.add(x)))]

                for pid_try in cand_parent_ids:
                    try:
                        cur.execute(sql, (str(pid_try),))
                        row = cur.fetchone()
                        if row and row[0] is not None:
                            try:
                                b = bytes(row[0])
                                logging.info(
                                    "get_person_image_bytes: DB image found for ParentId=%s (len=%d)",
                                    pid_try,
                                    len(b),
                                )
                                return b
                            except Exception:
                                logging.exception(
                                    "get_person_image_bytes: convert DB image to bytes failed for %s", pid_try
                                )
                                return row[0]
                    except Exception:
                        logging.debug("get_person_image_bytes: DB fetch failed for ParentId=%s", pid_try)
                        continue
            except Exception:
                logging.exception("get_person_image_bytes: DB query failed")
            finally:
                try:
                    if cur is not None:
                        cur.close()
                except Exception:
                    pass
                try:
                    conn.close()
                except Exception:
                    pass
    except Exception:
        logging.exception("get_person_image_bytes: unexpected DB path error")

    # Filesystem + base64 fallback
    try:
        pid_raw = str(parent_id).strip()
        cand_ids = [pid_raw]
        try:
            f = float(pid_raw)
            if f.is_integer():
                int_form = str(int(f))
                if int_form not in cand_ids:
                    cand_ids.append(int_form)
        except Exception:
            pass
        try:
            if pid_raw.isdigit():
                cand_ids.append(f"emp_{pid_raw}")
                if len(pid_raw) < 8:
                    cand_ids.append(pid_raw.zfill(8))
        except Exception:
            pass

        # unique preserve order
        cand_ids = list(dict.fromkeys(cand_ids))

        candidate_dirs = [
            (Path(DEFAULT_OUTDIR) / "images"),
            Path(DEFAULT_OUTDIR),
            Path(__file__).resolve().parent / "images",
            Path(__file__).resolve().parent,
            Path.cwd(),
        ]

        exts = (".jpg", ".jpeg", ".png", ".bmp", ".gif", ".webp")
        b64_exts = (".b64", ".txt")

        for c in cand_ids:
            for folder in candidate_dirs:
                try:
                    if not folder.exists():
                        continue
                except Exception:
                    continue

                # exact filename match with normal image extensions
                for ext in exts:
                    fp = folder / f"{c}{ext}"
                    try:
                        if fp.exists() and fp.is_file():
                            try:
                                return fp.read_bytes()
                            except Exception:
                                logging.exception("get_person_image_bytes: failed reading %s", fp)
                                continue
                    except Exception:
                        continue

                # base64 text file containers
                for ext in b64_exts:
                    fp = folder / f"{c}{ext}"
                    try:
                        if fp.exists() and fp.is_file():
                            try:
                                txt = fp.read_text(encoding="utf-8", errors="ignore").strip()
                                if txt:
                                    if "," in txt and txt.startswith("data:"):
                                        try:
                                            b64 = txt.split(",", 1)[1]
                                            return base64.b64decode(b64)
                                        except Exception:
                                            pass
                                    try:
                                        return base64.b64decode(txt)
                                    except Exception:
                                        logging.exception(
                                            "get_person_image_bytes: base64 decode failed for %s", fp
                                        )
                                        continue
                            except Exception:
                                logging.exception("get_person_image_bytes: failed reading base64 file %s", fp)
                                continue
                    except Exception:
                        continue

                # glob fallback: any file containing token c
                try:
                    for fp in folder.glob(f"*{c}*"):
                        if fp.is_file():
                            try:
                                b = fp.read_bytes()
                                if b:
                                    logging.info("get_person_image_bytes: loaded image via glob %s", fp)
                                    return b
                            except Exception:
                                logging.exception("get_person_image_bytes: failed reading glob file %s", fp)
                                continue
                except Exception:
                    logging.exception(
                        "get_person_image_bytes: glob check failed in %s for token %s", folder, c
                    )
                    continue
    except Exception:
        logging.exception("get_person_image_bytes: filesystem search failed for ParentId=%s", parent_id)

    logging.debug("get_person_image_bytes: no image found for ParentId=%s", parent_id)
    return None


# exported symbols
__all__ = ["get_person_image_bytes", "get_personnel_info", "_get_acvscore_conn"]



