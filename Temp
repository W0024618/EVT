  <script type="text/babel">
    (function () {
      const { useState, useEffect, useRef } = React;

      // CHANGE IF YOUR API HOST DIFFERS
      const API_BASE = "http://localhost:8002";

      function resolveApiImageUrl(imgUrl) {
        if (!imgUrl) return null;
        try {
          if (imgUrl.startsWith('http://') || imgUrl.startsWith('https://')) return imgUrl;
          // ensure API_BASE has no trailing slash
          var base = API_BASE.replace(/\/$/, '');
          if (imgUrl.startsWith('/')) return base + imgUrl;
          return base + '/' + imgUrl;
        } catch (e) {
          return imgUrl;
        }
      }

      // ... (all other constants, utilities unchanged) ...

      function App() {
        // ... state and refs unchanged ...

        // --- new helper: try several record endpoints (backend may vary) ---
        async function tryFetchRecord(employeeId) {
          if (!employeeId) throw new Error("No employee id");
          const candidates = [
            API_BASE + "/record?employee_id=" + encodeURIComponent(employeeId),
            API_BASE + "/api/record?employee_id=" + encodeURIComponent(employeeId),
            API_BASE + "/employee/" + encodeURIComponent(employeeId) + "/record",
            API_BASE + "/api/employees/" + encodeURIComponent(employeeId) + "/record",
            API_BASE + "/records?employee_id=" + encodeURIComponent(employeeId)
          ];
          for (const url of candidates) {
            try {
              const resp = await fetch(url, { method: 'GET' });
              if (resp && resp.ok) {
                const js = await resp.json().catch(() => null);
                if (js) return { js, url };
              } else {
                // try to detect a helpful error-body for debugging but continue
                // (don't throw here — try other endpoints)
              }
            } catch (err) {
              // ignore and try next
            }
          }
          throw new Error("All record endpoints failed");
        }

        // openEvidence updated to use tryFetchRecord and to set email/image in a deterministic way
        async function openEvidence(row) {
          setModalRow(row);
          setModalDetails(null);
          setModalLoading(true);
          try {
            const candidateId = (row && (row.EmployeeID || row.person_uid)) || "";
            let js = null;

            try {
              // try endpoints robustly
              const rec = await tryFetchRecord(candidateId);
              js = rec.js;
              console.info("record loaded from", rec.url);
            } catch (err) {
              // fallback: try simple /record call once directly (older API)
              try {
                const resp = await fetch(API_BASE + "/record?employee_id=" + encodeURIComponent(candidateId));
                if (resp.ok) js = await resp.json();
              } catch (err2) {
                // still nothing — will continue with null js
              }
            }

            // QUICK: set an explicit image_url if backend provided or build one from employee id
            const quickImageUrl = js && (js.image_url || js.imageUrl || js.ImageUrl) ? (js.image_url || js.imageUrl || js.ImageUrl) : null;
            const builtImage = quickImageUrl || (candidateId ? `/employee/${encodeURIComponent(candidateId)}/image` : null);

            // update modalRow immediately so UI renders email/image ASAP
            setModalRow(prev => Object.assign({}, prev || {}, {
              EmployeeEmail: prev && prev.EmployeeEmail ? prev.EmployeeEmail : (js && js.meta && (js.meta.email || js.meta.Email) ? (js.meta.email || js.meta.Email) : null),
              Email: prev && prev.Email ? prev.Email : (js && js.meta && (js.meta.email || js.meta.Email) ? (js.meta.email || js.meta.Email) : null),
              ImageUrl: builtImage || (prev && prev.ImageUrl) || null
            }));

            // Normalize details (keep aggregated_rows as array, raw_swipes as array)
            const details = {
              aggregated_rows: js && Array.isArray(js.aggregated_rows) ? js.aggregated_rows : (js && Array.isArray(js.sample) ? js.sample : []),
              raw_swipe_files: js && Array.isArray(js.raw_swipe_files) ? js.raw_swipe_files : (js && Array.isArray(js.files) ? js.files : []),
              raw_swipes: js && Array.isArray(js.raw_swipes) ? js.raw_swipes : []
            };
            setModalDetails(details);

            // Robustly extract email (now deterministic)
            let newEmail = null;
            try {
              if (details.aggregated_rows && details.aggregated_rows.length) {
                const f = details.aggregated_rows[0];
                newEmail = f.EmployeeEmail || f.Email || f.WorkEmail || f.EMail || null;
              }
              if (!newEmail && details.raw_swipes && details.raw_swipes.length) {
                const r0 = details.raw_swipes[0];
                newEmail = r0.EmployeeEmail || r0.Email || r0.WorkEmail || null;
              }
              // fallback to any meta in response
              if (!newEmail && js && js.meta && (js.meta.email || js.meta.Email)) {
                newEmail = js.meta.email || js.meta.Email;
              }
              // last fallback: original row (from table)
              if (!newEmail && row) {
                newEmail = row.EmployeeEmail || row.Email || null;
              }
            } catch (err) { /* ignore */ }

            // Also capture common fields (CardNumber etc.) from the first raw_swipe if missing
            let cardNum = null;
            try {
              if (details.aggregated_rows && details.aggregated_rows.length) {
                const f = details.aggregated_rows[0];
                cardNum = f.CardNumber || f.Card || null;
              }
              if (!cardNum && details.raw_swipes && details.raw_swipes.length) {
                const r0 = details.raw_swipes[0];
                cardNum = r0.CardNumber || r0.Card || null;
              }
            } catch (err) { }

            // Merge into modalRow (ensures UI re-render shows email/card)
            setModalRow(prev => Object.assign({}, prev || {}, {
              EmployeeEmail: newEmail || (prev && prev.EmployeeEmail) || null,
              Email: newEmail || (prev && prev.Email) || null,
              CardNumber: (prev && prev.CardNumber) || cardNum || null
            }));

          } catch (e) {
            alert("Failed loading details: " + e.message);
            console.error(e);
          } finally {
            setModalLoading(false);
          }
        }

        // ... rest unchanged until filtering & aggregation ...

        // AGGREGATION: group by EmployeeID / person_uid / fallback (name + card)
        function buildAggregated(rowsArr) {
          // unchanged...
        }

        // build aggregatedFiltered only if collapseDuplicates is enabled
        var aggregatedFiltered = collapseDuplicates ? buildAggregated(filtered) : null;

        // set up pagination source
        var sourceForPaging = collapseDuplicates ? (aggregatedFiltered || []) : filtered;

        // FIXED: derive totalPages / pageRows from sourceForPaging (previous code redefined these vars wrongly)
        var totalPages = Math.max(1, Math.ceil((sourceForPaging.length || 0) / pageSize));
        var pageRows = (sourceForPaging || []).slice((page - 1) * pageSize, page * pageSize);

        function exportFiltered() { downloadCSV(collapseDuplicates ? (aggregatedFiltered || []) : filtered, "trend_filtered_export.csv"); }

        // ... rest of code unchanged until render modal ...

        // compute unique flagged persons (unchanged) ...
        var flaggedCount = (summary && typeof summary.flagged_rows === 'number' && summary.flagged_rows > 0) ? summary.flagged_rows : _flaggedKeys.size;

        // --- NEW: compute a single modalEmail to use in modal rendering ---
        const modalEmail = (function () {
          try {
            if (modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0]) {
              const f = modalDetails.aggregated_rows[0];
              return f.EmployeeEmail || f.Email || f.WorkEmail || f.EMail || null;
            }
            if (modalDetails && modalDetails.raw_swipes && modalDetails.raw_swipes[0]) {
              const r0 = modalDetails.raw_swipes[0];
              return r0.EmployeeEmail || r0.Email || r0.WorkEmail || null;
            }
            if (modalRow) {
              return modalRow.EmployeeEmail || modalRow.Email || null;
            }
            return null;
          } catch (e) {
            return null;
          }
        })();

        // ... JSX return unchanged except email span replaced with modalEmail variable ...

        return (
          <div className="container" aria-live="polite">
            {/* ... rest of UI ... */}

                          <div className="detail-item">
                            <div className="detail-icon">
                              <i className="bi bi-envelope"></i>
                            </div>
                            <div className="detail-content">
                              <label>EmployeeEmail</label>

                              <span>
                                { modalEmail ? modalEmail : <span className="muted">—</span> }
                              </span>

                            </div>
                          </div>

            {/* ... rest of UI ... */}
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(App));
    })();
  </script>














Now I have Update Backend both App.py and trend Runner.py file as per suggestion .. 
now upadte in Frontend ..
Please find below index.html and styl.css file carefully and share me Updated snippet...


<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Behaviour Analysis — Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- React + ReactDOM + Babel (quick prototyping) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- Flatpickr -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    (function () {
      const { useState, useEffect, useRef } = React;

      // CHANGE IF YOUR API HOST DIFFERS
      const API_BASE = "http://localhost:8002";

      function resolveApiImageUrl(imgUrl) {
        if (!imgUrl) return null;
        try {
          if (imgUrl.startsWith('http://') || imgUrl.startsWith('https://')) return imgUrl;
          // ensure API_BASE has no trailing slash
          var base = API_BASE.replace(/\/$/, '');
          if (imgUrl.startsWith('/')) return base + imgUrl;
          return base + '/' + imgUrl;
        } catch (e) {
          return imgUrl;
        }
      }


      // --- Region / Location mapping copied from backend/duration_report.REGION_CONFIG (friendly / UI names) ---
      // Keep the keys lowercase to match backend region keys.
      const REGION_OPTIONS = {
        "apac": {
          label: "APAC",
          // Friendly names used by backend normalisation (duration_report) for APAC
          partitions: ["Pune", "Quezon City", "Taguig City", "MY.Kuala Lumpur", "IN.HYD", "SG.Singapore"]
        },
        "emea": {
          label: "EMEA",
          partitions: ["LT.Vilnius", "IT.Rome", "UK.London", "IE.DUblin", "DU.Abu Dhab", "ES.Madrid"]
        },
        "laca": {
          label: "LACA",
          partitions: ["AR.Cordoba", "BR.Sao Paulo", "CR.Costa Rica Partition", "PA.Panama City", "PE.Lima", "MX.Mexico City"]
        },
        "namer": {
          label: "NAMER",
          // show friendly names to the user, but we map them to backend partition tokens before sending
          partitions: ["Denver", "Austin Texas", "Miami", "New York"]
        }
      };

      // Map from UI-friendly location label -> backend search token (used for &city=)
      // For APAC, friendly labels match backend PartitionName2 normalised values so they map to themselves.
      // For NAMER, backend normalisation sets PartitionName2 to tokens like "US.CO.OBS", "USA/Canada Default" etc.
      const LOCATION_QUERY_VALUE = {
        "apac": {
          "Pune": "Pune",
          "Quezon City": "Quezon City",
          "Taguig City": "Taguig City",
          "MY.Kuala Lumpur": "MY.Kuala Lumpur",
          "IN.HYD": "IN.HYD",
          "SG.Singapore": "SG.Singapore"
        },
        "namer": {
          // friendly->backend tokens (this matches the backend duration_report normalisation)
          "Denver": "US.CO.OBS",
          "Austin Texas": "USA/Canada Default",
          "Miami": "US.FL.Miami",
          "New York": "US.NYC"
        },
        // default passthrough for other regions (if needed)
        "emea": {},
        "laca": {}
      };

      // Map risk text/colors (same as backend map_score_to_label buckets)
      const RISK_COLORS = {
        "Low": "#10b981",
        "Low Medium": "#86efac",
        "Medium": "#facc15",
        "Medium High": "#fb923c",
        "High": "#ef4444"
      };
      const RISK_LABELS = ["Low", "Low Medium", "Medium", "Medium High", "High"];

      // (rest unchanged) Explanations...
      const SCENARIO_EXPLANATIONS = {
        "long_gap_>=4.5h": "Long gap between swipes (>=4.5 hours).",
        "short_duration_<4h": "Short total presence (<4 hours).",
        "coffee_badging": "Multiple short swipes — possible coffee badging.",
        "low_swipe_count_<=2": "Very few swipes recorded for day (<=2).",
        "single_door": "Single door used during day.",
        "only_in": "Only IN events present.",
        "only_out": "Only OUT events present.",
        "overtime_>=10h": "Overtime (>=10 hours).",
        "very_long_duration_>=16h": "Very long presence (>=16 hours).",
        "unusually_high_swipes": "Unusually high number of swipes vs history.",
        "repeated_short_breaks": "Multiple short breaks in day.",
        "multiple_location_same_day": "Multiple locations used same day.",
        "weekend_activity": "Activity on weekend.",
        "repeated_rejection_count": "Multiple rejections.",
        "badge_sharing_suspected": "Same card used by multiple persons on same day.",
        "early_arrival_before_06": "First swipe earlier than 06:00.",
        "late_exit_after_22": "Last swipe after 22:00.",
        "shift_inconsistency": "Duration inconsistent with historical shift.",
        "trending_decline": "Historical trending decline.",
        "consecutive_absent_days": "Consecutive absent days historically.",
        "high_variance_duration": "High variance in durations historically.",
        "short_duration_on_high_presence_days": "Short duration despite high typical presence.",
        "swipe_overlap": "Swipes overlapping other users (possible tailgating).",
        "shortstay_longout_repeat": "Short in -> long out -> short return pattern."
      };

      // small utilities
      function pad(n) { return n.toString().padStart(2, '0'); }
      function formatDateISO(d) {
        if (!d) return "";
        const dt = (d instanceof Date) ? d : new Date(d);
        return dt.getFullYear() + "-" + pad(dt.getMonth() + 1) + "-" + pad(dt.getDate());
      }
      function safeDateDisplay(val) {
        if (!val && val !== 0) return "";
        try {
          const d = (val instanceof Date) ? val : new Date(val);
          if (isNaN(d.getTime())) return String(val);
          return d.toLocaleString();
        } catch (e) {
          return String(val);
        }
      }

      function sanitizeName(row) {
        if (!row) return "";
        // prefer feature/duration versions if present
        return row.EmployeeName_feat || row.EmployeeName_dur || row.EmployeeName || row.ObjectName1 || row.objectname1 || row.employee_name || row.person_uid || "";
      }


      function downloadCSV(rows, filename) {
        if (!rows || !rows.length) { alert("No rows to export"); return; }
        var cols = Object.keys(rows[0]);
        var lines = [cols.join(",")];
        rows.forEach(function (r) {
          var row = cols.map(function (c) {
            var v = (r[c] === undefined || r[c] === null) ? "" : String(r[c]).replace(/\n/g, ' ');
            return JSON.stringify(v);
          }).join(",");
          lines.push(row);
        });
        var blob = new Blob([lines.join("\n")], { type: 'text/csv' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a'); a.href = url; a.download = filename || 'export.csv'; a.click(); URL.revokeObjectURL(url);
      }

      // duration formatting helper
      function formatSecondsToHmsJS(seconds) {
        if (seconds === null || seconds === undefined || seconds === '') return "-";
        const n = Number(seconds);
        if (isNaN(n) || !isFinite(n)) return "-";
        const s = Math.max(0, Math.floor(n));
        const hh = Math.floor(s / 3600);
        const mm = Math.floor((s % 3600) / 60);
        const ss = s % 60;
        return pad(hh) + ":" + pad(mm) + ":" + pad(ss);
      }



      // duration formatting helper (HH:MM) — used for Duration fields (strict HH:MM)
      function formatSecondsToHmJS(seconds) {
        if (seconds === null || seconds === undefined || seconds === '') return "-";
        const n = Number(seconds);
        if (isNaN(n) || !isFinite(n)) return "-";
        const s = Math.max(0, Math.floor(n));
        const hh = Math.floor(s / 3600);
        const mm = Math.floor((s % 3600) / 60);
        // return HH:MM (hours may be >23)
        return String(hh) + ":" + String(mm).padStart(2, '0');
      }


      // ----- Day-boundary helpers -----
      // Backend assigns Date using LocaleMessageTime.date() (no 2AM shift).
      // Keep frontend day-boundary at 0 so logical dates match backend.
      const DAY_BOUNDARY_HOUR = 0;

      function logicalDateForTs(dt, boundaryHour = DAY_BOUNDARY_HOUR) {
        if (!dt || !(dt instanceof Date) || isNaN(dt.getTime())) return null;
        const hour = dt.getHours();
        const year = dt.getFullYear();
        const month = dt.getMonth();
        const day = dt.getDate();
        const out = new Date(year, month, day, 0, 0, 0, 0);
        // with boundaryHour = 0, this never subtracts a day -> matches backend date assignment
        if (hour < boundaryHour) {
          out.setDate(out.getDate() - 1);
        }
        const y = out.getFullYear();
        const m = String(out.getMonth() + 1).padStart(2, '0');
        const d = String(out.getDate()).padStart(2, '0');
        return `${y}-${m}-${d}`;
      }

      function makeLocalDateFromRow(r) {
        try {
          if (!r) return null;

          // backend usually includes LocaleMessageTime (ISO string). Prefer that.
          if (r.LocaleMessageTime) {
            const t = new Date(r.LocaleMessageTime);
            if (!isNaN(t.getTime())) return t;
          }

          function toInt(v, fallback = 0) {
            const n = Number(v);
            return Number.isFinite(n) ? n : fallback;
          }

          // Backend also supplies DateOnly + Time for frontend convenience — use those if present.
          if (r.DateOnly && r.Time) {
            try {
              // DateOnly might be a Date object or 'YYYY-MM-DD' string.
              const dateStr = String(r.DateOnly).slice(0, 10).replace(/\//g, '-');
              const dateParts = dateStr.split('-').map(p => toInt(p, NaN));
              if (dateParts.length === 3 && !isNaN(dateParts[0])) {
                const year = dateParts[0];
                const month = dateParts[1];
                const day = dateParts[2];

                const timeRaw = String(r.Time).split(/[.+Z ]/)[0];
                const timeParts = timeRaw.split(':').map(p => toInt(p, 0));
                const hh = timeParts[0] || 0;
                const mm = timeParts[1] || 0;
                const ss = timeParts[2] || 0;

                return new Date(year, month - 1, day, hh, mm, ss, 0);
              }
            } catch (e) { /* fallthrough */ }
          }

          // fallback: if Date and Time fields exist (older API formats)
          if (r.Date && r.Time) {
            try {
              const dateStr = String(r.Date).slice(0, 10).replace(/\//g, '-');
              const dateParts = dateStr.split('-').map(p => toInt(p, NaN));
              if (dateParts.length === 3 && !isNaN(dateParts[0])) {
                const year = dateParts[0];
                const month = dateParts[1];
                const day = dateParts[2];

                const timeRaw = String(r.Time).split(/[.+Z ]/)[0];
                const timeParts = timeRaw.split(':').map(p => toInt(p, 0));
                const hh = timeParts[0] || 0;
                const mm = timeParts[1] || 0;
                const ss = timeParts[2] || 0;

                return new Date(year, month - 1, day, hh, mm, ss, 0);
              }
            } catch (e) { /* fallthrough */ }
          }

          // if only DateOnly present, return midnight of that date
          if (r.DateOnly) {
            try {
              const parts = String(r.DateOnly).slice(0, 10).replace(/\//g, '-').split('-');
              if (parts.length === 3) {
                const y = toInt(parts[0], NaN);
                const m = toInt(parts[1], NaN);
                const d = toInt(parts[2], NaN);
                if (!isNaN(y)) return new Date(y, m - 1, d, 0, 0, 0, 0);
              }
            } catch (e) { /* fallthrough */ }
          }

          // if only Date present, use that
          if (r.Date) {
            try {
              const parts = String(r.Date).slice(0, 10).replace(/\//g, '-').split('-');
              if (parts.length === 3) {
                const y = toInt(parts[0], NaN);
                const m = toInt(parts[1], NaN);
                const d = toInt(parts[2], NaN);
                if (!isNaN(y)) return new Date(y, m - 1, d, 0, 0, 0, 0);
              }
            } catch (e) { /* fallthrough */ }
          }

        } catch (e) { }
        return null;
      }

      function App() {
        var yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);

        const [dateFrom, setDateFrom] = useState(formatDateISO(yesterday));
        const [dateTo, setDateTo] = useState(formatDateISO(new Date()));
        const [loading, setLoading] = useState(false);
        const [summary, setSummary] = useState({ rows: 0, flagged_rows: 0, files: [], end_date: null });
        const [rows, setRows] = useState([]);
        const [reasonsCount, setReasonsCount] = useState({});
        const [riskCounts, setRiskCounts] = useState({ "Low": 0, "Low Medium": 0, "Medium": 0, "Medium High": 0, "High": 0 });
        const [filterText, setFilterText] = useState("");
        const [page, setPage] = useState(1);
        const [selectedReason, setSelectedReason] = useState("");
        const [reasonFilterText, setReasonFilterText] = useState("");
        const [modalRow, setModalRow] = useState(null);
        const [modalDetails, setModalDetails] = useState(null);
        const [modalLoading, setModalLoading] = useState(false);
        const [collapseDuplicates, setCollapseDuplicates] = useState(true);
        const [selectedRiskFilter, setSelectedRiskFilter] = useState("");

        // New: region & location
        const [selectedRegion, setSelectedRegion] = useState("apac");
        const [selectedLocation, setSelectedLocation] = useState("All locations");

        const pageSize = 25;
        const chartRef = useRef(null);
        const chartInst = useRef(null);

        const fromRef = useRef(null);
        const toRef = useRef(null);
        const fromFp = useRef(null);
        const toFp = useRef(null);


        // Chat state
        const [chatOpen, setChatOpen] = useState(false);
        const [chatMessages, setChatMessages] = useState([]);
        const [chatInput, setChatInput] = useState("");
        const [chatLoading, setChatLoading] = useState(false);

        useEffect(function () {
          if (window.flatpickr && fromRef.current && toRef.current) {
            try { if (fromFp.current) fromFp.current.destroy(); } catch (e) { }
            try { if (toFp.current) toFp.current.destroy(); } catch (e) { }
            fromFp.current = window.flatpickr(fromRef.current, {
              dateFormat: "Y-m-d",
              defaultDate: dateFrom,
              allowInput: true,
              onChange: function (selectedDates, str) {
                if (selectedDates && selectedDates.length) {
                  const iso = formatDateISO(selectedDates[0]);
                  setDateFrom(iso);
                  try { if (toFp.current) toFp.current.set('minDate', iso); } catch (e) { }
                  if (dateTo && new Date(iso) > new Date(dateTo)) {
                    setDateTo(iso);
                    try { if (toFp.current) toFp.current.setDate(iso, true); } catch (e) { }
                  }
                }
              }
            });
            toFp.current = window.flatpickr(toRef.current, {
              dateFormat: "Y-m-d",
              defaultDate: dateTo,
              allowInput: true,
              onChange: function (selectedDates, str) {
                if (selectedDates && selectedDates.length) {
                  const iso = formatDateISO(selectedDates[0]);
                  setDateTo(iso);
                  try { if (fromFp.current) fromFp.current.set('maxDate', iso); } catch (e) { }
                  if (dateFrom && new Date(iso) < new Date(dateFrom)) {
                    setDateFrom(iso);
                    try { if (fromFp.current) fromFp.current.setDate(iso, true); } catch (e) { }
                  }
                }
              }
            });
            try { if (fromFp.current) fromFp.current.set('maxDate', dateTo); if (toFp.current) toFp.current.set('minDate', dateFrom); } catch (e) { }
          }
          loadLatest();
          return function () { try { if (fromFp.current) fromFp.current.destroy(); } catch (e) { } try { if (toFp.current) toFp.current.destroy(); } catch (e) { } };
          // eslint-disable-next-line
        }, []);

        useEffect(function () {
          try { if (fromFp.current && dateFrom) fromFp.current.setDate(dateFrom, false); } catch (e) { }
          try { if (toFp.current && dateTo) toFp.current.setDate(dateTo, false); } catch (e) { }
          try { if (fromFp.current) fromFp.current.set('maxDate', dateTo); } catch (e) { }
          try { if (toFp.current) toFp.current.set('minDate', dateFrom); } catch (e) { }
        }, [dateFrom, dateTo]);

        // When region changes, reset location to "All locations"
        useEffect(() => {
          setSelectedLocation("All locations");
        }, [selectedRegion]);

        async function runForRange() {
          setLoading(true);
          setRows([]);
          setSummary({ rows: 0, flagged_rows: 0, files: [], end_date: null });
          setReasonsCount({});
          setRiskCounts({ "Low": 0, "Low Medium": 0, "Medium": 0, "Medium High": 0, "High": 0 });
          try {
            const start = encodeURIComponent(dateFrom);
            const end = encodeURIComponent(dateTo);
            // include selected region & city if provided
            let url = API_BASE + "/run?start=" + start + "&end=" + end + "&full=true";
            if (selectedRegion) {
              url += "&region=" + encodeURIComponent(selectedRegion);
            }
            if (selectedLocation && selectedLocation !== "All locations") {
              // send backend-aware partition token (use mapping)
              const mapForRegion = LOCATION_QUERY_VALUE[selectedRegion] || {};
              const queryCity = mapForRegion[selectedLocation] || selectedLocation;
              url += "&city=" + encodeURIComponent(queryCity);
            }
            let r = await fetch(url, { method: 'GET' });
            if (!r.ok) { const txt = await r.text(); throw new Error("API returned " + r.status + ": " + txt); }
            let js = await r.json();

            const totalRows = (typeof js.aggregated_unique_persons === 'number') ? js.aggregated_unique_persons
              : (typeof js.rows === 'number') ? js.rows : 0;
            const totalFlagged = (typeof js.flagged_rows === 'number') ? js.flagged_rows : 0;
            const files = js.files || [];

            const sample = Array.isArray(js.flagged_persons) && js.flagged_persons.length ? js.flagged_persons
              : (Array.isArray(js.sample) ? js.sample : []);
            setRows(sample);

            setSummary({ rows: totalRows, flagged_rows: totalFlagged, files: files, end_date: formatDateISO(new Date(dateTo)) });

            if (js.reasons_count && Object.keys(js.reasons_count).length > 0) {
              setReasonsCount(js.reasons_count);
            } else {
              computeReasonsAndRisks(sample);
            }
            if (js.risk_counts && Object.keys(js.risk_counts).length > 0) {
              const all = { "Low": 0, "Low Medium": 0, "Medium": 0, "Medium High": 0, "High": 0 };
              Object.keys(js.risk_counts).forEach(k => { all[k] = js.risk_counts[k]; });
              setRiskCounts(all);
            } else {
              computeReasonsAndRisks(sample);
            }
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message);
            console.error(err);
          } finally {
            setLoading(false);
          }
        }

        function pushChatMessage(msg) {
          setChatMessages(prev => [...prev, msg]);
          setTimeout(() => {
            const el = document.querySelector('.chat-body');
            if (el) el.scrollTop = el.scrollHeight;
          }, 50);
        }






        // New: group rows by person and compute unique per-person reason + highest-severity risk
        function computeReasonsAndRisks(dataRows) {
          // helper severity mapping (higher => more severe)
          function severityForLabel(label) {
            const map = { "Low": 1, "Low Medium": 2, "Medium": 3, "Medium High": 4, "High": 5 };
            if (!label) return 1;
            return map[String(label)] || 1;
          }

          var personMap = {}; // key -> { rows:[], reasonsSet:Set, maxSeverity, chosenLabel }

          (dataRows || []).forEach(function (r) {
            try {
              var key = r.EmployeeID || r.person_uid || (sanitizeName(r) + '|' + (r.CardNumber || r.Card || ''));
              if (!key) {
                // fallback: unique by row index-ish (but try to avoid counting duplicates without id)
                key = JSON.stringify(r); // rare fallback
              }
              if (!personMap[key]) {
                personMap[key] = { rows: [], reasonsSet: new Set(), maxSeverity: 0, chosenLabel: null };
              }
              var p = personMap[key];
              p.rows.push(r);

              // collect reasons (set per person)
              var reasonsField = r.Reasons || r.DetectedScenarios || r.Detected || "";
              String(reasonsField).split(";").map(function (s) { return s && s.trim(); }).filter(Boolean).forEach(function (rs) {
                p.reasonsSet.add(rs);
              });

              // pick highest severity risk label across this person's rows
              var rl = getRiskLabelForRow(r);
              var sev = severityForLabel(rl);
              if (sev > p.maxSeverity) {
                p.maxSeverity = sev;
                p.chosenLabel = rl || "Low";
              }
            } catch (err) {
              // ignore malformed rows
              console.error("computeReasonsAndRisks row error", err);
            }
          });

          // Build aggregated counts: one contribution per person
          var reasonsCounts = {};
          var rcounts = { "Low": 0, "Low Medium": 0, "Medium": 0, "Medium High": 0, "High": 0 };

          Object.keys(personMap).forEach(function (k) {
            var p = personMap[k];
            // reasons: increment each reason once per person
            p.reasonsSet.forEach(function (rn) {
              reasonsCounts[rn] = (reasonsCounts[rn] || 0) + 1;
            });
            // risk: increment chosenLabel once per person (fallback to Low)
            var label = p.chosenLabel || "Low";
            if (!rcounts[label] && rcounts[label] !== 0) rcounts[label] = 0; // ensure key exists
            rcounts[label] = (rcounts[label] || 0) + 1;
          });

          setReasonsCount(reasonsCounts);
          setRiskCounts(rcounts);
        }








        async function loadLatest() {
          setLoading(true);
          try {
            // run for yesterday (to match backend's default behaviour)
            var d = new Date();
            d.setDate(d.getDate() - 1);
            var yesterday = formatDateISO(d);
            setDateFrom(yesterday);
            setDateTo(yesterday);

            const start = encodeURIComponent(yesterday);
            const end = encodeURIComponent(yesterday);
            let url = API_BASE + "/run?start=" + start + "&end=" + end + "&full=true";
            if (selectedRegion) {
              url += "&region=" + encodeURIComponent(selectedRegion);
            }
            if (selectedLocation && selectedLocation !== "All locations") {
              const mapForRegion = LOCATION_QUERY_VALUE[selectedRegion] || {};
              const queryCity = mapForRegion[selectedLocation] || selectedLocation;
              url += "&city=" + encodeURIComponent(queryCity);
            }
            let r = await fetch(url, { method: 'GET' });
            if (!r.ok) { const txt = await r.text(); throw new Error("API returned " + r.status + ": " + txt); }
            let js = await r.json();

            const totalRows = (typeof js.aggregated_unique_persons === 'number') ? js.aggregated_unique_persons
              : (typeof js.rows === 'number') ? js.rows : 0;
            const totalFlagged = (typeof js.flagged_rows === 'number') ? js.flagged_rows : 0;
            const files = js.files || [];

            const sample = Array.isArray(js.sample) ? js.sample : (Array.isArray(js.flagged_persons) ? js.flagged_persons : []);
            setRows(sample);
            setSummary({ rows: totalRows, flagged_rows: totalFlagged, files: files, end_date: yesterday });

            if (js.reasons_count && Object.keys(js.reasons_count).length > 0) {
              setReasonsCount(js.reasons_count);
            } else {
              computeReasonsAndRisks(sample);
            }
            if (js.risk_counts && Object.keys(js.risk_counts).length > 0) {
              const all = { "Low": 0, "Low Medium": 0, "Medium": 0, "Medium High": 0, "High": 0 };
              Object.keys(js.risk_counts).forEach(k => { all[k] = js.risk_counts[k]; });
              setRiskCounts(all);
            } else {
              computeReasonsAndRisks(sample);
            }
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message);
            console.error(err);
          } finally {
            setLoading(false);
          }
        }

        function getRiskLabelForRow(r) {
          if (!r) return null;
          var rl = r.RiskLevel || r.Risk || null;
          if (rl) return String(rl);
          if (r.RiskScore !== undefined && r.RiskScore !== null) {
            const mapNum = { 1: "Low", 2: "Low Medium", 3: "Medium", 4: "Medium High", 5: "High" };
            return mapNum[String(r.RiskScore)] || null;
          }
          if (r.AnomalyScore !== undefined && r.AnomalyScore !== null) {
            if (r.AnomalyScore >= 5) return "High";
            if (r.AnomalyScore >= 4) return "Medium High";
            if (r.AnomalyScore >= 3) return "Medium";
            if (r.AnomalyScore >= 2) return "Low Medium";
            return "Low";
          }
          return null;
        }

        function buildChart(rcounts) {
          var labels = RISK_LABELS;
          var values = labels.map(l => rcounts && rcounts[l] ? rcounts[l] : 0);
          var colors = labels.map(l => {
            if (selectedRiskFilter) {
              return (l === selectedRiskFilter) ? RISK_COLORS[l] : '#e6edf3';
            } else {
              return RISK_COLORS[l] || '#cccccc';
            }
          });

          var ctx = chartRef.current && chartRef.current.getContext ? chartRef.current.getContext('2d') : null;
          if (!ctx) return;
          try { if (chartInst.current) chartInst.current.destroy(); } catch (e) { }

          chartInst.current = new Chart(ctx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [{
                label: 'Flagged by Risk Level',
                data: values,
                borderColor: '#2563eb',
                backgroundColor: 'rgba(37,99,235,0.2)',
                fill: true,
                tension: 0.3,
                pointBackgroundColor: colors,
                pointRadius: 5,
                pointHoverRadius: 7
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: function (context) {
                      return context.parsed.y + ' cases';
                    }
                  }
                }
              },
              onClick: function (evt, elements) {
                if (elements && elements.length > 0) {
                  var idx = elements[0].index;
                  var label = this.data.labels[idx];
                  handleRiskBarClick(label);
                }
              },
              scales: {
                y: { beginAtZero: true, ticks: { precision: 0 } }
              }
            }
          });

        }

        useEffect(function () {
          buildChart(riskCounts);
        }, [riskCounts, selectedRiskFilter]);





        // Filtering & aggregation
        // Keep old filtering behaviour to produce 'filtered' (raw rows matching filters)
        var filtered = (rows || []).filter(function (r) {
          var hay = (sanitizeName(r) + " " + (r.EmployeeID || "") + " " + (r.CardNumber || "") + " " + (r.Reasons || r.DetectedScenarios || "")).toLowerCase();
          var textOk = !filterText || hay.indexOf(filterText.toLowerCase()) !== -1;
          var reasonOk = !selectedReason || (r.Reasons && ((";" + String(r.Reasons) + ";").indexOf(selectedReason) !== -1)) || (r.DetectedScenarios && ((";" + String(r.DetectedScenarios) + ";").indexOf(selectedReason) !== -1));
          var riskOk = true;
          if (selectedRiskFilter) {
            var rl = getRiskLabelForRow(r);
            if (!rl) { riskOk = false; }
            else riskOk = (String(rl) === String(selectedRiskFilter));
          }
          return textOk && reasonOk && riskOk;
        });

        // sort raw filtered (so aggregated picks same order for first-row)
        filtered.sort(function (a, b) {
          var va = Number(a.ViolationDaysLast90 || a.ViolationDaysLast_90 || 0);
          var vb = Number(b.ViolationDaysLast90 || b.ViolationDaysLast_90 || 0);
          if (isNaN(va)) va = 0;
          if (isNaN(vb)) vb = 0;
          if (vb !== va) return vb - va;
          return (sanitizeName(a) || "").localeCompare(sanitizeName(b) || "");
        });

        // AGGREGATION: group by EmployeeID / person_uid / fallback (name + card)
        function buildAggregated(rowsArr) {
          var map = new Map();
          rowsArr.forEach(function (r) {
            var id = r.EmployeeID || r.person_uid || (sanitizeName(r) + '|' + (r.CardNumber || r.Card || ''));
            var key = String(id);
            if (!map.has(key)) {
              map.set(key, {
                EmployeeName: sanitizeName(r),
                EmployeeID: r.EmployeeID || r.person_uid || "",
                CardNumber: r.CardNumber || r.Card || "",
                ViolationCount: 0,
                ReasonsSet: new Set(),
                ViolationDaysLast90: 0,
                FirstRow: r,
                _rows: []
              });
            }
            var agg = map.get(key);
            agg.ViolationCount += 1;
            agg._rows.push(r);
            // collect reasons
            var reasonsField = r.Reasons || r.DetectedScenarios || r.Detected || "";
            String(reasonsField).split(";").map(function (s) { return s.trim(); }).filter(Boolean).forEach(function (p) { agg.ReasonsSet.add(p); });
            // pick max ViolationDaysLast90 (representative)
            var v = Number(r.ViolationDaysLast90 || r.ViolationDaysLast_90 || r.ViolationDays || 0);
            if (!isNaN(v)) {
              agg.ViolationDaysLast90 = Math.max(agg.ViolationDaysLast90 || 0, v);
            }
          });

          var out = [];
          map.forEach(function (val, key) {
            out.push({
              EmployeeName: val.EmployeeName,
              EmployeeID: val.EmployeeID,
              CardNumber: val.CardNumber,
              ViolationCount: val.ViolationCount,
              Reasons: Array.from(val.ReasonsSet).join(";"),
              ViolationDaysLast90: val.ViolationDaysLast90,
              FirstRow: val.FirstRow,
              _rows: val._rows
            });
          });

          // sort aggregated by ViolationCount desc then name
          out.sort(function (a, b) {
            if (b.ViolationCount !== a.ViolationCount) return b.ViolationCount - a.ViolationCount;
            return (a.EmployeeName || "").localeCompare(b.EmployeeName || "");
          });

          return out;
        }

        // build aggregatedFiltered only if collapseDuplicates is enabled
        var aggregatedFiltered = collapseDuplicates ? buildAggregated(filtered) : null;

        // set up pagination source
        var sourceForPaging = collapseDuplicates ? (aggregatedFiltered || []) : filtered;

        var totalPages = Math.max(1, Math.ceil((sourceForPaging.length || 0) / pageSize));
        var pageRows = (sourceForPaging || []).slice((page - 1) * pageSize, page * pageSize);




        var totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
        var pageRows = filtered.slice((page - 1) * pageSize, page * pageSize);


        function exportFiltered() { downloadCSV(collapseDuplicates ? (aggregatedFiltered || []) : filtered, "trend_filtered_export.csv"); }


        function onReasonClick(reason) {
          if (!reason) { setSelectedReason(""); return; }
          if (selectedReason === reason) setSelectedReason(""); else setSelectedReason(reason);
          setPage(1);
        }





        async function openEvidence(row) {
          setModalRow(row);
          setModalDetails(null);
          setModalLoading(true);
          try {
            const q = encodeURIComponent(row.EmployeeID || row.person_uid || "");
            const resp = await fetch(API_BASE + "/record?employee_id=" + q);
            if (!resp.ok) { const txt = await resp.text(); throw new Error("record failed: " + resp.status + " - " + txt); }
            const js = await resp.json();

            // QUICK: set an explicit image_url if backend provided or build one from employee id
            const quickImageUrl = js.image_url || js.imageUrl || js.ImageUrl || null;
            const candidateId = (row && (row.EmployeeID || row.person_uid)) || null;
            const builtImage = quickImageUrl || (candidateId ? `/employee/${encodeURIComponent(candidateId)}/image` : null);

            // update modalRow immediately so UI renders email/image ASAP
            setModalRow(prev => Object.assign({}, prev || {}, {
              EmployeeEmail: prev && prev.EmployeeEmail ? prev.EmployeeEmail : (js.meta && (js.meta.email || js.meta.Email) ? (js.meta.email || js.meta.Email) : null),
              Email: prev && prev.Email ? prev.Email : (js.meta && (js.meta.email || js.meta.Email) ? (js.meta.email || js.meta.Email) : null),
              ImageUrl: builtImage || (prev && prev.ImageUrl) || null
            }));

            // Normalize details (keep aggregated_rows as array, raw_swipes as array)
            const details = {
              aggregated_rows: Array.isArray(js.aggregated_rows) ? js.aggregated_rows : (Array.isArray(js.sample) ? js.sample : []),
              raw_swipe_files: Array.isArray(js.raw_swipe_files) ? js.raw_swipe_files : (Array.isArray(js.files) ? js.files : []),
              raw_swipes: Array.isArray(js.raw_swipes) ? js.raw_swipes : []
            };
            setModalDetails(details);

            // Robustly extract email (check aggregated_rows -> raw_swipes -> modalRow)
            let newEmail = null;
            try {
              if (details.aggregated_rows && details.aggregated_rows.length) {
                const f = details.aggregated_rows[0];
                newEmail = newEmail || f.EmployeeEmail || f.Email || f.EmailAddress || f.WorkEmail || f.EMail || null;
              }
              if (!newEmail && details.raw_swipes && details.raw_swipes.length) {
                const r0 = details.raw_swipes[0];
                newEmail = newEmail || r0.EmployeeEmail || r0.Email || r0.EmailAddress || r0.WorkEmail || null;
              }
              // fallback to any meta in response
              if (!newEmail && js && js.meta && (js.meta.email || js.meta.Email)) {
                newEmail = js.meta.email || js.meta.Email;
              }
              // last fallback: original row (from table)
              if (!newEmail && row) {
                newEmail = row.EmployeeEmail || row.Email || null;
              }
            } catch (err) {
              // swallow - we'll just not show email if unavailable
            }

            // Also capture common fields (CardNumber etc.) from the first raw_swipe if missing
            let cardNum = null;
            try {
              if (details.aggregated_rows && details.aggregated_rows.length) {
                const f = details.aggregated_rows[0];
                cardNum = f.CardNumber || f.Card || null;
              }
              if (!cardNum && details.raw_swipes && details.raw_swipes.length) {
                const r0 = details.raw_swipes[0];
                cardNum = r0.CardNumber || r0.Card || null;
              }
            } catch (err) { }

            // Merge into modalRow (ensures UI re-render shows email/card)
            setModalRow(prev => Object.assign({}, prev || {}, {
              EmployeeEmail: newEmail || (prev && prev.EmployeeEmail) || null,
              Email: newEmail || (prev && prev.Email) || null,
              CardNumber: (prev && prev.CardNumber) || cardNum || null
            }));

          } catch (e) {
            alert("Failed loading details: " + e.message);
            console.error(e);
          } finally {
            setModalLoading(false);
          }
        }


        function closeModal() { setModalRow(null); setModalDetails(null); }

        // helper to render overlap
        function renderOverlapCell(r) {
          var ov = r.OverlapWith || r.swipe_overlap || r.overlap_with || null;
          if (ov && typeof ov === 'string') {
            var parts = ov.split(";").map(function (s) { return s.trim(); }).filter(Boolean);
            if (parts.length === 0) return <span className="muted">—</span>;
            return <span className="pill" title={ov}>{parts.length} overlap</span>;
          }
          return <span className="muted">—</span>;
        }

        function renderReasonChips(reasonText) {
          if (!reasonText) return <span className="muted">—</span>;
          const parts = String(reasonText).split(";").map(s => s.trim()).filter(Boolean);
          return parts.map((p, idx) => (<span key={idx} className="pill" title={SCENARIO_EXPLANATIONS[p] || p}>{p}</span>));
        }

        function renderReasonExplanations(reasonText) {
          if (!reasonText) return <div className="muted">No flags</div>;
          const parts = String(reasonText).split(";").map(s => s.trim()).filter(Boolean);
          return (
            <div>
              {parts.map((p, idx) => (
                <div key={idx} className="why-item" style={{ marginBottom: 8 }}>
                  <b>{p}</b>
                  <div className="small">{SCENARIO_EXPLANATIONS[p] || "No explanation available."}</div>
                </div>
              ))}
            </div>
          );
        }

        async function sendChat(qText, opts = { top_k: 5 }) {
          if (!qText || !qText.toString().trim()) return;
          const text = qText.toString().trim();
          pushChatMessage({ who: 'user', text });
          setChatInput("");
          setChatLoading(true);
          try {
            const payload = Object.assign({ q: text }, opts);
            const resp = await fetch(API_BASE + "/chatbot/query", {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            if (!resp.ok) {
              const t = await resp.text().catch(() => '');
              throw new Error("Server: " + resp.status + " " + t);
            }
            const js = await resp.json();
            const answer = js.answer || js.answer_text || js.result || "No answer returned.";
            const evidence = Array.isArray(js.evidence) ? js.evidence : (js.evidence ? [js.evidence] : []);
            pushChatMessage({ who: 'bot', text: answer, evidence });
          } catch (err) {
            pushChatMessage({ who: 'bot', text: "Error: " + err.message, evidence: [] });
            console.error("chat error", err);
          } finally {
            setChatLoading(false);
            setTimeout(() => {
              const el = document.querySelector('.chat-body');
              if (el) el.scrollTop = el.scrollHeight;
            }, 80);
          }
        }

        const QUICK_PROMPTS = [
          "Who is high risk today",
          "Who is low risk today",
          "Show me 320172 last 90 days",
          "Trend details for today — top reasons",
          "Explain repeated_short_breaks"
        ];
        function useQuickPrompt(q) {
          setChatOpen(true);
          sendChat(q);
        }

        // Swipe timeline rendering uses DAY_BOUNDARY_HOUR = 0 to match backend date assignment
        function renderSwipeTimeline(details, modalRow) {
          if (!details || !details.raw_swipes || details.raw_swipes.length === 0) {
            return <div className="muted">No raw swipe evidence available (person not flagged or raw file missing).</div>;
          }

          const all = details.raw_swipes.map(r => {
            const obj = Object.assign({}, r);
            try { obj.__ts = makeLocalDateFromRow(obj); } catch (e) { obj.__ts = null; }

            let gap = null;
            if (obj.SwipeGapSeconds !== undefined && obj.SwipeGapSeconds !== null) {
              gap = Number(obj.SwipeGapSeconds);
              if (isNaN(gap)) gap = null;
            } else if (obj.SwipeGap) {
              try {
                const parts = String(obj.SwipeGap).split(':').map(p => Number(p));
                if (parts.length === 3 && parts.every(p => !isNaN(p))) gap = parts[0] * 3600 + parts[1] * 60 + parts[2];
              } catch (e) { gap = null; }
            }
            obj.__gap = gap;
            obj.__zone_l = String((obj.Zone || '')).toLowerCase();

            // Prefer backend-provided date fields (DateOnly) or computed timestamp
            if (obj.__ts) {
              obj.__logical_date = logicalDateForTs(obj.__ts, DAY_BOUNDARY_HOUR);
            } else if (obj.DateOnly) {
              // DateOnly may be a string or object; coerce to YYYY-MM-DD
              obj.__logical_date = String(obj.DateOnly).slice(0, 10);
            } else if (obj.Date) {
              obj.__logical_date = String(obj.Date).slice(0, 10);
            } else {
              obj.__logical_date = null;
            }
            return obj;
          }).sort((a, b) => {
            // Primary sort: parsed timestamp if present
            if (a.__ts && b.__ts) return a.__ts - b.__ts;
            if (a.__ts) return -1;
            if (b.__ts) return 1;
            // Fallback: use DateOnly + Time or Date+Time strings
            const ka = (a.DateOnly || a.Date || '') + ' ' + (a.Time || '');
            const kb = (b.DateOnly || b.Date || '') + ' ' + (b.Time || '');
            return ka.localeCompare(kb);
          });

          // flags: dayStart for first row OR when logical date changes between rows
          const flags = new Array(all.length).fill(null).map(() => ({ dayStart: false, outReturn: false }));
          for (let i = 0; i < all.length; i++) {
            const cur = all[i];
            const prev = all[i - 1];
            const curDate = cur.__logical_date || (cur.DateOnly ? String(cur.DateOnly).slice(0, 10) : (cur.Date ? String(cur.Date).slice(0, 10) : null));
            const prevDate = prev ? (prev.__logical_date || (prev.DateOnly ? String(prev.DateOnly).slice(0, 10) : (prev.Date ? String(prev.Date).slice(0, 10) : null))) : null;
            if (!prev || prevDate !== curDate) {
              flags[i].dayStart = true;
            }
          }

          const OUT_RETURN_GAP_SECONDS = 60 * 60;
          for (let i = 0; i < all.length - 1; i++) {
            const a = all[i], b = all[i + 1];
            const aZone = a.__zone_l || ''; const bZone = b.__zone_l || ''; const bGap = b.__gap || 0;
            if (aZone.includes('out of office') || aZone.includes('out_of_office') || aZone.includes('out of')) {
              if (!bZone.includes('out of office') && (bGap >= OUT_RETURN_GAP_SECONDS || (bGap === null && aZone.includes('out')))) {
                flags[i].outReturn = true; flags[i + 1].outReturn = true;
              }
            }
          }

          for (let i = 0; i < all.length; i++) {
            if (flags[i].dayStart) {
              all[i].__gap = 0;
            }
          }

          return (
            <div className="table-scroll">
              <table className="evidence-table" role="table" aria-label="Swipe timeline">
                <thead>
                  <tr>
                    <th>Employee Name</th>
                    <th>Employee ID</th>
                    <th>Card</th>
                    <th>Date</th>
                    <th>Time</th>
                    <th>SwipeGap</th>
                    <th>Door</th>
                    <th>Direction</th>
                    <th>Zone</th>
                    <th>Note</th>
                  </tr>
                </thead>
                <tbody>
                  {all.map((rObj, idx) => {
                    const r = rObj || {};
                    const g = (r.__gap !== undefined && r.__gap !== null) ? Number(r.__gap) : null;
                    const isDayStart = flags[idx].dayStart;
                    const gapFormatted = (isDayStart)
                      ? formatSecondsToHmsJS(0)
                      : (
                        (r.SwipeGap && String(r.SwipeGap).trim())
                          ? String(r.SwipeGap)
                          : (g !== null && g !== undefined)
                            ? formatSecondsToHmsJS(g)
                            : "-"
                      );

                    // display date: prefer logical (backend date), then DateOnly, then Date
                    const displayDate = r.__logical_date || (r.DateOnly ? String(r.DateOnly).slice(0, 10) : (r.Date ? String(r.Date).slice(0, 10) : '-'));
                    const displayTime = r.Time || (r.__ts ? r.__ts.toTimeString().slice(0, 8) : '-');

                    const cls = [];
                    if (isDayStart) cls.push('row-day-start');
                    if (flags[idx].outReturn) cls.push('row-out-return');
                    const rowStyle = isDayStart ? { background: '#e6ffed' } : {};
                    let extraNote = "";
                    try {
                      const originalDate = r.Date ? String(r.Date).slice(0, 10) : null;
                      const logical = r.__logical_date || null;
                      if (originalDate && logical && originalDate !== logical) {
                        extraNote = `Orig: ${originalDate}`;
                        if ((String(r.Direction || '').toLowerCase().indexOf('out') !== -1)) {
                          extraNote += " — Out";
                        }
                      }
                    } catch (e) { extraNote = ""; }

                    return (
                      <tr key={idx} className={cls.join(' ')} style={rowStyle}>
                        <td className="small">{r.EmployeeName || '-'}</td>
                        <td className="small">{r.EmployeeID || '-'}</td>
                        <td className="small">{r.CardNumber || r.Card || '-'}</td>
                        <td className="small">{displayDate}</td>
                        <td className="small">{displayTime}</td>
                        <td className="small">{gapFormatted}</td>
                        <td className="small" style={{ minWidth: 160 }}>{r.Door || '-'}</td>
                        <td className="small">{r.Direction || '-'}</td>
                        <td className="small">{r.Zone || '-'}</td>
                        <td className="small">{r.Note || '-'}{r._source ? <span className="muted"> ({r._source})</span> : null}
                          {extraNote ? <div className="muted" style={{ fontSize: 11, marginTop: 4 }}>{extraNote}</div> : null}
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          );
        }

        function handleRiskBarClick(label) {
          if (!label) return;
          if (selectedRiskFilter === label) {
            setSelectedRiskFilter("");
          } else {
            setSelectedRiskFilter(label);
          }
          setPage(1);
        }

        function clearRiskFilter() {
          setSelectedRiskFilter("");
        }


        var rowsCount = (summary && typeof summary.rows === 'number') ? summary.rows : (rows ? rows.length : 0);

        // compute unique flagged persons (dedupe by same key used above)
        var _flaggedKeys = new Set();
        (rows || []).forEach(function (r) {
          if (r && (r.Reasons || r.DetectedScenarios)) {
            var k = r.EmployeeID || r.person_uid || (sanitizeName(r) + '|' + (r.CardNumber || r.Card || ''));
            if (!k) k = JSON.stringify(r);
            _flaggedKeys.add(k);
          }
        });
        var flaggedCount = (summary && typeof summary.flagged_rows === 'number' && summary.flagged_rows > 0) ? summary.flagged_rows : _flaggedKeys.size;

        var flaggedPct = rowsCount ? Math.round((flaggedCount * 100) / (rowsCount || 1)) : 0;



        // helper to get display label for current region
        function regionDisplayLabel(key) {
          if (!key) return '';
          return (REGION_OPTIONS[key] && REGION_OPTIONS[key].label) ? REGION_OPTIONS[key].label : key.toUpperCase();
        }

        return (
          <div className="container" aria-live="polite">
            {loading && (
              <div className="spinner-overlay" role="status" aria-label="Loading">
                <div className="spinner-box">
                  <div className="spinner" />
                  <div style={{ fontWeight: 700 }}>Loading…</div>
                </div>
              </div>
            )}

            <div className="topbar" role="banner">
              <div className="wu-brand" aria-hidden={false}>
                <div className="wu-logo">WU</div>
                <div className="title-block">
                  <h1>Western Union — Trend Analysis</h1>
                  <p style={{ margin: 0, fontSize: 13 }}>
                    {regionDisplayLabel(selectedRegion)} {selectedLocation && selectedLocation !== "All locations" ? "— " + selectedLocation : ""}
                  </p>
                </div>
              </div>

              <div className="header-actions" role="region" aria-label="controls">
                <div className="control">
                  <label className="small" htmlFor="fromDate">From</label>
                  <input id="fromDate" ref={fromRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                </div>

                <div className="control">
                  <label className="small" htmlFor="toDate">To</label>
                  <input id="toDate" ref={toRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                </div>

                <button className="btn-primary" onClick={runForRange} disabled={loading}>Run</button>
                <button className="btn-ghost" onClick={loadLatest} disabled={loading}>Load latest</button>
              </div>
            </div>

            <div className="card-shell">
              <div className="cards" aria-hidden={loading}>
                <div className="card" title="Rows analysed">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{(rowsCount !== undefined && rowsCount !== null) ? rowsCount.toLocaleString() : 0}</h3>
                      <p>Rows analysed</p>
                    </div>
                  </div>
                </div>
                <div className="card card-flagged" title="Flagged rows">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{(flaggedCount !== undefined && flaggedCount !== null) ? flaggedCount.toLocaleString() : 0}</h3>
                      <p>Flagged rows</p>
                    </div>
                  </div>
                </div>
                <div className="card card-rate" title="Flagged rate">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{flaggedPct}%</h3>
                      <p>Flagged rate</p>
                    </div>
                  </div>
                </div>
              </div>

              <div className="main">
                <div className="left">
                  <div className="chart-wrap" aria-label="Risk level chart">
                    <canvas ref={chartRef}></canvas>
                  </div>




                  <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginTop: 6 }}>
                    <input placeholder="Search name, employee id, card or reason..." value={filterText} onChange={function (e) { setFilterText(e.target.value); setPage(1); }} style={{ flex: 1, padding: 10, borderRadius: 6, border: '1px solid #e6edf3' }} />

                    <label style={{ display: 'flex', alignItems: 'center', gap: 8, marginRight: 8 }}>
                      <input type="checkbox" checked={collapseDuplicates} onChange={(e) => { setCollapseDuplicates(e.target.checked); setPage(1); }} />
                      <span className="small muted">Collapse duplicates</span>
                    </label>

                    <div className="muted">
                      Showing {collapseDuplicates ? (Array.isArray(aggregatedFiltered) ? aggregatedFiltered.length : filtered.length) : filtered.length} / {rows.length} rows
                    </div>

                    <button className="small-button" onClick={exportFiltered}>Export filtered</button>
                    {selectedRiskFilter ? <button className="small-button" onClick={clearRiskFilter}>Clear risk filter</button> : null}
                  </div>



                  <div style={{ marginTop: 10 }} className="table-scroll" role="region" aria-label="results table">
                    <table>
                      <thead>
                        <tr>
                          <th>Employee</th>
                          <th className="small">ID</th>
                          <th className="small">Card</th>
                          <th className="small">Date</th>
                          <th className="small">Duration</th>
                          <th className="small">ViolationDaysLast90</th>
                          <th className="small">Reasons</th>
                          <th className="small">Evidence</th>
                        </tr>
                      </thead>
                      <tbody>



                        {pageRows.map(function (r, idx) {
                          // if aggregated mode, r will be aggregated object (has ViolationCount and FirstRow/_rows)
                          var isAgg = collapseDuplicates && r && r.ViolationCount !== undefined;
                          var displayRow = isAgg ? r.FirstRow : r; // use FirstRow for details/evidence
                          var empName = isAgg ? (r.EmployeeName || sanitizeName(displayRow)) : sanitizeName(r);
                          var empId = isAgg ? (r.EmployeeID || displayRow.EmployeeID || "") : (r.EmployeeID || "");
                          var card = isAgg ? (r.CardNumber || displayRow.CardNumber || "") : (r.CardNumber || "");
                          var displayDate = safeDateDisplay(displayRow.DisplayDate || displayRow.Date || displayRow.DateOnly || displayRow.FirstSwipe || displayRow.LastSwipe);

                          var durText = (displayRow.Duration)
                            || (displayRow.DurationSeconds ? formatSecondsToHmJS(Number(displayRow.DurationSeconds))
                              : (displayRow.DurationMinutes ? formatSecondsToHmJS(Number(displayRow.DurationMinutes) * 60) : ""));

                          var reasonsText = isAgg ? (r.Reasons || displayRow.Reasons || displayRow.DetectedScenarios) : (r.Reasons || r.DetectedScenarios);

                          return (
                            <tr key={idx} className={(displayRow.Reasons && String(displayRow.Reasons).trim()) ? "flagged-row" : ""}>
                              <td className="row-click" onClick={function () { openEvidence(displayRow); }}>
                                {empName || <span className="muted">—</span>}
                                {isAgg ? <div className="small muted" style={{ marginTop: 4 }}>violation Count - {r.ViolationCount}</div> : null}
                              </td>
                              <td className="small">{empId}</td>
                              <td className="small">{card}</td>
                              <td className="small">{displayDate}</td>
                              <td className="small">{isAgg ? (displayRow.Duration || (displayRow.DurationSeconds ? formatSecondsToHmJS(Number(displayRow.DurationSeconds)) : "-")) : durText}</td>
                              <td className="small">
                                {(isAgg && r.ViolationDaysLast90 !== undefined && r.ViolationDaysLast90 !== null)
                                  ? String(r.ViolationDaysLast90)
                                  : ((displayRow.ViolationDaysLast90 !== undefined && displayRow.ViolationDaysLast90 !== null && displayRow.ViolationDaysLast90 !== "")
                                    ? (Number(displayRow.ViolationDaysLast90).toString())
                                    : ((displayRow.ViolationDaysLast_90 !== undefined && displayRow.ViolationDaysLast_90 !== null && displayRow.ViolationDaysLast_90 !== "")
                                      ? String(displayRow.ViolationDaysLast_90)
                                      : ((displayRow.ViolationDays !== undefined && displayRow.ViolationDays !== null) ? String(displayRow.ViolationDays) : "")
                                    )
                                  )
                                }
                              </td>
                              <td className="small">{renderReasonChips(reasonsText)}</td>
                              <td className="small">
                                <button className="evidence-btn" onClick={function () { openEvidence(displayRow); }}>Evidence</button>
                                {isAgg ? <span className="muted" style={{ marginLeft: 8 }}>({r.ViolationCount} rows)</span> : null}
                              </td>
                            </tr>
                          );
                        })}

                      </tbody>
                    </table>
                  </div>

                  <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginTop: 10 }}>
                    <button onClick={function () { setPage(function (p) { return Math.max(1, p - 1); }); }} disabled={page <= 1}>Prev</button>
                    <div className="muted">Page {page} / {totalPages}</div>
                    <button onClick={function () { setPage(function (p) { return Math.min(totalPages, p + 1); }); }} disabled={page >= totalPages}>Next</button>
                  </div>
                </div>

                <aside className="right" aria-label="side panel">

                  {/* NEW: Region & Location controls */}
                  <div className="sidebar-section" style={{ marginBottom: 12 }}>
                    <strong>Risk filters</strong>
                    <div className="small muted" style={{ marginTop: 6 }}>Select Region and Location to scope the run.</div>

                    <div style={{ display: 'flex', gap: 8, marginTop: 8, alignItems: 'center' }}>
                      <div style={{ flex: 1 }}>
                        <label className="small">Region</label>
                        <select
                          value={selectedRegion}
                          onChange={(e) => { setSelectedRegion(e.target.value); setPage(1); }}
                          style={{ width: '100%', padding: '6px 8px', borderRadius: 6, border: '1px solid #e2e8f0' }}
                        >
                          {Object.keys(REGION_OPTIONS).map(k => (
                            <option key={k} value={k}>{REGION_OPTIONS[k].label}</option>
                          ))}
                        </select>
                      </div>

                      <div style={{ flex: 1 }}>
                        <label className="small">Location</label>
                        <select
                          value={selectedLocation}
                          onChange={(e) => { setSelectedLocation(e.target.value); setPage(1); }}
                          style={{ width: '100%', padding: '6px 8px', borderRadius: 6, border: '1px solid #e2e8f0' }}
                        >
                          <option key="__all" value="All locations">All locations</option>
                          {(REGION_OPTIONS[selectedRegion] && REGION_OPTIONS[selectedRegion].partitions || []).map(loc => (
                            <option key={loc} value={loc}>{loc}</option>
                          ))}
                        </select>
                      </div>
                    </div>
                  </div>

                  {/* existing risk chips */}
                  <div className="sidebar-section">
                    <div className="risk-filter-list" style={{ marginTop: 8 }}>
                      {RISK_LABELS.map((lab) => {
                        const cnt = (riskCounts && riskCounts[lab]) ? riskCounts[lab] : 0;
                        const active = selectedRiskFilter === lab;
                        return (
                          <div key={lab} role="button" tabIndex={0} aria-pressed={active} className={"risk-chip " + (active ? "active" : "")} onClick={function () { handleRiskBarClick(lab); }} onKeyDown={function (e) { if (e.key === 'Enter' || e.key === ' ') { handleRiskBarClick(lab); } }}>
                            <div style={{ width: 10, height: 10, borderRadius: 999, background: RISK_COLORS[lab], boxShadow: '0 2px 6px rgba(0,0,0,0.08)' }}></div>
                            <div style={{ fontSize: 13 }}>{lab} <span className="muted" style={{ marginLeft: 6 }}>({cnt})</span></div>
                          </div>
                        );
                      })}
                    </div>

                    <div style={{ marginTop: 8 }}>
                      <button className="small-button" onClick={clearRiskFilter}>Clear risk filter</button>
                    </div>
                  </div>

                  <div className="sidebar-section" style={{ marginTop: 12 }}>
                    <strong>Top reasons summary</strong>
                    <div className="small muted" style={{ marginTop: 6 }}>Click a reason to filter the table by that reason. Click again to clear.</div>

                    <div style={{ marginTop: 8, display: 'flex', gap: 8 }}>
                      <input placeholder="Filter reason list..." value={reasonFilterText} onChange={function (e) { setReasonFilterText(e.target.value); }} style={{ flex: 1, padding: '6px 8px', borderRadius: 6, border: '1px solid #e2e8f0' }} />
                      <button className="small-button" onClick={function () { setSelectedReason(''); setReasonFilterText(''); }}>Clear</button>
                    </div>

                    <div style={{ marginTop: 8, maxHeight: 320, overflow: 'auto' }}>
                      {Object.keys(reasonsCount).length === 0 && <div className="muted">No flags found</div>}
                      {Object.entries(reasonsCount).sort(function (a, b) { return b[1] - a[1]; }).filter(function (kv) {
                        var name = kv[0];
                        if (!reasonFilterText) return true;
                        return name.toLowerCase().indexOf(reasonFilterText.toLowerCase()) !== -1;
                      }).slice(0, 50).map(function (kv) {
                        var name = kv[0], count = kv[1];
                        var active = selectedReason === name;
                        return (
                          <div key={name} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 8, marginBottom: 6 }}>
                            <button className={"chip " + (active ? "active" : "")} style={{ textAlign: 'left', flex: 1 }} onClick={function () { onReasonClick(name); }}>
                              {name}
                            </button>
                            <div style={{ minWidth: 48, textAlign: 'right' }} className="small"><b>{count}</b></div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </aside>
              </div>
            </div>




            {modalRow &&
              <div className="modal" onClick={closeModal}>
                <div className="modal-inner" onClick={function (e) { e.stopPropagation(); }}>
                  <div className="modal-header">
                    <div className="header-content">
                      <div className="header-icon">
                        <i className="bi bi-clipboard2-data-fill"></i>
                      </div>
                      <div className="header-text">
                        <h3>Details — Evidence</h3>
                        <div className="header-subtitle small">Evidence & explanation for selected row</div>
                      </div>
                    </div>
                    <button className="close-btn" onClick={closeModal}>
                      <i className="bi bi-x-lg"></i>
                      Close
                    </button>
                  </div>
                  <div className="modal-body">
                    {modalLoading && (
                      <div className="loading-state">
                        <div className="loading-spinner"></div>
                        <span>Loading evidence…</span>
                      </div>
                    )}
                    <div className="modal-top" role="region" aria-label="evidence summary">
                      <div className="image-section">
                        <div className="image-container">
                          <div className="multi-color-border">
                            <div className="color-ring color-1"></div>
                            <div className="color-ring color-2"></div>
                            <div className="color-ring color-3"></div>
                            <div className="color-ring color-4"></div>
                            <div className="image-content">







                              {/* Improved modal image block — prefer ObjectID/GUID and try more fallbacks */}

                              {(modalDetails && ((modalDetails.aggregated_rows && modalDetails.aggregated_rows.length > 0) || (modalDetails.raw_swipes && modalDetails.raw_swipes.length > 0))) ? (

                                (() => {
                                  // helper: candidate image key names (same as before)
                                  const candidateImageKeys = ['imageUrl', 'image_url', 'ImageUrl', 'image', 'Image', 'img', 'imgUrl', 'ImagePath', 'Photo', 'PhotoUrl', 'EmployeePhoto', 'photo', 'photoUrl'];

                                  // pick first md (aggregated/raw) row if exists
                                  const md = (modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0])
                                    || (modalDetails && modalDetails.raw_swipes && modalDetails.raw_swipes[0])
                                    || {};

                                  // try to obtain an explicit image path from md first
                                  let imgPath = candidateImageKeys.map(k => (md && md[k]) ? md[k] : null).find(Boolean) || null;

                                  // if not present yet, use any image_url included in full record response (js.image_url -> set below in openEvidence)
                                  if (!imgPath && modalRow && modalRow.ImageUrl) {
                                    imgPath = modalRow.ImageUrl;
                                  }

                                  // Build ordered id candidates preferring modalRow
                                  const idCandidates = [];
                                  if (modalRow && modalRow.EmployeeID) idCandidates.push(String(modalRow.EmployeeID));
                                  if (modalRow && modalRow.person_uid) idCandidates.push(String(modalRow.person_uid));
                                  if (md && md.EmployeeID) idCandidates.push(String(md.EmployeeID));
                                  if (md && md.person_uid) idCandidates.push(String(md.person_uid));
                                  if (md && md.ObjectID) idCandidates.push(String(md.ObjectID));
                                  if (md && md.GUID) idCandidates.push(String(md.GUID));

                                  const uniqIds = idCandidates.filter((v, i) => v && idCandidates.indexOf(v) === i);

                                  // If still no explicit path, build a likely image endpoint from the top id candidate
                                  if (!imgPath && uniqIds.length) {
                                    imgPath = `/employee/${encodeURIComponent(uniqIds[0])}/image`;
                                  }

                                  if (imgPath) {
                                    const imgSrc = resolveApiImageUrl(imgPath) || imgPath;
                                    return (
                                      <img
                                        className="modal-image"
                                        src={imgSrc}
                                        alt={sanitizeName(modalRow) || "Employee image"}
                                        onLoad={(e) => { try { console.info("employee image loaded:", e.target.src); } catch (e) { } }}
                                        onError={async (e) => {
                                          try {
                                            e.target.onerror = null;
                                            console.warn("image load failed for:", e.target.src);

                                            // cache-busted retry + API variants for all uniqIds
                                            const tryUrls = [];
                                            const original = e.target.src;
                                            tryUrls.push(original + (original.indexOf('?') === -1 ? '?cb=' + Date.now() : '&cb=' + Date.now()));
                                            uniqIds.forEach(id => {
                                              if (!id) return;
                                              const a = resolveApiImageUrl(`/api/employees/${encodeURIComponent(id)}/image`);
                                              const b = resolveApiImageUrl(`/employee/${encodeURIComponent(id)}/image`);
                                              if (a && tryUrls.indexOf(a) === -1) tryUrls.push(a);
                                              if (b && tryUrls.indexOf(b) === -1) tryUrls.push(b);
                                            });

                                            let found = null;
                                            for (const url of tryUrls) {
                                              try {
                                                const getr = await fetch(url, { method: 'GET', cache: 'no-store' });
                                                if (getr && getr.ok) {
                                                  const ct = (getr.headers.get('content-type') || '').toLowerCase();
                                                  if (ct.startsWith('image')) { found = url; break; }
                                                }
                                              } catch (err) { /* ignore */ }
                                            }

                                            if (found) {
                                              e.target.src = found + (found.indexOf('?') === -1 ? ('?cb=' + Date.now()) : ('&cb=' + Date.now()));
                                              return;
                                            }

                                            // final fallback SVG
                                            const svg = '<svg xmlns="http://www.w3.org/2000/svg" width="160" height="160"><rect fill="#eef2f7" width="100%" height="100%"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#64748b" font-size="18">No image</text></svg>';
                                            e.target.src = 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
                                          } catch (err) {
                                            try { e.target.style.display = 'none'; } catch (err2) { }
                                            console.error("image fallback error", err);
                                          }
                                        }}
                                      />
                                    );
                                  } else {
                                    // no id/path available -> simple placeholder (unchanged)
                                    return (
                                      <div className="modal-image-placeholder">
                                        <i className="bi bi-person-square"></i>
                                        <span>No image</span>
                                      </div>
                                    );
                                  }
                                })()

                              ) : (
                                <div className="modal-image-placeholder">
                                  <i className="bi bi-person-square"></i>
                                  <span>No image</span>
                                </div>

                              )}

                            </div>
                          </div>
                        </div>
                      </div>

                      <div className="modal-details">
                        <div className="details-header">
                          <div className="emp-info">
                            <div className="emp-name">
                              {sanitizeName(modalRow) || "—"}
                              <span
                                className="risk-badge"
                                style={{
                                  marginLeft: "12px",
                                  background:
                                    RISK_COLORS[modalRow.RiskLevel] ||
                                    RISK_COLORS[getRiskLabelForRow(modalRow)] ||
                                    RISK_COLORS["Low"],
                                }}
                              >
                                {modalRow.RiskLevel ||
                                  (modalRow.RiskScore ? "Score " + modalRow.RiskScore : "Low")}
                              </span>
                            </div>
                            <div className="emp-badge">
                              <i className="bi bi-person-badge"></i>
                              ID: {modalRow.EmployeeID || "—"}
                            </div>
                          </div>
                        </div>
                        <div className="details-grid">
                          <div className="detail-item">
                            <div className="detail-icon">
                              <i className="bi bi-credit-card"></i>
                            </div>
                            <div className="detail-content">
                              <label>Card Number</label>
                              <span>{modalRow.CardNumber || "—"}</span>
                            </div>
                          </div>
                          <div className="detail-item">
                            <div className="detail-icon">
                              <i className="bi bi-envelope"></i>
                            </div>
                            <div className="detail-content">
                              <label>EmployeeEmail</label>

                              <span>
                                {(
                                  // prefer aggregated_rows[0], then raw_swipes[0], then modalRow
                                  (modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0] && (modalDetails.aggregated_rows[0].EmployeeEmail || modalDetails.aggregated_rows[0].Email))
                                  || (modalDetails && modalDetails.raw_swipes && modalDetails.raw_swipes[0] && (modalDetails.raw_swipes[0].EmployeeEmail || modalDetails.raw_swipes[0].Email))
                                  || modalRow.EmployeeEmail
                                  || modalRow.Email
                                  || (modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0] && (modalDetails.aggregated_rows[0].WorkEmail || modalDetails.aggregated_rows[0].EMail))
                                ) ? (
                                  (modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0] && (modalDetails.aggregated_rows[0].EmployeeEmail || modalDetails.aggregated_rows[0].Email))
                                  || (modalDetails && modalDetails.raw_swipes && modalDetails.raw_swipes[0] && (modalDetails.raw_swipes[0].EmployeeEmail || modalDetails.raw_swipes[0].Email))
                                  || modalRow.EmployeeEmail
                                  || modalRow.Email
                                  || (modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0] && (modalDetails.aggregated_rows[0].WorkEmail || modalDetails.aggregated_rows[0].EMail))
                                ) : <span className="muted">—</span>}
                              </span>





                            </div>
                          </div>
                          <div className="detail-item">
                            <div className="detail-icon">
                              <i className="bi bi-calendar-date"></i>
                            </div>
                            <div className="detail-content">
                              <label>Date</label>
                              <span>{safeDateDisplay(modalRow.DisplayDate || modalRow.Date || modalRow.DateOnly || modalRow.FirstSwipe)}</span>
                            </div>
                          </div>
                          <div className="detail-item">
                            <div className="detail-icon">
                              <i className="bi bi-clock"></i>
                            </div>
                            <div className="detail-content">
                              <label>Duration</label>

                              <span className="duration-badge">
                                {modalRow.Duration
                                  || (modalRow.DurationSeconds ? formatSecondsToHmJS(Number(modalRow.DurationSeconds))
                                    : (modalRow.DurationMinutes ? formatSecondsToHmJS(Number(modalRow.DurationMinutes) * 60) : "—"))}
                              </span>


                            </div>
                            <div style={{ marginTop: 8, textAlign: 'right' }}>
                              <div className="muted">Violation days (90d)</div>
                              <div style={{ fontWeight: 700 }}>
                                {(modalRow.ViolationDaysLast90 !== undefined && modalRow.ViolationDaysLast90 !== null)
                                  ? modalRow.ViolationDaysLast90
                                  : 0}
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>

                      <div className="modal-reasons">
                        <div className="explanation-section" style={{ marginTop: 12 }}>
                          <div style={{ fontWeight: 700 }}>Explanation</div>
                          <div style={{
                            marginTop: 8,
                            maxHeight: 160,
                            overflow: 'auto',
                            background: '#fff',
                            border: '1px solid #eef2f7',
                            padding: 8,
                            borderRadius: 6
                          }}>
                            {(modalRow.Explanation || modalRow.ViolationExplanation)
                              ? <div style={{ whiteSpace: 'pre-wrap' }}>{modalRow.Explanation || modalRow.ViolationExplanation}</div>
                              : <div className="muted">No explanation provided.</div>}

                          </div>
                        </div>
                        <div className="reasons-section">
                          <div className="section-title">
                            <i className="bi bi-list-check"></i>
                            Reasons Flagged
                          </div>
                          <div className="reasons-list">
                            {renderReasonChips(modalRow.Reasons || modalRow.DetectedScenarios)}
                          </div>
                        </div>
                      </div>
                    </div>

                    <div className="evidence-section">
                      <div className="section-header">
                        <i className="bi bi-folder2-open"></i>
                        <h4>Available Evidence Files</h4>
                      </div>
                      <div className="files-container">
                        {modalDetails && modalDetails.raw_swipe_files && modalDetails.raw_swipe_files.length > 0 ? (
                          <div className="files-list">
                            {modalDetails.raw_swipe_files.map((f, i) => (
                              <div key={i} className="file-item">
                                <i className="bi bi-file-earmark-text"></i>
                                <span className="file-name">{f}</span>
                                <button
                                  className="download-btn"
                                  onClick={function () { window.location = API_BASE + "/swipes/" + encodeURIComponent(f); }}
                                >
                                  <i className="bi bi-download"></i>
                                  Download
                                </button>
                              </div>
                            ))}
                          </div>
                        ) : (
                          <div className="no-files">
                            <i className="bi bi-folder-x"></i>
                            <span>No raw swipe files found for this person/date.</span>
                          </div>
                        )}
                      </div>
                    </div>

                    <div className="timeline-section">
                      <div className="section-header">
                        <i className="bi bi-clock-history"></i>
                        <h4>Swipe Timeline</h4>
                        <span className="subtitle">Filtered for this person/date</span>
                      </div>
                      <div className="timeline-content">
                        {modalDetails ? renderSwipeTimeline(modalDetails, modalRow) : (
                          <div className="loading-timeline">
                            <i className="bi bi-hourglass-split"></i>
                            <span>Evidence not loaded yet.</span>
                          </div>
                        )}
                      </div>
                    </div>

                    <div className="raw-json-section">
                      <label className="toggle-label">
                        <input
                          type="checkbox"
                          id="showraw"
                          onChange={function (e) {
                            const el = document.getElementById('rawpayload');
                            if (el) el.style.display = e.target.checked ? 'block' : 'none';
                          }}
                        />
                        <span className="toggle-slider"></span>
                        <span className="toggle-text">
                          <i className="bi bi-code-slash"></i>
                          Show raw aggregated JSON
                        </span>
                      </label>
                      <div id="rawpayload" className="raw-json" style={{ display: 'none' }}>
                        <pre>{JSON.stringify(modalRow, null, 2)}</pre>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            }

            <button className="chat-fab" title="Ask Trend Details (Ask Me )" onClick={() => setChatOpen(true)} aria-label="Open chat">
              <span className="meta-icon"><img src="chat-bot.png" alt="" /></span>
            </button>


            {chatOpen && (
              <div className="chat-modal" role="dialog" aria-modal="true" aria-label="Trend Chatbot">
                <div className="chat-header">
                  <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                    <div style={{ width: 36, height: 36, borderRadius: 8, background: '#', display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#2563eb', fontWeight: 800 }}><img src="chat-bot.png" alt="" style={{ width: 36, height: 36, }} /></div>
                    <div>
                      <div className="title">Ask me — Trend Details</div>
                      <div style={{ fontSize: 12, opacity: 0.85 }}>Ask trend & risk questions</div>
                    </div>
                  </div>
                  <div style={{ marginLeft: 'auto' }}>
                    <button className="small-button bot-close" onClick={() => { setChatOpen(false); }}>Close</button>
                  </div>
                </div>

                <div className="chat-body">
                  {chatMessages.length === 0 && (
                    <div style={{ color: '#64748b', fontSize: 13 }}>
                      Hi — ask about trends (e.g. "Who is high risk today"). Use the quick prompts below.
                    </div>
                  )}
                  {chatMessages.map((m, i) => (
                    <div key={i} style={{ display: 'block' }}>
                      <div className={"chat-bubble " + (m.who === 'user' ? 'user' : 'bot')}>
                        {m.text}
                        {m.who === 'bot' && m.evidence && m.evidence.length > 0 && (
                          <div className="chat-evidence">
                            <strong>Evidence</strong>
                            <div style={{ marginTop: 6 }}>{m.evidence.slice(0, 5).map((e, j) => (<div key={j}>{typeof e === 'string' ? e : JSON.stringify(e)}</div>))}</div>
                          </div>
                        )}
                      </div>
                    </div>
                  ))}

                  {chatLoading && <div className="chat-loading" style={{ marginTop: 6 }}>Thinking…</div>}
                  <div style={{ marginTop: 8 }} className="quick-prompts" aria-hidden={chatLoading}>
                    {QUICK_PROMPTS.map((q, idx) => (
                      <button key={idx} onClick={() => useQuickPrompt(q)} disabled={chatLoading}>{q}</button>
                    ))}
                  </div>
                </div>

                <div className="chat-input-row">
                  <input
                    className="chat-input"
                    placeholder="Type a question, e.g. 'Who is high risk today'…"
                    value={chatInput}
                    onChange={(e) => setChatInput(e.target.value)}
                    onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChat(chatInput); } }}
                  />
                  <button className="chat-send-btn" onClick={() => sendChat(chatInput)} disabled={chatLoading}>Send</button>
                </div>
              </div>
            )}

          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(App));
    })();
  </script>
</body>

</html>











C:\Users\W0024618\Desktop\Trend Analysis\frontend\style.css



    /* ---------- Global ---------- */
    :root {
      --wu-yellow: #ffd400;
      --wu-black: #0a0a0a;
      --card-bg: #ffffff;
      --muted: #64748b;
      --accent: #2563eb;
      --panel: #f7fafc;
      --pill-bg: #eef6ff;
      --pill-text: #0b4f7a;
    }

    html,
    body {
      height: 100%;
    }

    body {
      font-family: Inter, Roboto, Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #f6f7fb;
      color: #1f2937;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .container {
      max-width: 1250px;
      margin: 12px auto;
      padding: 0;
    }

    /* ---------- Header (Western Union look) ---------- */
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      /* background: linear-gradient(90deg, #111 0%, #000 30%); */
      background: linear-gradient(90deg,#0f172a,#2563eb);
      color: var(--wu-yellow);
      padding: 12px 16px;
      /* border-radius: 8px 8px 0 0; */
      box-shadow: 0 8px 24px rgba(2, 6, 23, 0.18);
      gap: 12px;
      flex-wrap: wrap;
    }

    .wu-brand {
      display: flex;
      gap: 12px;
      align-items: center;
      min-width: 0;
    }

    .wu-logo {
      width: 54px;
      height: 34px;
      background: var(--wu-yellow);
      color: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      border-radius: 4px;
      box-shadow: inset 0 -2px 0 rgba(0, 0, 0, 0.08);
      font-family: "Helvetica Neue", Arial, sans-serif;
      flex-shrink: 0;
    }

    .title-block {
      line-height: 1;
      min-width: 0;
    }

    .title-block h1 {
      margin: 0;
      font-size: 18px;
      color: var(--wu-yellow);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 260px;
    }

    .title-block p {
      margin: 0;
      color: #e6e6e6;
      font-size: 13px;
    }

    .header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-left: auto;
      flex-wrap: wrap;
    }

    .header-actions .control {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .header-actions .control label {
      color: #e7e7e7;
      font-size: 13px;
      margin-right: 4px;
      white-space: nowrap;
    }

    .date-input {
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: transparent;
      color: #fff;
      min-width: 130px;
    }

    .header-actions button {
      padding: 8px 12px;
      border-radius: 6px;
      border: 0;
      font-weight: 600;
      cursor: pointer;
    }

    .btn-primary {
      background: var(--wu-yellow);
      color: var(--wu-black);
    }

    .btn-ghost {
      background: transparent;
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    
    .cards {
      display: flex;
      gap: 16px;
      margin: 8px 0 12px 0;
      padding: 8px 0;
      align-items: stretch;
    }

    .card {
      flex: 1;
      background: linear-gradient(135deg, #f7f4f4 0%, #f7f7f9 100%);
      padding: 20px;
      border-radius: 12px;

      box-shadow:
        0 4px 12px rgba(16, 24, 40, 0.05),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
      min-width: 200px;
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow:
        0 8px 24px rgba(16, 24, 40, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
      border-color: rgba(255, 212, 66, 0.3);
    }

    .card-content {
      display: flex;
      align-items: center;
      gap: 16px;
      height: 100%;
    }



    .card-icon i {
      font-size: 24px;
    }

    .card-flagged .card-icon {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      box-shadow: 0 4px 12px rgba(245, 87, 108, 0.3);
    }

    .card-rate .card-icon {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      box-shadow: 0 4px 12px rgba(79, 172, 254, 0.3);
    }

    .card-text {
      text-align: center;
      flex: 1;
    }

    .card h3 {
      margin: 0 0 4px 0;
      font-size: 28px;
      font-weight: 700;
      color: #0f172a;
      letter-spacing: -0.5px;
      line-height: 1.2;
    }

    .card p {
      margin: 0;
      color: #64748b;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.2px;
    }

    .card-gradient {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 4px;
      /* background: linear-gradient(90deg, #667eea, #764ba2); */
      opacity: 0.8;
      transition: all 0.3s ease;
    }




    /* Responsive design */
    @media (max-width: 768px) {
      .cards {
        flex-direction: column;
        gap: 12px;
      }

      .card {
        min-width: auto;
      }

      .card-content {
        gap: 12px;
      }

      .card-icon {
        width: 48px;
        height: 48px;
      }

      .card-icon i {
        font-size: 20px;
      }

      .card h3 {
        font-size: 24px;
      }
    }

    .main {
      display: flex;
      gap: 14px;
      margin-top: 6px;
      padding-bottom: 18px;
    }

    .left {
      flex: 2;
      background: transparent;
      padding-right: 6px;
    }

    .right {
      flex: 1;
      min-width: 260px;
    }

    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .date-input::-webkit-calendar-picker-indicator {
      display: none;
    }

    /* ---------- Chart ---------- */
    .chart-wrap {
      background: #fff;
      padding: 10px;
      border-radius: 8px;
      box-shadow: inset 0 0 0 1px #f1f5f9;
      height: 260px;
      margin-bottom: 10px;
    }

    /* ---------- Table ---------- */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      background: #fff;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(2, 6, 23, 0.03);
    }

    thead th {
      padding: 10px 8px;
      font-weight: 700;
      font-size: 13px;
      background: linear-gradient(90deg, #fff, #fbfbfb);
      border-bottom: 3px solid #e2e8f0;
      text-align: left;
    }

    tbody td {
      padding: 8px;
      border-bottom: 1px solid #f1f5f9;
      font-size: 13px;
      color: #0f172a;
      vertical-align: middle;
    }

    .small {
      font-size: 12px;
      color: var(--muted);
    }

    .row-click {
      cursor: pointer;
      color: #0f172a;
    }

    .flagged-row {
      background: linear-gradient(90deg, #fff8f0, #fff);
    }









    /* ---------- Chips & reasons ---------- */
    .pill {
      display: inline-block;
      padding: 4px 6px;
      border-radius: 999px;
      background: var(--pill-bg);
      color: var(--pill-text);
      font-size: 11px;
      cursor: pointer;
      margin: 3px 6px 3px 0;
      border: 1px solid rgba(2, 80, 160, 0.06);
      box-shadow: 0 1px 6px rgba(2, 80, 160, 0.03);
    }

    .chip {
      display: inline-block;
      padding: 5px 8px;
      border-radius: 999px;
      background: #eef2ff;
      color: #034f84;
      font-size: 12px;
      cursor: pointer;
      margin: 3px;
      border: 1px solid transparent;
    }

    .chip.active {
      background: #ffd;
      border-color: #f7c948;
      box-shadow: 0 2px 6px rgba(39, 39, 56, 0.06);
    }

    /* 👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇 */

    /* ---------- Enhanced Evidence Modal Styles ---------- */
    .modal {
      position: fixed;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      background: rgba(3, 6, 23, 0.65);
      backdrop-filter: blur(8px);
    }

    .modal-inner {
      width: 1000px;
      height: 640px;
      max-width: 96%;
      max-height: 92%;
      overflow: hidden;
      background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
      border-radius: 16px;
      padding: 0;
      box-shadow:
        0 32px 64px rgba(2, 6, 23, 0.4),
        0 0 0 1px rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: flex;
      flex-direction: column;
    }

    /* Enhanced Header */
    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      border-radius: 16px 16px 0 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      position: relative;
      overflow: hidden;
    }

    .modal-header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
      animation: shimmer 3s infinite;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }

      100% {
        transform: translateX(100%);
      }
    }

    .header-content {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .header-icon {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
    }

    .header-icon i {
      font-size: 20px;
    }

    .header-text h3 {
      margin: 0;
      font-size: 20px;
      font-weight: 700;
      color: white;
    }

    .header-subtitle {
      margin: 2px 0 0 0;
      font-size: 13px;
      opacity: 0.9;
      font-weight: 500;
    }

    .close-btn {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border-radius: 10px;
      padding: 10px 16px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .close-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }

    /* Enhanced Modal Body */
    .modal-body {
      padding: 10px;
      overflow: auto;
      flex: 1;
      background: #f8fafc;
    }

    /* Loading State */
    .loading-state {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
      padding: 10px;
      color: #64748b;
      font-weight: 600;
    }

    .loading-spinner {
      width: 20px;
      height: 20px;
      border: 2px solid #e2e8f0;
      border-top: 2px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    /* Enhanced Top Section */
    .modal-top {
      display: grid;
      grid-template-columns: 280px 1fr 360px;
      gap: 5px;
      align-items: start;
      background: white;
      padding: 10px;
      border-radius: 16px;
      box-shadow:
        0 8px 32px rgba(2, 6, 23, 0.08),
        0 2px 4px rgba(2, 6, 23, 0.02);
      border: 1px solid #f1f5f9;
      margin-bottom: 24px;
    }

    /* Multi-color Image Border */
    .image-section {
      display: flex;
      justify-content: center;
    }

    .image-container {
      position: relative;
    }

    .multi-color-border {
      position: relative;
      padding: 8px;
      border-radius: 16px;
      background: linear-gradient(135deg, #667eea, #f093fb, #f5576c, #4facfe);
      animation: rotateColors 4s linear infinite;
    }

    @keyframes rotateColors {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    .color-ring {
      position: absolute;
      border-radius: 12px;
      animation: pulse 2s infinite;
    }

    .color-1 {
      top: 2px;
      left: 2px;
      right: 2px;
      bottom: 2px;
      background: linear-gradient(45deg, #667eea, transparent);
      animation-delay: 0s;
    }

    .color-2 {
      top: 4px;
      left: 4px;
      right: 4px;
      bottom: 4px;
      background: linear-gradient(135deg, #f093fb, transparent);
      animation-delay: 0.5s;
    }

    .color-3 {
      top: 6px;
      left: 6px;
      right: 6px;
      bottom: 6px;
      background: linear-gradient(225deg, #f5576c, transparent);
      animation-delay: 1s;
    }

    .color-4 {
      top: 8px;
      left: 8px;
      right: 8px;
      bottom: 8px;
      background: linear-gradient(315deg, #4facfe, transparent);
      animation-delay: 1.5s;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 0.7;
      }

      50% {
        opacity: 1;
      }
    }

    .image-content {
      position: relative;
      z-index: 2;
      border-radius: 12px;
      overflow: hidden;
      background: white;
    }

    .modal-image {
      width: 100%;
      height: 250px;
      object-fit: cover;
      display: block;
    }

    .modal-image-placeholder {
      width: 100%;
      height: 250px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #64748b;
      background: linear-gradient(135deg, #f8fafc, #e2e8f0);
      border-radius: 12px;
      font-weight: 600;
      gap: 8px;
    }

    .modal-image-placeholder i {
      font-size: 48px;
      opacity: 0.5;
    }

    /* Enhanced Details Section */
    .modal-details {
      padding: 0;
    }

/* .................... */


.details-header {
  margin-bottom: 5px;
  padding-bottom: 10px;
  border-bottom: 2px solid #f1f5f9;
  display: flex;
  flex-direction: column;
}

.emp-info {
  display: flex;
  flex-direction: column;
}

.emp-name {
  display: flex;
  align-items: center;
  gap: 8px; /* space between name and badge */
  font-size: 18px;
  font-weight: 500;
  color: #0f172a;
  margin-bottom: 8px;
  background: linear-gradient(135deg, #0f172a, #334155);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
/* .................... */


    .details-header {
      margin-bottom: 5px;
      padding-bottom: 10px;
      border-bottom: 2px solid #f1f5f9;
    }

    .emp-name {
      font-size: 18px;
      font-weight: 800;
      color: #0f172a;
      margin-bottom: 8px;
      background: linear-gradient(135deg, #0f172a, #334155);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .emp-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #f1f5f9;
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      color: #475569;
    }

    .details-grid {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .detail-item {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: 5px;
      background: #f8fafc;
      border-radius: 12px;
      border: 1px solid #f1f5f9;
      transition: all 0.3s ease;
    }

    .detail-item:hover {
      background: white;
      box-shadow: 0 4px 12px rgba(2, 6, 23, 0.05);
      transform: translateY(-1px);
    }

    .detail-icon {
      width: 30px;
      height: 30px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-radius: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgb(254, 254, 254);
      flex-shrink: 0;
    }

    .detail-icon i {
      font-size: 16px;
    }

    .detail-content {
      display: flex;
      flex-direction: column;
      flex: 1;
    }

    .detail-content label {
      font-size: 12px;
      font-weight: 600;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 2px;
    }

    .detail-content span {
      font-size: 14px;
      font-weight: 700;
      color: #0f172a;
    }

    .duration-badge {
      /* background: linear-gradient(135deg, #10b981, #059669); */
      color: white;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 700;
    }

    /* Enhanced Reasons Section */
    .modal-reasons {
      padding: 20px;
      border-radius: 16px;
      background: linear-gradient(135deg, #ffffff, #f8fafc);
      border: 1px solid #f1f5f9;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .reasons-header {
      display: flex;
      align-items: center;
      gap: 2px;
      font-size: 16px;
      font-weight: 700;
      color: #0f172a;
      padding-bottom: 12px;
      border-bottom: 2px solid #f1f5f9;
    }

    .reasons-header i {
      color: #ef4444;
    }

    .section-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 700;
      color: #374151;
      margin-bottom: 12px;
    }

    .section-title i {
      color: #667eea;
    }

    .reasons-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      max-height: 80px;
      overflow: auto;
      padding-right: 4px;
    }

    .why-box {
      background: white;
      padding: 16px;
      border-radius: 12px;
      border-left: 4px solid #667eea;
      box-shadow: 0 4px 12px rgba(2, 6, 23, 0.03);
      max-height: 140px;
      overflow: auto;
      font-size: 13px;
      line-height: 1.4;
    }

    /* Enhanced Evidence Files */
    .evidence-section {
      background: white;
      padding: 20px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(2, 6, 23, 0.03);
      border: 1px solid #f1f5f9;
      margin-bottom: 20px;
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 16px;
    }

    .section-header h4 {
      margin: 0;
      color: #0f172a;
      font-size: 16px;
      font-weight: 700;
    }

    .section-header i {
      color: #667eea;
    }

    .files-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .file-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }

    .file-name {
      flex: 1;
      font-size: 13px;
      font-weight: 600;
      color: #374151;
    }

    .download-btn {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
      transition: all 0.3s ease;
    }

    .download-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .no-files {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 20px;
      justify-content: center;
      color: #64748b;
      font-weight: 600;
    }

    /* Enhanced Timeline Section */
    .timeline-section {
      background: white;
      padding: 20px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(2, 6, 23, 0.03);
      border: 1px solid #f1f5f9;
      margin-bottom: 20px;
    }

    .timeline-content {
      margin-top: 12px;
    }

    .loading-timeline {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 20px;
      justify-content: center;
      color: #64748b;
      font-weight: 600;
    }

    .subtitle {
      font-size: 12px;
      color: #64748b;
      font-weight: 500;
      margin-left: 8px;
    }

    /* Enhanced Raw JSON Section */
    .raw-json-section {
      background: white;
      padding: 20px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(2, 6, 23, 0.03);
      border: 1px solid #f1f5f9;
    }

    .toggle-label {
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      font-weight: 600;
      color: #374151;
    }

    .toggle-slider {
      width: 44px;
      height: 24px;
      background: #e2e8f0;
      border-radius: 12px;
      position: relative;
      transition: all 0.3s ease;
    }

    .toggle-slider::before {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      background: white;
      border-radius: 50%;
      top: 3px;
      left: 3px;
      transition: all 0.3s ease;
    }

    input[type="checkbox"] {
      display: none;
    }

    input[type="checkbox"]:checked+.toggle-slider {
      background: linear-gradient(135deg, #667eea, #764ba2);
    }

    input[type="checkbox"]:checked+.toggle-slider::before {
      transform: translateX(20px);
    }

    .toggle-text {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .raw-json {
      display: none;
      margin-top: 16px;
      background: #1e293b;
      color: #e2e8f0;
      padding: 16px;
      border-radius: 8px;
      overflow: auto;
      max-height: 200px;
    }

    .raw-json pre {
      margin: 0;
      font-size: 12px;
      font-family: 'Courier New', monospace;
    }

    /* Hide scrollbars */
    .reasons-list,
    .why-box,
    .raw-json {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    .reasons-list::-webkit-scrollbar,
    .why-box::-webkit-scrollbar,
    .raw-json::-webkit-scrollbar {
      display: none;
      width: 0;
      height: 0;
    }

    /* Responsive adjustments */
    @media (max-width: 1100px) {
      .modal-top {
        grid-template-columns: 240px 1fr 320px;
      }

      .modal-image,
      .modal-image-placeholder {
        height: 220px;
      }
    }

    @media (max-width: 860px) {
      .modal-inner {
        width: 92%;
        height: 82vh;
      }

      .modal-top {
        grid-template-columns: 1fr;
        gap: 20px;
      }

      .image-section {
        justify-content: center;
      }
    }



    /* evidence table styles & highlight classes */
    .evidence-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
    }

    .evidence-table th,
    .evidence-table td {
      padding: 8px 10px;
      border: 1px solid #e6edf3;
      font-size: 13px;
      text-align: left;
      vertical-align: middle;
    }

    .gap-flag {
      background: #fff5f0;
      color: #9a3412;
      padding: 4px 6px;
      border-radius: 6px;
      display: inline-block;
      margin-left: 8px;
      font-weight: 600;
    }

    /* Highlights requested by user */
    .row-day-start {
      background: linear-gradient(90deg, #eefbe8, #f7ffef);
    }

    .row-out-return {
      background: linear-gradient(90deg, #fff0f0, #fff6f6);
    }

    .row-out {
      background: linear-gradient(90deg, #fff7ed, #fffdf8);
    }

    .highlight-long-duration {
      outline: 2px solid rgba(239, 68, 68, 0.12);
    }

    /* Loading overlay */
    .spinner-overlay {
      position: fixed;
      inset: 0;
      background: rgba(255, 255, 255, 0.65);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(2px);
    }

    .spinner-box {
      display: flex;
      gap: 12px;
      align-items: center;
      background: #fff;
      padding: 14px 18px;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(2, 6, 23, 0.15);
      border: 1px solid #e6edf3;
    }

    .spinner {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 4px solid #e6e6e6;
      border-top-color: var(--accent);
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      100% {
        transform: rotate(360deg);
      }
    }

    .evidence-btn {
      padding: 7px 10px;
      background: #0ea5a4;
      color: #fff;
      border-radius: 6px;
      border: 0;
      cursor: pointer;
    }

    .small-button {
      padding: 6px 8px;
      font-size: 12px;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
      background: transparent;
      cursor: pointer;
    }
    .bot-close{
      color: #FFF;
    }

    .table-scroll {
      overflow: auto;
      max-width: 100%;
    }

    /* ---------- Responsive ---------- */
    @media (max-width: 1100px) {
      .modal-top {
        grid-template-columns: 180px 1fr 300px;
      }

      .image-wrap {
        width: 196px;
        height: 196px;
      }

      .modal-image {
        width: 188px;
        height: 188px;
      }
    }

    @media (max-width: 860px) {
      .modal-inner {
        width: 92%;
        height: 82vh;
      }

      .modal-top {
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .image-wrap {
        justify-content: flex-start;
      }
    }


    /* 👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆👆 */
    /* calendar input tweaks */
    .date-input {
      padding: 4px 6px;
      font-size: 12px;
      border-radius: 4px;
      min-width: 110px;
      background: #ffd700;
      color: #000;
      border: 1px solid #b89f00;
    }

    .flatpickr-calendar {
      font-size: 12px;
      transform: scale(0.9);
      transform-origin: top left;
    }


.risk-badge {
  display: inline-block;
  padding: 6px 10px;
  border-radius: 999px;
  font-weight: 800;
  color: #fff !important;               /* ✅ force white text for contrast */
  font-size: 12px;
  background: #000;                     /* fallback (inline style will override with RISK_COLORS) */
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
  border: 1px solid rgba(0,0,0,0.08);   /* subtle border so light backgrounds still show the badge boundary */
  text-shadow: 0 1px 0 rgba(0,0,0,0.90);/* small shadow to aid readability on noisy backgrounds */
}

    .risk-small {
      font-size: 12px;
      font-weight: 700;
    }

    .risk-chip {
      padding: 6px 8px;
      border-radius: 6px;
      cursor: pointer;
      border: 1px solid #e6edf3;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .risk-chip.active {
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      font-weight: 700;
    }

    .risk-chips {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .chart-legend {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-top: 6px;
    }

    .clear-filter {
      background: transparent;
      border: none;
      color: #0366d6;
      cursor: pointer;
      text-decoration: underline;
    }

   .modal .close-btn { display: none !important; }
 /* ---------- Chatbot UI ---------- */
    .chat-fab {
      position: fixed;
      right: 22px;
      bottom: 22px;
      width: 62px;
      height: 62px;
      border-radius: 999px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg,#4267B2,#00A4FF);
      box-shadow: 0 12px 36px rgba(2,6,23,0.22);
      color: #fff;
      font-weight: 800;
      cursor: pointer;
      z-index: 3000;
      border: none;
    }
    .chat-fab .meta-icon { font-size: 22px; display:flex; align-items:center; justify-content:center; }
    .chat-fab .meta-icon img {
  height: 62px; 
  width: 62px; 
  object-fit: contain; 
}
    .chat-modal { position: fixed; right: 22px; bottom: 100px; width: 420px; max-width: calc(100% - 40px); margin-top: 100px; height: 560px; background: #fff; border-radius: 12px; box-shadow: 0 24px 60px rgba(2,6,23,0.4); z-index: 3001; display: flex; flex-direction: column; overflow: hidden; }
    .chat-modal .chat-header { background: linear-gradient(90deg,#0f172a,#2563eb); margin-top: 70px; color: #fff; padding: 12px; display:flex; align-items:center; gap:12px; }
    .chat-modal .chat-header .title { font-weight:700; font-size:14px; }
    .chat-modal .chat-body { flex: 1; padding: 12px; overflow: auto; background: linear-gradient(180deg,#f7fafc,#fff); }
    .chat-bubble { max-width: 84%; padding: 10px 12px; margin: 6px 0; border-radius: 12px; font-size: 13px; line-height: 1.3; box-shadow: 0 6px 18px rgba(16,24,40,0.04); white-space: pre-wrap; }
    .chat-bubble.user { margin-left: auto; background: #0ea5a4; color: #fff; border-bottom-right-radius: 6px; }
    .chat-bubble.bot { margin-right: auto; background: #eef2ff; color: #0f172a; border-bottom-left-radius: 6px; }
    .chat-evidence { margin-top:6px; font-size:12px; color:#475569; background:#fff; border-left:3px solid #2563eb; padding:8px; border-radius:6px; }
    .chat-input-row { display:flex; gap:8px; padding:10px; border-top:1px solid #eef2f3; align-items:center; background: #fff; }
    .chat-input { flex: 1; padding: 10px 12px; border-radius: 8px; border: 1px solid #e6edf3; font-size: 14px; }
    .chat-send-btn { padding: 8px 12px; border-radius: 8px; border: none; background: #2563eb; color: #fff; cursor: pointer; font-weight: 700; }
    .quick-prompts { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .quick-prompts button { padding:6px 8px; border-radius:999px; border:1px solid #e2e8f0; background:#fff; cursor:pointer; font-size:12px; }
    .chat-loading { display:flex; gap:8px; align-items:center; color:#64748b; font-weight:600; }
    .modal .close-btn { display: none !important; }
    
    
    /* ... rest of CSS ... */







