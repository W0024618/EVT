Check below page carefully Export button is not visible here need to display Export report button 
so add export button carefully


// frontend/src/pages/DurationPage.jsx
import React, { useState, useMemo, useEffect, useCallback, useRef } from "react";
import { useAuth } from "../context/AuthContext";

import axios from "axios";
import {
  Box,
  Grid,
  Paper,
  Typography,
  TextField,
  Button,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  TableContainer,
  CircularProgress,
  IconButton,
  Tooltip,
  Card,
  CardContent,
  Dialog,
  DialogTitle,
  DialogContent,
  Divider,
  MenuItem,
  Select,
  FormControl,
  InputLabel,
  InputAdornment,
} from "@mui/material";
import DateRangeIcon from "@mui/icons-material/DateRange";
import SearchIcon from "@mui/icons-material/Search";
import DownloadIcon from "@mui/icons-material/CloudDownload";
import ClearIcon from "@mui/icons-material/Clear";
import VisibilityIcon from "@mui/icons-material/Visibility";

const API_BASE =
  import.meta.env.VITE_API_BASE ||
  import.meta.env.REACT_APP_API_BASE ||
  "http://localhost:8000";

const REGIONS = [
  { value: "apac", label: "APAC" },
  { value: "emea", label: "EMEA" },
  { value: "laca", label: "LACA" },
  { value: "namer", label: "NAMER" },
];

function secondsToHMS(s) {
  if (s == null) return "";
  const sec = Number(s);
  if (!Number.isFinite(sec)) return "";
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const r = Math.floor(sec % 60);
  return `${h}:${String(m).padStart(2, "0")}:${String(r).padStart(2, "0")}`;
}

function isoToDDMMYYYY(iso) {
  if (!iso) return iso;
  const dt = new Date(iso.includes("T") ? iso : `${iso}T00:00:00Z`);
  if (Number.isNaN(dt.getTime())) return iso;
  const dd = String(dt.getUTCDate()).padStart(2, "0");
  const mm = String(dt.getUTCMonth() + 1).padStart(2, "0");
  const yyyy = dt.getUTCFullYear();
  return `${dd}-${mm}-${yyyy}`;
}

function isoToLongDateNoCommas(iso) {
  if (!iso) return iso;
  const dt = new Date(iso.includes("T") ? iso : `${iso}T00:00:00Z`);
  if (Number.isNaN(dt.getTime())) return iso;
  const weekday = dt.toLocaleDateString(undefined, { weekday: "short" });
  const day = String(dt.getUTCDate()).padStart(2, "0");
  const month = String(dt.getUTCMonth() + 1).padStart(2, "0");
  const year = dt.getUTCFullYear();
  return `${weekday} ${day}-${month}-${year}`;
}

const SWIPE_DIFF_RED_THRESHOLD = 6 * 3600;

export default function DurationPage() {
  const [region, setRegion] = useState("apac");
  const auth = useAuth();

  const [city, setCity] = useState("");
  const [citiesForRegion, setCitiesForRegion] = useState([]);
  const [startDate, setStartDate] = useState("");
  const [endDate, setEndDate] = useState("");
  const [singleDate, setSingleDate] = useState("");
  const [useRange, setUseRange] = useState(true);

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const [searchEmployeeId, setSearchEmployeeId] = useState("");
  const [searchEmployeeName, setSearchEmployeeName] = useState("");
  const [searchCardNumber, setSearchCardNumber] = useState("");

  const [swipeDialogOpen, setSwipeDialogOpen] = useState(false);
  const [selectedEmployee, setSelectedEmployee] = useState(null);
  const [selectedSwipes, setSelectedSwipes] = useState([]);

  const [overrideDate, setOverrideDate] = useState("");
  const [overrideStartIndex, setOverrideStartIndex] = useState(null);
  const [overrideEndIndex, setOverrideEndIndex] = useState(null);
  const [overrideReason, setOverrideReason] = useState("");
  const [overrideApplying, setOverrideApplying] = useState(false);

  const startDateRef = useRef(null);
  const endDateRef = useRef(null);
  const singleDateRef = useRef(null);

  const tableSx = {
    "& th, & td": { border: "1px solid rgba(0,0,0,0.12)" },
    "& thead th": { backgroundColor: "#32a8ed", fontWeight: 900, fontSize: "16px" },
    "& tbody tr": { backgroundColor: "transparent" },
    "& tbody tr:hover": { backgroundColor: "rgba(255, 204, 0, 0.12)" },
  };

  const dialogTableSx = {
    "& th, & td": { border: "1px solid rgba(0,0,0,0.12)" },
    "& thead th": { backgroundColor: "#32a8ed", fontWeight: 700 },
    "& tbody tr:hover": { backgroundColor: "rgba(255, 204, 0, 0.08)" },
  };

  const openNativeDatePicker = (ref) => {
    if (!ref || !ref.current) return;
    try {
      if (typeof ref.current.showPicker === "function") {
        ref.current.showPicker();
      } else {
        ref.current.focus();
      }
    } catch (e) {
      try {
        ref.current.focus();
      } catch { }
    }
  };

  useEffect(() => {
    async function fetchCities() {
      setCitiesForRegion([]);
      setCity("");
      if (!auth.hasPermission(['headcount', `headcount.${region}`, 'global_access'])) {
        setError(`Access denied to ${region.toUpperCase()} locations`);
        return;
      } else {
        setError("");
      }

      try {
        const res = await axios.get(`${API_BASE}/duration/cities`, {
          params: { region },
          timeout: 20000,
        });
        const cities = res.data?.cities || [];
        setCitiesForRegion(cities);
      } catch (err) {
        console.warn("Failed to fetch cities list:", err?.message || err);
        setCitiesForRegion([]);
      }
    }
    fetchCities();
  }, [region]);

  const fetchDurations = useCallback(
    async (opts = {}) => {
      setError("");
      setLoading(true);
      setData(null);

      try {
        const params = {};

        if (useRange && startDate && endDate) {
          params.start_date = startDate;
          params.end_date = endDate;
        } else if (!useRange && singleDate) {
          params.date = singleDate;
        } else {
          if (singleDate) params.date = singleDate;
        }

        if (region) params.regions = region;
        if (city) params.city = city;

        if (searchEmployeeId) params.employee_id = searchEmployeeId;
        if (searchEmployeeName) params.employee_name = searchEmployeeName;
        if (searchCardNumber) params.card_number = searchCardNumber;

        const timeout = opts.timeout || 1200000;

        const res = await axios.get(`${API_BASE}/duration`, {
          params,
          timeout,
        });
        setData(res.data);
      } catch (err) {
        console.error(err);
        setError(err?.response?.data?.detail || err.message || "Failed to fetch duration data");
      } finally {
        setLoading(false);
      }
    },
    [useRange, startDate, endDate, singleDate, region, city, searchEmployeeId, searchEmployeeName, searchCardNumber]
  );

  const fetchAndMergeEmployee = useCallback(
    async ({ employeeId, person_uid } = {}) => {
      if (!employeeId && !person_uid) return;
      try {
        const params = {};
        if (useRange && startDate && endDate) {
          params.start_date = startDate;
          params.end_date = endDate;
        } else if (!useRange && singleDate) {
          params.date = singleDate;
        } else {
          if (singleDate) params.date = singleDate;
        }
        params.regions = region;
        if (employeeId) params.employee_id = employeeId;
        if (!employeeId && person_uid) {
          params.employee_name = person_uid;
        }
        params.sample_rows = 0;
        const res = await axios.get(`${API_BASE}/duration`, { params, timeout: 120000 });
        const resp = res.data;
        if (!resp || !resp.regions || !resp.regions[region]) {
          return;
        }
        const newRegionObj = resp.regions[region];
        const fetchedEmployees = newRegionObj.employees || [];

        setData((prev) => {
          try {
            if (!prev) {
              return resp;
            }
            const next = { ...prev, regions: { ...(prev.regions || {}) } };
            const prevRegion = (prev.regions || {})[region] || { dates: [], employees: [], swipes_by_date: {} };
            const mergedRegion = {
              ...prevRegion,
              dates: newRegionObj.dates || prevRegion.dates,
              date_rows: newRegionObj.date_rows || prevRegion.date_rows,
              swipes_by_date: { ...(prevRegion.swipes_by_date || {}), ...(newRegionObj.swipes_by_date || {}) },
            };

            const prevEmployees = Array.isArray(prevRegion.employees) ? [...prevRegion.employees] : [];
            fetchedEmployees.forEach((fe) => {
              const idx = prevEmployees.findIndex((p) => {
                if (p.person_uid && fe.person_uid) return p.person_uid === fe.person_uid;
                if (p.EmployeeID && fe.EmployeeID) return String(p.EmployeeID) === String(fe.EmployeeID);
                return false;
              });
              if (idx >= 0) {
                prevEmployees[idx] = fe;
              } else {
                prevEmployees.push(fe);
              }
            });

            mergedRegion.employees = prevEmployees;
            next.regions[region] = mergedRegion;
            return next;
          } catch (e) {
            console.error("Failed to merge employee data:", e);
            return resp;
          }
        });
      } catch (err) {
        console.error("fetchAndMergeEmployee failed:", err);
      }
    },
    [region, startDate, endDate, singleDate, useRange]
  );

  const regionObj = useMemo(() => {
    if (!data || !region) return null;
    return data.regions?.[region] || null;
  }, [data, region]);

  const computeWeekStarts = (datesIso) => {
    if (!datesIso || datesIso.length === 0) return [];
    const dateObjs = datesIso.map((d) => new Date(d + "T00:00:00Z"));
    const weekStartSet = new Set();
    dateObjs.forEach((dt) => {
      const day = dt.getUTCDay();
      const diff = (day + 6) % 7;
      const monday = new Date(dt);
      monday.setUTCDate(dt.getUTCDate() - diff);
      weekStartSet.add(monday.toISOString().slice(0, 10));
    });
    return Array.from(weekStartSet).sort();
  };

  const quote = (s) => `"${String(s ?? "").replace(/"/g, '""')}"`;

  const exportSummaryCsv = () => {
    if (!regionObj) return;
    const dates = regionObj.dates || [];
    const rows = regionObj.employees || [];

    const header = ["EmployeeID", "EmployeeName", "TotalSecondsPresentInRange", "DominantCategory", "ComplianceSummary", ...dates.map((d) => d)];
    const csvRows = [header.map((h) => quote(h)).join(",")];

    rows.forEach((r) => {
      const complianceText = r.compliance?.month_summary || "";
      const complianceCell = `'${complianceText}`;
      const row = [
        quote(r.EmployeeID || ""),
        quote(r.EmployeeName || ""),
        r.total_seconds_present_in_range ?? "",
        quote(r.duration_categories?.dominant_category || ""),
        quote(complianceCell),
        ...dates.map((d) => quote(r.durations?.[d] ?? "")),
      ];
      csvRows.push(row.join(","));
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `duration_summary_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  const exportReportCsv = () => {
    if (!regionObj) return;
    const datesIso = regionObj.dates || [];
    const weekStarts = computeWeekStarts(datesIso);

    const baseHeader = ["Sr.No", "EmployeeID", "EmployeeName", "CardNumber", "PersonnelType", "PartitionName2", "TotalSecondsPresentInRange"];
    const perDayHeaders = [];
    weekStarts.forEach((ws) => {
      for (let i = 0; i < 7; i++) {
        const d = new Date(ws + "T00:00:00Z");
        d.setUTCDate(d.getUTCDate() + i);
        const iso = d.toISOString().slice(0, 10);
        perDayHeaders.push(isoToLongDateNoCommas(iso));
      }
    });
    const perWeekHeaders = weekStarts.map((ws) => `Week compliance ${ws}`);

    const header = [...baseHeader, ...perDayHeaders, ...perWeekHeaders, "DominantCategory", "ComplianceSummary"];
    const csvRows = [header.map((h) => quote(h)).join(",")];

    const rows = regionObj.employees || [];
    rows.forEach((r, idx) => {
      const srNo = idx + 1;
      const employeeId = r.EmployeeID ?? "";
      const employeeName = r.EmployeeName ?? "";
      const cardNumber = r.CardNumber ?? "";
      const personnelType = r.PersonnelType ?? r.PersonnelTypeName ?? "";
      const partition = r.PartitionName2 ?? "";
      const totalSeconds = r.total_seconds_present_in_range ?? "";

      const perDayVals = [];
      weekStarts.forEach((ws) => {
        for (let i = 0; i < 7; i++) {
          const d = new Date(ws + "T00:00:00Z");
          d.setUTCDate(d.getUTCDate() + i);
          const iso = d.toISOString().slice(0, 10);

          const wk = r.compliance && r.compliance.weeks ? r.compliance.weeks[ws] : null;
          let outVal = "0";

          if (wk && wk.dates && Object.prototype.hasOwnProperty.call(wk.dates, iso)) {
            const secs = wk.dates[iso];
            if (secs !== null && secs !== undefined) {
              outVal = r.durations && r.durations[iso] ? r.durations[iso] : secondsToHMS(secs);
            } else {
              outVal = "0";
            }
          } else if (r.durations && Object.prototype.hasOwnProperty.call(r.durations, iso) && r.durations[iso]) {
            outVal = r.durations[iso];
          } else if (r.durations_seconds && Object.prototype.hasOwnProperty.call(r.durations_seconds, iso) && r.durations_seconds[iso]) {
            outVal = secondsToHMS(r.durations_seconds[iso]);
          } else {
            outVal = "0";
          }

          perDayVals.push(outVal);
        }
      });

      const perWeekVals = weekStarts.map((ws) => {
        const wk = r.compliance && r.compliance.weeks ? r.compliance.weeks[ws] : null;
        return wk && wk.compliant ? "Yes" : "No";
      });

      const complianceText = r.compliance?.month_summary || "";
      const complianceCell = `'${complianceText}`;

      const row = [
        `${srNo}`,
        quote(employeeId),
        quote(employeeName),
        quote(cardNumber),
        quote(personnelType),
        quote(partition),
        `${totalSeconds}`,
        ...perDayVals.map((v) => quote(v)),
        ...perWeekVals.map((v) => quote(v)),
        quote(r.duration_categories?.dominant_category || ""),
        quote(complianceCell),
      ];

      csvRows.push(row.join(","));
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `duration_report_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  const exportSwipesCsv = () => {
    if (!regionObj) return;
    const swipesByDate = regionObj.swipes_by_date || {};
    const rows = [];
    Object.entries(swipesByDate).forEach(([d, arr]) => {
      arr.forEach((s) => {
        rows.push({
          Date: d,
          LocaleMessageTime: s.LocaleMessageTime || "",
          Swipe_Time: s.Swipe_Time || "",
          EmployeeID: s.EmployeeID || "",
          PersonGUID: s.PersonGUID || "",
          ObjectName1: s.ObjectName1 || "",
          Door: s.Door || "",
          PersonnelType: s.PersonnelType || "",
          CardNumber: s.CardNumber || "",
          PrimaryLocation: s.PrimaryLocation || s.Text5 || "",
          PartitionName2: s.PartitionName2 || "",
          AdmitCode: s.AdmitCode || "",
          Direction: s.Direction || "",
          CompanyName: s.CompanyName || "",
        });
      });
    });

    if (rows.length === 0) {
      alert("No swipe rows available for current selection to export.");
      return;
    }

    const headers = [
      "Date",
      "LocaleMessageTime",
      "Swipe_Time",
      "EmployeeID",
      "PersonGUID",
      "ObjectName1",
      "Door",
      "PersonnelType",
      "CardNumber",
      "PrimaryLocation",
      "PartitionName2",
      "AdmitCode",
      "Direction",
      "CompanyName",
    ];
    const csvRows = [headers.map((h) => quote(h)).join(",")];
    rows.forEach((r) => {
      const line = headers.map((h) => quote(r[h] ?? "")).join(",");
      csvRows.push(line);
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `swipes_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  const exportSelectedEmployeeSwipes = () => {
    if (!selectedSwipes || selectedSwipes.length === 0) {
      alert("No swipe records to export for selected employee.");
      return;
    }
    const headers = [
      "Date",
      "LocaleMessageTime",
      "Swipe_Time",
      "EmployeeID",
      "PersonGUID",
      "ObjectName1",
      "Door",
      "PersonnelType",
      "CardNumber",
      "PrimaryLocation",
      "PartitionName2",
      "AdmitCode",
      "Direction",
      "CompanyName",
      "DiffSeconds",
      "DiffHHMMSS"
    ];
    const csvRows = [headers.map((h) => quote(h)).join(",")];
    selectedSwipes.forEach((s) => {
      const obj = { ...s };
      const line = headers.map((h) => quote(obj[h] ?? "")).join(",");
      csvRows.push(line);
    });
    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const empId = selectedEmployee?.EmployeeID || "employee";
    const filename = `swipes_${empId}_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  const getFilteredRows = useCallback(() => {
    if (!regionObj) return [];
    const rows = regionObj.employees || [];
    return rows.filter((r) => {
      const matchesEmployeeId = !searchEmployeeId || String(r.EmployeeID || "").toLowerCase().includes(searchEmployeeId.toLowerCase());
      const matchesName = !searchEmployeeName || String(r.EmployeeName || "").toLowerCase().includes(searchEmployeeName.toLowerCase());
      const matchesCard = !searchCardNumber || String(r.CardNumber || "").toLowerCase().includes(searchCardNumber.toLowerCase());
      return matchesEmployeeId && matchesName && matchesCard;
    });
  }, [regionObj, searchEmployeeId, searchEmployeeName, searchCardNumber]);

  const openSwipeDialogFor = (emp) => {
    setSelectedEmployee(emp);
    const swipesByDate = regionObj?.swipes_by_date || {};
    const matches = [];
    Object.entries(swipesByDate).forEach(([d, arr]) => {
      arr.forEach((s) => {
        const matchByEmployeeId = emp.EmployeeID && s.EmployeeID && String(s.EmployeeID) === String(emp.EmployeeID);
        const matchByCard = emp.CardNumber && s.CardNumber && String(s.CardNumber) === String(emp.CardNumber);
        const matchByPersonGuid = emp.person_uid && s.PersonGUID && String(s.PersonGUID) === String(emp.person_uid);
        if (matchByEmployeeId || matchByCard || matchByPersonGuid) {
          matches.push({ ...s, Date: d });
        }
      });
    });
    matches.sort((a, b) => {
      const ta = a.LocaleMessageTime ? new Date(a.LocaleMessageTime).getTime() : 0;
      const tb = b.LocaleMessageTime ? new Date(b.LocaleMessageTime).getTime() : 0;
      return ta - tb;
    });

    const withDiffs = matches.map((row, idx, arr) => {
      let diffSeconds = null;
      if (idx === 0) {
        diffSeconds = null;
      } else {
        const cur = row.LocaleMessageTime ? new Date(row.LocaleMessageTime).getTime() : null;
        const prev = arr[idx - 1].LocaleMessageTime ? new Date(arr[idx - 1].LocaleMessageTime).getTime() : null;
        if (cur != null && prev != null) {
          diffSeconds = Math.max(0, Math.floor((cur - prev) / 1000));
        } else {
          diffSeconds = null;
        }
      }
      return {
        ...row,
        DiffSeconds: diffSeconds,
        DiffHHMMSS: diffSeconds != null ? secondsToHMS(diffSeconds) : "-",
      };
    });

    setSelectedSwipes(withDiffs);

    const distinctDates = Array.from(new Set(withDiffs.map((m) => m.Date))).sort();
    setOverrideDate(distinctDates.length > 0 ? distinctDates[0] : "");
    setOverrideStartIndex(null);
    setOverrideEndIndex(null);
    setOverrideReason("");
    setSwipeDialogOpen(true);
  };

  const computeOverrideDurationSeconds = () => {
    if (!selectedSwipes || selectedSwipes.length === 0) return 0;
    if (overrideStartIndex == null || overrideEndIndex == null) return 0;
    const sIdx = Math.min(overrideStartIndex, overrideEndIndex);
    const eIdx = Math.max(overrideStartIndex, overrideEndIndex);
    const s = selectedSwipes[sIdx];
    const e = selectedSwipes[eIdx];
    if (!s || !e) return 0;
    const sa = s.LocaleMessageTime ? new Date(s.LocaleMessageTime).getTime() : null;
    const eb = e.LocaleMessageTime ? new Date(e.LocaleMessageTime).getTime() : null;
    if (!sa || !eb) return 0;
    return Math.max(0, Math.floor((eb - sa) / 1000));
  };

  const applyOverride = async () => {
    if (!selectedEmployee) return;
    if (!overrideDate) {
      alert("Please select a date for the override.");
      return;
    }
    if (overrideStartIndex == null || overrideEndIndex == null) {
      alert("Please select both start and end swipe entries.");
      return;
    }
    const sIdx = Math.min(overrideStartIndex, overrideEndIndex);
    const eIdx = Math.max(overrideStartIndex, overrideEndIndex);
    const s = selectedSwipes[sIdx];
    const e = selectedSwipes[eIdx];
    if (!s || !e) {
      alert("Invalid swipe selection.");
      return;
    }
    const start_ts = s.LocaleMessageTime || s.Swipe_Time;
    const end_ts = e.LocaleMessageTime || e.Swipe_Time;
    if (!start_ts || !end_ts) {
      alert("Selected swipe rows do not have timestamps.");
      return;
    }
    const seconds = computeOverrideDurationSeconds();
    if (seconds <= 0) {
      if (!window.confirm("Computed duration is 0. Do you still want to apply the override?")) {
        return;
      }
    }

    if (!auth.hasPermission(['headcount', `headcount.${region}`, 'global_access'])) {
      alert(`Access denied to apply overrides for ${region.toUpperCase()}`);
      return;
    }
    setOverrideApplying(true);

    try {
      await axios.post(`${API_BASE}/duration/override`, {
        region,
        person_uid: selectedEmployee.person_uid,
        date: overrideDate,
        start_ts: start_ts,
        end_ts: end_ts,
        reason: overrideReason,
        user: "frontend_user"
      }, { timeout: 30000 });

      await fetchAndMergeEmployee({ employeeId: selectedEmployee.EmployeeID, person_uid: selectedEmployee.person_uid });

      setSwipeDialogOpen(false);
      alert("Override applied — updated employee refreshed.");
    } catch (err) {
      console.error("Failed to apply override:", err);
      alert("Failed to apply override: " + (err?.response?.data?.detail || err.message || "unknown"));
    } finally {
      setOverrideApplying(false);
    }
  };

  const renderSwipeSelectionControls = () => {
    if (!selectedSwipes || selectedSwipes.length === 0) return null;

    const distinctDates = Array.from(new Set(selectedSwipes.map((m) => m.Date))).sort();
    const swipesAll = selectedSwipes;

    return (
      <Box sx={{ mt: 2 }}>
        <Grid container spacing={2} alignItems="center">
          <Grid item xs={12} md={4}>
            <FormControl fullWidth size="small">
              <InputLabel id="override-date-label">Date</InputLabel>
              <Select
                labelId="override-date-label"
                label="Date"
                value={overrideDate}
                onChange={(e) => {
                  setOverrideDate(e.target.value);
                  setOverrideStartIndex(null);
                  setOverrideEndIndex(null);
                }}
                sx={{ color: 'black' }}
              >
                {distinctDates.map((d) => (
                  <MenuItem key={d} value={d}>{isoToDDMMYYYY(d)}</MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

          <Grid item xs={12} md={4}>
            <FormControl fullWidth size="small">
              <InputLabel id="override-start-label">Start swipe</InputLabel>
              <Select
                labelId="override-start-label"
                label="Start swipe"
                value={overrideStartIndex == null ? "" : overrideStartIndex}
                onChange={(e) => {
                  const val = e.target.value === "" ? null : Number(e.target.value);
                  setOverrideStartIndex(val);
                  if (val !== null && selectedSwipes[val] && selectedSwipes[val].Date) {
                    setOverrideDate(selectedSwipes[val].Date);
                  }
                }}
                sx={{ color: 'black' }}
              >
                <MenuItem value=""><em>None</em></MenuItem>
                {swipesAll.map((s, idx) => {
                  const timeLabel = s.LocaleMessageTime ? new Date(s.LocaleMessageTime).toLocaleString() : s.Swipe_Time;
                  return (
                    <MenuItem key={`start-${idx}`} value={idx}>
                      {s.Date} — {timeLabel} {s.Door ? `— ${s.Door}` : ""}
                    </MenuItem>
                  );
                })}
              </Select>
            </FormControl>
          </Grid>

          <Grid item xs={12} md={4}>
            <FormControl fullWidth size="small">
              <InputLabel id="override-end-label">End swipe</InputLabel>
              <Select
                labelId="override-end-label"
                label="End swipe"
                value={overrideEndIndex == null ? "" : overrideEndIndex}
                onChange={(e) => {
                  const val = e.target.value === "" ? null : Number(e.target.value);
                  setOverrideEndIndex(val);
                  if (val !== null && (!overrideDate || overrideDate === "") && selectedSwipes[val] && selectedSwipes[val].Date) {
                    setOverrideDate(selectedSwipes[val].Date);
                  }
                }}
                sx={{ color: 'black' }}
              >
                <MenuItem value=""><em>None</em></MenuItem>
                {swipesAll.map((s, idx) => {
                  const timeLabel = s.LocaleMessageTime ? new Date(s.LocaleMessageTime).toLocaleString() : s.Swipe_Time;
                  return (
                    <MenuItem key={`end-${idx}`} value={idx}>
                      {s.Date} — {timeLabel} {s.Door ? `— ${s.Door}` : ""}
                    </MenuItem>
                  );
                })}
              </Select>
            </FormControl>
          </Grid>

          <Grid item xs={12}>
            <TextField
              fullWidth
              size="small"
              label="Reason (optional)"
              value={overrideReason}
              onChange={(e) => setOverrideReason(e.target.value)}
              sx={{
                "& .MuiInputBase-input": {
                  color: "black",   // text color
                },

              }}
            />
          </Grid>

          <Grid item xs={12} sx={{ display: "flex", gap: 1, justifyContent: "flex-end" }}>
            <Button
              variant="contained"
              onClick={applyOverride}
              disabled={overrideApplying || !overrideDate || overrideStartIndex == null || overrideEndIndex == null}
            >
              {overrideApplying ? "Applying..." : `Apply Override (${secondsToHMS(computeOverrideDurationSeconds())})`}
            </Button>
          </Grid>
        </Grid>

        <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: "block" }}>
          Tip: start and end swipe selectors now include all swipe records for this employee across the selected range — you can pick start on one date and end on another.
        </Typography>
      </Box>
    );
  };

  const renderTable = () => {
    if (!regionObj) return <Typography>No data for selected region.</Typography>;

    const dates = regionObj.dates || [];
    const rows = getFilteredRows();

    const weekStarts = computeWeekStarts(dates);

    return (
      <TableContainer component={Paper} sx={{ mt: 2, width: "100%", overflowX: "auto", boxShadow: 2, backgroundColor: "#2a82bd", color: "#000" }}>
        <Table size="small" stickyHeader sx={tableSx}>
          <TableHead>
            <TableRow sx={{ backgroundColor: "#e3f2fd", color: "#000" }}>
              <TableCell><b>Sr.No</b></TableCell>
              <TableCell><b>EmployeeID</b></TableCell>
              <TableCell><b>EmployeeName</b></TableCell>
              <TableCell><b>CardNumber</b></TableCell>
              <TableCell><b>PersonnelType</b></TableCell>
              <TableCell><b>PartitionName2</b></TableCell>
              <TableCell align="right"><b>Total (hh:mm:ss)</b></TableCell>
              {dates.map((d) => (
                <TableCell key={d} align="center"><b>{isoToDDMMYYYY(d)}</b></TableCell>
              ))}
              {weekStarts.map((ws) => (
                <TableCell key={ws} align="center"><b>{`Week ${ws} compliant`}</b></TableCell>
              ))}
              <TableCell align="center"><b>Dominant Category</b></TableCell>
              <TableCell align="center"><b>Compliance (weeks met/total)</b></TableCell>
              <TableCell align="center"><b>View</b></TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {rows.length === 0 ? (
              <TableRow>
                <TableCell colSpan={9 + (regionObj.dates || []).length + weekStarts.length} align="center">No employees in the response.</TableCell>
              </TableRow>
            ) : (
              rows.map((r, idx) => (
                <TableRow key={r.person_uid || `${r.EmployeeID}-${r.EmployeeName}`} sx={{ backgroundColor: "#e3f2fd", color: "#000" }}>
                  <TableCell sx={{ backgroundColor: "#FFF", color: "#000", fontWeight: "700" }}>{idx + 1}</TableCell>
                  <TableCell sx={{ backgroundColor: "#FFF", color: "#000", fontWeight: "700" }}>{r.EmployeeID || "-"}</TableCell>
                  <TableCell sx={{ backgroundColor: "#FFF", color: "#000", fontWeight: "700" }}>{r.EmployeeName || "-"}</TableCell>
                  <TableCell sx={{ backgroundColor: "#FFF", color: "#000", fontWeight: "700" }}>{r.CardNumber || "-"}</TableCell>
                  <TableCell sx={{ backgroundColor: "#FFF", color: "#000", fontWeight: "700" }}>{r.PersonnelType || r.PersonnelTypeName || "-"}</TableCell>
                  <TableCell sx={{ backgroundColor: "#FFF", color: "#000", fontWeight: "700" }}>{r.PartitionName2 || "-"}</TableCell>
                  <TableCell sx={{ backgroundColor: "#FFF", color: "#000", fontWeight: "700" }} align="right">{secondsToHMS(r.total_seconds_present_in_range)}</TableCell>
                  {dates.map((d) => (
                    <TableCell sx={{ backgroundColor: "#FFF", color: "#000", fontWeight: "700" }} key={d} align="center">{r.durations?.[d] ?? "-"}</TableCell>
                  ))}
                  {weekStarts.map((ws) => {
                    const wk = r.compliance && r.compliance.weeks ? r.compliance.weeks[ws] : null;
                    return <TableCell sx={{ backgroundColor: "#FFF", color: "#000", fontWeight: "700" }} key={ws} align="center">{wk && wk.compliant ? "Yes" : "No"}</TableCell>;
                  })}
                  <TableCell sx={{ backgroundColor: "#FFF", color: "#000", fontWeight: "700" }} align="center">
                    {r.duration_categories?.dominant_category || "-"}
                    {r.duration_categories?.red_flag > 0 ? " ⚠️" : ""}
                  </TableCell>
                  <TableCell sx={{ backgroundColor: "#FFF", color: "#000", fontWeight: "700" }} align="center">{r.compliance?.month_summary || "-"}</TableCell>
                  <TableCell sx={{ backgroundColor: "#FFF", color: "#000", fontWeight: "700" }} align="center">
                    <Tooltip title="View swipe records for this employee">
                      <Button size="small" variant="outlined" startIcon={<VisibilityIcon />} onClick={() => openSwipeDialogFor(r)} sx={{ backgroundColor: "#32a8ed", color: "#000" }} >
                        Viewe
                      </Button>
                    </Tooltip>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </TableContainer>
    );
  };

  return (
    <Box
      sx={{
        p: 3,
        width: "100%",
        maxWidth: "100vw",
        boxSizing: "border-box",
        background: "linear-gradient(to right, #f5f7fa, #e6ebf3)",
        minHeight: "100vh",
      }}
    >
      <Box sx={{ display: "flex", justifyContent: "center", mb: 2 }}>


        <Box
          sx={{
            border: "2px solid  #218dcc",
            background: "#1c95c9",
            borderRadius: 2,
            px: 3,
            py: 1.2,
            width: { xs: "100%", sm: "70%", md: "100%" },
            textAlign: "center",
            boxShadow: 3,
          }}
        >
          <Typography
            variant="h4"
            gutterBottom
            sx={{
              background: "#fff", // gradient text
              WebkitBackgroundClip: "text",
              WebkitTextFillColor: "transparent",
              fontWeight: "bold",
              display: "inline-block",
              paddingBottom: "6px",
              borderBottom: "3px solid rgba(240, 221, 12, 0.9)", // lighter border
              textShadow: "1px 1px 3px rgba(0,0,0,0.15)", // soft glow
              letterSpacing: "0.5px",
            }}
          >
            Duration Reports with Compliance & Category
          </Typography>
        </Box>

      </Box>

      <Grid container spacing={2} sx={{ backgroundColor: "#ffffff" }}>

        <Grid item xs={12} sx={{ backgroundColor: "#ffffff", color: "#e02500" }}>

          <Card
            elevation={4}
            sx={{
              // background: "linear-gradient(145deg, #fffbe6, #fff9db)",
              background: "linear-gradient(145deg, #fff, #ffff)",
              border: "1px solid rgb(10, 90, 136)",
              borderRadius: 3,
              p: 2,
              boxShadow: "0 4px 12px rgba(0,0,0,0.08)",
            }}
          >
            <CardContent>
              <Grid container spacing={3} alignItems="center">
                {/* Region */}
                <Grid item xs={12} md={2}>
                  <FormControl fullWidth size="small">
                    <InputLabel id="region-select-label" sx={{ color: "#000" }}>Region</InputLabel>
                    <Select
                      labelId="region-select-label"
                      value={region}
                      onChange={(e) => setRegion(e.target.value)}
                      sx={{ bgcolor: "#fff", borderRadius: 1, color: "#000" }}
                    >
                      {REGIONS.map((r) => (
                        <MenuItem key={r.value} value={r.value}>
                          {r.label}
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>

                {/* City */}
                <Grid item xs={12} md={3}>
                  <FormControl fullWidth size="small">
                    <InputLabel id="city-select-label" sx={{ color: "#000" }}>City / Partition</InputLabel>
                    <Select
                      labelId="city-select-label"
                      value={city}
                      onChange={(e) => setCity(e.target.value)}
                      renderValue={(v) => v || ""}
                      sx={{
                        borderRadius: 1,
                        backgroundColor: "#f9f9f9", // box background
                        color: "#0000", // text color
                        "& .MuiSelect-icon": { color: "#222" }, // dropdown arrow
                        "& .MuiOutlinedInput-notchedOutline": {

                        },
                        "& .MuiInputLabel-root": {
                          fontSize: "17px",
                          color: "black",
                        },


                      }}
                    >
                      <MenuItem value="">
                        <em>All</em>
                      </MenuItem>
                      {citiesForRegion?.length > 0 ? (
                        citiesForRegion.map((c, idx) => (
                          <MenuItem key={idx} value={c}>
                            {c}
                          </MenuItem>
                        ))
                      ) : (
                        <MenuItem disabled value="">
                          No predefined cities (type manually below)
                        </MenuItem>
                      )}
                    </Select>
                  </FormControl>
                  <TextField
                    fullWidth
                    size="small"
                    placeholder="Or type manually"
                    value={city}
                    onChange={(e) => setCity(e.target.value)}
                    sx={{
                      mt: 1,
                      borderRadius: 1,
                      "& .MuiInputBase-input": {
                        color: "#000", // input text
                        backgroundColor: "#f9f9f9", // input background
                      },

                      "&:hover .MuiOutlinedInput-notchedOutline": {
                        borderColor: "#1976d2",
                      },

                    }}
                  />
                </Grid>

                {/* NEW: Toggle + Run/Clear controls (visible) */}
                <Grid item xs={12} md={4} sx={{ display: "flex", gap: 1, alignItems: "center", justifyContent: { xs: "flex-start", md: "flex-end" } }}>
                  <Button
                    startIcon={<DateRangeIcon />}
                    variant={useRange ? "contained" : "outlined"}
                    onClick={() => setUseRange(true)}
                    color="warning"
                    size="medium"
                  >
                    Range
                  </Button>
                  <Button
                    startIcon={<DateRangeIcon />}
                    variant={!useRange ? "contained" : "outlined"}
                    onClick={() => setUseRange(false)}
                    color="warning"
                    size="medium"
                  >
                    Single Day
                  </Button>

                  <Button
                    variant="contained"
                    startIcon={<SearchIcon />}
                    onClick={() => fetchDurations()}
                    disabled={loading}
                    color="primary"
                    size="medium"
                  >
                    {loading ? "Loading..." : "Run"}
                  </Button>

                  <Button
                    variant="outlined"
                    startIcon={<ClearIcon />}
                    onClick={() => {
                      setStartDate("");
                      setEndDate("");
                      setSingleDate("");
                      setCity("");
                      setData(null);
                      setError("");
                      setSearchEmployeeId("");
                      setSearchEmployeeName("");
                      setSearchCardNumber("");
                    }}
                    size="medium"
                    sx={{ color: "black", borderColor: "#1976d2", }}
                  >
                    Clear
                  </Button>
                </Grid>

                {/* Date Pickers */}
                {useRange ? (
                  <>
                    <Grid item xs={12} md={3}>
                      <TextField
                        label="Start Date"
                        type="date"
                        fullWidth
                        size="small"
                        value={startDate}
                        onChange={(e) => setStartDate(e.target.value)}
                        inputRef={startDateRef}
                        InputLabelProps={{ shrink: true }}
                        InputProps={{
                          sx: { color: "#000" },
                          endAdornment: (
                            <InputAdornment position="end">
                              <IconButton
                                size="small"
                                onClick={() => openNativeDatePicker(startDateRef)}
                                sx={{ color: "#e6c200" }}
                              >
                                <DateRangeIcon />
                              </IconButton>
                            </InputAdornment>
                          ),
                        }}
                        sx={{
                          bgcolor: "#fff",
                          borderRadius: 1,
                          color: "#000",
                          "& .MuiInputLabel-root": {
                            color: "#000", // <-- label color
                            fontWeight: "bold",
                          },

                        }}
                      />
                    </Grid>
                    <Grid item xs={12} md={3}>
                      <TextField
                        label="End Date"
                        type="date"
                        fullWidth
                        size="small"
                        value={endDate}
                        onChange={(e) => setEndDate(e.target.value)}
                        inputRef={endDateRef}
                        InputLabelProps={{ shrink: true }}
                        InputProps={{
                          sx: { color: "#000" },
                          endAdornment: (
                            <InputAdornment position="end">
                              <IconButton
                                size="small"
                                onClick={() => openNativeDatePicker(endDateRef)}
                                sx={{ color: "#e6c200" }}
                              >
                                <DateRangeIcon />
                              </IconButton>
                            </InputAdornment>
                          ),
                        }}
                        sx={{
                          bgcolor: "#fff",
                          borderRadius: 1,
                          color: "#000",
                          "& .MuiInputLabel-root": {
                            color: "#000", // <-- label color
                            fontWeight: "bold",
                          },

                        }}
                      />
                    </Grid>
                  </>
                ) : (
                  <Grid item xs={12} md={3}>
                    <TextField
                      label="Date"
                      type="date"
                      fullWidth
                      size="small"
                      value={singleDate}
                      onChange={(e) => setSingleDate(e.target.value)}
                      inputRef={singleDateRef}
                      InputLabelProps={{ shrink: true }}
                      InputProps={{
                        sx: { color: "#000" },
                        endAdornment: (
                          <InputAdornment position="end">
                            <IconButton
                              size="small"
                              onClick={() => openNativeDatePicker(singleDateRef)}
                              sx={{ color: "#e6c200" }}
                            >
                              <DateRangeIcon />
                            </IconButton>
                          </InputAdornment>
                        ),
                      }}
                      sx={{
                        bgcolor: "#fff",
                        borderRadius: 1,
                        color: "#000",
                        "& .MuiInputLabel-root": {
                          color: "#000", // <-- label color
                          fontWeight: "bold",
                        },

                      }}
                    />
                  </Grid>
                )}

                {/* Search Fields */}
                {/* <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="Search Employee ID"
                    value={searchEmployeeId}
                    onChange={(e) => setSearchEmployeeId(e.target.value)}
                    size="small"
                    helperText="Type an ID and click Run"
                    sx={{ bgcolor: "#0000", borderRadius: 1, color: "#120101" }}
                  />
                </Grid> */}

                <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="Search Employee ID"
                    value={searchEmployeeId}
                    onChange={(e) => setSearchEmployeeId(e.target.value)}
                    size="small"
                    helperText="Type an ID and click Run"
                    sx={{
                      borderRadius: 1,
                      "& .MuiInputBase-input": {
                        color: "black", // Text color
                        backgroundColor: "white",
                        fontSize: "18px",
                      },
                      "& .MuiInputLabel-root": {
                        fontSize: "17px",
                        color: "black",
                      },
                      "& .MuiFormHelperText-root": {
                        color: "red", // Helper text color
                      },
                    }}
                  />
                </Grid>
                <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="Search Employee Name"
                    value={searchEmployeeName}
                    onChange={(e) => setSearchEmployeeName(e.target.value)}
                    size="small"
                    helperText="Type name and click Run"
                    sx={{
                      borderRadius: 1,
                      "& .MuiInputBase-input": {
                        color: "black", // Text color
                        backgroundColor: "white",
                        fontSize: "18px",
                      },
                      "& .MuiInputLabel-root": {
                        fontSize: "17px",
                        color: "black",
                      },
                      "& .MuiFormHelperText-root": {
                        color: "red", // Helper text color
                      },
                    }}
                  />
                </Grid>
                <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="Search Card Number"
                    value={searchCardNumber}
                    onChange={(e) => setSearchCardNumber(e.target.value)}
                    size="small"
                    helperText="Search by card number"
                    sx={{
                      borderRadius: 1,
                      "& .MuiInputBase-input": {
                        color: "black", // Text color
                        backgroundColor: "white",
                        fontSize: "18px",
                      },
                      "& .MuiInputLabel-root": {
                        fontSize: "17px",
                        color: "black",
                      },
                      "& .MuiFormHelperText-root": {
                        color: "red", // Helper text color
                      },
                    }}
                  />
                </Grid>
              </Grid>
            </CardContent>
          </Card>

        </Grid>

        <Grid item xs={12}>
          <Paper
            elevation={3}
            sx={{
              padding: 2,
              marginBottom: 3,
              borderRadius: 3,
              backgroundColor: "#ffffff",
              boxShadow: "0px 2px 8px rgba(0,0,0,0.06)",
              color: "#000"
            }}
          >
            <Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
              <Typography variant="subtitle1" sx={{ fontWeight: 700 }}>
                {data ? `Showing ${region.toUpperCase()} — ${data.start_date} → ${data.end_date}` : "No results yet"}
              </Typography>
            </Box>

            {loading && (
              <Box sx={{ display: "flex", justifyContent: "center", py: 4 }}>
                <CircularProgress />
              </Box>
            )}

            {error && (
              <Typography color="error" sx={{ mt: 2 }}>
                {error}
              </Typography>
            )}

            {!loading && !error && (
              <Box sx={{ mt: 2 }}>
                {renderTable()}
              </Box>
            )}
          </Paper>
        </Grid>
      </Grid>

      <Dialog open={swipeDialogOpen} onClose={() => setSwipeDialogOpen(false)} fullWidth maxWidth="xl" sx={{ backgroundColor: "#dfe4f2", color: "#000" }}>
        <DialogTitle sx={{ backgroundColor: "#dfe4f2", color: "#000" }}>
          Swipe records for: {selectedEmployee ? `${selectedEmployee.EmployeeID || ""} — ${selectedEmployee.EmployeeName || ""}` : ""}
        </DialogTitle>
        <DialogContent dividers sx={{ backgroundColor: "#fff", color: "#000" }}>
          {selectedSwipes.length === 0 ? (
            <Typography>No swipe records found for this employee in the selected range.</Typography>
          ) : (
            <>
              <Table size="small" sx={dialogTableSx} >
                <TableHead>
                  <TableRow sx={{ backgroundColor: "#e3f2fd", color: "#000" }} >
                    <TableCell><b>Date</b></TableCell>
                    <TableCell><b>Time (local)</b></TableCell>
                    <TableCell><b>Diff (hh:mm:ss)</b></TableCell>
                    <TableCell><b>Door</b></TableCell>
                    <TableCell><b>Direction</b></TableCell>
                    <TableCell><b>CardNumber</b></TableCell>
                    <TableCell><b>PersonnelType</b></TableCell>
                    <TableCell><b>Partition</b></TableCell>
                    <TableCell><b>PrimaryLocation</b></TableCell>
                    <TableCell><b>Company</b></TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {selectedSwipes.map((s, i) => {
                    const isLargeGap = s.DiffSeconds != null && s.DiffSeconds > SWIPE_DIFF_RED_THRESHOLD;
                    return (
                      <TableRow key={i} sx={isLargeGap ? { backgroundColor: "rgba(204, 199, 199, 0.08)" } : {}}>
                        <TableCell sx={{ backgroundColor: "#FFF", color: "#000" }}>{s.Date}</TableCell>
                        <TableCell sx={{ backgroundColor: "#FFF", color: "#000" }}>{s.Swipe_Time ?? (s.LocaleMessageTime ? new Date(s.LocaleMessageTime).toLocaleString() : "-")}</TableCell>
                        <TableCell sx={isLargeGap ? { color: "red", fontWeight: 700, backgroundColor: "#FFF", } : { backgroundColor: "#FFF", color: "#000" }}>{s.DiffHHMMSS ?? "-"}</TableCell>
                        <TableCell sx={{ backgroundColor: "#FFF", color: "#000" }}>{s.Door || s.ObjectName1 || "-"}</TableCell>
                        <TableCell sx={{ backgroundColor: "#FFF", color: "#000" }}>{s.Direction || "-"}</TableCell>
                        <TableCell sx={{ backgroundColor: "#FFF", color: "#000" }}>{s.CardNumber || "-"}</TableCell>
                        <TableCell sx={{ backgroundColor: "#FFF", color: "#000" }}>{s.PersonnelType || "-"}</TableCell>
                        <TableCell sx={{ backgroundColor: "#FFF", color: "#000" }}>{s.PartitionName2 || "-"}</TableCell>
                        <TableCell sx={{ backgroundColor: "#FFF", color: "#000" }}>{s.PrimaryLocation || s.Text5 || "-"}</TableCell>
                        <TableCell sx={{ backgroundColor: "#FFF", color: "#000" }}>{s.CompanyName || "-"}</TableCell>
                      </TableRow>
                    );
                  })}
                </TableBody>
              </Table>

              {renderSwipeSelectionControls()}
            </>
          )}
        </DialogContent>
        <Divider />
        <Box sx={{ p: 1, display: "flex", justifyContent: "flex-end", gap: 1, color: "#000", backgroundColor: "#FFF" }} >
          <Button onClick={() => exportSelectedEmployeeSwipes()} disabled={!selectedSwipes || selectedSwipes.length === 0} sx={{ backgroundColor: "#32a8ed", color: "#000",border: "1px solid rgba(0,0,0,0.12)" }}>Export Swipes</Button>
          <Button onClick={() => setSwipeDialogOpen(false)} sx={{ backgroundColor: "#fa1d00", color: "#000",border: "1px solid rgba(0,0,0,0.12)" }}>Close</Button>
        </Box>
      </Dialog>
    </Box>
  );
}







