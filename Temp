import React, { createContext, useContext, useEffect, useState } from 'react';
import axios from 'axios';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null); // { EmployeeName, EmployeeID, username, ...}
  const [permissions, setPermissions] = useState({}); // { device_health: true, headcount.apac: true, ... }
  const [loading, setLoading] = useState(true);
  const [token, setToken] = useState(() => localStorage.getItem('auth_token') || null);

  // Set axios default header when token changed
  useEffect(() => {
    if (token) {
      axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      localStorage.setItem('auth_token', token);
    } else {
      delete axios.defaults.headers.common['Authorization'];
      localStorage.removeItem('auth_token');
    }
  }, [token]);

  // Try to load user/permissions on start if token exists
  useEffect(() => {
    let cancelled = false;
    async function fetchMe() {
      if (!token) {
        setLoading(false);
        return;
      }
      try {
        const res = await axios.get('/api/auth/me'); // expects { user, permissions }
        if (cancelled) return;
        setUser(res.data.user || null);
        setPermissions(res.data.permissions || {});
      } catch (err) {
        console.warn('fetch /api/auth/me failed', err?.message || err);
        // if token invalid -> clear
        setToken(null);
        setUser(null);
        setPermissions({});
      } finally {
        if (!cancelled) setLoading(false);
      }
    }
    fetchMe();
    return () => { cancelled = true; };
  }, [token]);

  const login = async (username, password) => {
    try {
      const res = await axios.post('/api/auth/login', { username, password });
      const { token: t, user: u, permissions: p } = res.data;
      if (!t) throw new Error('missing token in login response');
      setToken(t);
      setUser(u || null);
      setPermissions(p || {});
      return { ok: true };
    } catch (err) {
      console.error('login failed', err?.response?.data || err?.message || err);
      const msg = err?.response?.data?.detail || err?.response?.data?.error || err?.message || 'Login failed';
      return { ok: false, error: msg };
    }
  };

  const logout = () => {
    setToken(null);
    setUser(null);
    setPermissions({});
  };

  // New: hasPermission supports:
  // - single permission string (e.g. 'device_health' or 'headcount.apac')
  // - returns true if user has 'global_access' (super-permission)
  // - returns true if exact key exists or if asked for 'headcount' and user has any 'headcount.*'
  // - accepts null/undefined -> false
  const hasPermission = (perm) => {
    if (!perm) return false;
    // super-permission
    if (permissions && permissions.global_access) return true;

    // if permission is array - require any match
    if (Array.isArray(perm)) {
      return perm.some(p => hasPermission(p));
    }

    // exact
    if (permissions && permissions[perm]) return true;

    // parent lookup: if asked 'headcount' and user has any headcount.* key - treat as allowed
    const parts = perm.split('.');
    if (parts.length === 1) {
      const prefix = `${perm}.`;
      for (const k of Object.keys(permissions || {})) {
        if (k.startsWith(prefix) && permissions[k]) return true;
      }
    }

    return false;
  };

  // canGrant (kept)
  const canGrant = !!permissions?.can_grant;

  // helper to refresh permissions (call when granting/revoking or token change)
  const refresh = async () => {
    if (!token) return;
    try {
      const res = await axios.get('/api/auth/me');
      setUser(res.data.user || null);
      setPermissions(res.data.permissions || {});
    } catch (err) {
      console.warn('refresh failed', err);
    }
  };

  return (
    <AuthContext.Provider value={{
      user,
      token,
      loading,
      login,
      logout,
      hasPermission,
      canGrant,
      permissions,
      refresh,
    }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  return useContext(AuthContext);
}















// (full file; only the important changed parts are commented inline)
import React, { useState, useEffect, useRef } from 'react';
import {
  Box, Typography, CircularProgress, IconButton, Button, Paper, Divider,
  LinearProgress, Snackbar, Alert, List, ListItem, ListItemText,Tooltip
} from '@mui/material';

import HomeIcon from '@mui/icons-material/Home';
import DescriptionIcon from '@mui/icons-material/Description';
import UploadFileIcon from '@mui/icons-material/UploadFile';

import MapChart from '../components/MapChart.jsx';
import api from '../api';
import { useAuth } from '../context/AuthContext';
import { useNavigate, Link } from 'react-router-dom';

import TimerIcon from "@mui/icons-material/AccessTime"; // duration icon
import { Link as RouterLink } from "react-router-dom";

/*
  Important: permission-based UI adjustments:
  - Region navigation requires 'headcount.<region>' or 'headcount' or 'global_access'
  - Upload Employee/Contractor: 'upload_active_employees' / 'upload_active_contractors'
  - Export Comparison: 'export_compare'
  - Device Health link: 'device_health'
  - GSOC Reports icon: 'gsoc_reports'
  - Duration icon: 'global_duration'
*/

export default function GlobalPage() {
  const navigate = useNavigate();
  const auth = useAuth();

  // ... (all unchanged state & effects from your original file)

  // Render
  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', overflow: 'hidden', bgcolor: 'background.default' }}>
      {/* Header */}
      <Box px={2} py={1} sx={{ backgroundColor: 'black', color: '#fff', borderBottom: '4px solid #FFD700', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
        <Box>
          <IconButton component={Link} to="/" sx={{ color: '#FFC72C' }}><HomeIcon fontSize="medium" /></IconButton>

          {/* Reports - requires 'gsoc_reports' */}
          {auth?.hasPermission('gsoc_reports') && (
            <IconButton component={Link} to="/reports" sx={{ color: '#FFC72C', ml: 1 }}>
              <DescriptionIcon fontSize="medium" />
            </IconButton>
          )}

          {/* Device camera link (protected by device_health) */}
          {auth?.hasPermission('device_health') && (
            <IconButton
              component="a"
              href="http://10.138.161.4:3000/dashboard/index.html"
              rel="noopener noreferrer"
              sx={{ color: '#FFC72C', ml: 1 }}
            >
              <i className="fa-solid fa-camera" style={{ fontSize: 20 }} />
            </IconButton>
          )}

          {/* Associate Verification Tool link */}
          {auth?.hasPermission('associate_verify') && (
            <IconButton
              component="a"
              href="http://10.199.22.57:3004/"
              rel="noopener noreferrer"
              sx={{ color: '#FFF', ml: 1 }}
            >
              <i className="bi bi-patch-check"></i>
            </IconButton>
          )}

{auth?.hasPermission('global_duration') && (
  <Tooltip title="Duration Reports">
    <IconButton
      component={RouterLink}
      to="/duration"
      size="large"
      aria-label="Duration Reports"
      sx={{ color: '#FFF', ml: 1 }}
    >
      <TimerIcon />
    </IconButton>
  </Tooltip>
)}

        </Box>

        <Box sx={{ flexGrow: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
          <Box component="img" src="/wu-head-logo.png" alt="WU Logo" sx={{ height: { xs: 30, md: 55 }, mr: 2 }} />
          <Typography variant="h5" sx={{ fontWeight: 'bold', color: 'primary.main' }}>Global Headcount Dashboard</Typography>
        </Box>

        <Box sx={{ width: 120 }} />
      </Box>

      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, p: 1 }}>
          {auth?.user ? (
            <>
              <Typography variant="body2" sx={{ color: '#fff', mr: 1 }}>
                {auth.user.EmployeeName || auth.user.username || ''}
              </Typography>
              <Button size="small" variant="outlined" onClick={() => { auth.logout(); window.location.href = '/login'; }}>
                Logout
              </Button>

              {auth.canGrant && (
                <Button size="small" variant="contained" onClick={() => navigate('/access-manager')} sx={{ ml: 1 }}>
                  Access Manager
                </Button>
              )}
            </>
          ) : (
            <Button size="small" variant="contained" onClick={() => navigate('/login')}>Login</Button>
          )}
        </Box>

      {/* Top row: Uploads | GLOBAL + Region Cards | Date selectors */}
      <Box sx={{ display: 'flex', alignItems: 'center', p: 1, px: 1, gap: 1 }}>
        {/* Left: fixed column with stacked upload/export buttons (aligned left) */}
        <Box sx={{ width: 260, display: 'flex', flexDirection: 'column', gap: 1 }}>
          <input type="file" accept=".xls,.xlsx,.csv" style={{ display: 'none' }} ref={fileInputEmpRef} onChange={onChooseEmployeeFile} />
          {auth?.hasPermission('upload_active_employees') && (
            <Button
              variant="contained"
              size="small"
              startIcon={<UploadFileIcon />}
              onClick={() => fileInputEmpRef.current && fileInputEmpRef.current.click()}
              sx={{ width: '100%', height: 25, textTransform: 'none', fontWeight: 700 }}
            >
              Upload Active Employee Sheet
            </Button>
          )}

          <input type="file" accept=".xls,.xlsx,.csv" style={{ display: 'none' }} ref={fileInputContrRef} onChange={onChooseContractorFile} />
          {auth?.hasPermission('upload_active_contractors') && (
            <Button
              variant="contained"
              size="small"
              startIcon={<UploadFileIcon />}
              onClick={() => fileInputContrRef.current && fileInputContrRef.current.click()}
              sx={{ width: '100%', height: 25, textTransform: 'none', fontWeight: 700 }}
            >
              Upload Active Contractor Sheet
            </Button>
          )}

          {auth?.hasPermission('export_compare') && (
            <Button
              variant="contained"
              size="small"
              startIcon={<DescriptionIcon />}
              onClick={exportUploadedSheets}
              sx={{ width: '100%', height: 25, textTransform: 'none', fontWeight: 700 }}
            >
              Export Comparison → Report
            </Button>
          )}
        </Box>

        {/* Center: flexible, keeps region cards exactly centered on screen */}
        <Box sx={{ flex: 1, display: 'flex', justifyContent: 'center' }}>
          <Box sx={{ display: 'flex', gap: 3, alignItems: 'center', justifyContent: 'center', flexWrap: 'wrap' }}>
            {[
              { key: 'global', label: 'GLOBAL', count: globalCount, url: null },
              { key: 'apac', label: 'APAC', count: counts.apac, url: 'http://10.199.22.57:3000/' },
              { key: 'emea', label: 'EMEA', count: counts.emea, url: 'http://10.199.22.57:3001/' },
              { key: 'laca', label: 'LACA', count: counts.laca, url: 'http://10.199.22.57:3003/' },
              { key: 'namer', label: 'NAMER', count: counts.namer, url: 'http://10.199.22.57:3002/' },
            ].map(region => (
              <Box
                key={region.key}
                onClick={() => {
                  if (region.key === 'global') {
                    const el = document.querySelector('[data-global-left-panel]');
                    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    setSelected('global');
                    return;
                  }
                  // require permission: headcount.<region> OR headcount OR global_access
                  const permCandidates = [`headcount.${region.key}`, 'headcount', 'global_access'];
                  if (!auth.hasPermission(permCandidates)) {
                    // simple UX: alert (could be replaced by nicer toast)
                    setSnack({ open: true, severity: 'warning', message: `Access denied to ${region.label} headcount` });
                    return;
                  }
                  if (region.url) window.location.href = region.url;
                }}
                sx={{
                  cursor: 'pointer',
                  width: 200,
                  height: 88,
                  display: 'flex',
                  flexDirection: 'column',
                  justifyContent: 'center',
                  alignItems: 'center',
                  border: '4px solid rgba(255, 204, 0, 0.89)',
                  borderRadius: 2,
                  boxShadow: 3,
                  bgcolor: 'transparent',
                  '&:hover': { opacity: 0.95 },
                }}
              >
                <Typography variant="subtitle2" sx={{ fontWeight: 'bold', color: '#FFC72C', fontSize: { xs: '0.95rem', md: '1.2rem' } }}>
                  {region.label}
                </Typography>
                <Typography variant="h4" sx={{ fontWeight: 900, fontSize: { xs: '1.2rem', md: '1.6rem' }, color: '#FFFFFF' }}>
                  {region.count ?? 0}
                </Typography>
              </Box>
            ))}
          </Box>
        </Box>

        {/* Right: fixed column for date selectors (aligned right) */}
        <Box sx={{ width: 360, display: 'flex', flexDirection: 'column', gap: 1, alignItems: 'flex-end' }}>
          <Paper sx={{ p: 1, display: 'flex', gap: 1, alignItems: 'center', boxShadow: 1, width: '100%' }}>
            <Box sx={{ display: 'flex', flexDirection: 'column', width: 160 }}>
              <Typography variant="caption" color="text.secondary">Select Start date</Typography>
              <input
                type="date"
                value={startDate}
                onChange={(e) => setStartDate(e.target.value)}
                style={{ width: '100%', height: 34, borderRadius: 4, border: '1px solid rgba(255,255,255,0.06)', padding: 4, background: '#FFCC00', color: 'Black' }}
              />
            </Box>

            <Box sx={{ display: 'flex', flexDirection: 'column', width: 160 }}>
              <Typography variant="caption" color="text.secondary">Select End date</Typography>
              <input
                type="date"
                value={endDate}
                onChange={(e) => setEndDate(e.target.value)}
                style={{ width: '100%', height: 34, borderRadius: 4, border: '1px solid rgba(255,255,255,0.06)', padding: 4, background: '#FFCC00', color: 'Black' }}
              />
            </Box>
          </Paper>

          <Box sx={{ width: '100%', display: 'flex', justifyContent: 'flex-start' }}>
            <Button size="small" variant="contained" onClick={applyDateRange} sx={{ height: 36, textTransform: 'none', fontWeight: 700 }}>
              Apply
            </Button>
          </Box>
        </Box>
      </Box>

      {/* ... remainder of the file unchanged (left summary, map, right averages, snackbars) */}
      {/* I preserved the rest of your original implementations (SSE, polling, CSV logic, etc.) */}
      {/* ... */}
    </Box>
  );
}












// (At top of file - add useAuth import)
import { useAuth } from '../context/AuthContext';

// ... existing imports / helpers unchanged ...

export default function ReportsPage() {
  const auth = useAuth();

  // --- state ---
  const [tab, setTab] = useState(0);

  // ... rest of your state unchanged ...

  const handleGenerate = async () => {
    // Permission gating: determine required permission for each tab
    const requirePermissionForTab = () => {
      if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
      if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
      if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
      if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
      if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
      if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
      return ['gsoc_reports'];
    };

    if (!auth.hasPermission(requirePermissionForTab())) {
      alert('You do not have permission to generate this report.');
      return;
    }

    setLoading(true);
    try {
      const baseParams = { region, location: location || undefined };

      // ... rest of generation logic unchanged, but before navigation in tab 5 we re-check permissions

      // ----- 5: HeadCount / External navigation -----
      if (tab === 5) {
        // final check (region specific)
        const permCandidates = [`headcount.${region}`, 'headcount', 'global_access'];
        if (!auth.hasPermission(permCandidates)) {
          alert(`You do not have permission to view HeadCount for ${region.toUpperCase()}.`);
          setLoading(false);
          return;
        }

        let url = '';

        // ... existing URL building logic unchanged ...

        if (url) window.location.href = url;
        else alert('Invalid region or location selected.');
        return;
      }

      // (all other tabs proceed as before)
    } catch (err) {
      console.error(err);
      alert('Failed to generate report');
    } finally {
      setLoading(false);
    }
  };

  // disabled conditions - include permission check
  const disabled = loading
    || !region
    || (tab === 0 && (!from || !to || selectedEmps.length === 0)) // Daily Access
    || (tab === 1 && (!from || !to)) // Raw
    || (tab === 2 && (!from || !to)) // Rejection - require date range
    || (tab === 3 && !from) // EUROC (single day)
    || (tab === 4 && (!from || !to));

  const navDisabled = !region || loading;

  // Compute Export button text/disabled w.r.t permission
  const exportPermsForTab = () => {
    if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
    if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
    if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
    if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
    if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
    if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
    return ['gsoc_reports'];
  };

  const exportAllowed = auth.hasPermission(exportPermsForTab());

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
        {/* Topbar / Header */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            px: 3,
            py: 2,
            borderBottom: '1px solid rgba(255,204,0,0.08)',
            background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
          }}
        >
          {/* ... header unchanged ... */}
          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
            <Button
              startIcon={<DownloadIcon />}
              onClick={handleGenerate}
              disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
              sx={{
                bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                color: '#000',
                fontWeight: 800,
                px: 3,
                py: 1,
                borderRadius: 3,
                boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
                transformOrigin: 'center',
                '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-2px)' : 'none' }
              }}
            >
              {loading ? 'Loading…'
                       : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
            </Button>
          </Box>
        </Box>

        {/* ... remainder of UI unchanged, but internal generate handlers already guarded */}











import React, { useEffect, useState } from 'react';
import { Box, Paper, TextField, Button, Typography, Checkbox, FormControlLabel, Grid, Alert } from '@mui/material';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';

// Define available page keys (map to UI names)
// Added granular keys: headcount.<region>, gsoc_reports.<report>, upload/export perms, global_access
const PAGES = [
  { key: 'global_access', label: 'Global Access (all pages)' },
  { key: 'device_health', label: 'Device Health Dashboard' },
  { key: 'headcount', label: 'HeadCount (any region)' },
  { key: 'headcount.apac', label: 'HeadCount — APAC' },
  { key: 'headcount.emea', label: 'HeadCount — EMEA' },
  { key: 'headcount.laca', label: 'HeadCount — LACA' },
  { key: 'headcount.namer', label: 'HeadCount — NAMER' },
  { key: 'headcount.partition.pune', label: 'HeadCount — Pune (partition)' },

  { key: 'ert', label: 'ERT Members' },
  { key: 'associate_verify', label: 'Associate Verification Tool' },

  // GSOC reports per-report keys
  { key: 'gsoc_reports', label: 'GSOC Reports (all)' },
  { key: 'gsoc_reports.daily_access', label: 'GSOC — Daily Access' },
  { key: 'gsoc_reports.raw', label: 'GSOC — Raw' },
  { key: 'gsoc_reports.rejection', label: 'GSOC — Rejection' },
  { key: 'gsoc_reports.euroc', label: 'GSOC — EUROC Admit/Reject' },
  { key: 'gsoc_reports.time_duration', label: 'GSOC — Time Duration' },
  { key: 'gsoc_reports.headcount', label: 'GSOC — HeadCount (external nav)' },

  // Upload / export permissions
  { key: 'upload_active_employees', label: 'Upload Active Employee Sheet' },
  { key: 'upload_active_contractors', label: 'Upload Active Contractor Sheet' },
  { key: 'export_compare', label: 'Export Comparison (Missing vs CCURE)' },

  { key: 'global_duration', label: 'Duration Page (global)' },
  { key: 'can_grant', label: 'Grant permissions (admin)' },
];

export default function AccessManager() {
  const auth = useAuth();
  const [employeeId, setEmployeeId] = useState('');
  const [employeeName, setEmployeeName] = useState('');
  const [checked, setChecked] = useState({});
  const [status, setStatus] = useState(null);

  useEffect(() => {
    // nothing heavy here
  }, []);

  if (!auth.canGrant) {
    return <Box sx={{ p: 3 }}><Alert severity="error">You don't have grant permissions.</Alert></Box>;
  }

  const handleCheck = (k) => {
    setChecked(prev => ({ ...prev, [k]: !prev[k] }));
  };

  const handleGrant = async () => {
    if (!employeeId && !employeeName) {
      setStatus({ type: 'error', msg: 'Enter Employee ID or name to grant access' });
      return;
    }
    setStatus({ type: 'info', msg: 'Granting...' });
    try {
      const pages = Object.keys(checked).filter(k => checked[k]);
      await axios.post('/api/auth/grant', { grantee_employee_id: employeeId, grantee_name: employeeName, pages });
      setStatus({ type: 'success', msg: 'Granted successfully' });
      auth.refresh();
    } catch (err) {
      console.error(err);
      setStatus({ type: 'error', msg: err?.response?.data?.detail || err?.message || 'Grant failed' });
    }
  };

  const handleRevoke = async () => {
    if (!employeeId && !employeeName) {
      setStatus({ type: 'error', msg: 'Enter Employee ID or name to revoke access' });
      return;
    }
    setStatus({ type: 'info', msg: 'Revoking...' });
    try {
      const pages = Object.keys(checked).filter(k => checked[k]);
      await axios.post('/api/auth/revoke', { grantee_employee_id: employeeId, grantee_name: employeeName, pages });
      setStatus({ type: 'success', msg: 'Revoked successfully' });
      auth.refresh();
    } catch (err) {
      console.error(err);
      setStatus({ type: 'error', msg: err?.response?.data?.detail || err?.message || 'Revoke failed' });
    }
  };

  const selectAll = () => {
    const obj = {};
    PAGES.forEach(p => obj[p.key] = true);
    setChecked(obj);
  };
  const clearAll = () => setChecked({});

  return (
    <Box sx={{ p: 3 }}>
      <Paper sx={{ p: 3 }}>
        <Typography variant="h6" sx={{ mb: 2 }}>Access Manager — Grant / Revoke Pages</Typography>

        {status && <Alert severity={status.type} sx={{ mb: 2 }}>{status.msg}</Alert>}

        <Grid container spacing={2}>
          <Grid item xs={12} md={6}>
            <TextField fullWidth label="Employee ID (e.g. W0025562)" value={employeeId} onChange={e => setEmployeeId(e.target.value)} helperText="EmployeeID or login"/>
          </Grid>
          <Grid item xs={12} md={6}>
            <TextField fullWidth label="Employee Name (optional)" value={employeeName} onChange={e => setEmployeeName(e.target.value)} />
          </Grid>

          <Grid item xs={12}>
            <Typography sx={{ mb: 1, fontWeight: 700 }}>Pages to grant / revoke</Typography>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
              {PAGES.map(p => (
                <FormControlLabel
                  key={p.key}
                  control={<Checkbox checked={!!checked[p.key]} onChange={() => handleCheck(p.key)} />}
                  label={p.label}
                />
              ))}
            </Box>

            <Box sx={{ display: 'flex', gap: 1, mt: 2 }}>
              <Button variant="outlined" onClick={selectAll}>Select all</Button>
              <Button variant="outlined" onClick={clearAll}>Clear</Button>
              <Button variant="contained" color="primary" onClick={handleGrant}>Grant access</Button>
              <Button variant="contained" color="error" onClick={handleRevoke}>Revoke access</Button>
            </Box>

            <Typography variant="caption" sx={{ display: 'block', mt: 2, color: 'text.secondary' }}>
              Granting will call backend and store the mapping. Revoking will remove access. After changes, this UI refreshes current user's permissions (if affected).
            </Typography>
          </Grid>
        </Grid>
      </Paper>
    </Box>
  );
}









{
  "users": [
    {
      "username": "Lloyds Das",
      "employeeId": "314345",
      "password": "password123",
      "permissions": {
        "can_grant": true,
        "global_access": true,
        "device_health": true,
        "headcount": true,
        "headcount.apac": true,
        "headcount.emea": true,
        "headcount.laca": true,
        "headcount.namer": true,
        "ert": true,
        "associate_verify": true,
        "gsoc_reports": true,
        "global_duration": true,
        "upload_active_employees": true,
        "upload_active_contractors": true,
        "export_compare": true
      }
    },
    {
      "username": "Pandey, Sonu",
      "employeeId": "326131",
      "password": "password123",
      "permissions": {
        "can_grant": true,
        "global_access": true,
        "device_health": true,
        "headcount": true,
        "headcount.apac": true,
        "headcount.emea": true,
        "headcount.laca": true,
        "headcount.namer": true,
        "ert": true,
        "associate_verify": true,
        "gsoc_reports": true,
        "global_duration": true,
        "upload_active_employees": true,
        "upload_active_contractors": true,
        "export_compare": true
      }
    },
    {
      "username": "Diwate, Swapnil",
      "employeeId": "W0024618",
      "password": "password123",
      "permissions": {
        "can_grant": true,
        "global_access": true,
        "device_health": true,
        "headcount": true,
        "headcount.apac": true,
        "headcount.emea": true,
        "headcount.laca": true,
        "headcount.namer": true,
        "ert": true,
        "associate_verify": true,
        "gsoc_reports": true,
        "global_duration": true,
        "upload_active_employees": true,
        "upload_active_contractors": true,
        "export_compare": true
      }
    },
    {
      "username": "Dhobale, Abhishek",
      "employeeId": "W0025562",
      "password": "password123",
      "permissions": {
        "ert": true
      }
    }
  ]
}





























C:\Users\W0024618\Desktop\global-page\backend\config\users.json


{
  "users": [
    {
      "username": "Lloyds Das",
      "employeeId": "314345",
      "password": "password123",
      "permissions": {
        "can_grant": true,
        "device_health": true,
        "headcount": true,
        "ert": true,
        "associate_verify": true,
        "gsoc_reports": true,
        "global_duration": true
      }
    },
    {
      "username": "Pandey, Sonu",
      "employeeId": "326131",
      "password": "password123",
      "permissions": {
        "can_grant": true,
        "device_health": true,
        "headcount": true,
        "ert": true,
        "associate_verify": true,
        "gsoc_reports": true,
        "global_duration": true
      }
    },
    {
      "username": "Diwate, Swapnil",
      "employeeId": "W0024618",
      "password": "password123",
      "permissions": {
        "can_grant": true,
        "device_health": true,
        "headcount": true,
        "ert": true,
        "associate_verify": true,
        "gsoc_reports": true,
        "global_duration": true
      }
    },
    {
      "username": "Dhobale, Abhishek",
      "employeeId": "W0025562",
      "password": "password123",
      "permissions": {
        "ert": true
      }
    }
  ]
}








// backend/routes/auth.js
import express from 'express';
import { readFile, writeFile } from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import crypto from 'crypto';

const router = express.Router();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const USERS_FILE = path.resolve(__dirname, '../config/users.json');

// In-memory token->employeeId map (lost on server restart)
const activeTokens = new Map();

async function loadUsers() {
  try {
    const raw = await readFile(USERS_FILE, 'utf8');
    const obj = JSON.parse(raw);
    return obj && Array.isArray(obj.users) ? obj.users : [];
  } catch (err) {
    // If missing file, return empty array
    return [];
  }
}

async function saveUsers(users) {
  const payload = { users };
  await writeFile(USERS_FILE, JSON.stringify(payload, null, 2), 'utf8');
}

function genToken() {
  return crypto.randomBytes(32).toString('hex');
}

function findUser(users, { username, employeeId }) {
  if (employeeId) {
    const byId = users.find(u => String(u.employeeId).toLowerCase() === String(employeeId).toLowerCase());
    if (byId) return byId;
  }
  if (username) {
    const byName = users.find(u => String(u.username).toLowerCase() === String(username).toLowerCase());
    if (byName) return byName;
    // also allow login by exact EmployeeID sent in username field
    const byId2 = users.find(u => String(u.employeeId).toLowerCase() === String(username).toLowerCase());
    if (byId2) return byId2;
  }
  return null;
}

// middleware to require token and attach user object to req.currentUser
async function requireAuth(req, res, next) {
  try {
    const auth = req.headers.authorization || '';
    if (!auth.startsWith('Bearer ')) return res.status(401).json({ detail: 'Missing auth token' });
    const token = auth.slice(7).trim();
    const empId = activeTokens.get(token);
    if (!empId) return res.status(401).json({ detail: 'Invalid or expired token' });

    const users = await loadUsers();
    const user = users.find(u => String(u.employeeId).toLowerCase() === String(empId).toLowerCase());
    if (!user) return res.status(401).json({ detail: 'Invalid token (user not found)' });

    req.currentUser = user;
    req.currentToken = token;
    next();
  } catch (err) {
    next(err);
  }
}

// --- POST /login
// body: { username, password }
router.post('/login', async (req, res, next) => {
  try {
    const { username, password } = req.body || {};
    if (!username || !password) return res.status(400).json({ detail: 'username and password are required' });

    const users = await loadUsers();
    const user = findUser(users, { username });
    if (!user) return res.status(401).json({ detail: 'Invalid credentials' });

    // plain-text compare for prototype. Replace with bcrypt in prod.
    if (String(user.password || '') !== String(password)) return res.status(401).json({ detail: 'Invalid credentials' });

    // generate token and store mapping
    const token = genToken();
    activeTokens.set(token, user.employeeId);

    // Return minimal user object (do not expose password)
    const safeUser = {
      username: user.username,
      employeeId: user.employeeId,
      // you can include additional fields if present
    };

    return res.json({ token, user: safeUser, permissions: user.permissions || {} });
  } catch (err) {
    next(err);
  }
});

// --- GET /me
// header: Authorization: Bearer <token>
router.get('/me', requireAuth, async (req, res, next) => {
  try {
    const user = req.currentUser;
    const safeUser = { username: user.username, employeeId: user.employeeId };
    return res.json({ user: safeUser, permissions: user.permissions || {} });
  } catch (err) {
    next(err);
  }
});

// --- POST /grant
// body: { grantee_employee_id, grantee_name, pages: ['headcount','ert', ...] }
// Only callers with currentUser.permissions.can_grant === true
router.post('/grant', requireAuth, async (req, res, next) => {
  try {
    const caller = req.currentUser;
    if (!caller.permissions || !caller.permissions.can_grant) return res.status(403).json({ detail: 'You do not have grant permission' });

    const { grantee_employee_id, grantee_name, pages } = req.body || {};
    if ((!grantee_employee_id && !grantee_name) || !Array.isArray(pages)) {
      return res.status(400).json({ detail: 'grantee_employee_id or grantee_name and pages[] are required' });
    }

    const users = await loadUsers();

    let grantee = findUser(users, { employeeId: grantee_employee_id, username: grantee_name });

    if (!grantee) {
      // create minimal user record (password blank) — admin should set password later
      grantee = {
        username: grantee_name || (grantee_employee_id ? `emp-${grantee_employee_id}` : 'unknown'),
        employeeId: grantee_employee_id || `unknown-${Date.now()}`,
        password: '',
        permissions: {}
      };
      users.push(grantee);
    }

    if (!grantee.permissions) grantee.permissions = {};
    for (const p of pages) {
      grantee.permissions[p] = true;
    }

    await saveUsers(users);

    // Return updated grantee (sans password)
    const safeGrantee = { username: grantee.username, employeeId: grantee.employeeId, permissions: grantee.permissions };
    return res.json({ ok: true, grantee: safeGrantee });
  } catch (err) {
    next(err);
  }
});

// --- POST /revoke
// body: { grantee_employee_id, grantee_name, pages: ['headcount', ...] }
// Only callers with can_grant
router.post('/revoke', requireAuth, async (req, res, next) => {
  try {
    const caller = req.currentUser;
    if (!caller.permissions || !caller.permissions.can_grant) return res.status(403).json({ detail: 'You do not have grant permission' });

    const { grantee_employee_id, grantee_name, pages } = req.body || {};
    if ((!grantee_employee_id && !grantee_name) || !Array.isArray(pages)) {
      return res.status(400).json({ detail: 'grantee_employee_id or grantee_name and pages[] are required' });
    }

    const users = await loadUsers();
    const grantee = findUser(users, { employeeId: grantee_employee_id, username: grantee_name });
    if (!grantee) return res.status(404).json({ detail: 'Grantee not found' });

    if (!grantee.permissions) grantee.permissions = {};
    for (const p of pages) {
      delete grantee.permissions[p]; // remove key
    }

    await saveUsers(users);

    const safeGrantee = { username: grantee.username, employeeId: grantee.employeeId, permissions: grantee.permissions };
    return res.json({ ok: true, grantee: safeGrantee });
  } catch (err) {
    next(err);
  }
});

// --- GET /list  (debug; returns users without passwords)
router.get('/list', requireAuth, async (req, res, next) => {
  try {
    const users = await loadUsers();
    const safe = users.map(u => ({ username: u.username, employeeId: u.employeeId, permissions: u.permissions || {} }));
    return res.json({ users: safe });
  } catch (err) {
    next(err);
  }
});

export default router;









// C:\Users\W0024618\Desktop\global-page\backend\index.js
import express from 'express';
import cors from 'cors';
import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';
import reportsRouter from './routes/reports.js';
import headcountRouter from './routes/headcount.js';
import vipRouter       from './routes/vip.js';
import authRouter      from './routes/auth.js';   // <-- NEW

const __filename = fileURLToPath(import.meta.url);
const __dirname  = dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3008;

// 1) Middleware
app.use(cors());              // enable CORS for all origins
app.use(express.json());      // parse JSON payloads

// 2) Static Assets (if you have any in ../public)
app.use(express.static(resolve(__dirname, '../public')));

// 3) API Routes
app.use('/api/headcount', headcountRouter);
app.use('/api/vip',       vipRouter);
app.use('/api/reports',   reportsRouter);
app.use('/api/auth',      authRouter);   // <-- NEW

// 4) Health-check endpoint (optional)
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok', uptime: process.uptime() });
});

// 5) Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res
    .status(err.status || 500)
    .json({ error: err.message || 'Internal Server Error' });
});

// 6) Start server
app.listen(PORT, () => {
  console.log(`🌍 Global-backend listening on http://localhost:${PORT}`);
});


