Now frontend look good now update below 
1) in Frontend swipe records if i want to update Duration Manually it supports only single date ..
like Current logic is ...
swapnil Diwate  Swipe records are 11-sep and 12-sep 
if i want to adjust duration it suppots only one date like i selct start date as 11-sep 
then in end date will display only 11-sep ..

so expected is if i select start date is 11-sep , and i want to select end date 12-sep
need this logic like we need option to select end date as per swipe records like 11 or 12 -sep ..
Update only above request and share me updated snippet carefully




// frontend/src/pages/DurationPage.jsx
import React, { useState, useMemo, useEffect, useCallback, useRef } from "react";
import axios from "axios";
import {
  Box,
  Grid,
  Paper,
  Typography,
  TextField,
  Button,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  TableContainer,
  CircularProgress,
  IconButton,
  Tooltip,
  Card,
  CardContent,
  Dialog,
  DialogTitle,
  DialogContent,
  Divider,
  MenuItem,
  Select,
  FormControl,
  InputLabel,
  InputAdornment,
} from "@mui/material";
import DateRangeIcon from "@mui/icons-material/DateRange";
import SearchIcon from "@mui/icons-material/Search";
import DownloadIcon from "@mui/icons-material/CloudDownload";
import ClearIcon from "@mui/icons-material/Clear";
import VisibilityIcon from "@mui/icons-material/Visibility";

const API_BASE =
  import.meta.env.VITE_API_BASE ||
  import.meta.env.REACT_APP_API_BASE ||
  "http://localhost:8000";

const REGIONS = [
  { value: "apac", label: "APAC" },
  { value: "emea", label: "EMEA" },
  { value: "laca", label: "LACA" },
  { value: "namer", label: "NAMER" },
];

function secondsToHMS(s) {
  if (s == null) return "";
  const sec = Number(s);
  if (!Number.isFinite(sec)) return "";
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const r = Math.floor(sec % 60);
  return `${h}:${String(m).padStart(2, "0")}:${String(r).padStart(2, "0")}`;
}

function isoToDDMMYYYY(iso) {
  if (!iso) return iso;
  const dt = new Date(iso.includes("T") ? iso : `${iso}T00:00:00Z`);
  if (Number.isNaN(dt.getTime())) return iso;
  const dd = String(dt.getUTCDate()).padStart(2, "0");
  const mm = String(dt.getUTCMonth() + 1).padStart(2, "0");
  const yyyy = dt.getUTCFullYear();
  return `${dd}-${mm}-${yyyy}`;
}

function isoToLongDateNoCommas(iso) {
  if (!iso) return iso;
  const dt = new Date(iso.includes("T") ? iso : `${iso}T00:00:00Z`);
  if (Number.isNaN(dt.getTime())) return iso;
  const weekday = dt.toLocaleDateString(undefined, { weekday: "short" });
  const day = String(dt.getUTCDate()).padStart(2, "0");
  const month = String(dt.getUTCMonth() + 1).padStart(2, "0");
  const year = dt.getUTCFullYear();
  return `${weekday} ${day}-${month}-${year}`;
}

// threshold used for highlighting swipe differences > 6 hours
const SWIPE_DIFF_RED_THRESHOLD = 6 * 3600;

export default function DurationPage() {
  const [region, setRegion] = useState("apac");
  const [city, setCity] = useState("");
  const [citiesForRegion, setCitiesForRegion] = useState([]);
  const [startDate, setStartDate] = useState("");
  const [endDate, setEndDate] = useState("");
  const [singleDate, setSingleDate] = useState("");
  const [useRange, setUseRange] = useState(true);

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const [searchEmployeeId, setSearchEmployeeId] = useState("");
  const [searchEmployeeName, setSearchEmployeeName] = useState("");
  const [searchCardNumber, setSearchCardNumber] = useState("");

  const [swipeDialogOpen, setSwipeDialogOpen] = useState(false);
  const [selectedEmployee, setSelectedEmployee] = useState(null);
  const [selectedSwipes, setSelectedSwipes] = useState([]);

  // New UI state for override selection
  const [overrideDate, setOverrideDate] = useState("");
  const [overrideStartIndex, setOverrideStartIndex] = useState(null);
  const [overrideEndIndex, setOverrideEndIndex] = useState(null);
  const [overrideReason, setOverrideReason] = useState("");
  const [overrideApplying, setOverrideApplying] = useState(false);

  // Refs for native date inputs so we can call showPicker() (if supported)
  const startDateRef = useRef(null);
  const endDateRef = useRef(null);
  const singleDateRef = useRef(null);

  // Styling for tables (borders + header background)
  const tableSx = {
    "& th, & td": { border: "1px solid rgba(0,0,0,0.12)" },
    "& thead th": { backgroundColor: "#FFD700", fontWeight: 700 },
    "& tbody tr": { backgroundColor: "transparent" },
    "& tbody tr:hover": { backgroundColor: "rgba(255, 204, 0, 0.12)" },
  };

  const dialogTableSx = {
    "& th, & td": { border: "1px solid rgba(0,0,0,0.12)" },
    "& thead th": { backgroundColor: "#FFD700", fontWeight: 700 },
    "& tbody tr:hover": { backgroundColor: "rgba(255, 204, 0, 0.08)" },
  };

  // helper to try to open the native date picker (where supported)
  const openNativeDatePicker = (ref) => {
    if (!ref || !ref.current) return;
    try {
      if (typeof ref.current.showPicker === "function") {
        ref.current.showPicker();
      } else {
        ref.current.focus();
      }
    } catch (e) {
      try {
        ref.current.focus();
      } catch {}
    }
  };

  // fetch cities when region changes
  useEffect(() => {
    async function fetchCities() {
      setCitiesForRegion([]);
      setCity("");
      try {
        const res = await axios.get(`${API_BASE}/duration/cities`, {
          params: { region },
          timeout: 20000,
        });
        const cities = res.data?.cities || [];
        setCitiesForRegion(cities);
      } catch (err) {
        console.warn("Failed to fetch cities list:", err?.message || err);
        setCitiesForRegion([]);
      }
    }
    fetchCities();
  }, [region]);

  // --- fetch durations (full) ---
  const fetchDurations = useCallback(
    async (opts = {}) => {
      // default full fetch (used when user clicks Run)
      setError("");
      setLoading(true);
      setData(null);

      try {
        const params = {};
        if (useRange && startDate && endDate) {
          params.start_date = startDate;
          params.end_date = endDate;
        } else if (!useRange && singleDate) {
          params.date = singleDate;
        } else {
          if (singleDate) params.date = singleDate;
        }

        if (region) params.regions = region;
        if (city) params.city = city;

        // server-side filters
        if (searchEmployeeId) params.employee_id = searchEmployeeId;
        if (searchEmployeeName) params.employee_name = searchEmployeeName;
        if (searchCardNumber) params.card_number = searchCardNumber;

        // allow overriding timeout via opts
        const timeout = opts.timeout || 1200000;

        const res = await axios.get(`${API_BASE}/duration`, {
          params,
          timeout,
        });
        setData(res.data);
      } catch (err) {
        console.error(err);
        setError(err?.response?.data?.detail || err.message || "Failed to fetch duration data");
      } finally {
        setLoading(false);
      }
    },
    [useRange, startDate, endDate, singleDate, region, city, searchEmployeeId, searchEmployeeName, searchCardNumber]
  );

  // --- targeted fetch: get only single employee for current region and merge into UI ---
  const fetchAndMergeEmployee = useCallback(
    async ({ employeeId, person_uid } = {}) => {
      if (!employeeId && !person_uid) return;
      try {
        const params = {};
        if (useRange && startDate && endDate) {
          params.start_date = startDate;
          params.end_date = endDate;
        } else if (!useRange && singleDate) {
          params.date = singleDate;
        } else {
          if (singleDate) params.date = singleDate;
        }
        params.regions = region;
        // prefer server-side employee_id filter (EmployeeID)
        if (employeeId) params.employee_id = employeeId;
        // if no EmployeeID but we have person_uid, pass employee_name or a unique param — backend supports employee_id only,
        // but person_uid may match PersonGUID in swipes. We'll pass employee_name if nothing else.
        if (!employeeId && person_uid) {
          params.employee_name = person_uid;
        }
        params.sample_rows = 0; // we only need exact employee rows, avoid extra samples
        const res = await axios.get(`${API_BASE}/duration`, { params, timeout: 120000 });
        const resp = res.data;
        if (!resp || !resp.regions || !resp.regions[region]) {
          // no matching data returned
          return;
        }
        const newRegionObj = resp.regions[region];
        const fetchedEmployees = newRegionObj.employees || [];

        setData((prev) => {
          try {
            if (!prev) {
              // nothing previously, use fetched answer
              return resp;
            }
            const next = { ...prev, regions: { ...(prev.regions || {}) } };
            const prevRegion = (prev.regions || {})[region] || { dates: [], employees: [], swipes_by_date: {} };
            // merge dates and swipes_by_date from fetched
            const mergedRegion = {
              ...prevRegion,
              dates: newRegionObj.dates || prevRegion.dates,
              date_rows: newRegionObj.date_rows || prevRegion.date_rows,
              swipes_by_date: { ...(prevRegion.swipes_by_date || {}), ...(newRegionObj.swipes_by_date || {}) },
            };

            // update (replace) employees: for each fetched employee, replace or insert into prevRegion.employees
            const prevEmployees = Array.isArray(prevRegion.employees) ? [...prevRegion.employees] : [];
            fetchedEmployees.forEach((fe) => {
              const idx = prevEmployees.findIndex((p) => {
                // match by person_uid if present else by EmployeeID
                if (p.person_uid && fe.person_uid) return p.person_uid === fe.person_uid;
                if (p.EmployeeID && fe.EmployeeID) return String(p.EmployeeID) === String(fe.EmployeeID);
                return false;
              });
              if (idx >= 0) {
                prevEmployees[idx] = fe;
              } else {
                // insert (keeping sort might be messy, so append)
                prevEmployees.push(fe);
              }
            });

            mergedRegion.employees = prevEmployees;
            next.regions[region] = mergedRegion;
            return next;
          } catch (e) {
            // fallback: set full response
            console.error("Failed to merge employee data:", e);
            return resp;
          }
        });
      } catch (err) {
        console.error("fetchAndMergeEmployee failed:", err);
      }
    },
    [region, startDate, endDate, singleDate, useRange]
  );

  // derive current region object quickly
  const regionObj = useMemo(() => {
    if (!data || !region) return null;
    return data.regions?.[region] || null;
  }, [data, region]);

  // helpers to compute week starts from regionObj.dates
  const computeWeekStarts = (datesIso) => {
    if (!datesIso || datesIso.length === 0) return [];
    const dateObjs = datesIso.map((d) => new Date(d + "T00:00:00Z"));
    const weekStartSet = new Set();
    dateObjs.forEach((dt) => {
      const day = dt.getUTCDay();
      const diff = (day + 6) % 7; // shift so Monday is week start
      const monday = new Date(dt);
      monday.setUTCDate(dt.getUTCDate() - diff);
      weekStartSet.add(monday.toISOString().slice(0, 10));
    });
    return Array.from(weekStartSet).sort();
  };

  // --- CSV helpers (unchanged, kept local) ---
  const quote = (s) => `"${String(s ?? "").replace(/"/g, '""')}"`;

  const exportSummaryCsv = () => {
    if (!regionObj) return;
    const dates = regionObj.dates || [];
    const rows = regionObj.employees || [];

    const header = ["EmployeeID", "EmployeeName", "TotalSecondsPresentInRange", "DominantCategory", "ComplianceSummary", ...dates.map((d) => d)];
    const csvRows = [header.map((h) => quote(h)).join(",")];

    rows.forEach((r) => {
      const complianceText = r.compliance?.month_summary || "";
      const complianceCell = `'${complianceText}`; // force text in Excel
      const row = [
        quote(r.EmployeeID || ""),
        quote(r.EmployeeName || ""),
        r.total_seconds_present_in_range ?? "",
        quote(r.duration_categories?.dominant_category || ""),
        quote(complianceCell),
        ...dates.map((d) => quote(r.durations?.[d] ?? "")),
      ];
      csvRows.push(row.join(","));
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `duration_summary_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  const exportReportCsv = () => {
    if (!regionObj) return;
    const datesIso = regionObj.dates || [];
    const weekStarts = computeWeekStarts(datesIso);

    const baseHeader = ["Sr.No", "EmployeeID", "EmployeeName", "CardNumber", "PersonnelType", "PartitionName2", "TotalSecondsPresentInRange"];
    const perDayHeaders = [];
    weekStarts.forEach((ws) => {
      for (let i = 0; i < 7; i++) {
        const d = new Date(ws + "T00:00:00Z");
        d.setUTCDate(d.getUTCDate() + i);
        const iso = d.toISOString().slice(0, 10);
        perDayHeaders.push(isoToLongDateNoCommas(iso));
      }
    });
    const perWeekHeaders = weekStarts.map((ws) => `Week compliance ${ws}`);

    const header = [...baseHeader, ...perDayHeaders, ...perWeekHeaders, "DominantCategory", "ComplianceSummary"];
    const csvRows = [header.map((h) => quote(h)).join(",")];

    const rows = regionObj.employees || [];
    rows.forEach((r, idx) => {
      const srNo = idx + 1;
      const employeeId = r.EmployeeID ?? "";
      const employeeName = r.EmployeeName ?? "";
      const cardNumber = r.CardNumber ?? "";
      const personnelType = r.PersonnelType ?? r.PersonnelTypeName ?? "";
      const partition = r.PartitionName2 ?? "";
      const totalSeconds = r.total_seconds_present_in_range ?? "";

      const perDayVals = [];
      weekStarts.forEach((ws) => {
        for (let i = 0; i < 7; i++) {
          const d = new Date(ws + "T00:00:00Z");
          d.setUTCDate(d.getUTCDate() + i);
          const iso = d.toISOString().slice(0, 10);

          const wk = r.compliance && r.compliance.weeks ? r.compliance.weeks[ws] : null;
          let outVal = "0";

          if (wk && wk.dates && Object.prototype.hasOwnProperty.call(wk.dates, iso)) {
            const secs = wk.dates[iso];
            if (secs !== null && secs !== undefined) {
              outVal = r.durations && r.durations[iso] ? r.durations[iso] : secondsToHMS(secs);
            } else {
              outVal = "0";
            }
          } else if (r.durations && Object.prototype.hasOwnProperty.call(r.durations, iso) && r.durations[iso]) {
            outVal = r.durations[iso];
          } else if (r.durations_seconds && Object.prototype.hasOwnProperty.call(r.durations_seconds, iso) && r.durations_seconds[iso]) {
            outVal = secondsToHMS(r.durations_seconds[iso]);
          } else {
            outVal = "0";
          }

          perDayVals.push(outVal);
        }
      });

      const perWeekVals = weekStarts.map((ws) => {
        const wk = r.compliance && r.compliance.weeks ? r.compliance.weeks[ws] : null;
        return wk && wk.compliant ? "Yes" : "No";
      });

      const complianceText = r.compliance?.month_summary || "";
      const complianceCell = `'${complianceText}`;

      const row = [
        `${srNo}`,
        quote(employeeId),
        quote(employeeName),
        quote(cardNumber),
        quote(personnelType),
        quote(partition),
        `${totalSeconds}`,
        ...perDayVals.map((v) => quote(v)),
        ...perWeekVals.map((v) => quote(v)),
        quote(r.duration_categories?.dominant_category || ""),
        quote(complianceCell),
      ];

      csvRows.push(row.join(","));
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `duration_report_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  const exportSwipesCsv = () => {
    if (!regionObj) return;
    const swipesByDate = regionObj.swipes_by_date || {};
    const rows = [];
    Object.entries(swipesByDate).forEach(([d, arr]) => {
      arr.forEach((s) => {
        rows.push({
          Date: d,
          LocaleMessageTime: s.LocaleMessageTime || "",
          Swipe_Time: s.Swipe_Time || "",
          EmployeeID: s.EmployeeID || "",
          PersonGUID: s.PersonGUID || "",
          ObjectName1: s.ObjectName1 || "",
          Door: s.Door || "",
          PersonnelType: s.PersonnelType || "",
          CardNumber: s.CardNumber || "",
          PrimaryLocation: s.PrimaryLocation || s.Text5 || "",
          PartitionName2: s.PartitionName2 || "",
          AdmitCode: s.AdmitCode || "",
          Direction: s.Direction || "",
          CompanyName: s.CompanyName || "",
        });
      });
    });

    if (rows.length === 0) {
      alert("No swipe rows available for current selection to export.");
      return;
    }

    const headers = [
      "Date",
      "LocaleMessageTime",
      "Swipe_Time",
      "EmployeeID",
      "PersonGUID",
      "ObjectName1",
      "Door",
      "PersonnelType",
      "CardNumber",
      "PrimaryLocation",
      "PartitionName2",
      "AdmitCode",
      "Direction",
      "CompanyName",
    ];
    const csvRows = [headers.map((h) => quote(h)).join(",")];
    rows.forEach((r) => {
      const line = headers.map((h) => quote(r[h] ?? "")).join(",");
      csvRows.push(line);
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `swipes_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // Export selected employee's swipes
  const exportSelectedEmployeeSwipes = () => {
    if (!selectedSwipes || selectedSwipes.length === 0) {
      alert("No swipe records to export for selected employee.");
      return;
    }
    const headers = [
      "Date",
      "LocaleMessageTime",
      "Swipe_Time",
      "EmployeeID",
      "PersonGUID",
      "ObjectName1",
      "Door",
      "PersonnelType",
      "CardNumber",
      "PrimaryLocation",
      "PartitionName2",
      "AdmitCode",
      "Direction",
      "CompanyName",
      "DiffSeconds",
      "DiffHHMMSS"
    ];
    const csvRows = [headers.map((h) => quote(h)).join(",")];
    selectedSwipes.forEach((s) => {
      const obj = { ...s };
      const line = headers.map((h) => quote(obj[h] ?? "")).join(",");
      csvRows.push(line);
    });
    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const empId = selectedEmployee?.EmployeeID || "employee";
    const filename = `swipes_${empId}_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // --- Render helpers ---
  const getFilteredRows = useCallback(() => {
    if (!regionObj) return [];
    const rows = regionObj.employees || [];
    return rows.filter((r) => {
      const matchesEmployeeId = !searchEmployeeId || String(r.EmployeeID || "").toLowerCase().includes(searchEmployeeId.toLowerCase());
      const matchesName = !searchEmployeeName || String(r.EmployeeName || "").toLowerCase().includes(searchEmployeeName.toLowerCase());
      const matchesCard = !searchCardNumber || String(r.CardNumber || "").toLowerCase().includes(searchCardNumber.toLowerCase());
      return matchesEmployeeId && matchesName && matchesCard;
    });
  }, [regionObj, searchEmployeeId, searchEmployeeName, searchCardNumber]);

  // compute diffs for selected swipes when opening dialog and attach diff meta
  const openSwipeDialogFor = (emp) => {
    setSelectedEmployee(emp);
    const swipesByDate = regionObj?.swipes_by_date || {};
    const matches = [];
    Object.entries(swipesByDate).forEach(([d, arr]) => {
      arr.forEach((s) => {
        const matchByEmployeeId = emp.EmployeeID && s.EmployeeID && String(s.EmployeeID) === String(emp.EmployeeID);
        const matchByCard = emp.CardNumber && s.CardNumber && String(s.CardNumber) === String(emp.CardNumber);
        const matchByPersonGuid = emp.person_uid && s.PersonGUID && String(s.PersonGUID) === String(emp.person_uid);
        if (matchByEmployeeId || matchByCard || matchByPersonGuid) {
          matches.push({ ...s, Date: d });
        }
      });
    });
    matches.sort((a, b) => {
      const ta = a.LocaleMessageTime ? new Date(a.LocaleMessageTime).getTime() : 0;
      const tb = b.LocaleMessageTime ? new Date(b.LocaleMessageTime).getTime() : 0;
      return ta - tb;
    });

    // compute diffs (difference to previous swipe)
    const withDiffs = matches.map((row, idx, arr) => {
      let diffSeconds = null;
      if (idx === 0) {
        diffSeconds = null;
      } else {
        const cur = row.LocaleMessageTime ? new Date(row.LocaleMessageTime).getTime() : null;
        const prev = arr[idx - 1].LocaleMessageTime ? new Date(arr[idx - 1].LocaleMessageTime).getTime() : null;
        if (cur != null && prev != null) {
          diffSeconds = Math.max(0, Math.floor((cur - prev) / 1000));
        } else {
          diffSeconds = null;
        }
      }
      return {
        ...row,
        DiffSeconds: diffSeconds,
        DiffHHMMSS: diffSeconds != null ? secondsToHMS(diffSeconds) : "-",
      };
    });

    setSelectedSwipes(withDiffs);
    // reset override state
    const distinctDates = Array.from(new Set(withDiffs.map((m) => m.Date))).sort();
    setOverrideDate(distinctDates.length > 0 ? distinctDates[0] : "");
    setOverrideStartIndex(null);
    setOverrideEndIndex(null);
    setOverrideReason("");
    setSwipeDialogOpen(true);
  };

  const computeOverrideDurationSeconds = () => {
    if (!selectedSwipes || selectedSwipes.length === 0) return 0;
    if (overrideStartIndex == null || overrideEndIndex == null) return 0;
    const sIdx = Math.min(overrideStartIndex, overrideEndIndex);
    const eIdx = Math.max(overrideStartIndex, overrideEndIndex);
    const s = selectedSwipes[sIdx];
    const e = selectedSwipes[eIdx];
    if (!s || !e) return 0;
    const sa = s.LocaleMessageTime ? new Date(s.LocaleMessageTime).getTime() : null;
    const eb = e.LocaleMessageTime ? new Date(e.LocaleMessageTime).getTime() : null;
    if (!sa || !eb) return 0;
    return Math.max(0, Math.floor((eb - sa) / 1000));
  };

  const applyOverride = async () => {
    if (!selectedEmployee) return;
    if (!overrideDate) {
      alert("Please select a date for the override.");
      return;
    }
    if (overrideStartIndex == null || overrideEndIndex == null) {
      alert("Please select both start and end swipe entries.");
      return;
    }
    const sIdx = Math.min(overrideStartIndex, overrideEndIndex);
    const eIdx = Math.max(overrideStartIndex, overrideEndIndex);
    const s = selectedSwipes[sIdx];
    const e = selectedSwipes[eIdx];
    if (!s || !e) {
      alert("Invalid swipe selection.");
      return;
    }
    const start_ts = s.LocaleMessageTime || s.Swipe_Time;
    const end_ts = e.LocaleMessageTime || e.Swipe_Time;
    if (!start_ts || !end_ts) {
      alert("Selected swipe rows do not have timestamps.");
      return;
    }
    const seconds = computeOverrideDurationSeconds();
    if (seconds <= 0) {
      if (!window.confirm("Computed duration is 0. Do you still want to apply the override?")) {
        return;
      }
    }

    setOverrideApplying(true);
    try {
      await axios.post(`${API_BASE}/duration/override`, {
        region,
        person_uid: selectedEmployee.person_uid,
        date: overrideDate,
        start_ts: start_ts,
        end_ts: end_ts,
        reason: overrideReason,
        user: "frontend_user"
      }, { timeout: 30000 });

      // Instead of refreshing whole UI, fetch only the updated employee and merge
      await fetchAndMergeEmployee({ employeeId: selectedEmployee.EmployeeID, person_uid: selectedEmployee.person_uid });

      setSwipeDialogOpen(false);
      alert("Override applied — updated employee refreshed.");
    } catch (err) {
      console.error("Failed to apply override:", err);
      alert("Failed to apply override: " + (err?.response?.data?.detail || err.message || "unknown"));
    } finally {
      setOverrideApplying(false);
    }
  };

  const renderSwipeSelectionControls = () => {
    if (!selectedSwipes || selectedSwipes.length === 0) return null;
    const distinctDates = Array.from(new Set(selectedSwipes.map((m) => m.Date))).sort();
    const swipesForDate = selectedSwipes.filter((s) => s.Date === overrideDate);

    return (
      <Box sx={{ mt: 2 }}>
        <Grid container spacing={2} alignItems="center">
          <Grid item xs={12} md={4}>
            <FormControl fullWidth size="small">
              <InputLabel id="override-date-label">Date</InputLabel>
              <Select
                labelId="override-date-label"
                label="Date"
                value={overrideDate}
                onChange={(e) => {
                  setOverrideDate(e.target.value);
                  setOverrideStartIndex(null);
                  setOverrideEndIndex(null);
                }}
              >
                {distinctDates.map((d) => (
                  <MenuItem key={d} value={d}>{isoToDDMMYYYY(d)}</MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

          <Grid item xs={12} md={4}>
            <FormControl fullWidth size="small">
              <InputLabel id="override-start-label">Start swipe</InputLabel>
              <Select
                labelId="override-start-label"
                label="Start swipe"
                value={overrideStartIndex == null ? "" : overrideStartIndex}
                onChange={(e) => setOverrideStartIndex(e.target.value === "" ? null : Number(e.target.value))}
              >
                <MenuItem value=""><em>None</em></MenuItem>
                {swipesForDate.map((s, idx) => (
                  <MenuItem key={idx} value={idx}>
                    {s.LocaleMessageTime ? new Date(s.LocaleMessageTime).toLocaleString() : s.Swipe_Time}
                    {" — "}{s.Door || s.ObjectName1 || ""}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

          <Grid item xs={12} md={4}>
            <FormControl fullWidth size="small">
              <InputLabel id="override-end-label">End swipe</InputLabel>
              <Select
                labelId="override-end-label"
                label="End swipe"
                value={overrideEndIndex == null ? "" : overrideEndIndex}
                onChange={(e) => setOverrideEndIndex(e.target.value === "" ? null : Number(e.target.value))}
              >
                <MenuItem value=""><em>None</em></MenuItem>
                {swipesForDate.map((s, idx) => (
                  <MenuItem key={idx} value={idx}>
                    {s.LocaleMessageTime ? new Date(s.LocaleMessageTime).toLocaleString() : s.Swipe_Time}
                    {" — "}{s.Door || s.ObjectName1 || ""}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

          <Grid item xs={12}>
            <TextField
              fullWidth
              size="small"
              label="Reason (optional)"
              value={overrideReason}
              onChange={(e) => setOverrideReason(e.target.value)}
            />
          </Grid>

          <Grid item xs={12} sx={{ display: "flex", gap: 1, justifyContent: "flex-end" }}>
            <Button
              variant="contained"
              onClick={applyOverride}
              disabled={overrideApplying || !overrideDate || overrideStartIndex == null || overrideEndIndex == null}
            >
              {overrideApplying ? "Applying..." : `Apply Override (${secondsToHMS(computeOverrideDurationSeconds())})`}
            </Button>
          </Grid>
        </Grid>
      </Box>
    );
  };

  const renderTable = () => {
    if (!regionObj) return <Typography>No data for selected region.</Typography>;

    const dates = regionObj.dates || [];
    const rows = getFilteredRows();

    const weekStarts = computeWeekStarts(dates);

    return (
      <TableContainer component={Paper} sx={{ mt: 2, width: "100%", overflowX: "auto", boxShadow: 2 }}>
        <Table size="small" stickyHeader sx={tableSx}>
          <TableHead>
            <TableRow>
              <TableCell><b>Sr.No</b></TableCell>
              <TableCell><b>EmployeeID</b></TableCell>
              <TableCell><b>EmployeeName</b></TableCell>
              <TableCell><b>CardNumber</b></TableCell>
              <TableCell><b>PersonnelType</b></TableCell>
              <TableCell><b>PartitionName2</b></TableCell>
              <TableCell align="right"><b>Total (hh:mm:ss)</b></TableCell>
              {dates.map((d) => (
                <TableCell key={d} align="center"><b>{isoToDDMMYYYY(d)}</b></TableCell>
              ))}
              {weekStarts.map((ws) => (
                <TableCell key={ws} align="center"><b>{`Week ${ws} compliant`}</b></TableCell>
              ))}
              <TableCell align="center"><b>Dominant Category</b></TableCell>
              <TableCell align="center"><b>Compliance (weeks met/total)</b></TableCell>
              <TableCell align="center"><b>View</b></TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {rows.length === 0 ? (
              <TableRow>
                <TableCell colSpan={9 + (regionObj.dates || []).length + weekStarts.length} align="center">No employees in the response.</TableCell>
              </TableRow>
            ) : (
              rows.map((r, idx) => (
                <TableRow key={r.person_uid || `${r.EmployeeID}-${r.EmployeeName}`}>
                  <TableCell>{idx + 1}</TableCell>
                  <TableCell>{r.EmployeeID || "-"}</TableCell>
                  <TableCell>{r.EmployeeName || "-"}</TableCell>
                  <TableCell>{r.CardNumber || "-"}</TableCell>
                  <TableCell>{r.PersonnelType || r.PersonnelTypeName || "-"}</TableCell>
                  <TableCell>{r.PartitionName2 || "-"}</TableCell>
                  <TableCell align="right">{secondsToHMS(r.total_seconds_present_in_range)}</TableCell>
                  {dates.map((d) => (
                    <TableCell key={d} align="center">{r.durations?.[d] ?? "-"}</TableCell>
                  ))}
                  {weekStarts.map((ws) => {
                    const wk = r.compliance && r.compliance.weeks ? r.compliance.weeks[ws] : null;
                    return <TableCell key={ws} align="center">{wk && wk.compliant ? "Yes" : "No"}</TableCell>;
                  })}
                  <TableCell align="center">
                    {r.duration_categories?.dominant_category || "-"}
                    {r.duration_categories?.red_flag > 0 ? " ⚠️" : ""}
                  </TableCell>
                  <TableCell align="center">{r.compliance?.month_summary || "-"}</TableCell>
                  <TableCell align="center">
                    <Tooltip title="View swipe records for this employee">
                      <Button size="small" variant="outlined" startIcon={<VisibilityIcon />} onClick={() => openSwipeDialogFor(r)}>
                        View
                      </Button>
                    </Tooltip>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </TableContainer>
    );
  };

  // --- JSX UI (top controls) ---
  return (
    <Box
      sx={{
        p: 3,
        width: "100%",
        maxWidth: "100vw",
        boxSizing: "border-box",
        background: "linear-gradient(180deg,rgb(37, 37, 37),rgb(16, 16, 15))",
        minHeight: "100vh",
      }}
    >
      <Box sx={{ display: "flex", justifyContent: "center", mb: 2 }}>
        <Box
          sx={{
            border: "3px solid #FFD700",
            background: "linear-gradient(90deg,#fffbe6,#fff7cc)",
            borderRadius: 2,
            px: 3,
            py: 1.2,
            width: { xs: "100%", sm: "70%", md: "50%" },
            textAlign: "center",
            boxShadow: 3,
          }}
        >
          <Typography variant="h5" sx={{ fontWeight: 800, color: "#333" }}>
            Duration Reports with Compliance & Category
          </Typography>
        </Box>
      </Box>

      <Grid container spacing={2}>
        <Grid item xs={12}>
          <Card elevation={3}>
            <CardContent>
              <Grid container spacing={2} alignItems="center">
                <Grid item xs={12} md={2}>
                  <FormControl fullWidth size="small">
                    <InputLabel id="region-select-label">Region</InputLabel>
                    <Select
                      labelId="region-select-label"
                      label="Region"
                      value={region}
                      onChange={(e) => setRegion(e.target.value)}
                    >
                      {REGIONS.map((r) => (
                        <MenuItem key={r.value} value={r.value}>{r.label}</MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>

                <Grid item xs={12} md={3}>
                  <FormControl fullWidth size="small">
                    <InputLabel id="city-select-label">City / Partition </InputLabel>
                    <Select
                      labelId="city-select-label"
                      label="City / Partition (optional)"
                      value={city}
                      onChange={(e) => setCity(e.target.value)}
                      renderValue={(v) => v || ""}
                    >
                      <MenuItem value=""><em>All</em></MenuItem>
                      {citiesForRegion && citiesForRegion.length > 0 ? (
                        citiesForRegion.map((c, idx) => (
                          <MenuItem key={idx} value={c}>{c}</MenuItem>
                        ))
                      ) : (
                        <MenuItem disabled value="">
                          No predefined cities (you can type in the input below instead)
                        </MenuItem>
                      )}
                    </Select>
                  </FormControl>
                  <TextField
                    fullWidth
                    size="small"
                    placeholder="Or type to override / fuzzy-match"
                    value={city}
                    onChange={(e) => setCity(e.target.value)}
                    sx={{ mt: 1 }}
                  />
                </Grid>

                <Grid item xs={12} md={5} sx={{ display: "flex", gap: 1, justifyContent: "flex-end", alignItems: "center" }}>
                  <Button
                    startIcon={<DateRangeIcon />}
                    variant={useRange ? "contained" : "outlined"}
                    onClick={() => setUseRange(true)}
                    color="warning"
                  >
                    Range
                  </Button>
                  <Button
                    startIcon={<DateRangeIcon />}
                    variant={!useRange ? "contained" : "outlined"}
                    onClick={() => setUseRange(false)}
                    color="warning"
                  >
                    Single Day
                  </Button>
                </Grid>

                {useRange ? (
                  <>
                    <Grid item xs={12} md={3}>
                      <FormControl fullWidth size="small">
                        <TextField
                          label="Start date"
                          type="date"
                          fullWidth
                          InputLabelProps={{ shrink: true }}
                           value={startDate}
                          onChange={(e) => setStartDate(e.target.value)}
                          size="small"
                          inputRef={startDateRef}
                          InputProps={{
                            endAdornment: (
                              <InputAdornment position="end">
                                <IconButton
                                  size="small"
                                  onClick={() => openNativeDatePicker(startDateRef)}
                                  sx={{ color: "#FFD700" }}
                                >
                                  <DateRangeIcon />
                                </IconButton>
                              </InputAdornment>
                            ),
                          }}
                          sx={{ bgcolor: "#30302e" }}
                        />
                      </FormControl>
                    </Grid>
                    <Grid item xs={12} md={3}>
                      <FormControl fullWidth size="small">
                        <TextField
                          label="End date"
                          type="date"
                          fullWidth
                          InputLabelProps={{ shrink: true }}
                          value={endDate}
                          onChange={(e) => setEndDate(e.target.value)}
                          size="small"
                          inputRef={endDateRef}
                          InputProps={{
                            endAdornment: (
                              <InputAdornment position="end">
                                <IconButton
                                  size="small"
                                  onClick={() => openNativeDatePicker(endDateRef)}
                                  sx={{ color: "#FFD700" }}
                                >
                                  <DateRangeIcon />
                                </IconButton>
                              </InputAdornment>
                            ),
                          }}
                          sx={{ bgcolor: "#30302e" }}
                        />
                      </FormControl>
                    </Grid>
                  </>
                ) : (
                  <Grid item xs={12} md={3}>
                    <FormControl fullWidth size="small">
                      <TextField
                        label="Date"
                        type="date"
                        fullWidth
                        InputLabelProps={{ shrink: true }}
                        value={singleDate}
                        onChange={(e) => setSingleDate(e.target.value)}
                        size="small"
                        inputRef={singleDateRef}
                        InputProps={{
                          endAdornment: (
                            <InputAdornment position="end">
                              <IconButton
                                size="small"
                                onClick={() => openNativeDatePicker(singleDateRef)}
                                sx={{ color: "#FFD700" }}
                              >
                                <DateRangeIcon />
                              </IconButton>
                            </InputAdornment>
                          ),
                        }}
                        sx={{ bgcolor: "transparent" }}
                      />
                    </FormControl>
                  </Grid>
                )}

                <Grid item xs={12} md={6} sx={{ display: "flex", gap: 1, alignItems: "center" }}>
                  <Button
                    variant="contained"
                    startIcon={<SearchIcon />}
                    onClick={() => fetchDurations()}
                    disabled={loading}
                    color="primary"
                  >
                    {loading ? "Loading..." : "Run"}
                  </Button>

                  <Button
                    variant="outlined"
                    startIcon={<ClearIcon />}
                    onClick={() => {
                      setStartDate("");
                      setEndDate("");
                      setSingleDate("");
                      setCity("");
                      setData(null);
                      setError("");
                      setSearchEmployeeId("");
                      setSearchEmployeeName("");
                      setSearchCardNumber("");
                    }}
                  >
                    Clear
                  </Button>

                  <Tooltip title="Export Summary CSV (per-person)">
                    <span>
                      <IconButton onClick={exportSummaryCsv} disabled={!regionObj || (regionObj.employees || []).length === 0}>
                        <DownloadIcon />
                      </IconButton>
                    </span>
                  </Tooltip>

                  <Tooltip title="Export full report (Sr.No, ... Compliance)">
                    <span>
                      <Button variant="contained" onClick={exportReportCsv} disabled={!regionObj || (regionObj.employees || []).length === 0}>
                        Export Report
                      </Button>
                    </span>
                  </Tooltip>

                  <Tooltip title="Export raw swipes for this region/date range">
                    <span>
                      <Button variant="outlined" onClick={exportSwipesCsv} disabled={!regionObj || Object.keys(regionObj.swipes_by_date || {}).length === 0}>
                        Export Swipes
                      </Button>
                    </span>
                  </Tooltip>
                </Grid>

                <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="Search Employee ID"
                    value={searchEmployeeId}
                    onChange={(e) => setSearchEmployeeId(e.target.value)}
                    size="small"
                    helperText="Type an ID and click Run to fetch only that employee (server-side filter)"
                  />
                </Grid>
                <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="Search Employee Name"
                    value={searchEmployeeName}
                    onChange={(e) => setSearchEmployeeName(e.target.value)}
                    size="small"
                    helperText="Type name and click Run to fetch only matching employees"
                  />
                </Grid>
                <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="Search Card Number"
                    value={searchCardNumber}
                    onChange={(e) => setSearchCardNumber(e.target.value)}
                    size="small"
                    helperText="Search card number (server-side filter)"
                  />
                </Grid>

              </Grid>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12}>
          <Paper sx={{ p: 2 }}>
            <Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
              <Typography variant="subtitle1" sx={{ fontWeight: 700 }}>
                {data ? `Showing ${region.toUpperCase()} — ${data.start_date} → ${data.end_date}` : "No results yet"}
              </Typography>
            </Box>

            {loading && (
              <Box sx={{ display: "flex", justifyContent: "center", py: 4 }}>
                <CircularProgress />
              </Box>
            )}

            {error && (
              <Typography color="error" sx={{ mt: 2 }}>
                {error}
              </Typography>
            )}

            {!loading && !error && (
              <Box sx={{ mt: 2 }}>
                {renderTable()}
              </Box>
            )}
          </Paper>
        </Grid>
      </Grid>

      {/* Swipe dialog */}
      <Dialog open={swipeDialogOpen} onClose={() => setSwipeDialogOpen(false)} fullWidth maxWidth="xl">
        <DialogTitle>
          Swipe records for: {selectedEmployee ? `${selectedEmployee.EmployeeID || ""} — ${selectedEmployee.EmployeeName || ""}` : ""}
        </DialogTitle>
        <DialogContent dividers>
          {selectedSwipes.length === 0 ? (
            <Typography>No swipe records found for this employee in the selected range.</Typography>
          ) : (
            <>
              <Table size="small" sx={dialogTableSx}>
                <TableHead>
                  <TableRow>
                    <TableCell><b>Date</b></TableCell>
                    <TableCell><b>Time (local)</b></TableCell>
                    <TableCell><b>Diff (hh:mm:ss)</b></TableCell>
                    <TableCell><b>Door</b></TableCell>
                    <TableCell><b>Direction</b></TableCell>
                    <TableCell><b>CardNumber</b></TableCell>
                    <TableCell><b>PersonnelType</b></TableCell>
                    <TableCell><b>Partition</b></TableCell>
                    <TableCell><b>PrimaryLocation</b></TableCell>
                    <TableCell><b>Company</b></TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {selectedSwipes.map((s, i) => {
                    const isLargeGap = s.DiffSeconds != null && s.DiffSeconds > SWIPE_DIFF_RED_THRESHOLD;
                    return (
                      <TableRow key={i} sx={isLargeGap ? { backgroundColor: "rgba(255,0,0,0.08)" } : {}}>
                        <TableCell>{s.Date}</TableCell>
                        <TableCell>{s.Swipe_Time ?? (s.LocaleMessageTime ? new Date(s.LocaleMessageTime).toLocaleString() : "-")}</TableCell>
                        <TableCell sx={isLargeGap ? { color: "red", fontWeight: 700 } : {}}>{s.DiffHHMMSS ?? "-"}</TableCell>
                        <TableCell>{s.Door || s.ObjectName1 || "-"}</TableCell>
                        <TableCell>{s.Direction || "-"}</TableCell>
                        <TableCell>{s.CardNumber || "-"}</TableCell>
                        <TableCell>{s.PersonnelType || "-"}</TableCell>
                        <TableCell>{s.PartitionName2 || "-"}</TableCell>
                        <TableCell>{s.PrimaryLocation || s.Text5 || "-"}</TableCell>
                        <TableCell>{s.CompanyName || "-"}</TableCell>
                      </TableRow>
                    );
                  })}
                </TableBody>
              </Table>

              {renderSwipeSelectionControls()}
            </>
          )}
        </DialogContent>
        <Divider />
        <Box sx={{ p: 1, display: "flex", justifyContent: "flex-end", gap: 1 }}>
          <Button onClick={() => exportSelectedEmployeeSwipes()} disabled={!selectedSwipes || selectedSwipes.length === 0}>Export Swipes</Button>
          <Button onClick={() => setSwipeDialogOpen(false)}>Close</Button>
        </Box>
      </Dialog>
    </Box>
  );
}







