  // NEW: visited-today counts from summary API (poll every minute)
  const [visitedCounts, setVisitedCounts] = useState({ employee: null, contractor: null, total: null });

  useEffect(() => {
    let mounted = true;
    let timer = null;

    const fetchVisitedSummary = async () => {
      try {
        // use existing api axios instance (same base as other api.get calls)
        const res = await api.get('/ccure/verify?raw=true');
        if (!mounted) return;
        const data = res && res.data ? res.data : null;

        // try to read the shape we expect
        const h = (data && (data.headcount_attendance_summary || data.headcount || data.headcount_details)) || {};
        const emp = Number(h.employee || 0);
        const con = Number(h.contractor || 0);
        const tot = h.total_visited_today != null ? Number(h.total_visited_today) : (emp + con);

        setVisitedCounts({ employee: emp, contractor: con, total: tot });
      } catch (e) {
        // network or parse error - don't crash; keep old values
        // optionally you can setVisitedCounts to nulls on repeated failure
        console.warn('[visited summary] fetch failed', e);
      } finally {
        // schedule next fetch in 60s
        timer = setTimeout(fetchVisitedSummary, 60000);
      }
    };

    // immediate first fetch
    fetchVisitedSummary();

    return () => {
      mounted = false;
      if (timer) clearTimeout(timer);
    };
  }, []); // run once










// prefer the minute-polling visitedCounts if present, otherwise fall back to existing values
const displayEmployee = visitedCounts.employee != null ? visitedCounts.employee : (headEmployee ?? liveEmp ?? '—');
const displayContractor = visitedCounts.contractor != null ? visitedCounts.contractor : (headContractor ?? liveContr ?? '—');
const displayHeadTotal = visitedCounts.total != null ? visitedCounts.total : (headTotalVisited ?? ( (displayEmployee === '—' || displayContractor === '—') ? '—' : (Number(displayEmployee || 0) + Number(displayContractor || 0)) ));

// then render:
<Typography variant="h5" sx={{ fontWeight: 800 }}>{displayEmployee}</Typography>
...
<Typography variant="h5" sx={{ fontWeight: 800 }}>{displayContractor}</Typography>
...
<Typography variant="body2" sx={{ fontWeight: 700 }}>{displayHeadTotal}</Typography>
...
<Typography variant="body2" sx={{ fontWeight: 700 }}>{liveCurrentTotal ?? '—'}</Typography>











        if isinstance(detailed, dict):
            mapped = _map_detailed_to_resp(detailed)
            summary = _build_verify_like_summary_from_mapped(mapped, include_raw=False)

            # Honor ?raw=true: return mapped (full summary/mapped payload) for clients that request it.
            if raw:
                try:
                    # save raw-mapped payload to cache (wrapper contains cached_at + payload)
                    _save_ccure_cache(start_date, end_date, {"raw": mapped})
                    # broadcast the mapped payload as-is (SSE clients will get this)
                    broadcast_ccure_update(mapped)
                except Exception:
                    logger.exception("Failed to cache/broadcast raw compute result")
                return JSONResponse(mapped)

            # Default behavior: return the pruned minimal payload used by the UI
            pruned = _prune_summary(summary)
            try:
                _save_ccure_cache(start_date, end_date, pruned)
                broadcast_ccure_update(pruned)
            except Exception:
                logger.exception("Failed to cache/broadcast compute result")
            return JSONResponse(pruned)







            if raw:
                try:
                    _save_ccure_cache(start_date, end_date, {"raw": mapped_fallback})
                    broadcast_ccure_update(mapped_fallback)
                except Exception:
                    logger.exception("Failed to cache/broadcast fallback raw result")
                return JSONResponse(mapped_fallback)

            pruned = _prune_summary(summary)
            ...








