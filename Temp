// frontend/src/pages/DurationPage.jsx
import React, { useState, useMemo } from "react";
import axios from "axios";
import {
  Box,
  Grid,
  Paper,
  Typography,
  TextField,
  Button,
  MenuItem,
  Select,
  InputLabel,
  FormControl,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  TableContainer,
  CircularProgress,
  IconButton,
  Tooltip,
  Card,
  CardContent,
} from "@mui/material";
import DateRangeIcon from "@mui/icons-material/DateRange";
import SearchIcon from "@mui/icons-material/Search";
import DownloadIcon from "@mui/icons-material/CloudDownload";
import ClearIcon from "@mui/icons-material/Clear";

// Prefer Vite env; fallback to other envs and default
const API_BASE = import.meta.env.VITE_API_BASE || import.meta.env.REACT_APP_API_BASE || "http://localhost:8000";

const REGIONS = [
  { value: "apac", label: "APAC" },
  { value: "emea", label: "EMEA" },
  { value: "laca", label: "LACA" },
  { value: "namer", label: "NAMER" },
];

function secondsToHMS(s) {
  if (s == null) return "";
  const sec = Number(s);
  if (!Number.isFinite(sec)) return "";
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const r = Math.floor(sec % 60);
  return `${h}:${String(m).padStart(2, "0")}:${String(r).padStart(2, "0")}`;
}

// Format ISO date "YYYY-MM-DD" -> "DD-MM-YYYY"
function isoToDDMMYYYY(iso) {
  if (!iso) return iso;
  // Use Date to parse; ensure compatibility with iso date-only by adding "T00:00:00Z"
  const dt = new Date(iso.includes("T") ? iso : `${iso}T00:00:00Z`);
  if (Number.isNaN(dt.getTime())) return iso;
  const dd = String(dt.getUTCDate()).padStart(2, "0");
  const mm = String(dt.getUTCMonth() + 1).padStart(2, "0");
  const yyyy = dt.getUTCFullYear();
  return `${dd}-${mm}-${yyyy}`;
}

export default function DurationPage() {
  const [region, setRegion] = useState("apac");
  const [city, setCity] = useState("");
  const [startDate, setStartDate] = useState(""); // YYYY-MM-DD
  const [endDate, setEndDate] = useState("");
  const [singleDate, setSingleDate] = useState("");
  const [useRange, setUseRange] = useState(true);

  const [data, setData] = useState(null); // full API response
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  // Build query params & fetch
  const fetchDurations = async () => {
    setError("");
    setLoading(true);
    setData(null);

    try {
      const params = {};
      // if range selected and both dates provided -> range mode
      if (useRange && startDate && endDate) {
        params.start_date = startDate;
        params.end_date = endDate;
      } else if (!useRange && singleDate) {
        params.date = singleDate;
      } else {
        // incomplete selection: prefer singleDate if present otherwise use today's date
        if (singleDate) params.date = singleDate;
      }

      if (region) params.regions = region;
      if (city) params.city = city;

      const res = await axios.get(`${API_BASE}/duration`, { params, timeout: 120000 });
      setData(res.data);
    } catch (err) {
      console.error(err);
      setError(err?.response?.data?.detail || err.message || "Failed to fetch duration data");
    } finally {
      setLoading(false);
    }
  };

  // Dynamic columns and rows for selected region
  const regionObj = useMemo(() => {
    if (!data || !region) return null;
    return data.regions?.[region] || null;
  }, [data, region]);

  // Simple Summary CSV export (existing behavior)
  const exportSummaryCsv = () => {
    if (!regionObj) return;
    const dates = regionObj.dates || [];
    const rows = regionObj.employees || [];

    // header
    const header = ["EmployeeID", "EmployeeName", "TotalSecondsPresentInRange", ...dates];
    const csvRows = [header.join(",")];

    rows.forEach((r) => {
      const row = [
        `"${(r.EmployeeID || "").toString().replace(/"/g, '""')}"`,
        `"${(r.EmployeeName || "").toString().replace(/"/g, '""')}"`,
        r.total_seconds_present_in_range ?? "",
        ...dates.map((d) => `"${(r.durations?.[d] ?? "")}"`),
      ];
      csvRows.push(row.join(","));
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `duration_summary_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // NEW: Export report with exact required columns:
  // Sr.No, EmployeeID, EmployeeName, CardNumber, PersonnelType, PartitionName2, TotalSecondsPresentInRange, [dd-mm-yyyy...]
  const exportReportCsv = () => {
    if (!regionObj) return;
    const datesIso = regionObj.dates || []; // e.g. ["2025-09-01", ...]
    const datesFormatted = datesIso.map(isoToDDMMYYYY); // e.g. ["01-09-2025", ...]
    const rows = regionObj.employees || [];

    // Build header exactly as requested
    const header = [
      "Sr.No",
      "EmployeeID",
      "EmployeeName",
      "CardNumber",
      "PersonnelType",
      "PartitionName2",
      "TotalSecondsPresentInRange",
      ...datesFormatted,
    ];
    const csvRows = [header.join(",")];

    rows.forEach((r, idx) => {
      const srNo = idx + 1;
      const employeeId = r.EmployeeID ?? "";
      const employeeName = r.EmployeeName ?? "";
      const cardNumber = r.CardNumber ?? "";
      const personnelType = r.PersonnelType ?? r.PersonnelTypeName ?? "";
      const partition = r.PartitionName2 ?? "";
      const totalSeconds = r.total_seconds_present_in_range ?? "";

      // Per-date values: use r.durations[iso] if present, otherwise empty string
      const perDateVals = datesIso.map((iso) => {
        const v = r.durations?.[iso];
        return v == null ? "" : v;
      });

      const escaped = [
        `${srNo}`, // Sr.No is numeric, no quotes needed but keep consistent
        `"${String(employeeId).replace(/"/g, '""')}"`,
        `"${String(employeeName).replace(/"/g, '""')}"`,
        `"${String(cardNumber).replace(/"/g, '""')}"`,
        `"${String(personnelType).replace(/"/g, '""')}"`,
        `"${String(partition).replace(/"/g, '""')}"`,
        `${totalSeconds}`,
        ...perDateVals.map(v => `"${String(v).replace(/"/g, '""')}"`)
      ];

      csvRows.push(escaped.join(","));
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;

    // filename with region and date-range
    const filename = `duration_report_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // Detailed per-person CSV export (kept for compatibility) — unchanged
  const exportDetailedCsv = () => {
    if (!regionObj) return;
    const dates = regionObj.dates || [];
    const rows = regionObj.employees || [];

    const headers = [
      "person_uid",
      "EmployeeID",
      "EmployeeName",
      "CardNumber",
      "FirstSwipe",
      "LastSwipe",
      "FirstDoor",
      "LastDoor",
      "PersonnelType",
      "PartitionName2",
      "CompanyName",
      "PrimaryLocation",
      "FirstDirection",
      "LastDirection",
      "TotalSecondsPresentInRange",
      "DurationSecondsPerDate"
    ];
    // add each date to header
    const fullHeader = headers.concat(dates);
    const csvRows = [fullHeader.join(",")];

    rows.forEach(r => {
      const fixed = [
        `"${(r.person_uid || "").toString().replace(/"/g, '""')}"`,
        `"${(r.EmployeeID || "").toString().replace(/"/g, '""')}"`,
        `"${(r.EmployeeName || "").toString().replace(/"/g, '""')}"`,
        `"${(r.CardNumber || "").toString().replace(/"/g, '""')}"`,
        `"${(r.FirstSwipe || "")}"`,
        `"${(r.LastSwipe || "")}"`,
        `"${(r.FirstDoor || "").toString().replace(/"/g, '""')}"`,
        `"${(r.LastDoor || "").toString().replace(/"/g, '""')}"`,
        `"${(r.PersonnelType || "").toString().replace(/"/g, '""')}"`,
        `"${(r.PartitionName2 || "").toString().replace(/"/g, '""')}"`,
        `"${(r.CompanyName || "").toString().replace(/"/g, '""')}"`,
        `"${(r.PrimaryLocation || "").toString().replace(/"/g, '""')}"`,
        `"${(r.FirstDirection || "").toString().replace(/"/g, '""')}"`,
        `"${(r.LastDirection || "").toString().replace(/"/g, '""')}"`,
        `${r.total_seconds_present_in_range ?? ""}`,
        // as a single JSON-ish string of durations_seconds map
        `"${JSON.stringify(r.durations_seconds || {}).replace(/"/g, '""')}"`
      ];
      const perDateVals = dates.map(d => `"${(r.durations?.[d] ?? "")}"`);
      csvRows.push(fixed.concat(perDateVals).join(","));
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `duration_detailed_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // Export raw swipes for selected region (uses swipes_by_date returned by API)
  const exportSwipesCsv = () => {
    if (!regionObj) return;
    const swipesByDate = regionObj.swipes_by_date || {};
    // Flatten to rows (add date column)
    const rows = [];
    Object.entries(swipesByDate).forEach(([d, arr]) => {
      arr.forEach(s => {
        rows.push({
          Date: d,
          LocaleMessageTime: s.LocaleMessageTime || "",
          Swipe_Time: s.Swipe_Time || "",
          EmployeeID: s.EmployeeID || "",
          PersonGUID: s.PersonGUID || "",
          ObjectName1: s.ObjectName1 || "",
          Door: s.Door || "",
          PersonnelType: s.PersonnelType || "",
          CardNumber: s.CardNumber || "",
          PrimaryLocation: s.PrimaryLocation || s.Text5 || "",
          PartitionName2: s.PartitionName2 || "",
          AdmitCode: s.AdmitCode || "",
          Direction: s.Direction || "",
          CompanyName: s.CompanyName || ""
        });
      });
    });

    if (rows.length === 0) {
      alert("No swipe rows available for current selection to export.");
      return;
    }

    const headers = [
      "Date",
      "LocaleMessageTime",
      "Swipe_Time",
      "EmployeeID",
      "PersonGUID",
      "ObjectName1",
      "Door",
      "PersonnelType",
      "CardNumber",
      "PrimaryLocation",
      "PartitionName2",
      "AdmitCode",
      "Direction",
      "CompanyName"
    ];
    const csvRows = [headers.join(",")];
    rows.forEach(r => {
      const line = headers.map(h => {
        const v = r[h] ?? "";
        return `"${String(v).replace(/"/g, '""')}"`;
      }).join(",");
      csvRows.push(line);
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `swipes_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // Render helpers
  const renderTable = () => {
    if (!regionObj) return <Typography>No data for selected region.</Typography>;

    const dates = regionObj.dates || [];
    const rows = regionObj.employees || [];

    return (
      <TableContainer component={Paper} sx={{ mt: 2 }}>
        <Table size="small">
          <TableHead>
            <TableRow>
              <TableCell><b>EmployeeID</b></TableCell>
              <TableCell><b>EmployeeName</b></TableCell>
              <TableCell align="right"><b>Total (hh:mm:ss)</b></TableCell>
              {dates.map((d) => (
                <TableCell key={d} align="center"><b>{isoToDDMMYYYY(d)}</b></TableCell>
              ))}
            </TableRow>
          </TableHead>
          <TableBody>
            {rows.length === 0 ? (
              <TableRow>
                <TableCell colSpan={3 + dates.length} align="center">No employees in the response.</TableCell>
              </TableRow>
            ) : (
              rows.map((r) => (
                <TableRow key={r.person_uid || `${r.EmployeeID}-${r.EmployeeName}`}>
                  <TableCell>{r.EmployeeID || "-"}</TableCell>
                  <TableCell>{r.EmployeeName || "-"}</TableCell>
                  <TableCell align="right">{secondsToHMS(r.total_seconds_present_in_range)}</TableCell>
                  {dates.map((d) => (
                    <TableCell key={d} align="center">{r.durations?.[d] ?? "-"}</TableCell>
                  ))}
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </TableContainer>
    );
  };

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h5" gutterBottom>
        Duration Reports
      </Typography>

      <Grid container spacing={2}>
        <Grid item xs={12} md={8}>
          <Card>
            <CardContent>
              <Grid container spacing={2} alignItems="center">
                <Grid item xs={12} md={4}>
                  <FormControl fullWidth>
                    <InputLabel id="region-label">Region</InputLabel>
                    <Select
                      labelId="region-label"
                      value={region}
                      label="Region"
                      onChange={(e) => setRegion(e.target.value)}
                    >
                      {REGIONS.map((r) => (
                        <MenuItem key={r.value} value={r.value}>{r.label}</MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>

                <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="City / Partition (optional)"
                    placeholder="e.g. CR.Costa Rica Partition"
                    value={city}
                    onChange={(e) => setCity(e.target.value)}
                  />
                </Grid>

                <Grid item xs={12} md={4} sx={{ display: "flex", gap: 1 }}>
                  <Button
                    startIcon={<DateRangeIcon />}
                    variant={useRange ? "contained" : "outlined"}
                    onClick={() => setUseRange(true)}
                  >
                    Range
                  </Button>
                  <Button
                    startIcon={<DateRangeIcon />}
                    variant={!useRange ? "contained" : "outlined"}
                    onClick={() => setUseRange(false)}
                  >
                    Single Day
                  </Button>
                </Grid>

                {useRange ? (
                  <>
                    <Grid item xs={12} md={4}>
                      <TextField
                        label="Start date"
                        type="date"
                        fullWidth
                        InputLabelProps={{ shrink: true }}
                        value={startDate}
                        onChange={(e) => setStartDate(e.target.value)}
                      />
                    </Grid>
                    <Grid item xs={12} md={4}>
                      <TextField
                        label="End date"
                        type="date"
                        fullWidth
                        InputLabelProps={{ shrink: true }}
                        value={endDate}
                        onChange={(e) => setEndDate(e.target.value)}
                      />
                    </Grid>
                  </>
                ) : (
                  <Grid item xs={12} md={4}>
                    <TextField
                      label="Date"
                      type="date"
                      fullWidth
                      InputLabelProps={{ shrink: true }}
                      value={singleDate}
                      onChange={(e) => setSingleDate(e.target.value)}
                    />
                  </Grid>
                )}

                <Grid item xs={12} md={4} sx={{ display: "flex", gap: 1, alignItems: "center" }}>
                  <Button
                    variant="contained"
                    startIcon={<SearchIcon />}
                    onClick={fetchDurations}
                    disabled={loading}
                  >
                    {loading ? "Loading..." : "Run"}
                  </Button>

                  <Button
                    variant="outlined"
                    startIcon={<ClearIcon />}
                    onClick={() => {
                      setStartDate("");
                      setEndDate("");
                      setSingleDate("");
                      setCity("");
                      setData(null);
                      setError("");
                    }}
                  >
                    Clear
                  </Button>

                  <Tooltip title="Export Summary CSV (per-person)">
                    <span>
                      <IconButton onClick={exportSummaryCsv} disabled={!regionObj || (regionObj.employees || []).length === 0}>
                        <DownloadIcon />
                      </IconButton>
                    </span>
                  </Tooltip>

                  <Tooltip title="Export report with exact columns (Sr.No, EmployeeID, EmployeeName, CardNumber, PersonnelType, PartitionName2, TotalSecondsPresentInRange, dates...)">
                    <span>
                      <Button variant="contained" onClick={exportReportCsv} disabled={!regionObj || (regionObj.employees || []).length === 0}>
                        Export Report
                      </Button>
                    </span>
                  </Tooltip>

                  <Tooltip title="Export raw swipes for this region/date range">
                    <span>
                      <Button variant="outlined" onClick={exportSwipesCsv} disabled={!regionObj || Object.keys(regionObj.swipes_by_date || {}).length === 0}>
                        Export Swipes
                      </Button>
                    </span>
                  </Tooltip>

                </Grid>
              </Grid>
            </CardContent>
          </Card>

          <Box sx={{ mt: 2 }}>
            <Paper sx={{ p: 2 }}>
              <Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                <Typography variant="subtitle1">
                  {data ? `Showing ${region.toUpperCase()} — ${data.start_date} → ${data.end_date}` : "No results yet"}
                </Typography>
                <Typography variant="caption" color="text.secondary">
                  Tip: use the CSV export for offline analysis
                </Typography>
              </Box>

              {loading && (
                <Box sx={{ display: "flex", justifyContent: "center", py: 4 }}>
                  <CircularProgress />
                </Box>
              )}

              {error && (
                <Typography color="error" sx={{ mt: 2 }}>
                  {error}
                </Typography>
              )}

              {!loading && !error && (
                <Box sx={{ mt: 2 }}>
                  {renderTable()}
                </Box>
              )}
            </Paper>
          </Box>
        </Grid>

        <Grid item xs={12} md={4}>
          <Card sx={{ position: "sticky", top: 16 }}>
            <CardContent>
              <Typography variant="h6">How it works</Typography>
              <Typography variant="body2" sx={{ mt: 1 }}>
                - Use Range for multiple days (start + end).<br/>
                - Use Single Day for a calendar date.<br/>
                - Region selects which region to query (APAC/EMEA/LACA/NAMER).<br/>
                - City filters by PartitionName2 / PrimaryLocation / Door / EmployeeName.<br/>
                - The table shows per-person durations per day and a total seconds value.
              </Typography>

              <Box sx={{ mt: 2 }}>
                <Typography variant="subtitle2">Example endpoints</Typography>
                <Typography variant="caption" display="block">
                  Single day: <code>/duration?date=2025-09-04&regions=apac</code>
                </Typography>
                <Typography variant="caption" display="block">
                  Range: <code>/duration?start_date=2025-09-01&end_date=2025-09-05&regions=apac&city=CR.Costa%20Rica%20Partition</code>
                </Typography>
              </Box>
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    </Box>
  );
}














Now In duration Report below Are the Column 
person_uid	EmployeeID	EmployeeName	CardNumber	FirstSwipe	LastSwipe	FirstDoor	LastDoor	PersonnelType	PartitionName2	CompanyName	PrimaryLocation	FirstDirection	LastDirection	TotalSecondsPresentInRange	DurationSecondsPerDate	01-09-2025	02-09-2025	03-09-2025	04-09-2025	05-09-2025

So We need Only,

Sr.No EmployeeID	EmployeeName	CardNumber  PersonnelType PartitionName2  TotalSecondsPresentInRange 01-09-2025	02-09-2025	03-09-2025	04-09-2025	05-09-2025


We need Exact this Report so Update File as per my requirnment..


 


// frontend/src/pages/DurationPage.jsx
import React, { useState, useMemo } from "react";
import axios from "axios";
import {
  Box,
  Grid,
  Paper,
  Typography,
  TextField,
  Button,
  MenuItem,
  Select,
  InputLabel,
  FormControl,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  TableContainer,
  CircularProgress,
  IconButton,
  Tooltip,
  Card,
  CardContent,
  Stack
} from "@mui/material";
import DateRangeIcon from "@mui/icons-material/DateRange";
import SearchIcon from "@mui/icons-material/Search";
import DownloadIcon from "@mui/icons-material/CloudDownload";
import ClearIcon from "@mui/icons-material/Clear";

// Prefer Vite env; fallback to other envs and default
const API_BASE = import.meta.env.VITE_API_BASE || import.meta.env.REACT_APP_API_BASE || "http://localhost:8000";

const REGIONS = [
  { value: "apac", label: "APAC" },
  { value: "emea", label: "EMEA" },
  { value: "laca", label: "LACA" },
  { value: "namer", label: "NAMER" },
];

function secondsToHMS(s) {
  if (s == null) return "";
  const sec = Number(s);
  if (!Number.isFinite(sec)) return "";
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const r = Math.floor(sec % 60);
  return `${h}:${String(m).padStart(2, "0")}:${String(r).padStart(2, "0")}`;
}

export default function DurationPage() {
  const [region, setRegion] = useState("apac");
  const [city, setCity] = useState("");
  const [startDate, setStartDate] = useState(""); // YYYY-MM-DD
  const [endDate, setEndDate] = useState("");
  const [singleDate, setSingleDate] = useState("");
  const [useRange, setUseRange] = useState(true);

  const [data, setData] = useState(null); // full API response
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  // Build query params & fetch
  const fetchDurations = async () => {
    setError("");
    setLoading(true);
    setData(null);

    try {
      const params = {};
      // if range selected and both dates provided -> range mode
      if (useRange && startDate && endDate) {
        params.start_date = startDate;
        params.end_date = endDate;
      } else if (!useRange && singleDate) {
        params.date = singleDate;
      } else {
        // incomplete selection: prefer singleDate if present otherwise use today's date
        if (singleDate) params.date = singleDate;
      }

      if (region) params.regions = region;
      if (city) params.city = city;

      const res = await axios.get(`${API_BASE}/duration`, { params, timeout: 120000 });
      setData(res.data);
    } catch (err) {
      console.error(err);
      setError(err?.response?.data?.detail || err.message || "Failed to fetch duration data");
    } finally {
      setLoading(false);
    }
  };

  // Dynamic columns and rows for selected region
  const regionObj = useMemo(() => {
    if (!data || !region) return null;
    return data.regions?.[region] || null;
  }, [data, region]);

  // Simple Summary CSV export (existing behavior)
  const exportSummaryCsv = () => {
    if (!regionObj) return;
    const dates = regionObj.dates || [];
    const rows = regionObj.employees || [];

    // header
    const header = ["EmployeeID", "EmployeeName", "TotalSecondsPresentInRange", ...dates];
    const csvRows = [header.join(",")];

    rows.forEach((r) => {
      const row = [
        `"${(r.EmployeeID || "").toString().replace(/"/g, '""')}"`,
        `"${(r.EmployeeName || "").toString().replace(/"/g, '""')}"`,
        r.total_seconds_present_in_range ?? "",
        ...dates.map((d) => `"${(r.durations?.[d] ?? "")}"`),
      ];
      csvRows.push(row.join(","));
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `duration_summary_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // Detailed per-person CSV export (First/Last swipe, doors, card, company, primary location, directions, durations)
  const exportDetailedCsv = () => {
    if (!regionObj) return;
    const dates = regionObj.dates || [];
    const rows = regionObj.employees || [];

    const headers = [
      "person_uid",
      "EmployeeID",
      "EmployeeName",
      "CardNumber",
      "FirstSwipe",
      "LastSwipe",
      "FirstDoor",
      "LastDoor",
      "PersonnelType",
      "PartitionName2",
      "CompanyName",
      "PrimaryLocation",
      "FirstDirection",
      "LastDirection",
      "TotalSecondsPresentInRange",
      "DurationSecondsPerDate"
    ];
    // add each date to header
    const fullHeader = headers.concat(dates);
    const csvRows = [fullHeader.join(",")];

    rows.forEach(r => {
      const fixed = [
        `"${(r.person_uid || "").toString().replace(/"/g, '""')}"`,
        `"${(r.EmployeeID || "").toString().replace(/"/g, '""')}"`,
        `"${(r.EmployeeName || "").toString().replace(/"/g, '""')}"`,
        `"${(r.CardNumber || "").toString().replace(/"/g, '""')}"`,
        `"${(r.FirstSwipe || "")}"`,
        `"${(r.LastSwipe || "")}"`,
        `"${(r.FirstDoor || "").toString().replace(/"/g, '""')}"`,
        `"${(r.LastDoor || "").toString().replace(/"/g, '""')}"`,
        `"${(r.PersonnelType || "").toString().replace(/"/g, '""')}"`,
        `"${(r.PartitionName2 || "").toString().replace(/"/g, '""')}"`,
        `"${(r.CompanyName || "").toString().replace(/"/g, '""')}"`,
        `"${(r.PrimaryLocation || "").toString().replace(/"/g, '""')}"`,
        `"${(r.FirstDirection || "").toString().replace(/"/g, '""')}"`,
        `"${(r.LastDirection || "").toString().replace(/"/g, '""')}"`,
        `${r.total_seconds_present_in_range ?? ""}`,
        // as a single JSON-ish string of durations_seconds map
        `"${JSON.stringify(r.durations_seconds || {}).replace(/"/g, '""')}"`
      ];
      const perDateVals = dates.map(d => `"${(r.durations?.[d] ?? "")}"`);
      csvRows.push(fixed.concat(perDateVals).join(","));
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `duration_detailed_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // Export raw swipes for selected region (uses swipes_by_date returned by API)
  const exportSwipesCsv = () => {
    if (!regionObj) return;
    const swipesByDate = regionObj.swipes_by_date || {};
    // Flatten to rows (add date column)
    const rows = [];
    Object.entries(swipesByDate).forEach(([d, arr]) => {
      arr.forEach(s => {
        rows.push({
          Date: d,
          LocaleMessageTime: s.LocaleMessageTime || "",
          Swipe_Time: s.Swipe_Time || "",
          EmployeeID: s.EmployeeID || "",
          PersonGUID: s.PersonGUID || "",
          ObjectName1: s.ObjectName1 || "",
          Door: s.Door || "",
          PersonnelType: s.PersonnelType || "",
          CardNumber: s.CardNumber || "",
          PrimaryLocation: s.PrimaryLocation || s.Text5 || "",
          PartitionName2: s.PartitionName2 || "",
          AdmitCode: s.AdmitCode || "",
          Direction: s.Direction || "",
          CompanyName: s.CompanyName || ""
        });
      });
    });

    if (rows.length === 0) {
      alert("No swipe rows available for current selection to export.");
      return;
    }

    const headers = [
      "Date",
      "LocaleMessageTime",
      "Swipe_Time",
      "EmployeeID",
      "PersonGUID",
      "ObjectName1",
      "Door",
      "PersonnelType",
      "CardNumber",
      "PrimaryLocation",
      "PartitionName2",
      "AdmitCode",
      "Direction",
      "CompanyName"
    ];
    const csvRows = [headers.join(",")];
    rows.forEach(r => {
      const line = headers.map(h => {
        const v = r[h] ?? "";
        return `"${String(v).replace(/"/g, '""')}"`;
      }).join(",");
      csvRows.push(line);
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `swipes_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // Render helpers
  const renderTable = () => {
    if (!regionObj) return <Typography>No data for selected region.</Typography>;

    const dates = regionObj.dates || [];
    const rows = regionObj.employees || [];

    return (
      <TableContainer component={Paper} sx={{ mt: 2 }}>
        <Table size="small">
          <TableHead>
            <TableRow>
              <TableCell><b>EmployeeID</b></TableCell>
              <TableCell><b>EmployeeName</b></TableCell>
              <TableCell align="right"><b>Total (hh:mm:ss)</b></TableCell>
              {dates.map((d) => (
                <TableCell key={d} align="center"><b>{d}</b></TableCell>
              ))}
            </TableRow>
          </TableHead>
          <TableBody>
            {rows.length === 0 ? (
              <TableRow>
                <TableCell colSpan={3 + dates.length} align="center">No employees in the response.</TableCell>
              </TableRow>
            ) : (
              rows.map((r) => (
                <TableRow key={r.person_uid || `${r.EmployeeID}-${r.EmployeeName}`}>
                  <TableCell>{r.EmployeeID || "-"}</TableCell>
                  <TableCell>{r.EmployeeName || "-"}</TableCell>
                  <TableCell align="right">{secondsToHMS(r.total_seconds_present_in_range)}</TableCell>
                  {dates.map((d) => (
                    <TableCell key={d} align="center">{r.durations?.[d] ?? "-"}</TableCell>
                  ))}
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </TableContainer>
    );
  };

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h5" gutterBottom>
        Duration Reports
      </Typography>

      <Grid container spacing={2}>
        <Grid item xs={12} md={8}>
          <Card>
            <CardContent>
              <Grid container spacing={2} alignItems="center">
                <Grid item xs={12} md={4}>
                  <FormControl fullWidth>
                    <InputLabel id="region-label">Region</InputLabel>
                    <Select
                      labelId="region-label"
                      value={region}
                      label="Region"
                      onChange={(e) => setRegion(e.target.value)}
                    >
                      {REGIONS.map((r) => (
                        <MenuItem key={r.value} value={r.value}>{r.label}</MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>

                <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="City / Partition (optional)"
                    placeholder="e.g. CR.Costa Rica Partition"
                    value={city}
                    onChange={(e) => setCity(e.target.value)}
                  />
                </Grid>

                <Grid item xs={12} md={4} sx={{ display: "flex", gap: 1 }}>
                  <Button
                    startIcon={<DateRangeIcon />}
                    variant={useRange ? "contained" : "outlined"}
                    onClick={() => setUseRange(true)}
                  >
                    Range
                  </Button>
                  <Button
                    startIcon={<DateRangeIcon />}
                    variant={!useRange ? "contained" : "outlined"}
                    onClick={() => setUseRange(false)}
                  >
                    Single Day
                  </Button>
                </Grid>

                {useRange ? (
                  <>
                    <Grid item xs={12} md={4}>
                      <TextField
                        label="Start date"
                        type="date"
                        fullWidth
                        InputLabelProps={{ shrink: true }}
                        value={startDate}
                        onChange={(e) => setStartDate(e.target.value)}
                      />
                    </Grid>
                    <Grid item xs={12} md={4}>
                      <TextField
                        label="End date"
                        type="date"
                        fullWidth
                        InputLabelProps={{ shrink: true }}
                        value={endDate}
                        onChange={(e) => setEndDate(e.target.value)}
                      />
                    </Grid>
                  </>
                ) : (
                  <Grid item xs={12} md={4}>
                    <TextField
                      label="Date"
                      type="date"
                      fullWidth
                      InputLabelProps={{ shrink: true }}
                      value={singleDate}
                      onChange={(e) => setSingleDate(e.target.value)}
                    />
                  </Grid>
                )}

                <Grid item xs={12} md={4} sx={{ display: "flex", gap: 1, alignItems: "center" }}>
                  <Button
                    variant="contained"
                    startIcon={<SearchIcon />}
                    onClick={fetchDurations}
                    disabled={loading}
                  >
                    {loading ? "Loading..." : "Run"}
                  </Button>

                  <Button
                    variant="outlined"
                    startIcon={<ClearIcon />}
                    onClick={() => {
                      setStartDate("");
                      setEndDate("");
                      setSingleDate("");
                      setCity("");
                      setData(null);
                      setError("");
                    }}
                  >
                    Clear
                  </Button>

                  <Tooltip title="Export Summary CSV (per-person)">
                    <span>
                      <IconButton onClick={exportSummaryCsv} disabled={!regionObj || (regionObj.employees || []).length === 0}>
                        <DownloadIcon />
                      </IconButton>
                    </span>
                  </Tooltip>

                  <Tooltip title="Export Detailed CSV (first/last swipes, card, doors, company)">
                    <span>
                      <Button variant="contained" onClick={exportDetailedCsv} disabled={!regionObj || (regionObj.employees || []).length === 0}>
                        Export Details
                      </Button>
                    </span>
                  </Tooltip>

                  <Tooltip title="Export raw swipes for this region/date range">
                    <span>
                      <Button variant="outlined" onClick={exportSwipesCsv} disabled={!regionObj || Object.keys(regionObj.swipes_by_date || {}).length === 0}>
                        Export Swipes
                      </Button>
                    </span>
                  </Tooltip>

                </Grid>
              </Grid>
            </CardContent>
          </Card>

          <Box sx={{ mt: 2 }}>
            <Paper sx={{ p: 2 }}>
              <Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                <Typography variant="subtitle1">
                  {data ? `Showing ${region.toUpperCase()} — ${data.start_date} → ${data.end_date}` : "No results yet"}
                </Typography>
                <Typography variant="caption" color="text.secondary">
                  Tip: use the CSV export for offline analysis
                </Typography>
              </Box>

              {loading && (
                <Box sx={{ display: "flex", justifyContent: "center", py: 4 }}>
                  <CircularProgress />
                </Box>
              )}

              {error && (
                <Typography color="error" sx={{ mt: 2 }}>
                  {error}
                </Typography>
              )}

              {!loading && !error && (
                <Box sx={{ mt: 2 }}>
                  {renderTable()}
                </Box>
              )}
            </Paper>
          </Box>
        </Grid>

        <Grid item xs={12} md={4}>
          <Card sx={{ position: "sticky", top: 16 }}>
            <CardContent>
              <Typography variant="h6">How it works</Typography>
              <Typography variant="body2" sx={{ mt: 1 }}>
                - Use Range for multiple days (start + end).<br/>
                - Use Single Day for a calendar date.<br/>
                - Region selects which region to query (APAC/EMEA/LACA/NAMER).<br/>
                - City filters by PartitionName2 / PrimaryLocation / Door / EmployeeName.<br/>
                - The table shows per-person durations per day and a total seconds value.
              </Typography>

              <Box sx={{ mt: 2 }}>
                <Typography variant="subtitle2">Example endpoints</Typography>
                <Typography variant="caption" display="block">
                  Single day: <code>/duration?date=2025-09-04&regions=apac</code>
                </Typography>
                <Typography variant="caption" display="block">
                  Range: <code>/duration?start_date=2025-09-01&end_date=2025-09-05&regions=apac&city=CR.Costa%20Rica%20Partition</code>
                </Typography>
              </Box>
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    </Box>
  );
}

















#C:\Users\W0024618\Desktop\global-page\backend\attendance-analytics\app.py

@app.get("/duration")
async def api_duration(
    date_param: Optional[str] = Query(None, alias="date", description="Target date YYYY-MM-DD. Defaults to today in Asia/Kolkata"),
    start_date: Optional[str] = Query(None, description="Start date for a range (YYYY-MM-DD)"),
    end_date: Optional[str] = Query(None, description="End date for a range (YYYY-MM-DD)"),
    regions: Optional[str] = Query(None, description="Comma-separated list: apac,emea,laca,namer. Default: all"),
    city: Optional[str] = Query(None, description="Optional city/location filter (e.g. Pune). Case-insensitive, matches PartitionName2/PrimaryLocation/Door/EmployeeName"),
    outdir: Optional[str] = Query(None, description="Output directory for CSVs. Defaults to OUTPUT_DIR/duration_reports"),
    sample_rows: int = Query(10, ge=0, le=100, description="How many sample rows to include per region in response")
):
    """
    Returns per-region duration aggregates and swipe-level details:
    - response.regions[region].dates -> list of ISO dates covered
    - response.regions[region].employees -> list of persons with:
        person_uid, EmployeeID, EmployeeName, CardNumber, FirstSwipe, LastSwipe, FirstDoor, LastDoor,
        PersonnelType, PartitionName2, CompanyName, PrimaryLocation, FirstDirection, LastDirection,
        durations (map date->HH:MM:SS), durations_seconds (map date->seconds), total_seconds_present_in_range
    - response.regions[region].swipes_by_date -> { "YYYY-MM-DD": [ { swipe fields... }, ... ], ... }
    """
    try:
        # --- parse region list
        if regions:
            regions_list = [r.strip().lower() for r in regions.split(",") if r.strip()]
        else:
            regions_list = ["apac", "emea", "laca", "namer"]

        # --- parse output dir
        if outdir:
            outdir_path = Path(outdir)
        else:
            outdir_path = OUTPUT_DIR / "duration_reports"
        outdir_path.mkdir(parents=True, exist_ok=True)

        # --- determine date(s)
        def _parse_date(s: str) -> date:
            try:
                return datetime.strptime(s, "%Y-%m-%d").date()
            except Exception:
                return date.fromisoformat(s)

        if start_date and end_date:
            try:
                start_obj = _parse_date(start_date)
                end_obj = _parse_date(end_date)
            except Exception:
                raise HTTPException(status_code=400, detail="Invalid start_date or end_date format. Use YYYY-MM-DD.")
            if start_obj > end_obj:
                raise HTTPException(status_code=400, detail="start_date must be <= end_date")
            # safety: limit max days to avoid overloading
            max_days = 31
            days_count = (end_obj - start_obj).days + 1
            if days_count > max_days:
                raise HTTPException(status_code=400, detail=f"Date range too large (> {max_days} days). Please request a smaller range.")
            date_list = [start_obj + timedelta(days=i) for i in range(days_count)]
            range_mode = True
        else:
            # single-date: prefer explicit `date` query param, otherwise today's Asia/Kolkata
            if date_param:
                try:
                    target_date = _parse_date(date_param)
                except Exception:
                    raise HTTPException(status_code=400, detail="Invalid date format. Use YYYY-MM-DD.")
            else:
                tz = ZoneInfo("Asia/Kolkata")
                target_date = datetime.now(tz).date()
            date_list = [target_date]
            start_obj = end_obj = date_list[0]
            range_mode = False

        # --- import duration_report lazily
        try:
            import duration_report
        except Exception as e:
            logger.exception("Failed importing duration_report module")
            raise HTTPException(status_code=500, detail=f"duration module import failed: {e}")

        loop = asyncio.get_running_loop()

        # Helper serializer (safe conversion for pandas / numpy types)
        def _to_json_safe(v):
            try:
                if pd.isna(v):
                    return None
            except Exception:
                pass
            if isinstance(v, (datetime, date)):
                return v.isoformat()
            if hasattr(v, "isoformat") and not isinstance(v, str):
                try:
                    return v.isoformat()
                except Exception:
                    pass
            # numpy.int64 etc are int-like
            try:
                if isinstance(v, (int, float, bool)):
                    return v
            except Exception:
                pass
            # fallback to string
            try:
                return str(v)
            except Exception:
                return None

        # For each date, call run_for_date and collect results
        per_date_results = {}  # iso_date -> results dict returned by duration_report.run_for_date
        for single_date in date_list:
            try:
                task = loop.run_in_executor(None, duration_report.run_for_date, single_date, regions_list, str(outdir_path), city)
                per_date_results[single_date.isoformat()] = await asyncio.wait_for(task, timeout=COMPUTE_WAIT_TIMEOUT_SECONDS)
            except asyncio.TimeoutError:
                raise HTTPException(status_code=504, detail=f"Duration computation timed out for date {single_date.isoformat()}")
            except Exception as e:
                logger.exception("duration run_for_date failed for date %s", single_date)
                raise HTTPException(status_code=500, detail=f"duration run failed for {single_date.isoformat()}: {e}")

        # Aggregate results per region and per employee across dates
        resp: Dict[str, Any] = {
            "start_date": start_obj.isoformat(),
            "end_date": end_obj.isoformat(),
            "regions": {}
        }

        for r in regions_list:
            try:
                dates_iso = [d.isoformat() for d in date_list]

                # employee_map keyed by person_uid (prefer) else by EmployeeID|EmployeeName
                employees_map: Dict[str, Dict[str, Any]] = {}
                swipes_by_date: Dict[str, list] = {}
                date_rows = {}

                for iso_d, day_res in per_date_results.items():
                    # day_res is a dict: region -> {"swipes": df, "durations": df} OR region -> df
                    region_obj = day_res.get(r) if isinstance(day_res, dict) else None
                    durations_df = None
                    swipes_df = None
                    if isinstance(region_obj, dict):
                        swipes_df = region_obj.get("swipes")
                        durations_df = region_obj.get("durations")
                    elif isinstance(region_obj, pd.DataFrame):
                        durations_df = region_obj

                    # counts
                    rows_count = int(len(durations_df)) if isinstance(durations_df, pd.DataFrame) else 0
                    swipe_count = int(len(swipes_df)) if isinstance(swipes_df, pd.DataFrame) else 0
                    date_rows[iso_d] = {"rows": rows_count, "swipe_rows": swipe_count}

                    # collect swipe rows for this date (if present) into JSON-able dicts
                    if isinstance(swipes_df, pd.DataFrame) and not swipes_df.empty:
                        swipe_records = []
                        # ensure expected columns exist
                        for c in ["LocaleMessageTime", "EmployeeName", "Door", "EmployeeID", "CardNumber", "PartitionName2", "PersonnelTypeName", "CompanyName", "PrimaryLocation", "Direction", "EmployeeIdentity", "MessageType", "Text5"]:
                            if c not in swipes_df.columns:
                                swipes_df[c] = None
                        for _, srow in swipes_df.iterrows():
                            dt = srow.get("LocaleMessageTime")
                            iso_ts = None
                            if pd.notna(dt):
                                try:
                                    iso_ts = pd.to_datetime(dt).isoformat()
                                except Exception:
                                    try:
                                        iso_ts = datetime.fromtimestamp(float(dt)).isoformat()
                                    except Exception:
                                        iso_ts = str(dt)
                            swipe_records.append({
                                "LocaleMessageTime": iso_ts,
                                "Dateonly": iso_d,
                                "Swipe_Time": (pd.to_datetime(srow.get("LocaleMessageTime")).time().isoformat() if pd.notna(srow.get("LocaleMessageTime")) else None),
                                "EmployeeID": _to_json_safe(srow.get("EmployeeID")),
                                "PersonGUID": _to_json_safe(srow.get("EmployeeIdentity") or srow.get("EmployeeIdentity")),
                                "ObjectName1": _to_json_safe(srow.get("EmployeeName")),
                                "Door": _to_json_safe(srow.get("Door")),
                                "PersonnelType": _to_json_safe(srow.get("PersonnelTypeName") or srow.get("PersonnelType")),
                                "CardNumber": _to_json_safe(srow.get("CardNumber")),
                                "Text5": _to_json_safe(srow.get("PrimaryLocation") or srow.get("Text5")),
                                "PartitionName2": _to_json_safe(srow.get("PartitionName2")),
                                "AdmitCode": _to_json_safe(srow.get("AdmitCode") or srow.get("MessageType")),
                                "Direction": _to_json_safe(srow.get("Direction")),
                                "CompanyName": _to_json_safe(srow.get("CompanyName")),
                                "PrimaryLocation": _to_json_safe(srow.get("PrimaryLocation") or srow.get("Text5")),
                            })
                        swipes_by_date[iso_d] = swipe_records
                    else:
                        # ensure an empty list present for this date to keep shape stable
                        swipes_by_date.setdefault(iso_d, [])

                    # If we have durations_df with per-person aggregated rows, use it to build employees map
                    if isinstance(durations_df, pd.DataFrame) and not durations_df.empty:
                        # ensure useful columns present (the compute_daily_durations from duration_report provides many)
                        # expected possible columns: person_uid, EmployeeID, EmployeeName, CardNumber, Date,
                        # FirstSwipe, LastSwipe, FirstDoor, LastDoor, Duration, DurationSeconds,
                        # PersonnelTypeName, PartitionName2, CompanyName, PrimaryLocation, FirstDirection, LastDirection
                        for col in ["person_uid", "EmployeeID", "EmployeeName", "CardNumber", "Date",
                                    "FirstSwipe", "LastSwipe", "FirstDoor", "LastDoor",
                                    "Duration", "DurationSeconds", "PersonnelTypeName", "PartitionName2",
                                    "CompanyName", "PrimaryLocation", "FirstDirection", "LastDirection"]:
                            if col not in durations_df.columns:
                                durations_df[col] = None

                        for _, drow in durations_df.iterrows():
                            person_uid = drow.get("person_uid")
                            if pd.isna(person_uid) or person_uid is None or str(person_uid).strip() == "":
                                # fallback key
                                person_uid = f"{_to_json_safe(drow.get('EmployeeID'))}|{_to_json_safe(drow.get('EmployeeName'))}"
                            # initialize employee entry if missing
                            if person_uid not in employees_map:
                                employees_map[person_uid] = {
                                    "person_uid": person_uid,
                                    "EmployeeID": _to_json_safe(drow.get("EmployeeID")),
                                    "EmployeeName": _to_json_safe(drow.get("EmployeeName")),
                                    "CardNumber": _to_json_safe(drow.get("CardNumber")),
                                    "durations": {d: None for d in dates_iso},
                                    "durations_seconds": {d: None for d in dates_iso},
                                    "total_seconds_present_in_range": 0,
                                    # include first/last aggregates (will be updated if multiple dates present)
                                    "FirstSwipe": None,
                                    "LastSwipe": None,
                                    "FirstDoor": _to_json_safe(drow.get("FirstDoor")),
                                    "LastDoor": _to_json_safe(drow.get("LastDoor")),
                                    "PersonnelType": _to_json_safe(drow.get("PersonnelTypeName") or drow.get("PersonnelType")),
                                    "PartitionName2": _to_json_safe(drow.get("PartitionName2")),
                                    "CompanyName": _to_json_safe(drow.get("CompanyName")),
                                    "PrimaryLocation": _to_json_safe(drow.get("PrimaryLocation")),
                                    "FirstDirection": _to_json_safe(drow.get("FirstDirection")),
                                    "LastDirection": _to_json_safe(drow.get("LastDirection")),
                                }

                            # populate this date for this person
                            dur_str = None if pd.isna(drow.get("Duration")) else str(drow.get("Duration"))
                            dur_secs = None
                            try:
                                v = drow.get("DurationSeconds")
                                if pd.notna(v):
                                    dur_secs = int(float(v))
                            except Exception:
                                dur_secs = None

                            employees_map[person_uid]["durations"][iso_d] = dur_str
                            employees_map[person_uid]["durations_seconds"][iso_d] = dur_secs
                            if dur_secs is not None:
                                employees_map[person_uid]["total_seconds_present_in_range"] += dur_secs

                            # update FirstSwipe/LastSwipe across dates (keep earliest FirstSwipe and latest LastSwipe)
                            try:
                                fs = drow.get("FirstSwipe")
                                ls = drow.get("LastSwipe")
                                # normalize to datetime if possible
                                if pd.notna(fs):
                                    fs_dt = pd.to_datetime(fs)
                                    cur_fs = employees_map[person_uid].get("FirstSwipe")
                                    if cur_fs is None:
                                        employees_map[person_uid]["FirstSwipe"] = _to_json_safe(fs_dt)
                                    else:
                                        # keep earliest
                                        if pd.to_datetime(cur_fs) > fs_dt:
                                            employees_map[person_uid]["FirstSwipe"] = _to_json_safe(fs_dt)
                                if pd.notna(ls):
                                    ls_dt = pd.to_datetime(ls)
                                    cur_ls = employees_map[person_uid].get("LastSwipe")
                                    if cur_ls is None:
                                        employees_map[person_uid]["LastSwipe"] = _to_json_safe(ls_dt)
                                    else:
                                        # keep latest
                                        if pd.to_datetime(cur_ls) < ls_dt:
                                            employees_map[person_uid]["LastSwipe"] = _to_json_safe(ls_dt)
                            except Exception:
                                pass

                # convert employees_map to list and sort
                emp_list = list(employees_map.values())
                emp_list.sort(key=lambda x: ((x.get("EmployeeName") or "") or "").lower())

                durations_sample = emp_list[:sample_rows] if sample_rows and sample_rows > 0 else []

                resp["regions"][r] = {
                    "dates": dates_iso,
                    "employees": emp_list,
                    "durations_sample": durations_sample,
                    "date_rows": date_rows,
                    "swipes_by_date": swipes_by_date
                }
            except Exception:
                logger.exception("Failed to aggregate range results for region %s", r)
                resp["regions"][r] = {"dates": [d.isoformat() for d in date_list], "employees": [], "durations_sample": [], "date_rows": {}, "swipes_by_date": {}}

        return JSONResponse(resp)
    except HTTPException:
        raise
    except Exception as exc:
        logger.exception("api_duration (range) failed")
        raise HTTPException(status_code=500, detail=f"duration api error: {exc}")











