//C:\Users\W0024618\Desktop\global-page\frontend\src\pages\DailyAccessReport.jsx

import ExcelJS from 'exceljs';

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');

function _extractServerDateTimeParts(iso) {
  if (!iso) return null;
  const s = String(iso);
  let datePart = '', timePart = '';
  if (s.includes('T')) {
    [datePart, timePart] = s.split('T');
  } else if (s.includes(' ')) {
    [datePart, timePart] = s.split(' ');
  } else {
    return null;
  }
  datePart = datePart.slice(0, 10);
  timePart = (timePart || '').replace(/Z|[+-]\d{2}:\d{2}$/, '').replace(/\.\d+$/, '');
  const dParts = datePart.split('-').map(p => parseInt(p, 10));
  const tParts = timePart.split(':').map(p => parseInt(p || '0', 10));
  return {
    year: dParts[0] || 0,
    month: dParts[1] || 0,
    day: dParts[2] || 0,
    hour: tParts[0] || 0,
    minute: tParts[1] || 0,
    second: tParts[2] || 0
  };
}

function formatDateFromServerISO_forDaily(iso) {
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const mon = MONTH_ABBR[(p.month - 1) || 0];
  return `${pad2(p.day)}-${mon}-${String(p.year).slice(-2)}`;
}

function formatTimeFromServerISO_forDaily(iso) {
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const hh = p.hour;
  const mm = p.minute || 0;
  const ss = p.second || 0;
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1;
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
}

// Helper used to produce the server "ISO-like" string if row only has DateOnly+Swipe_Time.
// This mirrors your existing buildISOFromDateOnlyAndSwipe behavior but returns an ISO-like string
function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10);
  if (!swipeIso) {
    return `${datePart}T00:00:00.000`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000`;
  }
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000`;
}

/**
 * Generate Daily Access Excel using server-provided literal wall-clock strings.
 * rows: array of objects from backend
 * opts: { from, to, selectedEmps, region }
 */
export async function generateDailyAccessExcelFromRows(rows = [], opts = {}) {
  const { from, to, selectedEmps = [], region = 'emea' } = opts;
  const wb = new ExcelJS.Workbook();

  // local helpers & constants for formatting
  const THIN_BORDER = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
  const THICK_BORDER = { top: { style: 'thick' }, left: { style: 'thick' }, bottom: { style: 'thick' }, right: { style: 'thick' } };
  const GRAY_FILL = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };

  const colLetter = (c => {
    let n = c, s = '';
    while (n > 0) {
      const m = (n - 1) % 26;
      s = String.fromCharCode(65 + m) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  });

  // For each selected employee create a sheet (same logic as before)
  for (const emp of selectedEmps) {
    // worksheet name must be <= 31 chars
    const ws = wb.addWorksheet(emp.substring(0, 31));

    // hide gridlines
    try { ws.views = [{ showGridLines: false }]; } catch (e) { /* ignore */ }

    // skip first row (blank)
    ws.addRow([]);

    // Headers we will use (starting at column B)
    const headers = [
      'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
      'Access Card No.', 'Door Name', 'Location', 'Swipe'
    ];

    const startCol = 2; // column B
    const endCol = startCol + headers.length - 1;

    // Title row (row 2)
    ws.addRow([null]); // ensure row 2 exists
    const title = `${(region || '').toUpperCase()} Daily Access Report - ${from || ''}${to ? ' to ' + to : ''}`;
    ws.mergeCells(`${colLetter(startCol)}2:${colLetter(endCol)}2`);
    const titleCell = ws.getCell(colLetter(startCol) + '2');
    titleCell.value = title;
    titleCell.font = { bold: true, size: 14 };
    titleCell.alignment = { horizontal: 'center', vertical: 'middle' };
    ws.getRow(2).height = 22;
    for (let c = startCol; c <= endCol; c++) {
      const cell = ws.getCell(2, c);
      cell.fill = GRAY_FILL;
      cell.font = { bold: true, size: 14 };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.border = THICK_BORDER;
    }

    // Header row (row 3) - add a null at column A so that column A remains blank
    const headerRow = ws.addRow([null, ...headers]);
    headerRow.height = 20;
    headerRow.eachCell((cell, colNumber) => {
      if (colNumber >= startCol && colNumber <= endCol) {
        cell.font = { bold: true };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        cell.fill = GRAY_FILL;
        cell.border = THICK_BORDER;
      }
    });

    // set columns (include blank A)
    const cols = [{ key: 'blankA', width: 3 }];
    headers.forEach(h => cols.push({ key: h.replace(/\s+/g, '').toLowerCase(), width: 18 }));
    ws.columns = cols;

    // add data rows (start row 4)
    const rowsForEmp = (rows || []).filter(r => r.ObjectName1 === emp);
    if ((rowsForEmp || []).length === 0) {
      // no rows: show a centered message under header (merge across content columns)
      const msgRowIndex = ws.lastRow ? ws.lastRow.number + 1 : 4;
      ws.mergeCells(`${colLetter(startCol)}${msgRowIndex}:${colLetter(endCol)}${msgRowIndex}`);
      const mcell = ws.getCell(`${colLetter(startCol)}${msgRowIndex}`);
      mcell.value = 'There is no swipe records found in Ccure';
      mcell.alignment = { horizontal: 'center', vertical: 'middle' };
      mcell.border = THIN_BORDER;
    } else {
      rowsForEmp.forEach((r, idx) => {
        // prefer server-provided formatted string field `LocaleMessageTime`
        // if backend returns DateOnly+Swipe_Time, build a pseudo-ISO from them
        let isoText = '';
        if (r.LocaleMessageTime) {
          isoText = r.LocaleMessageTime;
        } else if (r.LocaleMessageTimeStr) {
          isoText = r.LocaleMessageTimeStr;
        } else if (r.DateOnly) {
          isoText = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
        } else {
          isoText = '';
        }

        const dateStr = isoText ? formatDateFromServerISO_forDaily(isoText) : '';
        const timeStr = isoText ? formatTimeFromServerISO_forDaily(isoText) : '';

        const rowVals = [
          null, // blank A
          idx + 1,
          dateStr,
          timeStr,
          r.ObjectName1 || r.EmployeeName || '',
          r.EmployeeID || '',
          r.CardNumber || r.Card || '',
          r.Door || r.ObjectName2 || '',
          r.location || '',
          r.Direction || r.Swipe || ''
        ];

        // slice to headers length + 1 (blank A)
        const trimmed = rowVals.slice(0, 1 + headers.length);
        const row = ws.addRow(trimmed);

        row.eachCell((cell, colNumber) => {
          if (colNumber >= startCol && colNumber <= endCol) {
            cell.border = THIN_BORDER;
            // all center aligned as requested
            cell.alignment = { vertical: 'middle', horizontal: 'center' };
          }
        });
      });
    }

    // apply thick outside border around header + data (B..endCol)
    const headerRowIndex = 3;
    const firstRowIdx = headerRowIndex;
    const lastRowIdx = ws.lastRow ? ws.lastRow.number : headerRowIndex;
    for (let r = firstRowIdx; r <= lastRowIdx; r++) {
      for (let c = startCol; c <= endCol; c++) {
        const cell = ws.getCell(r, c);
        if (!cell.border) cell.border = THIN_BORDER;
        const border = {
          top: (r === firstRowIdx) ? { style: 'thick' } : (cell.border.top || { style: 'thin' }),
          bottom: (r === lastRowIdx) ? { style: 'thick' } : (cell.border.bottom || { style: 'thin' }),
          left: (c === startCol) ? { style: 'thick' } : (cell.border.left || { style: 'thin' }),
          right: (c === endCol) ? { style: 'thick' } : (cell.border.right || { style: 'thin' })
        };
        cell.border = border;
      }
    }

    // do not autosize per instructions
    ws.autoFilter = `${colLetter(startCol)}3:${colLetter(endCol)}3`;
  }

  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const filename = `Daily Access Report(${from ? from : ''} to ${to ? to : ''}).xlsx`;
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
}

export default {
  generateDailyAccessExcelFromRows
};






















//C:\Users\W0024618\Desktop\global-page\frontend\src\pages\DailyAccessReport.jsx

import ExcelJS from 'exceljs';

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');

function _extractServerDateTimeParts(iso) {
  if (!iso) return null;
  const s = String(iso);
  let datePart = '', timePart = '';
  if (s.includes('T')) {
    [datePart, timePart] = s.split('T');
  } else if (s.includes(' ')) {
    [datePart, timePart] = s.split(' ');
  } else {
    return null;
  }
  datePart = datePart.slice(0, 10);
  timePart = (timePart || '').replace(/Z|[+-]\d{2}:\d{2}$/, '').replace(/\.\d+$/, '');
  const dParts = datePart.split('-').map(p => parseInt(p, 10));
  const tParts = timePart.split(':').map(p => parseInt(p || '0', 10));
  return {
    year: dParts[0] || 0,
    month: dParts[1] || 0,
    day: dParts[2] || 0,
    hour: tParts[0] || 0,
    minute: tParts[1] || 0,
    second: tParts[2] || 0
  };
}

function formatDateFromServerISO_forDaily(iso) {
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const mon = MONTH_ABBR[(p.month - 1) || 0];
  return `${pad2(p.day)}-${mon}-${String(p.year).slice(-2)}`;
}

function formatTimeFromServerISO_forDaily(iso) {
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const hh = p.hour;
  const mm = p.minute || 0;
  const ss = p.second || 0;
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1;
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
}

// Helper used to produce the server "ISO-like" string if row only has DateOnly+Swipe_Time.
// This mirrors your existing buildISOFromDateOnlyAndSwipe behavior but returns an ISO-like string
function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10);
  if (!swipeIso) {
    return `${datePart}T00:00:00.000`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000`;
  }
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000`;
}

/**
 * Generate Daily Access Excel using server-provided literal wall-clock strings.
 * rows: array of objects from backend
 * opts: { from, to, selectedEmps, region }
 */
export async function generateDailyAccessExcelFromRows(rows = [], opts = {}) {
  const { from, to, selectedEmps = [], region = 'emea' } = opts;

  // Formatting constants (local to this function only)
  const THIN_BORDER = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
  const THICK_BORDER = { top: { style: 'thick' }, left: { style: 'thick' }, bottom: { style: 'thick' }, right: { style: 'thick' } };
  const GRAY_FILL = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };

  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Daily Access');

  // helper: convert 1-index col num to letter
  const colLetter = (c => {
    let n = c, s = '';
    while (n > 0) {
      const m = (n - 1) % 26;
      s = String.fromCharCode(65 + m) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  });

  // hide gridlines
  try { ws.views = [{ showGridLines: false }]; } catch (e) { /* ignore */ }

  // skip first row (blank)
  ws.addRow([]);

  // headers we will use (starting at column B)
  const headers = [
    'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
    'Access Card No.', 'Door Name', 'Location', 'Swipe'
  ];

  const startCol = 2; // B
  const endCol = startCol + headers.length - 1;

  // Title row (row 2)
  ws.addRow([null]);
  const title = `${(region || '').toUpperCase()} Daily Access Report - ${from || ''}${to ? ' to ' + to : ''}`;
  ws.mergeCells(`${colLetter(startCol)}2:${colLetter(endCol)}2`);
  const titleCell = ws.getCell(colLetter(startCol) + '2');
  titleCell.value = title;
  titleCell.font = { bold: true, size: 14 };
  titleCell.alignment = { horizontal: 'center', vertical: 'middle' };
  ws.getRow(2).height = 22;
  for (let c = startCol; c <= endCol; c++) {
    const cell = ws.getCell(2, c);
    cell.fill = GRAY_FILL;
    cell.font = { bold: true, size: 14 };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.border = THICK_BORDER;
  }

  // Header row (row 3)
  const headerRow = ws.addRow([null, ...headers]);
  headerRow.height = 20;
  headerRow.eachCell((cell, colNumber) => {
    if (colNumber >= startCol && colNumber <= endCol) {
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.fill = GRAY_FILL;
      cell.border = THICK_BORDER;
    }
  });

  // set columns widths (A blank)
  const cols = [{ key: 'blankA', width: 3 }];
  headers.forEach(h => cols.push({ key: h.replace(/\s+/g, '').toLowerCase(), width: 18 }));
  ws.columns = cols;

  // add data rows (start row 4) — include only rows that match selectedEmps if provided
  const rowsToUse = (Array.isArray(rows) ? rows : []).filter(r => {
    if (!selectedEmps || !selectedEmps.length) return true;
    // match either by ObjectName1 or EmployeeID or name substring match
    const name = (r.ObjectName1 || '').toString();
    const id = (r.EmployeeID || '').toString();
    return selectedEmps.some(sel => {
      const s = (sel || '').toString();
      return s === name || s === id || name.includes(s) || id.includes(s);
    });
  });

  rowsToUse.forEach((r, idx) => {
    // attempt to build commonly expected fields
    let iso = '';
    if (r.LocaleMessageTime) iso = r.LocaleMessageTime;
    else if (r.LocaleMessageTimeStr) iso = r.LocaleMessageTimeStr;
    else if (r.DateOnly) iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);

    const dateStr = iso ? formatDateFromServerISO_forDaily(iso) : (r.DateOnly ? formatDateFromServerISO_forDaily(r.DateOnly) : '');
    const timeStr = iso ? formatTimeFromServerISO_forDaily(iso) : (r.Swipe_Time ? formatTimeFromServerISO_forDaily(r.Swipe_Time) : '');

    const rowVals = [
      null, // column A blank
      idx + 1,
      dateStr,
      timeStr,
      r.ObjectName1 || r.EmployeeName || '',
      r.EmployeeID || '',
      r.CardNumber || r.Card || '',
      r.Door || r.ObjectName2 || '',
      r.location || '',
      r.Direction || r.Swipe || ''
    ];

    // In case the header count is 9 but we built 10 elements above, slice to headers length + 1 for blankA
    const trimmed = rowVals.slice(0, 1 + headers.length);
    const row = ws.addRow(trimmed);

    row.eachCell((cell, colNumber) => {
      if (colNumber >= startCol && colNumber <= endCol) {
        cell.border = THIN_BORDER;
        // center align as requested for data columns
        cell.alignment = { vertical: 'middle', horizontal: 'center' };
      }
    });
  });

  // apply thick outside border around header + data (B..endCol)
  const headerRowIndex = 3;
  const firstRow = headerRowIndex;
  const lastRow = ws.lastRow ? ws.lastRow.number : headerRowIndex;
  for (let r = firstRow; r <= lastRow; r++) {
    for (let c = startCol; c <= endCol; c++) {
      const cell = ws.getCell(r, c);
      if (!cell.border) cell.border = THIN_BORDER;
      const border = {
        top: (r === firstRow) ? { style: 'thick' } : (cell.border.top || { style: 'thin' }),
        bottom: (r === lastRow) ? { style: 'thick' } : (cell.border.bottom || { style: 'thin' }),
        left: (c === startCol) ? { style: 'thick' } : (cell.border.left || { style: 'thin' }),
        right: (c === endCol) ? { style: 'thick' } : (cell.border.right || { style: 'thin' })
      };
      cell.border = border;
    }
  }

  // No autosize per instructions

  // write and download
  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const filename = `DailyAccess_${(region || '').toUpperCase()}_${(from || '')}${to ? `_to_${to}` : ''}.xlsx`;
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
}

export default {
  generateDailyAccessExcelFromRows
};

















//C:\Users\W0024618\Desktop\global-page\frontend\src\pages\DailyAccessReport.jsx

import ExcelJS from 'exceljs';

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');

function _extractServerDateTimeParts(iso) {
  if (!iso) return null;
  const s = String(iso);
  let datePart = '', timePart = '';
  if (s.includes('T')) {
    [datePart, timePart] = s.split('T');
  } else if (s.includes(' ')) {
    [datePart, timePart] = s.split(' ');
  } else {
    return null;
  }
  datePart = datePart.slice(0, 10);
  timePart = (timePart || '').replace(/Z|[+-]\d{2}:\d{2}$/, '').replace(/\.\d+$/, '');
  const dParts = datePart.split('-').map(p => parseInt(p, 10));
  const tParts = timePart.split(':').map(p => parseInt(p || '0', 10));
  return {
    year: dParts[0] || 0,
    month: dParts[1] || 0,
    day: dParts[2] || 0,
    hour: tParts[0] || 0,
    minute: tParts[1] || 0,
    second: tParts[2] || 0
  };
}

function formatDateFromServerISO_forDaily(iso) {
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const mon = MONTH_ABBR[(p.month - 1) || 0];
  return `${pad2(p.day)}-${mon}-${String(p.year).slice(-2)}`;
}

function formatTimeFromServerISO_forDaily(iso) {
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const hh = p.hour;
  const mm = p.minute || 0;
  const ss = p.second || 0;
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1;
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
}

// Helper used to produce the server "ISO-like" string if row only has DateOnly+Swipe_Time.
// This mirrors your existing buildISOFromDateOnlyAndSwipe behavior but returns an ISO-like string
function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10);
  if (!swipeIso) {
    return `${datePart}T00:00:00.000`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000`;
  }
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000`;
}

/**
 * Generate Daily Access Excel using server-provided literal wall-clock strings.
 * rows: array of objects from backend
 * opts: { from, to, selectedEmps, region }
 */
export async function generateDailyAccessExcelFromRows(rows = [], opts = {}) {
  const { from, to, selectedEmps = [], region = 'emea' } = opts;
  const wb = new ExcelJS.Workbook();

  // group rows by ObjectName1 (employee)
  for (const emp of selectedEmps) {
    const ws = wb.addWorksheet(emp.substring(0, 31));
    const headers = ['Date', 'Time', 'Name', 'Contractor ID', 'Card No', 'Door Name', 'Message Type', 'Partition', 'Swipe'];
    ws.addRow(headers);
    const hdr = ws.getRow(1);
    hdr.font = { bold: true };
    hdr.alignment = { vertical: 'middle', horizontal: 'center' };
    hdr.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'date', width: 12 },
      { key: 'time', width: 12 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'card', width: 15 },
      { key: 'door', width: 40 },
      { key: 'msg', width: 20 },
      { key: 'part', width: 15 },
      { key: 'swipe', width: 10 }
    ];

    const rowsForEmp = rows.filter(r => r.ObjectName1 === emp);
    if (!rowsForEmp.length) {
      ws.mergeCells('A2:I2');
      ws.getCell('A2').value = 'There is no swipe records found in Ccure';
      ws.getCell('A2').alignment = { horizontal: 'center' };
    } else {
      rowsForEmp.forEach(r => {
        // prefer server-provided formatted string field `LocaleMessageTime`
        // if backend returns DateOnly+Swipe_Time, build a pseudo-ISO from them
        let isoText = '';
        if (r.LocaleMessageTime) {
          isoText = r.LocaleMessageTime; // should be "YYYY-MM-DD HH:MM:SS.mmm" (string)
        } else if (r.LocaleMessageTimeStr) {
          isoText = r.LocaleMessageTimeStr;
        } else if (r.DateOnly) {
          isoText = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
        }

        // Use the simple formatter that interprets the string as literal wall-clock parts
        const dateStr = isoText ? formatDateFromServerISO_forDaily(isoText) : '';
        const timeStr = isoText ? formatTimeFromServerISO_forDaily(isoText) : '';

        // Normalize message type text: e.g. "CardAdmitted" -> "Card Admitted"
        const rawMsg = (r.AdmitCode || r.Messagetype || '').toString();
        const msgFormatted = rawMsg ? rawMsg.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/\s+/g, ' ').trim() : '';

        const row = ws.addRow([
          dateStr,
          timeStr,
          r.ObjectName1 || '',
          r.EmployeeID || '',
          r.CardNumber || '',
          r.Door || r.ObjectName2 || '',
          msgFormatted,
          r.location || '',
          r.Swipe || r.Direction || ''
        ]);

        row.getCell(1).alignment = { horizontal: 'left' };
        row.getCell(2).alignment = { horizontal: 'left' };
        row.eachCell(c => {
          c.border = {
            top: { style: 'thin' }, left: { style: 'thin' },
            bottom: { style: 'thin' }, right: { style: 'thin' }
          };
          c.alignment = { vertical: 'middle', horizontal: 'left' };
        });
      });
    }

    ws.autoFilter = 'A1:I1';
  }

  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const filename = `Daily Access Report(${from ? from : ''} to ${to ? to : ''}).xlsx`;
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
}

export default {
  generateDailyAccessExcelFromRows
};






