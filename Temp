Good Morning 
Now i want to make Login Access 
Thosw who are register in Employee in backend this only login and View the explore Global page details ..

In Global page there are multiple APi endpoint is there ..
so 
from Frotend 
i want give acces and restrict access for employee wise login..

1)In Global page there Multiple API like 
1) Device Health Dashboard 
2) HeadCount ( APAC , EMEA, LACA , NAMER,)
3)ERT members page ( Pune , Costa Rica )
4) Associate Verification Tool 
5)GSOC Reports 
6)Global Duration page like ..

So i want to 
make Login Details like ....
Lloyds , Das ( 314345) 
Pandey, Sonu (326131)
Diwate, Swapnil( W0024618)

Only this are have access to grant access someone ..

2) Create Login Details like Username , Password ,

then only accesible member only explore accessible content like ..

Lloyds Das gave access to Dhobale, Abhishek( W0025562) then this Employee details will automatically store in backend .
again lloyds das want to remove access fro Abhishek ..

swapnil gave access to Vrutik , sankalp , Manisha ..Sejal ..
swapnil gave Vrutil ..access for all
1) Device Health Dashboard 
2) HeadCount ( APAC , EMEA, LACA , NAMER,)
3)ERT members page ( Pune , Costa Rica )
4) Associate Verification Tool 
5)GSOC Reports 

this page then Vrutik need to check and explore only above 4 page ...

suppose Lloyds, dass  gave access to sameer kanade for ERT menbers then only he can access ERT API.. 

so Check below Global page details and all page detail and create login page carefully ..





// frontend/src/pages/GlobalPage.jsx

import React, { useState, useEffect, useRef } from 'react';
import {
  Box, Typography, CircularProgress, IconButton, Button, Paper, Divider,
  LinearProgress, Snackbar, Alert, List, ListItem, ListItemText,Tooltip
} from '@mui/material';

import HomeIcon from '@mui/icons-material/Home';
import DescriptionIcon from '@mui/icons-material/Description';
import UploadFileIcon from '@mui/icons-material/UploadFile';

import MapChart from '../components/MapChart.jsx';
import api from '../api';
import { useNavigate, Link } from 'react-router-dom';



import TimerIcon from "@mui/icons-material/AccessTime"; // duration icon
import { Link as RouterLink } from "react-router-dom";

/*
  Important:
  - Do NOT mix /api/headcount and /api/ccure/verify.
  - Region cards (APAC/EMEA/LACA/NAMER) come only from /api/headcount.
  - Live vs CCURE Summary now comes from /api/ccure/verify?raw=true.
  - Initial region totals are zero (keeps previous UI behaviour).
  - We implement polling for headcount and SSE for ccure/stream (realtime via SSE).
*/

export default function GlobalPage() {
  const navigate = useNavigate();

  // Region totals (headcount) - default to zeros so UI shows 0 immediately (preserve previous behaviour)
  const [counts, setCounts] = useState({ apac: 0, emea: 0, laca: 0, namer: 0 });
  const [selected, setSelected] = useState('global');

  // Averages/ccure state (left panel)
  const [averages, setAverages] = useState(null);
  const [loadingAverages, setLoadingAverages] = useState(true);
  const [averagesError, setAveragesError] = useState(null);

  // upload state
  const [uploading, setUploading] = useState(false);
  const [uploadResult, setUploadResult] = useState(null);
  const [uploadError, setUploadError] = useState(null);

  // (kept for backwards-compatibility but upload buttons are always shown now)
  const [uploadedEmployee, setUploadedEmployee] = useState(false);
  const [uploadedContractor, setUploadedContractor] = useState(false);

  const [exportReportPath, setExportReportPath] = useState(null);

  // top-row file inputs
  const fileInputEmpRef = useRef();
  const fileInputContrRef = useRef();
  const [snack, setSnack] = useState({ open: false, severity: 'info', message: '' });

  // date-range state for top-right controls
  const [startDate, setStartDate] = useState('');
  const [endDate, setEndDate] = useState('');

  // Polling refs for safe scheduling and backoff
  const headcountRef = useRef({ timerId: null, failureCount: 0, isFetching: false });
  const averagesRef = useRef({ timerId: null, failureCount: 0, isFetching: false });


  const [showCenterUploads, setShowCenterUploads] = useState(false);


  // -----------------------
  // HEADCOUNT POLLING ONLY (unchanged)
  // -----------------------
  useEffect(() => {
    let mounted = true;

    const fetchHeadcount = async () => {
      if (!mounted) return;
      if (headcountRef.current.isFetching) return;
      headcountRef.current.isFetching = true;

      try {
        const res = await api.get('/headcount');
        if (!mounted) return;
        const d = res.data;
        if (d && typeof d === 'object') {
          const newCounts = {
            apac: Number(d.apac || 0),
            emea: Number(d.emea || 0),
            laca: Number(d.laca || 0),
            namer: Number(d.namer || 0),
          };
          setCounts(prev => {
            if (
              prev.apac === newCounts.apac &&
              prev.emea === newCounts.emea &&
              prev.laca === newCounts.laca &&
              prev.namer === newCounts.namer
            ) {
              return prev;
            }
            return newCounts;
          });
        } else {
          console.warn('[headcount] unexpected response shape - ignoring', d);
        }
        headcountRef.current.failureCount = 0;
      } catch (err) {
        headcountRef.current.failureCount = (headcountRef.current.failureCount || 0) + 1;
        console.warn('[headcount] fetch failed:', err?.message || err);
      } finally {
        headcountRef.current.isFetching = false;
        const f = headcountRef.current.failureCount || 0;
        const backoffMs = 15000 * Math.pow(2, Math.min(Math.max(f - 1, 0), 4)); // 15s..240s
        headcountRef.current.timerId = setTimeout(fetchHeadcount, backoffMs);
      }
    };

    fetchHeadcount();

    return () => {
      mounted = false;
      if (headcountRef.current.timerId) clearTimeout(headcountRef.current.timerId);
      headcountRef.current.isFetching = false;
    };
  }, []); // run once

  // AVERAGES: use SSE (direct to Python backend) with fallback initial fetch
  useEffect(() => {
    let stopped = false;
    let es = null;
    let backoff = 100000;

    // Allow override via VITE_PY_BACKEND; otherwise assume python at :8000
    const PY_BACKEND = (import.meta.env.VITE_PY_BACKEND || `${window.location.protocol}//${window.location.hostname}:8000`).replace(/\/$/, '');

    const connect = () => {
      if (stopped) return;
      try {
        es = new EventSource(`${PY_BACKEND}/ccure/stream`);
      } catch (err) {
        console.warn('SSE creation failed', err);
        es = null;
      }

      if (!es) {
        initialFetch();
        return;
      }

      es.onopen = () => {
        console.info('[SSE] connected to', `${PY_BACKEND}/ccure/stream`);
        backoff = 1000;
        setAveragesError(null);
      };

      es.onmessage = (evt) => {
        try {
          const payload = JSON.parse(evt.data);
          setAverages(payload);
          setLoadingAverages(false);
          setAveragesError(null);
        } catch (e) {
          console.warn('Failed to parse SSE message', e);
        }
      };

      es.onerror = (err) => {
        console.warn('[SSE] error/closed, attempting reconnect', err);
        try { es.close(); } catch (e) { }
        es = null;
        if (stopped) return;
        setTimeout(() => {
          backoff = Math.min(backoff * 2, 30000);
          connect();
        }, backoff);
      };
    };

    const initialFetch = async () => {
      setLoadingAverages(true);
      setAveragesError(null);
      try {
        const res = await api.get('/ccure/verify?raw=true');
        setAverages(res.data);
        setLoadingAverages(false);
        setAveragesError(null);
      } catch (err) {
        console.warn('initial /ccure/verify?raw=true fetch failed', err);
        setLoadingAverages(false);
        setAveragesError(err);
      }
    };

    initialFetch();
    connect();

    return () => {
      stopped = true;
      if (es) {
        try { es.close(); } catch (e) { }
        es = null;
      }
    };
  }, []);

  // -----------------------
  // Upload helper (updated to use fetch, kept robust)
  // -----------------------
  const handleUpload = async (file, type) => {
    if (!file) return;
    const endpoint = type === 'employee' ? '/upload/active-employees' : '/upload/active-contractors';

    const PY_BACKEND = (import.meta.env.VITE_PY_BACKEND || `${window.location.protocol}//${window.location.hostname}:8000`).replace(/\/$/, '');
    const url = `${PY_BACKEND}${endpoint}`;

    const fd = new FormData();
    fd.append('file', file, file.name);

    setUploading(true);
    setUploadResult(null);
    setUploadError(null);

    try {
      console.info('Uploading to', url, file.name);
      const resp = await fetch(url, {
        method: 'POST',
        body: fd,
      });

      const rawText = await resp.text();
      let data = null;
      try { data = rawText ? JSON.parse(rawText) : null; } catch (e) { data = { raw: rawText }; }

      console.info('Upload response', resp.status, resp.statusText, data);

      if (!resp.ok) {
        throw new Error(`Upload failed HTTP ${resp.status} ${resp.statusText} - ${JSON.stringify(data)}`);
      }

      setUploadResult(data);
      setSnack({ open: true, severity: 'success', message: `Active Sheet Updated successfully: ${file.name}` });

      // mark canonical presence if backend returned detail.canonical_saved
      const saved = data && data.detail && (data.detail.canonical_saved || data.detail.canonical_saved === "");
      if (type === 'employee') setUploadedEmployee(!!saved);
      if (type === 'contractor') setUploadedContractor(!!saved);

      // best-effort refresh of averages/headcount
      try {
        const r1 = await fetch(`${PY_BACKEND}/ccure/verify?raw=true`);
        if (r1.ok) setAverages(await r1.json());
      } catch (e) { console.warn('refresh verify failed', e); }

      try {
        const r2 = await fetch(`${PY_BACKEND}/headcount`);
        if (r2.ok) {
          const d = await r2.json();
          if (d && typeof d === 'object') {
            setCounts({
              apac: Number(d.apac || 0),
              emea: Number(d.emea || 0),
              laca: Number(d.laca || 0),
              namer: Number(d.namer || 0)
            });
          }
        }
      } catch (e) { console.warn('refresh headcount failed', e); }

    } catch (err) {
      console.error('Upload failed', err);
      setUploadError(err);
      setSnack({ open: true, severity: 'error', message: `Upload failed: ${file.name} — ${err.message}` });
    } finally {
      setUploading(false);
    }
  };

  // --- Helpers: find CCURE arrays in 'averages' and generate CSV ---
  const _escapeCsv = (v) => {
    if (v === null || v === undefined) return '';
    if (typeof v === 'object') {
      try { v = JSON.stringify(v); } catch { v = String(v); }
    }
    const s = String(v).replace(/"/g, '""');
    return `"${s}"`;
  };

  // Find candidate arrays inside the averages object that look like CCURE comparison rows
  const findCcureArrays = (obj) => {
    const found = [];
    if (!obj || typeof obj !== 'object') return found;

    const inspect = (parentKey, val) => {
      if (!val) return;
      if (Array.isArray(val) && val.length > 0 && typeof val[0] === 'object') {
        const sample = val[0];
        // heuristic: many ccure rows have ccure_key or EmployeeID or EmpName fields
        if ('ccure_key' in sample || 'EmployeeID' in sample || 'EmpName' in sample) {
          found.push({ key: parentKey, arr: val });
        }
      } else if (typeof val === 'object') {
        for (const k of Object.keys(val)) {
          inspect(parentKey ? `${parentKey}.${k}` : k, val[k]);
        }
      }
    };

    inspect('', obj);
    return found;
  };

  // Build CSV rows with the requested columns:
  // Employees: ccure_key, EmployeeID, EmpName, PersonnelType, Manager_Name, Profile_Disabled, Employee_Status
  // Contractors: ccure_key, EmployeeID, EmpName, VendorCompany, PersonnelType, Manager_Name, Profile_Disabled, Employee_Status
  const generateCcureCompareCSV = (averagesPayload) => {
    if (!averagesPayload || typeof averagesPayload !== 'object') return null;

    const candidates = findCcureArrays(averagesPayload);
    if (!candidates || candidates.length === 0) return null;

    // choose the first plausible array
    const rows = candidates[0].arr;

    if (!Array.isArray(rows) || rows.length === 0) return null;

    const headers = ['ccure_key', 'EmployeeID', 'EmpName', 'VendorCompany', 'PersonnelType', 'Manager_Name', 'Profile_Disabled', 'Employee_Status'];
    const lines = [headers.map(h => _escapeCsv(h)).join(',')];

    const readField = (r, name) => {
      if (!r) return '';
      if (r[name] !== undefined && r[name] !== null) return r[name];
      if (r.raw && typeof r.raw === 'object' && r.raw[name] !== undefined && r.raw[name] !== null) return r.raw[name];
      // some backends put nested object as string in "raw"
      if (typeof r.raw === 'string') {
        try {
          const parsed = JSON.parse(r.raw);
          if (parsed && parsed[name] !== undefined) return parsed[name];
        } catch { }
      }
      return '';
    };

    for (const r of rows) {
      // derive PersonnelType (sometimes present in row or row.raw)
      const personnelType = readField(r, 'PersonnelType') || readField(r, 'Personnel_Type') || readField(r, 'PersonnelTypeName') || '';

      const ccure_key = readField(r, 'ccure_key') || readField(r, 'CcureKey') || readField(r, 'EmployeeID') || '';
      const employeeId = readField(r, 'EmployeeID') || readField(r, 'Employee_Id') || '';
      const empName = readField(r, 'EmpName') || readField(r, 'EmployeeName') || readField(r, 'Name') || '';
      const vendorCompany = readField(r, 'VendorCompany') || readField(r, 'Vendor_Company') || '';
      const managerName = readField(r, 'Manager_Name') || readField(r, 'ManagerName') || '';
      let profileDisabled = readField(r, 'Profile_Disabled');
      if (profileDisabled === true || profileDisabled === false) profileDisabled = String(profileDisabled);
      const employeeStatus = readField(r, 'Employee_Status') || readField(r, 'Status') || '';

      const rowValues = [
        ccure_key,
        employeeId,
        empName,
        vendorCompany,
        personnelType,
        managerName,
        profileDisabled,
        employeeStatus,
      ];

      lines.push(rowValues.map(v => _escapeCsv(v)).join(','));
    }

    const csvContent = lines.join('\n');
    return csvContent;
  };

  // Export: request server to generate compare report and download the xlsx (binary)
  const exportUploadedSheets = async () => {
    setUploading(true);
    try {
      const PY_BACKEND = (import.meta.env.VITE_PY_BACKEND || `${window.location.protocol}//${window.location.hostname}:8000`).replace(/\/$/, '');

      // attempt server-side generation as before
      let genJson = null;
      try {
        const genRes = await fetch(`${PY_BACKEND}/ccure/compare?export=true`, {
          method: 'GET',
        });

        try {
          genJson = await genRes.json();
        } catch (e) {
          const txt = await genRes.text().catch(() => '');
          throw new Error(`Export generation returned non-JSON response: ${txt}`);
        }

        if (!genRes.ok || !genJson || !genJson.report_path) {
          const msg = (genJson && (genJson.detail || genJson.error)) || JSON.stringify(genJson || {});
          console.warn('Server export generation failed or returned unexpected payload:', msg);
          setSnack({ open: true, severity: 'warning', message: 'Server export generation failed; attempting client CSV export' });
        } else {
          // server returned a report_path — attempt to download it
          const reportPath = genJson.report_path;
          setExportReportPath(reportPath);
          setSnack({ open: true, severity: 'success', message: 'Export created — downloading now' });

          try {
            const dlUrl = `${PY_BACKEND}/ccure/report/${encodeURIComponent(reportPath)}`;
            const fileRes = await fetch(dlUrl, { method: 'GET' });

            if (!fileRes.ok) {
              const txt = await fileRes.text().catch(() => '');
              console.warn('Failed to download server report:', txt);
            } else {
              const blob = await fileRes.blob();
              const blobUrl = window.URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = blobUrl;
              a.download = reportPath || 'missing_vs_ccure.xlsx';
              document.body.appendChild(a);
              a.click();
              a.remove();
              window.URL.revokeObjectURL(blobUrl);
            }
          } catch (e) {
            console.warn('Server report download failed:', e);
          }
        }
      } catch (err) {
        // log and fall through to client-side CSV
        console.warn('exportUploadedSheets server call failed:', err);
      }

      // --- Client-side CSV fallback / supplemental export with requested columns ---
      try {
        const csv = generateCcureCompareCSV(averages || {});
        if (csv) {
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          // prefer a descriptive filename
          const fname = `missing_vs_ccure_custom_${(new Date()).toISOString().slice(0, 10)}.csv`;
          a.download = fname;
          document.body.appendChild(a);
          a.click();
          a.remove();
          window.URL.revokeObjectURL(url);
          setSnack({ open: true, severity: 'success', message: 'Custom CCURE CSV downloaded' });
        } else {
          // nothing to export client-side
          setSnack(prev => ({ ...prev, open: true, severity: 'info', message: 'No CCURE rows found in current averages payload for CSV export' }));
        }
      } catch (e) {
        console.error('Client CSV generation failed', e);
        setSnack(prev => ({ ...prev, open: true, severity: 'error', message: `CSV generation failed: ${e?.message || e}` }));
      }

    } catch (err) {
      console.error('exportUploadedSheets error', err);
      setSnack({ open: true, severity: 'error', message: `Export failed: ${err.message || err}` });
    } finally {
      setUploading(false);
    }
  };

  const onChooseEmployeeFile = (e) => { const f = e.target.files && e.target.files[0]; if (f) handleUpload(f, 'employee'); e.target.value = null; };
  const onChooseContractorFile = (e) => { const f = e.target.files && e.target.files[0]; if (f) handleUpload(f, 'contractor'); e.target.value = null; };

  // apply date range to re-fetch /ccure/verify
  const applyDateRange = async () => {
    if (!startDate || !endDate) {
      setSnack({ open: true, severity: 'warning', message: 'Please select start and end dates' });
      return;
    }
    setLoadingAverages(true);
    setAveragesError(null);
    try {
      const res = await api.get(`/ccure/verify?raw=true&start_date=${startDate}&end_date=${endDate}`);
      setAverages(res.data);
      setLoadingAverages(false);
      setSnack({ open: true, severity: 'success', message: 'Averages updated' });
    } catch (err) {
      console.warn('applyDateRange failed', err);
      setLoadingAverages(false);
      setAveragesError(err);
      setSnack({ open: true, severity: 'error', message: 'Failed to update averages' });
    }
  };

  // safe helper for nested averages paths
  const safe = (path, fallback = null) => {
    if (!averages) return fallback;
    try {
      return path.split('.').reduce((a, k) => (a && a[k] !== undefined ? a[k] : fallback), averages);
    } catch {
      return fallback;
    }
  };

  // Derived values (unchanged)
  const ccureActiveEmployees = safe('ccure_reported.employees',
    safe('ccure_active.active_employees',
      safe('ccure_active.ccure_active_employees_reported', null)
    )
  );
  const ccureActiveContractors = safe('ccure_reported.contractors',
    safe('ccure_active.active_contractors',
      safe('ccure_active.ccure_active_contractors_reported', null)
    )
  );

  const headTotalVisited = safe('headcount_attendance_summary.total_visited_today',
    safe('headcount_details.total_visited_today', null)
  );
  const headEmployee = safe('headcount_attendance_summary.employee',
    safe('headcount_details.employee', null)
  );
  const headContractor = safe('headcount_attendance_summary.contractor',
    safe('headcount_details.contractor', null)
  );

  const liveCurrentTotal = safe('live_headcount_region_clients.currently_present_total',
    safe('live_headcount_details.currently_present_total',
      null
    )
  );
  const liveEmp = safe('live_headcount_region_clients.employee',
    safe('live_headcount_details.employee', null)
  );
  const liveContr = safe('live_headcount_region_clients.contractor',
    safe('live_headcount_details.contractor', null)
  );

  const empPct = safe('percentages_vs_ccure.head_employee_pct_vs_ccure_today',
    safe('averages.head_emp_pct_vs_ccure_today', null)
  );
  const conPct = safe('percentages_vs_ccure.head_contractor_pct_vs_ccure_today',
    safe('averages.head_contractor_pct_vs_ccure_today', null)
  );
  const overallPct = safe('percentages_vs_ccure.head_overall_pct_vs_ccure_today',
    safe('averages.headcount_overall_pct_vs_ccure_today', null)
  );

  const avg7 = safe('averages.history_avg_overall_last_7_days',
    safe('averages.avg_headcount_last_7_days',
      safe('averages.avg_headcount_last_7_days_db', null)
    )
  );

  const respDate = safe('date', null);

  const locationAvgsObj = safe('averages.history_avg_by_location_last_7_days',
    safe('history_avg_by_location_last_7_days',
      safe('raw.averages.history_avg_by_location_last_7_days', {})
    )
  );

  const locationAvgsList = React.useMemo(() => {
    if (!locationAvgsObj || typeof locationAvgsObj !== 'object') return [];
    const arr = Object.entries(locationAvgsObj).map(([loc, vals]) => {
      return {
        location: loc,
        avg_employee_last_7_days: vals.avg_employee_last_7_days ?? vals.history_avg_employee_last_7_days ?? vals.avg_employee ?? null,
        avg_contractor_last_7_days: vals.avg_contractor_last_7_days ?? vals.history_avg_contractor_last_7_days ?? vals.avg_contractor ?? null,
        avg_overall_last_7_days: vals.avg_overall_last_7_days ?? vals.history_avg_overall_last_7_days ?? vals.avg_overall ?? null,
        history_days_counted: vals.history_days_counted ?? null
      };
    });
    arr.sort((a, b) => (b.avg_overall_last_7_days ?? -Infinity) - (a.avg_overall_last_7_days ?? -Infinity));
    return arr;
  }, [locationAvgsObj]);

  const globalCount = Number((counts.apac || 0)) + Number((counts.emea || 0)) + Number((counts.laca || 0)) + Number((counts.namer || 0));

  const hideScrollbarSx = {
    overflowY: 'auto',
    '&::-webkit-scrollbar': { width: 0, height: 0 },
    scrollbarWidth: 'none',
    msOverflowStyle: 'none',
  };

  // Render
  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh', overflow: 'hidden', bgcolor: 'background.default' }}>
      {/* Header */}
      <Box px={2} py={1} sx={{ backgroundColor: 'black', color: '#fff', borderBottom: '4px solid #FFD700', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
        <Box>
          <IconButton component={Link} to="/" sx={{ color: '#FFC72C' }}><HomeIcon fontSize="medium" /></IconButton>
          <IconButton component={Link} to="/reports" sx={{ color: '#FFC72C', ml: 1 }}><DescriptionIcon fontSize="medium" /></IconButton>
          <IconButton
            component="a"
            href="http://10.138.161.4:3000/dashboard/index.html"

            rel="noopener noreferrer"
            sx={{ color: '#FFC72C', ml: 1 }}
          >
            <i className="fa-solid fa-camera" style={{ fontSize: 20 }} />
          </IconButton>

          <IconButton
            component="a"
            href="http://10.199.22.57:3004/"
            rel="noopener noreferrer"
            sx={{ color: '#FFF', ml: 1 }}
          >
            <i className="bi bi-patch-check"></i>
          </IconButton>



{/* place this after the Associate Verification Tool link */}
<Tooltip title="Duration Reports">
  <IconButton
              component={RouterLink}
              to="/duration"
              size="large"
              aria-label="Duration Reports"
              sx={{ color: '#FFF', ml: 1 }}
            >
              <TimerIcon />
            </IconButton>
          </Tooltip>


        </Box>

        <Box sx={{ flexGrow: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
          <Box component="img" src="/wu-head-logo.png" alt="WU Logo" sx={{ height: { xs: 30, md: 55 }, mr: 2 }} />
          <Typography variant="h5" sx={{ fontWeight: 'bold', color: 'primary.main' }}>Global Headcount Dashboard</Typography>
        </Box>

        <Box sx={{ width: 120 }} />
      </Box>

      {/* Top row: Uploads | GLOBAL + Region Cards | Date selectors */}
      <Box sx={{ display: 'flex', alignItems: 'center', p: 1, px: 1, gap: 1 }}>
        {/* Left: fixed column with stacked upload/export buttons (aligned left) */}
        <Box sx={{ width: 260, display: 'flex', flexDirection: 'column', gap: 1 }}>
          <input type="file" accept=".xls,.xlsx,.csv" style={{ display: 'none' }} ref={fileInputEmpRef} onChange={onChooseEmployeeFile} />
          <Button
            variant="contained"
            size="small"
            startIcon={<UploadFileIcon />}
            onClick={() => fileInputEmpRef.current && fileInputEmpRef.current.click()}
            sx={{ width: '100%', height: 25, textTransform: 'none', fontWeight: 700 }}
          >
            Upload Active Employee Sheet
          </Button>

          <input type="file" accept=".xls,.xlsx,.csv" style={{ display: 'none' }} ref={fileInputContrRef} onChange={onChooseContractorFile} />
          <Button
            variant="contained"
            size="small"
            startIcon={<UploadFileIcon />}
            onClick={() => fileInputContrRef.current && fileInputContrRef.current.click()}
            sx={{ width: '100%', height: 25, textTransform: 'none', fontWeight: 700 }}
          >
            Upload Active Contractor Sheet
          </Button>

          <Button
            variant="contained"
            size="small"
            startIcon={<DescriptionIcon />}
            onClick={exportUploadedSheets}
            sx={{ width: '100%', height: 25, textTransform: 'none', fontWeight: 700 }}
          >
            Export Comparison → Report
          </Button>
        </Box>

        {/* Center: flexible, keeps region cards exactly centered on screen */}
        <Box sx={{ flex: 1, display: 'flex', justifyContent: 'center' }}>
          <Box sx={{ display: 'flex', gap: 3, alignItems: 'center', justifyContent: 'center', flexWrap: 'wrap' }}>
            {[
              { key: 'global', label: 'GLOBAL', count: globalCount, url: null },
              { key: 'apac', label: 'APAC', count: counts.apac, url: 'http://10.199.22.57:3000/' },
              { key: 'emea', label: 'EMEA', count: counts.emea, url: 'http://10.199.22.57:3001/' },
              { key: 'laca', label: 'LACA', count: counts.laca, url: 'http://10.199.22.57:3003/' },
              { key: 'namer', label: 'NAMER', count: counts.namer, url: 'http://10.199.22.57:3002/' },
            ].map(region => (
              <Box
                key={region.key}
                onClick={() => {
                  if (region.key === 'global') {
                    const el = document.querySelector('[data-global-left-panel]');
                    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    setSelected('global');
                    return;
                  }
                  if (region.url) window.location.href = region.url;
                }}
                sx={{
                  cursor: 'pointer',
                  width: 200,
                  height: 88,
                  display: 'flex',
                  flexDirection: 'column',
                  justifyContent: 'center',
                  alignItems: 'center',
                  border: '4px solid rgba(255, 204, 0, 0.89)',
                  borderRadius: 2,
                  boxShadow: 3,
                  bgcolor: 'transparent',
                  '&:hover': { opacity: 0.95 },
                }}
              >
                <Typography variant="subtitle2" sx={{ fontWeight: 'bold', color: '#FFC72C', fontSize: { xs: '0.95rem', md: '1.2rem' } }}>
                  {region.label}
                </Typography>
                <Typography variant="h4" sx={{ fontWeight: 900, fontSize: { xs: '1.2rem', md: '1.6rem' }, color: '#FFFFFF' }}>
                  {region.count ?? 0}
                </Typography>
              </Box>
            ))}
          </Box>
        </Box>

        {/* Right: fixed column for date selectors (aligned right) */}
        <Box sx={{ width: 360, display: 'flex', flexDirection: 'column', gap: 1, alignItems: 'flex-end' }}>
          <Paper sx={{ p: 1, display: 'flex', gap: 1, alignItems: 'center', boxShadow: 1, width: '100%' }}>
            <Box sx={{ display: 'flex', flexDirection: 'column', width: 160 }}>
              <Typography variant="caption" color="text.secondary">Select Start date</Typography>
              <input
                type="date"
                value={startDate}
                onChange={(e) => setStartDate(e.target.value)}
                style={{ width: '100%', height: 34, borderRadius: 4, border: '1px solid rgba(255,255,255,0.06)', padding: 4, background: '#FFCC00', color: 'Black' }}
              />
            </Box>

            <Box sx={{ display: 'flex', flexDirection: 'column', width: 160 }}>
              <Typography variant="caption" color="text.secondary">Select End date</Typography>
              <input
                type="date"
                value={endDate}
                onChange={(e) => setEndDate(e.target.value)}
                style={{ width: '100%', height: 34, borderRadius: 4, border: '1px solid rgba(255,255,255,0.06)', padding: 4, background: '#FFCC00', color: 'Black' }}
              />
            </Box>
          </Paper>

          <Box sx={{ width: '100%', display: 'flex', justifyContent: 'flex-start' }}>
            <Button size="small" variant="contained" onClick={applyDateRange} sx={{ height: 36, textTransform: 'none', fontWeight: 700 }}>
              Apply
            </Button>
          </Box>
        </Box>
      </Box>

      {/* Main: left summary | center map | right averages */}
      <Box sx={{ display: 'flex', flex: 1, overflow: 'hidden' }}>
        {/* Left detail panel */}
        <Box
          data-global-left-panel
          sx={{
            width: { xs: 320, md: 360 },
            minWidth: { md: 320 },
            p: 2,
            bgcolor: 'background.paper',
            borderRight: '1px solid rgba(255,255,255,0.06)',
            display: 'flex',
            flexDirection: 'column',
            ...hideScrollbarSx,
            height: '100%',
          }}
        >
          <Typography variant="h6" sx={{ mb: 1, color: 'primary.main' }}>Live vs CCURE Summary</Typography>

          {loadingAverages ? (
            <Box sx={{ py: 2 }}><LinearProgress /></Box>
          ) : averagesError ? (
            <Alert severity="error">Failed to load CCURE averages</Alert>
          ) : averages ? (
            <>
              <Paper sx={{ p: 2, mb: 2, bgcolor: 'rgba(255,255,255,0.02)' }} elevation={0}>
                <Typography variant="subtitle2" color="text.secondary">CCURE Active (reported)</Typography>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 1, alignItems: 'center' }}>
                  <Box>
                    <Typography variant="h4" sx={{ fontWeight: 800 }}>{ccureActiveEmployees ?? '—'}</Typography>
                    <Typography variant="caption" color="text.secondary">Active Employees</Typography>
                  </Box>
                  <Box sx={{ textAlign: 'right' }}>
                    <Typography variant="h5" sx={{ fontWeight: 800 }}>{ccureActiveContractors ?? '—'}</Typography>
                    <Typography variant="caption" color="text.secondary">Active Contractors</Typography>
                  </Box>
                </Box>
              </Paper>

              <Paper sx={{ p: 2, mb: 2, bgcolor: 'rgba(255,255,255,0.02)' }} elevation={0}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                  <Typography variant="subtitle2" color="text.secondary">Live Today</Typography>
                  <Typography variant="caption" color="text.secondary">{respDate ?? ''}</Typography>
                </Box>

                <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 1 }}>
                  <Box>
                    <Typography variant="h5" sx={{ fontWeight: 800 }}>{headEmployee ?? liveEmp ?? '—'}</Typography>
                    <Typography variant="caption" color="text.secondary">Employee</Typography>
                  </Box>
                  <Box>
                    <Typography variant="h5" sx={{ fontWeight: 800 }}>{headContractor ?? liveContr ?? '—'}</Typography>
                    <Typography variant="caption" color="text.secondary">Contractor</Typography>
                  </Box>
                </Box>

                <Divider sx={{ my: 1 }} />

                <Box>
                  <Typography variant="caption" color="text.secondary">Totals</Typography>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.75 }}>
                    <Typography variant="body2">Attendance total (today)</Typography>
                    <Typography variant="body2" sx={{ fontWeight: 700 }}>{headTotalVisited ?? '—'}</Typography>
                  </Box>

                  <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
                    <Typography variant="body2">Live region total</Typography>
                    <Typography variant="body2" sx={{ fontWeight: 700 }}>{liveCurrentTotal ?? '—'}</Typography>
                  </Box>

                  {safe('headcount_details.total_visited_today', null) != null && (
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
                      <Typography variant="body2">Detail rows total</Typography>
                      <Typography variant="body2" sx={{ fontWeight: 700 }}>{safe('headcount_details.total_visited_today', '—')}</Typography>
                    </Box>
                  )}
                </Box>
              </Paper>

              <Paper sx={{ p: 2, mb: 2, bgcolor: 'rgba(255,255,255,0.02)' }} elevation={0}>
                <Typography variant="subtitle2" color="text.secondary">Percentages vs CCURE</Typography>

                <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 1 }}>
                  <Typography variant="body2">Employees</Typography>
                  <Typography variant="body2" sx={{ fontWeight: 700 }}>{empPct != null ? `${empPct}%` : '—'}</Typography>
                </Box>
                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                  <Typography variant="body2">Contractors</Typography>
                  <Typography variant="body2" sx={{ fontWeight: 700 }}>{conPct != null ? `${conPct}%` : '—'}</Typography>
                </Box>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
                  <Typography variant="body2">Overall</Typography>
                  <Typography variant="body2" sx={{ fontWeight: 700 }}>{overallPct != null ? `${overallPct}%` : '—'}</Typography>
                </Box>

                <Divider sx={{ my: 1 }} />
                <Typography variant="caption" color="text.secondary">Averages</Typography>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 1 }}>
                  <Typography variant="body2">7-day avg headcount</Typography>
                  <Typography variant="body2" sx={{ fontWeight: 700 }}>{avg7 ?? '—'}</Typography>
                </Box>
              </Paper>

              {averages.notes && (
                <Paper sx={{ p: 2, mb: 2, bgcolor: 'rgba(255,255,255,0.01)' }}>
                  <Typography variant="body2" sx={{ mt: 1 }}>{averages.notes}</Typography>
                </Paper>
              )}
            </>
          ) : (
            <Typography variant="body2" color="text.secondary">No data</Typography>
          )}
        </Box>

        {/* Center: map (flex) */}
        <Box sx={{ flex: 1, minWidth: 0, position: 'relative', display: 'flex', flexDirection: 'column' }}>
          <Box sx={{ flex: 1, minHeight: 0 }}>
            <MapChart selected={selected} onClickSite={r => setSelected(r)} initialZoom={1.8} />
          </Box>
        </Box>

        {/* Right side: Location averages panel */}
        <Box
          sx={{
            width: { xs: 320, md: 360 },
            minWidth: { md: 320 },
            borderLeft: '1px solid rgba(255,255,255,0.06)',
            bgcolor: 'background.paper',
            p: 2,
            display: 'flex',
            flexDirection: 'column',
            ...hideScrollbarSx,
            height: '100%',
          }}
        >
          <Typography variant="h6" sx={{ mb: 1, color: 'primary.main' }}>Location Averages</Typography>

          {loadingAverages ? (
            <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', py: 4 }}>
              <CircularProgress />
            </Box>
          ) : averagesError ? (
            <Alert severity="error">Failed to load location averages</Alert>
          ) : locationAvgsList.length === 0 ? (
            <Typography variant="body2" color="text.secondary">No location averages available</Typography>
          ) : (
            <List dense disablePadding sx={{ flex: 1 }}>
              {locationAvgsList.map(item => (
                <ListItem key={item.location} sx={{ alignItems: 'flex-start', py: 1.25, borderBottom: '1px solid rgba(255,255,255,0.03)' }}>
                  <ListItemText
                    primary={
                      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <Typography sx={{ fontWeight: 800 }}>{item.location}</Typography>
                        <Typography variant="body2" sx={{ fontWeight: 800 }}>
                          {item.avg_overall_last_7_days != null ? Math.round(item.avg_overall_last_7_days) : '—'}
                        </Typography>
                      </Box>
                    }
                    secondary={
                      <Box sx={{ display: 'flex', gap: 2, mt: 0.5, flexWrap: 'wrap' }}>
                        <Typography variant="caption" color="text.secondary">Emp: <strong>{item.avg_employee_last_7_days != null ? Math.round(item.avg_employee_last_7_days) : '—'}</strong></Typography>
                        <Typography variant="caption" color="text.secondary">Contr: <strong>{item.avg_contractor_last_7_days != null ? Math.round(item.avg_contractor_last_7_days) : '—'}</strong></Typography>
                        {item.history_days_counted != null && <Typography variant="caption" color="text.secondary">Days: {item.history_days_counted}</Typography>}
                      </Box>
                    }
                    primaryTypographyProps={{ component: 'div' }}
                    secondaryTypographyProps={{ component: 'div' }}
                  />
                </ListItem>
              ))}
            </List>
          )}
        </Box>
      </Box>

      <Snackbar open={snack.open} autoHideDuration={3500} onClose={() => setSnack(prev => ({ ...prev, open: false }))}>
        <Alert severity={snack.severity} onClose={() => setSnack(prev => ({ ...prev, open: false }))}>{snack.message}</Alert>
      </Snackbar>
       
    </Box>
  );
}








// frontend/src/pages/DurationPage.jsx
import React, { useState, useMemo, useEffect, useCallback, useRef } from "react";
import axios from "axios";
import {
  Box,
  Grid,
  Paper,
  Typography,
  TextField,
  Button,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  TableContainer,
  CircularProgress,
  IconButton,
  Tooltip,
  Card,
  CardContent,
  Dialog,
  DialogTitle,
  DialogContent,
  Divider,
  MenuItem,
  Select,
  FormControl,
  InputLabel,
  InputAdornment,
} from "@mui/material";
import DateRangeIcon from "@mui/icons-material/DateRange";
import SearchIcon from "@mui/icons-material/Search";
import DownloadIcon from "@mui/icons-material/CloudDownload";
import ClearIcon from "@mui/icons-material/Clear";
import VisibilityIcon from "@mui/icons-material/Visibility";

const API_BASE =
  import.meta.env.VITE_API_BASE ||
  import.meta.env.REACT_APP_API_BASE ||
  "http://localhost:8000";

const REGIONS = [
  { value: "apac", label: "APAC" },
  { value: "emea", label: "EMEA" },
  { value: "laca", label: "LACA" },
  { value: "namer", label: "NAMER" },
];

function secondsToHMS(s) {
  if (s == null) return "";
  const sec = Number(s);
  if (!Number.isFinite(sec)) return "";
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const r = Math.floor(sec % 60);
  return `${h}:${String(m).padStart(2, "0")}:${String(r).padStart(2, "0")}`;
}

function isoToDDMMYYYY(iso) {
  if (!iso) return iso;
  const dt = new Date(iso.includes("T") ? iso : `${iso}T00:00:00Z`);
  if (Number.isNaN(dt.getTime())) return iso;
  const dd = String(dt.getUTCDate()).padStart(2, "0");
  const mm = String(dt.getUTCMonth() + 1).padStart(2, "0");
  const yyyy = dt.getUTCFullYear();
  return `${dd}-${mm}-${yyyy}`;
}

function isoToLongDateNoCommas(iso) {
  if (!iso) return iso;
  const dt = new Date(iso.includes("T") ? iso : `${iso}T00:00:00Z`);
  if (Number.isNaN(dt.getTime())) return iso;
  const weekday = dt.toLocaleDateString(undefined, { weekday: "short" });
  const day = String(dt.getUTCDate()).padStart(2, "0");
  const month = String(dt.getUTCMonth() + 1).padStart(2, "0");
  const year = dt.getUTCFullYear();
  return `${weekday} ${day}-${month}-${year}`;
}

// threshold used for highlighting swipe differences > 6 hours
const SWIPE_DIFF_RED_THRESHOLD = 6 * 3600;

export default function DurationPage() {
  const [region, setRegion] = useState("apac");
  const [city, setCity] = useState("");
  const [citiesForRegion, setCitiesForRegion] = useState([]);
  const [startDate, setStartDate] = useState("");
  const [endDate, setEndDate] = useState("");
  const [singleDate, setSingleDate] = useState("");
  const [useRange, setUseRange] = useState(true);

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const [searchEmployeeId, setSearchEmployeeId] = useState("");
  const [searchEmployeeName, setSearchEmployeeName] = useState("");
  const [searchCardNumber, setSearchCardNumber] = useState("");

  const [swipeDialogOpen, setSwipeDialogOpen] = useState(false);
  const [selectedEmployee, setSelectedEmployee] = useState(null);
  const [selectedSwipes, setSelectedSwipes] = useState([]);

  // New UI state for override selection
  const [overrideDate, setOverrideDate] = useState("");
  const [overrideStartIndex, setOverrideStartIndex] = useState(null);
  const [overrideEndIndex, setOverrideEndIndex] = useState(null);
  const [overrideReason, setOverrideReason] = useState("");
  const [overrideApplying, setOverrideApplying] = useState(false);

  // Refs for native date inputs so we can call showPicker() (if supported)
  const startDateRef = useRef(null);
  const endDateRef = useRef(null);
  const singleDateRef = useRef(null);

  // Styling for tables (borders + header background)
  const tableSx = {
    "& th, & td": { border: "1px solid rgba(0,0,0,0.12)" },
    "& thead th": { backgroundColor: "#FFD700", fontWeight: 700 },
    "& tbody tr": { backgroundColor: "transparent" },
    "& tbody tr:hover": { backgroundColor: "rgba(255, 204, 0, 0.12)" },
  };

  const dialogTableSx = {
    "& th, & td": { border: "1px solid rgba(0,0,0,0.12)" },
    "& thead th": { backgroundColor: "#FFD700", fontWeight: 700 },
    "& tbody tr:hover": { backgroundColor: "rgba(255, 204, 0, 0.08)" },
  };

  // helper to try to open the native date picker (where supported)
  const openNativeDatePicker = (ref) => {
    if (!ref || !ref.current) return;
    try {
      if (typeof ref.current.showPicker === "function") {
        ref.current.showPicker();
      } else {
        ref.current.focus();
      }
    } catch (e) {
      try {
        ref.current.focus();
      } catch {}
    }
  };

  // fetch cities when region changes
  useEffect(() => {
    async function fetchCities() {
      setCitiesForRegion([]);
      setCity("");
      try {
        const res = await axios.get(`${API_BASE}/duration/cities`, {
          params: { region },
          timeout: 20000,
        });
        const cities = res.data?.cities || [];
        setCitiesForRegion(cities);
      } catch (err) {
        console.warn("Failed to fetch cities list:", err?.message || err);
        setCitiesForRegion([]);
      }
    }
    fetchCities();
  }, [region]);

  // --- fetch durations (full) ---
  const fetchDurations = useCallback(
    async (opts = {}) => {
      // default full fetch (used when user clicks Run)
      setError("");
      setLoading(true);
      setData(null);

      try {
        const params = {};
        if (useRange && startDate && endDate) {
          params.start_date = startDate;
          params.end_date = endDate;
        } else if (!useRange && singleDate) {
          params.date = singleDate;
        } else {
          if (singleDate) params.date = singleDate;
        }

        if (region) params.regions = region;
        if (city) params.city = city;

        // server-side filters
        if (searchEmployeeId) params.employee_id = searchEmployeeId;
        if (searchEmployeeName) params.employee_name = searchEmployeeName;
        if (searchCardNumber) params.card_number = searchCardNumber;

        // allow overriding timeout via opts
        const timeout = opts.timeout || 1200000;

        const res = await axios.get(`${API_BASE}/duration`, {
          params,
          timeout,
        });
        setData(res.data);
      } catch (err) {
        console.error(err);
        setError(err?.response?.data?.detail || err.message || "Failed to fetch duration data");
      } finally {
        setLoading(false);
      }
    },
    [useRange, startDate, endDate, singleDate, region, city, searchEmployeeId, searchEmployeeName, searchCardNumber]
  );

  // --- targeted fetch: get only single employee for current region and merge into UI ---
  const fetchAndMergeEmployee = useCallback(
    async ({ employeeId, person_uid } = {}) => {
      if (!employeeId && !person_uid) return;
      try {
        const params = {};
        if (useRange && startDate && endDate) {
          params.start_date = startDate;
          params.end_date = endDate;
        } else if (!useRange && singleDate) {
          params.date = singleDate;
        } else {
          if (singleDate) params.date = singleDate;
        }
        params.regions = region;
        // prefer server-side employee_id filter (EmployeeID)
        if (employeeId) params.employee_id = employeeId;
        // if no EmployeeID but we have person_uid, pass employee_name or a unique param — backend supports employee_id only,
        // but person_uid may match PersonGUID in swipes. We'll pass employee_name if nothing else.
        if (!employeeId && person_uid) {
          params.employee_name = person_uid;
        }
        params.sample_rows = 0; // we only need exact employee rows, avoid extra samples
        const res = await axios.get(`${API_BASE}/duration`, { params, timeout: 120000 });
        const resp = res.data;
        if (!resp || !resp.regions || !resp.regions[region]) {
          // no matching data returned
          return;
        }
        const newRegionObj = resp.regions[region];
        const fetchedEmployees = newRegionObj.employees || [];

        setData((prev) => {
          try {
            if (!prev) {
              // nothing previously, use fetched answer
              return resp;
            }
            const next = { ...prev, regions: { ...(prev.regions || {}) } };
            const prevRegion = (prev.regions || {})[region] || { dates: [], employees: [], swipes_by_date: {} };
            // merge dates and swipes_by_date from fetched
            const mergedRegion = {
              ...prevRegion,
              dates: newRegionObj.dates || prevRegion.dates,
              date_rows: newRegionObj.date_rows || prevRegion.date_rows,
              swipes_by_date: { ...(prevRegion.swipes_by_date || {}), ...(newRegionObj.swipes_by_date || {}) },
            };

            // update (replace) employees: for each fetched employee, replace or insert into prevRegion.employees
            const prevEmployees = Array.isArray(prevRegion.employees) ? [...prevRegion.employees] : [];
            fetchedEmployees.forEach((fe) => {
              const idx = prevEmployees.findIndex((p) => {
                // match by person_uid if present else by EmployeeID
                if (p.person_uid && fe.person_uid) return p.person_uid === fe.person_uid;
                if (p.EmployeeID && fe.EmployeeID) return String(p.EmployeeID) === String(fe.EmployeeID);
                return false;
              });
              if (idx >= 0) {
                prevEmployees[idx] = fe;
              } else {
                // insert (keeping sort might be messy, so append)
                prevEmployees.push(fe);
              }
            });

            mergedRegion.employees = prevEmployees;
            next.regions[region] = mergedRegion;
            return next;
          } catch (e) {
            // fallback: set full response
            console.error("Failed to merge employee data:", e);
            return resp;
          }
        });
      } catch (err) {
        console.error("fetchAndMergeEmployee failed:", err);
      }
    },
    [region, startDate, endDate, singleDate, useRange]
  );

  // derive current region object quickly
  const regionObj = useMemo(() => {
    if (!data || !region) return null;
    return data.regions?.[region] || null;
  }, [data, region]);

  // helpers to compute week starts from regionObj.dates
  const computeWeekStarts = (datesIso) => {
    if (!datesIso || datesIso.length === 0) return [];
    const dateObjs = datesIso.map((d) => new Date(d + "T00:00:00Z"));
    const weekStartSet = new Set();
    dateObjs.forEach((dt) => {
      const day = dt.getUTCDay();
      const diff = (day + 6) % 7; // shift so Monday is week start
      const monday = new Date(dt);
      monday.setUTCDate(dt.getUTCDate() - diff);
      weekStartSet.add(monday.toISOString().slice(0, 10));
    });
    return Array.from(weekStartSet).sort();
  };

  // --- CSV helpers (unchanged, kept local) ---
  const quote = (s) => `"${String(s ?? "").replace(/"/g, '""')}"`;

  const exportSummaryCsv = () => {
    if (!regionObj) return;
    const dates = regionObj.dates || [];
    const rows = regionObj.employees || [];

    const header = ["EmployeeID", "EmployeeName", "TotalSecondsPresentInRange", "DominantCategory", "ComplianceSummary", ...dates.map((d) => d)];
    const csvRows = [header.map((h) => quote(h)).join(",")];

    rows.forEach((r) => {
      const complianceText = r.compliance?.month_summary || "";
      const complianceCell = `'${complianceText}`; // force text in Excel
      const row = [
        quote(r.EmployeeID || ""),
        quote(r.EmployeeName || ""),
        r.total_seconds_present_in_range ?? "",
        quote(r.duration_categories?.dominant_category || ""),
        quote(complianceCell),
        ...dates.map((d) => quote(r.durations?.[d] ?? "")),
      ];
      csvRows.push(row.join(","));
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `duration_summary_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  const exportReportCsv = () => {
    if (!regionObj) return;
    const datesIso = regionObj.dates || [];
    const weekStarts = computeWeekStarts(datesIso);

    const baseHeader = ["Sr.No", "EmployeeID", "EmployeeName", "CardNumber", "PersonnelType", "PartitionName2", "TotalSecondsPresentInRange"];
    const perDayHeaders = [];
    weekStarts.forEach((ws) => {
      for (let i = 0; i < 7; i++) {
        const d = new Date(ws + "T00:00:00Z");
        d.setUTCDate(d.getUTCDate() + i);
        const iso = d.toISOString().slice(0, 10);
        perDayHeaders.push(isoToLongDateNoCommas(iso));
      }
    });
    const perWeekHeaders = weekStarts.map((ws) => `Week compliance ${ws}`);

    const header = [...baseHeader, ...perDayHeaders, ...perWeekHeaders, "DominantCategory", "ComplianceSummary"];
    const csvRows = [header.map((h) => quote(h)).join(",")];

    const rows = regionObj.employees || [];
    rows.forEach((r, idx) => {
      const srNo = idx + 1;
      const employeeId = r.EmployeeID ?? "";
      const employeeName = r.EmployeeName ?? "";
      const cardNumber = r.CardNumber ?? "";
      const personnelType = r.PersonnelType ?? r.PersonnelTypeName ?? "";
      const partition = r.PartitionName2 ?? "";
      const totalSeconds = r.total_seconds_present_in_range ?? "";

      const perDayVals = [];
      weekStarts.forEach((ws) => {
        for (let i = 0; i < 7; i++) {
          const d = new Date(ws + "T00:00:00Z");
          d.setUTCDate(d.getUTCDate() + i);
          const iso = d.toISOString().slice(0, 10);

          const wk = r.compliance && r.compliance.weeks ? r.compliance.weeks[ws] : null;
          let outVal = "0";

          if (wk && wk.dates && Object.prototype.hasOwnProperty.call(wk.dates, iso)) {
            const secs = wk.dates[iso];
            if (secs !== null && secs !== undefined) {
              outVal = r.durations && r.durations[iso] ? r.durations[iso] : secondsToHMS(secs);
            } else {
              outVal = "0";
            }
          } else if (r.durations && Object.prototype.hasOwnProperty.call(r.durations, iso) && r.durations[iso]) {
            outVal = r.durations[iso];
          } else if (r.durations_seconds && Object.prototype.hasOwnProperty.call(r.durations_seconds, iso) && r.durations_seconds[iso]) {
            outVal = secondsToHMS(r.durations_seconds[iso]);
          } else {
            outVal = "0";
          }

          perDayVals.push(outVal);
        }
      });

      const perWeekVals = weekStarts.map((ws) => {
        const wk = r.compliance && r.compliance.weeks ? r.compliance.weeks[ws] : null;
        return wk && wk.compliant ? "Yes" : "No";
      });

      const complianceText = r.compliance?.month_summary || "";
      const complianceCell = `'${complianceText}`;

      const row = [
        `${srNo}`,
        quote(employeeId),
        quote(employeeName),
        quote(cardNumber),
        quote(personnelType),
        quote(partition),
        `${totalSeconds}`,
        ...perDayVals.map((v) => quote(v)),
        ...perWeekVals.map((v) => quote(v)),
        quote(r.duration_categories?.dominant_category || ""),
        quote(complianceCell),
      ];

      csvRows.push(row.join(","));
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `duration_report_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  const exportSwipesCsv = () => {
    if (!regionObj) return;
    const swipesByDate = regionObj.swipes_by_date || {};
    const rows = [];
    Object.entries(swipesByDate).forEach(([d, arr]) => {
      arr.forEach((s) => {
        rows.push({
          Date: d,
          LocaleMessageTime: s.LocaleMessageTime || "",
          Swipe_Time: s.Swipe_Time || "",
          EmployeeID: s.EmployeeID || "",
          PersonGUID: s.PersonGUID || "",
          ObjectName1: s.ObjectName1 || "",
          Door: s.Door || "",
          PersonnelType: s.PersonnelType || "",
          CardNumber: s.CardNumber || "",
          PrimaryLocation: s.PrimaryLocation || s.Text5 || "",
          PartitionName2: s.PartitionName2 || "",
          AdmitCode: s.AdmitCode || "",
          Direction: s.Direction || "",
          CompanyName: s.CompanyName || "",
        });
      });
    });

    if (rows.length === 0) {
      alert("No swipe rows available for current selection to export.");
      return;
    }

    const headers = [
      "Date",
      "LocaleMessageTime",
      "Swipe_Time",
      "EmployeeID",
      "PersonGUID",
      "ObjectName1",
      "Door",
      "PersonnelType",
      "CardNumber",
      "PrimaryLocation",
      "PartitionName2",
      "AdmitCode",
      "Direction",
      "CompanyName",
    ];
    const csvRows = [headers.map((h) => quote(h)).join(",")];
    rows.forEach((r) => {
      const line = headers.map((h) => quote(r[h] ?? "")).join(",");
      csvRows.push(line);
    });

    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const filename = `swipes_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // Export selected employee's swipes
  const exportSelectedEmployeeSwipes = () => {
    if (!selectedSwipes || selectedSwipes.length === 0) {
      alert("No swipe records to export for selected employee.");
      return;
    }
    const headers = [
      "Date",
      "LocaleMessageTime",
      "Swipe_Time",
      "EmployeeID",
      "PersonGUID",
      "ObjectName1",
      "Door",
      "PersonnelType",
      "CardNumber",
      "PrimaryLocation",
      "PartitionName2",
      "AdmitCode",
      "Direction",
      "CompanyName",
      "DiffSeconds",
      "DiffHHMMSS"
    ];
    const csvRows = [headers.map((h) => quote(h)).join(",")];
    selectedSwipes.forEach((s) => {
      const obj = { ...s };
      const line = headers.map((h) => quote(obj[h] ?? "")).join(",");
      csvRows.push(line);
    });
    const blob = new Blob([csvRows.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const empId = selectedEmployee?.EmployeeID || "employee";
    const filename = `swipes_${empId}_${region}_${data?.start_date || ""}_to_${data?.end_date || ""}.csv`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // --- Render helpers ---
  const getFilteredRows = useCallback(() => {
    if (!regionObj) return [];
    const rows = regionObj.employees || [];
    return rows.filter((r) => {
      const matchesEmployeeId = !searchEmployeeId || String(r.EmployeeID || "").toLowerCase().includes(searchEmployeeId.toLowerCase());
      const matchesName = !searchEmployeeName || String(r.EmployeeName || "").toLowerCase().includes(searchEmployeeName.toLowerCase());
      const matchesCard = !searchCardNumber || String(r.CardNumber || "").toLowerCase().includes(searchCardNumber.toLowerCase());
      return matchesEmployeeId && matchesName && matchesCard;
    });
  }, [regionObj, searchEmployeeId, searchEmployeeName, searchCardNumber]);

  // compute diffs for selected swipes when opening dialog and attach diff meta


const openSwipeDialogFor = (emp) => {
  setSelectedEmployee(emp);
  const swipesByDate = regionObj?.swipes_by_date || {};
  const matches = [];
  Object.entries(swipesByDate).forEach(([d, arr]) => {
    arr.forEach((s) => {
      const matchByEmployeeId = emp.EmployeeID && s.EmployeeID && String(s.EmployeeID) === String(emp.EmployeeID);
      const matchByCard = emp.CardNumber && s.CardNumber && String(s.CardNumber) === String(emp.CardNumber);
      const matchByPersonGuid = emp.person_uid && s.PersonGUID && String(s.PersonGUID) === String(emp.person_uid);
      if (matchByEmployeeId || matchByCard || matchByPersonGuid) {
        matches.push({ ...s, Date: d });
      }
    });
  });
  matches.sort((a, b) => {
    const ta = a.LocaleMessageTime ? new Date(a.LocaleMessageTime).getTime() : 0;
    const tb = b.LocaleMessageTime ? new Date(b.LocaleMessageTime).getTime() : 0;
    return ta - tb;
  });

  // compute diffs (difference to previous swipe) and attach meta
  const withDiffs = matches.map((row, idx, arr) => {
    let diffSeconds = null;
    if (idx === 0) {
      diffSeconds = null;
    } else {
      const cur = row.LocaleMessageTime ? new Date(row.LocaleMessageTime).getTime() : null;
      const prev = arr[idx - 1].LocaleMessageTime ? new Date(arr[idx - 1].LocaleMessageTime).getTime() : null;
      if (cur != null && prev != null) {
        diffSeconds = Math.max(0, Math.floor((cur - prev) / 1000));
      } else {
        diffSeconds = null;
      }
    }
    return {
      ...row,
      DiffSeconds: diffSeconds,
      DiffHHMMSS: diffSeconds != null ? secondsToHMS(diffSeconds) : "-",
    };
  });

  setSelectedSwipes(withDiffs);

  // reset override state:
  const distinctDates = Array.from(new Set(withDiffs.map((m) => m.Date))).sort();
  // default override date remains the earliest swipe date (but will auto-change when start swipe chosen)
  setOverrideDate(distinctDates.length > 0 ? distinctDates[0] : "");
  setOverrideStartIndex(null);
  setOverrideEndIndex(null);
  setOverrideReason("");
  setSwipeDialogOpen(true);
};



  const computeOverrideDurationSeconds = () => {
    if (!selectedSwipes || selectedSwipes.length === 0) return 0;
    if (overrideStartIndex == null || overrideEndIndex == null) return 0;
    const sIdx = Math.min(overrideStartIndex, overrideEndIndex);
    const eIdx = Math.max(overrideStartIndex, overrideEndIndex);
    const s = selectedSwipes[sIdx];
    const e = selectedSwipes[eIdx];
    if (!s || !e) return 0;
    const sa = s.LocaleMessageTime ? new Date(s.LocaleMessageTime).getTime() : null;
    const eb = e.LocaleMessageTime ? new Date(e.LocaleMessageTime).getTime() : null;
    if (!sa || !eb) return 0;
    return Math.max(0, Math.floor((eb - sa) / 1000));
  };

  const applyOverride = async () => {
    if (!selectedEmployee) return;
    if (!overrideDate) {
      alert("Please select a date for the override.");
      return;
    }
    if (overrideStartIndex == null || overrideEndIndex == null) {
      alert("Please select both start and end swipe entries.");
      return;
    }
    const sIdx = Math.min(overrideStartIndex, overrideEndIndex);
    const eIdx = Math.max(overrideStartIndex, overrideEndIndex);
    const s = selectedSwipes[sIdx];
    const e = selectedSwipes[eIdx];
    if (!s || !e) {
      alert("Invalid swipe selection.");
      return;
    }
    const start_ts = s.LocaleMessageTime || s.Swipe_Time;
    const end_ts = e.LocaleMessageTime || e.Swipe_Time;
    if (!start_ts || !end_ts) {
      alert("Selected swipe rows do not have timestamps.");
      return;
    }
    const seconds = computeOverrideDurationSeconds();
    if (seconds <= 0) {
      if (!window.confirm("Computed duration is 0. Do you still want to apply the override?")) {
        return;
      }
    }

    setOverrideApplying(true);
    try {
      await axios.post(`${API_BASE}/duration/override`, {
        region,
        person_uid: selectedEmployee.person_uid,
        date: overrideDate,
        start_ts: start_ts,
        end_ts: end_ts,
        reason: overrideReason,
        user: "frontend_user"
      }, { timeout: 30000 });

      // Instead of refreshing whole UI, fetch only the updated employee and merge
      await fetchAndMergeEmployee({ employeeId: selectedEmployee.EmployeeID, person_uid: selectedEmployee.person_uid });

      setSwipeDialogOpen(false);
      alert("Override applied — updated employee refreshed.");
    } catch (err) {
      console.error("Failed to apply override:", err);
      alert("Failed to apply override: " + (err?.response?.data?.detail || err.message || "unknown"));
    } finally {
      setOverrideApplying(false);
    }
  };


const renderSwipeSelectionControls = () => {
  if (!selectedSwipes || selectedSwipes.length === 0) return null;

  // distinct dates for the override-date dropdown
  const distinctDates = Array.from(new Set(selectedSwipes.map((m) => m.Date))).sort();

  // We'll present start/end selects which enumerate ALL swipe records (global index into selectedSwipes),
  // so user can pick start on one date and end on another.
  const swipesAll = selectedSwipes;

  return (
    <Box sx={{ mt: 2 }}>
      <Grid container spacing={2} alignItems="center">
        <Grid item xs={12} md={4}>
          <FormControl fullWidth size="small">
            <InputLabel id="override-date-label">Date</InputLabel>
            <Select
              labelId="override-date-label"
              label="Date"
              value={overrideDate}
              onChange={(e) => {
                setOverrideDate(e.target.value);
                // clear selections when changing date manually to avoid confusion
                setOverrideStartIndex(null);
                setOverrideEndIndex(null);
              }}
            >
              {distinctDates.map((d) => (
                <MenuItem key={d} value={d}>{isoToDDMMYYYY(d)}</MenuItem>
              ))}
            </Select>
          </FormControl>
        </Grid>

        <Grid item xs={12} md={4}>
          <FormControl fullWidth size="small">
            <InputLabel id="override-start-label">Start swipe</InputLabel>
            <Select
              labelId="override-start-label"
              label="Start swipe"
              value={overrideStartIndex == null ? "" : overrideStartIndex}
              onChange={(e) => {
                const val = e.target.value === "" ? null : Number(e.target.value);
                setOverrideStartIndex(val);
                // auto-set overrideDate to the start swipe's date (useful when spanning dates)
                if (val !== null && selectedSwipes[val] && selectedSwipes[val].Date) {
                  setOverrideDate(selectedSwipes[val].Date);
                }
                // clear end selection if it was before start (optional UX decision)
                if (overrideEndIndex !== null) {
                  // keep it — user can pick any end; we won't auto-clear to avoid annoyance
                }
              }}
            >
              <MenuItem value=""><em>None</em></MenuItem>
              {swipesAll.map((s, idx) => {
                const timeLabel = s.LocaleMessageTime ? new Date(s.LocaleMessageTime).toLocaleString() : s.Swipe_Time;
                return (
                  <MenuItem key={`start-${idx}`} value={idx}>
                    {s.Date} — {timeLabel} {s.Door ? `— ${s.Door}` : ""}
                  </MenuItem>
                );
              })}
            </Select>
          </FormControl>
        </Grid>

        <Grid item xs={12} md={4}>
          <FormControl fullWidth size="small">
            <InputLabel id="override-end-label">End swipe</InputLabel>
            <Select
              labelId="override-end-label"
              label="End swipe"
              value={overrideEndIndex == null ? "" : overrideEndIndex}
              onChange={(e) => {
                const val = e.target.value === "" ? null : Number(e.target.value);
                setOverrideEndIndex(val);
                // if overrideDate not set (rare), set to end swipe date for safety
                if (val !== null && (!overrideDate || overrideDate === "") && selectedSwipes[val] && selectedSwipes[val].Date) {
                  setOverrideDate(selectedSwipes[val].Date);
                }
              }}
            >
              <MenuItem value=""><em>None</em></MenuItem>
              {swipesAll.map((s, idx) => {
                const timeLabel = s.LocaleMessageTime ? new Date(s.LocaleMessageTime).toLocaleString() : s.Swipe_Time;
                return (
                  <MenuItem key={`end-${idx}`} value={idx}>
                    {s.Date} — {timeLabel} {s.Door ? `— ${s.Door}` : ""}
                  </MenuItem>
                );
              })}
            </Select>
          </FormControl>
        </Grid>

        <Grid item xs={12}>
          <TextField
            fullWidth
            size="small"
            label="Reason (optional)"
            value={overrideReason}
            onChange={(e) => setOverrideReason(e.target.value)}
          />
        </Grid>

        <Grid item xs={12} sx={{ display: "flex", gap: 1, justifyContent: "flex-end" }}>
          <Button
            variant="contained"
            onClick={applyOverride}
            disabled={overrideApplying || !overrideDate || overrideStartIndex == null || overrideEndIndex == null}
          >
            {overrideApplying ? "Applying..." : `Apply Override (${secondsToHMS(computeOverrideDurationSeconds())})`}
          </Button>
        </Grid>
      </Grid>

      <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: "block" }}>
        Tip: start and end swipe selectors now include all swipe records for this employee across the selected range — you can pick start on one date and end on another.
      </Typography>
    </Box>
  );
};



  const renderTable = () => {
    if (!regionObj) return <Typography>No data for selected region.</Typography>;

    const dates = regionObj.dates || [];
    const rows = getFilteredRows();

    const weekStarts = computeWeekStarts(dates);

    return (
      <TableContainer component={Paper} sx={{ mt: 2, width: "100%", overflowX: "auto", boxShadow: 2 }}>
        <Table size="small" stickyHeader sx={tableSx}>
          <TableHead>
            <TableRow>
              <TableCell><b>Sr.No</b></TableCell>
              <TableCell><b>EmployeeID</b></TableCell>
              <TableCell><b>EmployeeName</b></TableCell>
              <TableCell><b>CardNumber</b></TableCell>
              <TableCell><b>PersonnelType</b></TableCell>
              <TableCell><b>PartitionName2</b></TableCell>
              <TableCell align="right"><b>Total (hh:mm:ss)</b></TableCell>
              {dates.map((d) => (
                <TableCell key={d} align="center"><b>{isoToDDMMYYYY(d)}</b></TableCell>
              ))}
              {weekStarts.map((ws) => (
                <TableCell key={ws} align="center"><b>{`Week ${ws} compliant`}</b></TableCell>
              ))}
              <TableCell align="center"><b>Dominant Category</b></TableCell>
              <TableCell align="center"><b>Compliance (weeks met/total)</b></TableCell>
              <TableCell align="center"><b>View</b></TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {rows.length === 0 ? (
              <TableRow>
                <TableCell colSpan={9 + (regionObj.dates || []).length + weekStarts.length} align="center">No employees in the response.</TableCell>
              </TableRow>
            ) : (
              rows.map((r, idx) => (
                <TableRow key={r.person_uid || `${r.EmployeeID}-${r.EmployeeName}`}>
                  <TableCell>{idx + 1}</TableCell>
                  <TableCell>{r.EmployeeID || "-"}</TableCell>
                  <TableCell>{r.EmployeeName || "-"}</TableCell>
                  <TableCell>{r.CardNumber || "-"}</TableCell>
                  <TableCell>{r.PersonnelType || r.PersonnelTypeName || "-"}</TableCell>
                  <TableCell>{r.PartitionName2 || "-"}</TableCell>
                  <TableCell align="right">{secondsToHMS(r.total_seconds_present_in_range)}</TableCell>
                  {dates.map((d) => (
                    <TableCell key={d} align="center">{r.durations?.[d] ?? "-"}</TableCell>
                  ))}
                  {weekStarts.map((ws) => {
                    const wk = r.compliance && r.compliance.weeks ? r.compliance.weeks[ws] : null;
                    return <TableCell key={ws} align="center">{wk && wk.compliant ? "Yes" : "No"}</TableCell>;
                  })}
                  <TableCell align="center">
                    {r.duration_categories?.dominant_category || "-"}
                    {r.duration_categories?.red_flag > 0 ? " ⚠️" : ""}
                  </TableCell>
                  <TableCell align="center">{r.compliance?.month_summary || "-"}</TableCell>
                  <TableCell align="center">
                    <Tooltip title="View swipe records for this employee">
                      <Button size="small" variant="outlined" startIcon={<VisibilityIcon />} onClick={() => openSwipeDialogFor(r)}>
                        View
                      </Button>
                    </Tooltip>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </TableContainer>
    );
  };

  // --- JSX UI (top controls) ---
  return (
    <Box
      sx={{
        p: 3,
        width: "100%",
        maxWidth: "100vw",
        boxSizing: "border-box",
        background: "linear-gradient(180deg,rgb(37, 37, 37),rgb(16, 16, 15))",
        minHeight: "100vh",
      }}
    >
      <Box sx={{ display: "flex", justifyContent: "center", mb: 2 }}>
        <Box
          sx={{
            border: "3px solid #FFD700",
            background: "linear-gradient(90deg,#fffbe6,#fff7cc)",
            borderRadius: 2,
            px: 3,
            py: 1.2,
            width: { xs: "100%", sm: "70%", md: "50%" },
            textAlign: "center",
            boxShadow: 3,
          }}
        >
          <Typography variant="h5" sx={{ fontWeight: 800, color: "#333" }}>
            Duration Reports with Compliance & Category
          </Typography>
        </Box>
      </Box>

      <Grid container spacing={2}>
        <Grid item xs={12}>
          <Card elevation={3}>
            <CardContent>
              <Grid container spacing={2} alignItems="center">
                <Grid item xs={12} md={2}>
                  <FormControl fullWidth size="small">
                    <InputLabel id="region-select-label">Region</InputLabel>
                    <Select
                      labelId="region-select-label"
                      label="Region"
                      value={region}
                      onChange={(e) => setRegion(e.target.value)}
                    >
                      {REGIONS.map((r) => (
                        <MenuItem key={r.value} value={r.value}>{r.label}</MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>

                <Grid item xs={12} md={3}>
                  <FormControl fullWidth size="small">
                    <InputLabel id="city-select-label">City / Partition </InputLabel>
                    <Select
                      labelId="city-select-label"
                      label="City / Partition (optional)"
                      value={city}
                      onChange={(e) => setCity(e.target.value)}
                      renderValue={(v) => v || ""}
                    >
                      <MenuItem value=""><em>All</em></MenuItem>
                      {citiesForRegion && citiesForRegion.length > 0 ? (
                        citiesForRegion.map((c, idx) => (
                          <MenuItem key={idx} value={c}>{c}</MenuItem>
                        ))
                      ) : (
                        <MenuItem disabled value="">
                          No predefined cities (you can type in the input below instead)
                        </MenuItem>
                      )}
                    </Select>
                  </FormControl>
                  <TextField
                    fullWidth
                    size="small"
                    placeholder="Or type to override / fuzzy-match"
                    value={city}
                    onChange={(e) => setCity(e.target.value)}
                    sx={{ mt: 1 }}
                  />
                </Grid>

                <Grid item xs={12} md={5} sx={{ display: "flex", gap: 1, justifyContent: "flex-end", alignItems: "center" }}>
                  <Button
                    startIcon={<DateRangeIcon />}
                    variant={useRange ? "contained" : "outlined"}
                    onClick={() => setUseRange(true)}
                    color="warning"
                  >
                    Range
                  </Button>
                  <Button
                    startIcon={<DateRangeIcon />}
                    variant={!useRange ? "contained" : "outlined"}
                    onClick={() => setUseRange(false)}
                    color="warning"
                  >
                    Single Day
                  </Button>
                </Grid>

                {useRange ? (
                  <>
                    <Grid item xs={12} md={3}>
                      <FormControl fullWidth size="small">
                        <TextField
                          label="Start date"
                          type="date"
                          fullWidth
                          InputLabelProps={{ shrink: true }}
                           value={startDate}
                          onChange={(e) => setStartDate(e.target.value)}
                          size="small"
                          inputRef={startDateRef}
                          InputProps={{
                            endAdornment: (
                              <InputAdornment position="end">
                                <IconButton
                                  size="small"
                                  onClick={() => openNativeDatePicker(startDateRef)}
                                  sx={{ color: "#FFD700" }}
                                >
                                  <DateRangeIcon />
                                </IconButton>
                              </InputAdornment>
                            ),
                          }}
                          sx={{ bgcolor: "#30302e" }}
                        />
                      </FormControl>
                    </Grid>
                    <Grid item xs={12} md={3}>
                      <FormControl fullWidth size="small">
                        <TextField
                          label="End date"
                          type="date"
                          fullWidth
                          InputLabelProps={{ shrink: true }}
                          value={endDate}
                          onChange={(e) => setEndDate(e.target.value)}
                          size="small"
                          inputRef={endDateRef}
                          InputProps={{
                            endAdornment: (
                              <InputAdornment position="end">
                                <IconButton
                                  size="small"
                                  onClick={() => openNativeDatePicker(endDateRef)}
                                  sx={{ color: "#FFD700" }}
                                >
                                  <DateRangeIcon />
                                </IconButton>
                              </InputAdornment>
                            ),
                          }}
                          sx={{ bgcolor: "#30302e" }}
                        />
                      </FormControl>
                    </Grid>
                  </>
                ) : (
                  <Grid item xs={12} md={3}>
                    <FormControl fullWidth size="small">
                      <TextField
                        label="Date"
                        type="date"
                        fullWidth
                        InputLabelProps={{ shrink: true }}
                        value={singleDate}
                        onChange={(e) => setSingleDate(e.target.value)}
                        size="small"
                        inputRef={singleDateRef}
                        InputProps={{
                          endAdornment: (
                            <InputAdornment position="end">
                              <IconButton
                                size="small"
                                onClick={() => openNativeDatePicker(singleDateRef)}
                                sx={{ color: "#FFD700" }}
                              >
                                <DateRangeIcon />
                              </IconButton>
                            </InputAdornment>
                          ),
                        }}
                        sx={{ bgcolor: "transparent" }}
                      />
                    </FormControl>
                  </Grid>
                )}

                <Grid item xs={12} md={6} sx={{ display: "flex", gap: 1, alignItems: "center" }}>
                  <Button
                    variant="contained"
                    startIcon={<SearchIcon />}
                    onClick={() => fetchDurations()}
                    disabled={loading}
                    color="primary"
                  >
                    {loading ? "Loading..." : "Run"}
                  </Button>

                  <Button
                    variant="outlined"
                    startIcon={<ClearIcon />}
                    onClick={() => {
                      setStartDate("");
                      setEndDate("");
                      setSingleDate("");
                      setCity("");
                      setData(null);
                      setError("");
                      setSearchEmployeeId("");
                      setSearchEmployeeName("");
                      setSearchCardNumber("");
                    }}
                  >
                    Clear
                  </Button>

                  <Tooltip title="Export Summary CSV (per-person)">
                    <span>
                      <IconButton onClick={exportSummaryCsv} disabled={!regionObj || (regionObj.employees || []).length === 0}>
                        <DownloadIcon />
                      </IconButton>
                    </span>
                  </Tooltip>

                  <Tooltip title="Export full report (Sr.No, ... Compliance)">
                    <span>
                      <Button variant="contained" onClick={exportReportCsv} disabled={!regionObj || (regionObj.employees || []).length === 0}>
                        Export Report
                      </Button>
                    </span>
                  </Tooltip>

                  <Tooltip title="Export raw swipes for this region/date range">
                    <span>
                      <Button variant="outlined" onClick={exportSwipesCsv} disabled={!regionObj || Object.keys(regionObj.swipes_by_date || {}).length === 0}>
                        Export Swipes
                      </Button>
                    </span>
                  </Tooltip>
                </Grid>

                <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="Search Employee ID"
                    value={searchEmployeeId}
                    onChange={(e) => setSearchEmployeeId(e.target.value)}
                    size="small"
                    helperText="Type an ID and click Run to fetch only that employee (server-side filter)"
                  />
                </Grid>
                <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="Search Employee Name"
                    value={searchEmployeeName}
                    onChange={(e) => setSearchEmployeeName(e.target.value)}
                    size="small"
                    helperText="Type name and click Run to fetch only matching employees"
                  />
                </Grid>
                <Grid item xs={12} md={4}>
                  <TextField
                    fullWidth
                    label="Search Card Number"
                    value={searchCardNumber}
                    onChange={(e) => setSearchCardNumber(e.target.value)}
                    size="small"
                    helperText="Search card number (server-side filter)"
                  />
                </Grid>

              </Grid>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12}>
          <Paper sx={{ p: 2 }}>
            <Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
              <Typography variant="subtitle1" sx={{ fontWeight: 700 }}>
                {data ? `Showing ${region.toUpperCase()} — ${data.start_date} → ${data.end_date}` : "No results yet"}
              </Typography>
            </Box>

            {loading && (
              <Box sx={{ display: "flex", justifyContent: "center", py: 4 }}>
                <CircularProgress />
              </Box>
            )}

            {error && (
              <Typography color="error" sx={{ mt: 2 }}>
                {error}
              </Typography>
            )}

            {!loading && !error && (
              <Box sx={{ mt: 2 }}>
                {renderTable()}
              </Box>
            )}
          </Paper>
        </Grid>
      </Grid>

      {/* Swipe dialog */}
      <Dialog open={swipeDialogOpen} onClose={() => setSwipeDialogOpen(false)} fullWidth maxWidth="xl">
        <DialogTitle>
          Swipe records for: {selectedEmployee ? `${selectedEmployee.EmployeeID || ""} — ${selectedEmployee.EmployeeName || ""}` : ""}
        </DialogTitle>
        <DialogContent dividers>
          {selectedSwipes.length === 0 ? (
            <Typography>No swipe records found for this employee in the selected range.</Typography>
          ) : (
            <>
              <Table size="small" sx={dialogTableSx}>
                <TableHead>
                  <TableRow>
                    <TableCell><b>Date</b></TableCell>
                    <TableCell><b>Time (local)</b></TableCell>
                    <TableCell><b>Diff (hh:mm:ss)</b></TableCell>
                    <TableCell><b>Door</b></TableCell>
                    <TableCell><b>Direction</b></TableCell>
                    <TableCell><b>CardNumber</b></TableCell>
                    <TableCell><b>PersonnelType</b></TableCell>
                    <TableCell><b>Partition</b></TableCell>
                    <TableCell><b>PrimaryLocation</b></TableCell>
                    <TableCell><b>Company</b></TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {selectedSwipes.map((s, i) => {
                    const isLargeGap = s.DiffSeconds != null && s.DiffSeconds > SWIPE_DIFF_RED_THRESHOLD;
                    return (
                      <TableRow key={i} sx={isLargeGap ? { backgroundColor: "rgba(255,0,0,0.08)" } : {}}>
                        <TableCell>{s.Date}</TableCell>
                        <TableCell>{s.Swipe_Time ?? (s.LocaleMessageTime ? new Date(s.LocaleMessageTime).toLocaleString() : "-")}</TableCell>
                        <TableCell sx={isLargeGap ? { color: "red", fontWeight: 700 } : {}}>{s.DiffHHMMSS ?? "-"}</TableCell>
                        <TableCell>{s.Door || s.ObjectName1 || "-"}</TableCell>
                        <TableCell>{s.Direction || "-"}</TableCell>
                        <TableCell>{s.CardNumber || "-"}</TableCell>
                        <TableCell>{s.PersonnelType || "-"}</TableCell>
                        <TableCell>{s.PartitionName2 || "-"}</TableCell>
                        <TableCell>{s.PrimaryLocation || s.Text5 || "-"}</TableCell>
                        <TableCell>{s.CompanyName || "-"}</TableCell>
                      </TableRow>
                    );
                  })}
                </TableBody>
              </Table>

              {renderSwipeSelectionControls()}
            </>
          )}
        </DialogContent>
        <Divider />
        <Box sx={{ p: 1, display: "flex", justifyContent: "flex-end", gap: 1 }}>
          <Button onClick={() => exportSelectedEmployeeSwipes()} disabled={!selectedSwipes || selectedSwipes.length === 0}>Export Swipes</Button>
          <Button onClick={() => setSwipeDialogOpen(false)}>Close</Button>
        </Box>
      </Dialog>
    </Box>
  );
}










//Swapnil  include Euroc 

// src/pages/ReportsPage.jsx
import React, { useState } from 'react';
import {
  Box, FormControl, InputLabel, Select, OutlinedInput,
  Checkbox, ListItemText, MenuItem, Button,
  CircularProgress, Typography, TextField, Tabs, Tab, Grid, Paper, Drawer, IconButton, Divider, List, ListItem, ListItemIcon, Avatar, Collapse
} from '@mui/material';

import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import axios from 'axios';
import ExcelJS from 'exceljs';
import * as XLSX from 'xlsx';


import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import PlaceIcon from '@mui/icons-material/Place';
import PeopleIcon from '@mui/icons-material/People';
import DownloadIcon from '@mui/icons-material/CloudDownload';
import FilterListIcon from '@mui/icons-material/FilterList';
// Static lists
const EMPLOYEE_OPTIONS = [
  'Vainilaitis, Valdas',
  'Tomasevic, Kazimez',
  'Sesickis, Janas',
  'Valiunas, Sigitas'
];


const REGION_OPTIONS = ['global', 'apac', 'emea', 'laca', 'namer'];
const LOCATION_MAP = {
  apac: ['APAC.Default', 'JP.Tokyo', 'PH.Manila', 'MY.Kuala Lumpur'],
  emea: ['AUT.Vienna', 'DU.Abu Dhab', 'IE.Dublin', 'IT.Rome', 'LT.Vilnius', 'MA.Casablanca', 'RU.Moscow', 'UK.London', 'ES.Madrid'],
  laca: ['AR.Cordoba', 'CR.Costa Rica Partition', 'MX.Mexico City', 'PE.Lima', 'BR.Sao Paulo', 'PA.Panama City'],
  namer: ['US.NYC', 'US.FL.Miami', 'USA/Canada Default', 'US.CO.OBS'],
  global: [] // optional — location select will be disabled when global is chosen
};



function formatDisplayDate(date) {
  const d = new Date(date);
  const day = d.getDate();
  const suf = day % 10 === 1 && day !== 11 ? 'st'
    : day % 10 === 2 && day !== 12 ? 'nd'
      : day % 10 === 3 && day !== 13 ? 'rd' : 'th';
  const mon = d.toLocaleString('default', { month: 'long' });
  return `${day}${suf} ${mon} ${d.getFullYear()}`;
}



// helpers: format server-provided ISO as display strings (use UTC getters so Z times are treated as server wall-clock)
const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');

function formatDateFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  const y = dt.getUTCFullYear();
  const m = dt.getUTCMonth(); // 0..11
  const d = dt.getUTCDate();
  const yrShort = String(y).slice(-2);
  return `${pad2(d)}-${MONTH_ABBR[m]}-${yrShort}`;         // e.g. "12-Aug-25"
}

function formatTimeFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  let hh = dt.getUTCHours();   // use UTC parts so we trust server wall-clock
  const mm = dt.getUTCMinutes();
  const ss = dt.getUTCSeconds();
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1; // convert 0->12, 13->1 etc.
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;        // e.g. "12:01:24 AM"
}

// for DateOnly + Swipe_Time situation: build ISO string where date comes from DateOnly and time from Swipe_Time UTC
function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  // dateOnlyIso = "2025-08-12T00:00:00.000Z"
  // swipeIso = "1970-01-01T00:01:24.000Z" (time)
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10); // "YYYY-MM-DD"
  if (!swipeIso) {
    return `${datePart}T00:00:00.000Z`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000Z`;
  }
  // fallback if swipeIso is "HH:mm:ss"
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000Z`;
}




function formatShortRange(fromDate, toDate) {
  if (!fromDate || !toDate) return '';
  const f = formatDisplayDate(fromDate); // e.g. "1st August 2025"
  const t = formatDisplayDate(toDate);   // e.g. "13th August 2025"
  const [fDay, fMon, fYear] = f.split(' ');
  const [tDay, tMon, tYear] = t.split(' ');

  if (fMon === tMon && fYear === tYear) {
    return `${fDay} to ${tDay} ${fMon}`; // "1st to 13th August"
  }
  // different month or year -> show both months
  return `${fDay} ${fMon} to ${tDay} ${tMon}`;
}

// --- helper: build raw report filename per your rules ---

function buildRawFileName({ region, location, rawSearch, from, to }) {
  const shortRange = formatShortRange(from, to);
  const regionPart = (region || '').toUpperCase();
  const locPart = location ? `-${location.split('.').pop()}` : '';
  const prefix = rawSearch && rawSearch.toString().trim() ? `${rawSearch.toString().trim()} ` : '';
  // Keep "Raw report" text exactly as requested
  const base = `${regionPart}${locPart} Raw report ${shortRange}`;
  // sanitize for filesystem (remove problematic chars)
  const safeBase = base.replace(/[\/\\:\*\?"<>\|]+/g, '').replace(/\s+/g, ' ').trim();
  return `${prefix}${safeBase}.xlsx`;
}



export default function ReportsPage() {
  // --- state ---
  const [tab, setTab] = useState(0);

  const [region, setRegion] = useState('emea');
  const [location, setLocation] = useState('');
  const [from, setFrom] = useState(null);
  const [to, setTo] = useState(null);
  const [showFromCal, setShowFromCal] = useState(false);
  const [showToCal, setShowToCal] = useState(false);
  const [selectedEmps, setSelectedEmps] = useState([]);
  const [loading, setLoading] = useState(false);


    // helper — convert "YYYY-MM-DD..." (ISO) into a local midnight Date (avoids UTC shift)
  const isoDateOnlyToLocalDate = (iso) => {
    if (!iso) return null;
    const s = iso.toString().slice(0, 10);
    const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
    return new Date(y, m - 1, d);
  };


// Build a Date that preserves the server-provided wall-clock values.
// If swipeTime is an ISO (with Z), read UTC components and use them as local values.
const buildLocalDateFromDateOnlyAndSwipe = (dateOnly, swipeTime) => {
  if (!dateOnly) return null;

  // parse YYYY-MM-DD (first 10 chars)
  const dateStr = dateOnly.toString().slice(0, 10);
  const [yy, mm, dd] = dateStr.split('-').map(n => parseInt(n, 10));

  let hh = 0, min = 0, ss = 0;
  if (swipeTime) {
    const parsed = new Date(swipeTime);
    if (!isNaN(parsed.getTime())) {
      // Use UTC getters so we interpret the ISO(Z) as server wall-clock values
      hh = parsed.getUTCHours();
      min = parsed.getUTCMinutes();
      ss = parsed.getUTCSeconds();
    } else {
      // fallback to "HH:mm[:ss]" format parsing
      const parts = swipeTime.split(':').map(p => parseInt(p, 10));
      if (parts.length >= 2) {
        hh = parts[0] || 0;
        min = parts[1] || 0;
        ss = parts[2] || 0;
      }
    }
  }

  // Construct a local Date that has the same displayed Y/M/D HH:MM:SS as the server's values.
  return new Date(yy, mm - 1, dd, hh, min, ss);
};



// returns a server-wall-clock ISO for a row: prefer LocaleMessageTime, else DateOnly+Swipe_Time
const getServerISO = (r) => {
  if (!r) return '';
  if (r.LocaleMessageTime) return r.LocaleMessageTime;
  if (r.DateOnly) return buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  return '';
};

// returns YYYY-MM-DD for server wall-clock (used for filtering)
const getServerYMD = (r) => {
  const iso = getServerISO(r);
  if (!iso) return '';
  return iso.slice(0, 10); // "YYYY-MM-DD"
};



  // Handle tab switch (Daily / Raw / Rejection)
  const handleTabChange = (_, v) => {
    setTab(v);
    // reset all filters
    setRegion('emea');
    setLocation('');
    setFrom(null);
    setTo(null);
    setSelectedEmps([]);
  };



  /** Time Duration Excel generator */
  const generateTimeDurationExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Time Duration');

    // Title row
    ws.mergeCells('A1:M1');

ws.getCell('A1').value =
  `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
      
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };
    // Header row
    const headers = [
      'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
      'Partition', 'Text5', 'Year', 'Week', 'Date',
      'First Swipe', 'Last Swipe', 'Duration', 'Category',
      'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    // Columns widths
    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'ptype', width: 18 },
      { key: 'part', width: 15 },
      { key: 'txt5', width: 20 },
      { key: 'year', width: 8 },
      { key: 'week', width: 6 },
      { key: 'date', width: 12 },
      { key: 'first', width: 16 },
      { key: 'last', width: 16 },
      { key: 'dur', width: 10 },
      { key: 'cat', width: 12 },
      { key: 'dpw', width: 12 },
      { key: 'vdw', width: 14 },
      { key: 'cdw', width: 12 },
      { key: 'def', width: 10 }
    ];




    data.forEach((r, idx) => {
      const first = new Date(r.FirstSwipeTime);
      const last = new Date(r.LastSwipeTime);
      const date = new Date(r.ShiftedDate);
      const row = ws.addRow([
        idx + 1,
        r.ObjectName1,
        r.EmployeeID,
        r.PersonnelType,
        r.PartitionName2,
        r.text5,
        r.YearNumber,
        r.WeekNumber,
        date,
        first,
        last,
        r.DurationHHMM,
        r.TimeDiffCategory,
        r.DaysPresentInWeek,
        r.ViolationDaysInWeek,
        r.CleanDaysInWeek,
        r.Defaulter
      ]);

      // Date & time formatting
      row.getCell(9).numFmt = 'dd-mmm-yy';
      row.getCell(10).numFmt = 'h:mm:ss AM/PM';
      row.getCell(11).numFmt = 'h:mm:ss AM/PM';

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    ws.autoFilter = 'A2:Q2';

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

   const filename =
  `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;


    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };




  // // --- Excel for Daily Access (unchanged) ---
  
const generateDailyAccessExcel = async allRows => {
  const wb = new ExcelJS.Workbook();

  for (const emp of selectedEmps) {
    const ws = wb.addWorksheet(emp.substring(0, 31));
    const headers = [
      'Date', 'Time', 'Name', 'Contractor ID', 'Card No',
      'Door Name', 'Message Type', 'Partition', 'Swipe'
    ];
    ws.addRow(headers);
    const hdr = ws.getRow(1);
    hdr.font = { bold: true };
    hdr.alignment = { vertical: 'middle', horizontal: 'center' };
    hdr.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'date', width: 12 },
      { key: 'time', width: 12 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'card', width: 15 },
      { key: 'door', width: 40 },
      { key: 'msg', width: 15 },
      { key: 'part', width: 15 },
      { key: 'swipe', width: 10 }
    ];

    const rows = allRows.filter(r => r.ObjectName1 === emp);
    if (!rows.length) {
      ws.mergeCells('A2', 'I2');
      ws.getCell('A2').value = 'There is no swipe records found in Ccure';
      ws.getCell('A2').alignment = { horizontal: 'center' };
    } else {
      rows.forEach(r => {
        const iso = getServerISO(r); // server wall-clock ISO or ''
        const dateStr = iso ? formatDateFromServerISO(iso) : '';
        const timeStr = iso ? formatTimeFromServerISO(iso) : '';

        const row = ws.addRow([
          dateStr,
          timeStr,
          r.ObjectName1 || '',
          r.EmployeeID || '',
          r.CardNumber || '',
          r.Door || r.ObjectName2 || '',
          r.AdmitCode || r.Messagetype || '',
          r.location || '',
          r.Swipe || r.Direction || ''
        ]);

        // treat them as strings to preserve server wall-clock display
        row.getCell(1).alignment = { horizontal: 'left' };
        row.getCell(2).alignment = { horizontal: 'left' };

        row.eachCell(c => {
          c.border = {
            top: { style: 'thin' }, left: { style: 'thin' },
            bottom: { style: 'thin' }, right: { style: 'thin' }
          };
          c.alignment = { vertical: 'middle', horizontal: 'left' };
        });
      });
    }
    ws.autoFilter = 'A1:I1';
  }

  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const filename = `Daily Access Report(${formatDisplayDate(from)} to ${formatDisplayDate(to)}).xlsx`;
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
};


  // // --- Excel for Rejection (unchanged except UTC->local fix) ---

const generateRejectionExcel = async data => {
  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Rejection');

  const title = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}`;
  ws.mergeCells('A1:J1');
  ws.getCell('A1').value = title;
  ws.getCell('A1').font = { bold: true, size: 14 };
  ws.getCell('A1').alignment = { horizontal: 'center' };

  const headers = [
    'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
    'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
  ];
  const headerRow = ws.addRow(headers);
  headerRow.font = { bold: true };
  headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
  headerRow.eachCell(c => {
    c.border = {
      top: { style: 'thin' }, left: { style: 'thin' },
      bottom: { style: 'thin' }, right: { style: 'thin' }
    };
  });

  ws.columns = [
    { key: 'sr', width: 8 },
    { key: 'date', width: 12 },
    { key: 'time', width: 12 },
    { key: 'name', width: 25 },
    { key: 'id', width: 15 },
    { key: 'card', width: 15 },
    { key: 'type', width: 15 },
    { key: 'door', width: 40 },
    { key: 'loc', width: 15 },
    { key: 'swipe', width: 10 }
  ];

  data.forEach((r, idx) => {
    const iso = getServerISO(r);
    const dateStr = iso ? formatDateFromServerISO(iso) : '';
    const timeStr = iso ? formatTimeFromServerISO(iso) : '';

    const row = ws.addRow([
      idx + 1,
      dateStr,
      timeStr,
      r.ObjectName1 || '',
      r.EmployeeID || '',
      r.CardNumber || '',
      r.Rejection_Type || '',
      r.Door || r.ObjectName2 || '',
      r.location || '',
      r.Direction || r.Swipe || ''
    ]);

    row.getCell(2).alignment = { horizontal: 'left' };
    row.getCell(3).alignment = { horizontal: 'left' };

    row.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
      c.alignment = { vertical: 'middle', horizontal: 'left' };
    });
  });

  // Summary (unchanged but leaves numbers as numbers)
  const counts = data.reduce((a, r) => {
    const k = r.Rejection_Type || 'Unknown';
    a[k] = (a[k] || 0) + 1; return a;
  }, {});
  let rowIdx = 3;
  ws.getCell(rowIdx, 11).value = 'Rejection';
  ws.getCell(rowIdx, 12).value = 'Count';
  [11, 12].forEach(c => {
    const cell = ws.getCell(rowIdx, c);
    cell.font = { bold: true };
    cell.alignment = { horizontal: 'center' };
    cell.border = {
      top: { style: 'thin' }, left: { style: 'thin' },
      bottom: { style: 'thin' }, right: { style: 'thin' }
    };
  });
  rowIdx++;
  Object.entries(counts).forEach(([type, cnt]) => {
    ws.getCell(rowIdx, 11).value = type;
    ws.getCell(rowIdx, 12).value = cnt;
    [11, 12].forEach(c => {
      const cell = ws.getCell(rowIdx, c);
      cell.alignment = { horizontal: 'left' };
      cell.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });
    rowIdx++;
  });
  ws.getCell(rowIdx, 11).value = 'Total';
  ws.getCell(rowIdx, 12).value = data.length;
  [11, 12].forEach(c => {
    const cell = ws.getCell(rowIdx, c);
    cell.font = { bold: true };
    cell.alignment = { horizontal: 'left' };
    cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
  });

  // Download
  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const filename = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}.xlsx`;
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
};

  const [rawSearch, setRawSearch] = useState(''); // search string for Raw report (name or id)
  const [rawAdmitFilter, setRawAdmitFilter] = useState('all'); // 'all' | 'admit' | 'reject'




// generateRawExcel(rows, opts)
const generateRawExcel = async (rows, opts = {}) => {
  // helper: format time coming from Swipe_Time (handles ISO or "HH:mm[:ss]" fallback)
  const formatTimeFromSwipe = (swipeIso) => {
    if (!swipeIso) return '';
    // try ISO parse first
    const dt = new Date(swipeIso);
    if (!isNaN(dt.getTime())) {
      return formatTimeFromServerISO(swipeIso);
    }
    // fallback: parse "HH:mm" or "HH:mm:ss"
    const parts = ('' + swipeIso).split(':').map(p => parseInt(p || 0, 10));
    const hh = parts[0] || 0;
    const mm = parts[1] || 0;
    const ss = parts[2] || 0;
    const ampm = hh >= 12 ? 'PM' : 'AM';
    const hh12 = ((hh + 11) % 12) + 1;
    return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
  };

  // determine which columns to include based on filter
  const admitFilter = (opts.rawAdmitFilter || 'all').toString().toLowerCase(); // 'all'|'admit'|'reject'

  // base columns always present
  const baseHeaders = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber'];
  // conditional columns
  const admitCol = 'AdmitCode';
  const rejCol = 'Rejection_Type';
  // always include these at end
  const tailCols = ['Direction','Door'];

  // build final headers in requested order
  let headers = [...baseHeaders];
  if (admitFilter === 'all') {
    headers.push(admitCol);
    headers.push(...tailCols);
    headers.push(rejCol);
  } else if (admitFilter === 'admit') {
    // admitted only -> hide Rejection_Type
    headers.push(admitCol);
    headers.push(...tailCols);
  } else if (admitFilter === 'reject') {
    // rejected only -> hide AdmitCode
    headers.push(...tailCols);
    headers.push(rejCol);
  } else {
    // defensive fallback - include both
    headers.push(admitCol);
    headers.push(...tailCols);
    headers.push(rejCol);
  }

  if (!rows || !rows.length) {
    // fallback: write an empty workbook with dynamic headers
    const wbEmpty = XLSX.utils.book_new();
    const wsEmpty = XLSX.utils.aoa_to_sheet([headers]);
    XLSX.utils.book_append_sheet(wbEmpty, wsEmpty, 'Raw');
    const fileNameEmpty = buildRawFileName(opts);
    XLSX.writeFile(wbEmpty, fileNameEmpty);
    return;
  }

  // Build rows for sheet mapping only included headers
  const rowsForSheet = rows.map(r => {
    // Build server-wall-clock ISO for the row (LocaleMessageTime preferred)
    const iso = getServerISO(r); // LocaleMessageTime || DateOnly+Swipe_Time
    const dateStr = iso ? formatDateFromServerISO(iso) : '';
    const timeStr = iso ? formatTimeFromServerISO(iso) : '';
    const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');

    // Format DateOnly as DD-MMM-YY (if present), otherwise blank
    const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';

    // Format Swipe_Time as h:mm:ss AM/PM — handle ISO or HH:mm fallback
    const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

    // Build a full object then pick keys according to headers to control column inclusion order
    const fullObj = {
      LocaleMessageTime: localeMsgFormatted,
      DateOnly: dateOnlyFormatted,
      Swipe_Time: swipeTimeFormatted,
      EmployeeID: r.EmployeeID || '',
      ObjectName1: r.ObjectName1 || '',
      PersonnelType: r.PersonnelType || '',
      location: r.location || '',
      CardNumber: r.CardNumber || '',
      AdmitCode: r.AdmitCode || r.Messagetype || '',
      Direction: r.Direction || r.Swipe || '',
      Door: r.Door || r.ObjectName2 || '',
      Rejection_Type: r.Rejection_Type || ''
    };

    // pick only the requested headers
    const picked = {};
    headers.forEach(h => {
      // ensure we always provide a string/empty when key missing
      picked[h] = (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '';
    });
    return picked;
  });

  // create workbook/sheet with ordered headers
  const ws = XLSX.utils.json_to_sheet(rowsForSheet, { header: headers });
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Raw');

  // build filename per your examples
  const filename = buildRawFileName(opts);

  XLSX.writeFile(wb, filename);
};




const handleGenerate = async () => {
  setLoading(true);
  try {
    const baseParams = { region, location: location || undefined };

    // Helper: format dates in local time without timezone conversion for API parameters
    const formatLocalDate = (date, endOfDay = false) => {
      const d = new Date(date);
      if (endOfDay) d.setHours(23, 59, 59, 999);
      else d.setHours(0, 0, 0, 0);
      const pad = n => n.toString().padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}` +
             `T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    };

    // Helper: convert ISO date-only string (YYYY-MM-DD...) into a local midnight Date (avoids UTC shift)
    const isoDateOnlyToLocalDate = (iso) => {
      if (!iso) return null;
      const s = iso.toString().slice(0, 10); // YYYY-MM-DD
      const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
      return new Date(y, m - 1, d);
    };

    const pad2 = n => n.toString().padStart(2, '0');
    const toLocalYMD = date => `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`;




    // // // ----- 0: Daily Access -----
    if (tab === 0) {
      const params = {
        ...baseParams,
        from: formatLocalDate(from),
        to: formatLocalDate(to, true),
        employees: selectedEmps.join(',')
      };
      const resp = await axios.get('/api/reports/daily-access', { params });

      const startDate = new Date(from); startDate.setHours(8, 0, 0, 0);
      const endDate = new Date(to); endDate.setHours(8, 0, 0, 0);

      const rows = (resp.data && resp.data.data) || [];
      const filtered = rows.filter(r => {
        const dt = new Date(r.LocaleMessageTime);
        return dt >= startDate && dt < endDate;
      });

      await generateDailyAccessExcel(filtered);
      return;
    }


    // ----- 1: Raw -----
    if (tab === 1) {

const params = {
  ...baseParams,
  startDate: formatLocalDate(from),
  endDate: formatLocalDate(to, true),
  admitFilter: rawAdmitFilter  // <-- pass the UI value ('all'|'admit'|'reject')
};
const resp = await axios.get('/api/reports/raw', { params });
      const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

      const rowsSrc = (resp.data && resp.data.data) || [];
      const rows = rowsSrc.filter(r => {
        const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
        return date >= startDate && date <= endDate;
      });

      let filtered = rows;
      if (rawSearch && rawSearch.trim() !== '') {
        const s = rawSearch.trim().toLowerCase();
        filtered = rows.filter(r => {
          const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
          const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
          return id.includes(s) || name.includes(s);
        });
      }


// await generateRawExcel(filtered, { region, location, rawSearch, from, to });

await generateRawExcel(filtered, { region, location, rawSearch, from, to, rawAdmitFilter });


      return;
    }




    // ----- 2: Rejection -----
    if (tab === 2) {
      const params = { ...baseParams, startDate: formatLocalDate(from), endDate: formatLocalDate(to, true) };
      const resp = await axios.get('/api/reports/rejection', { params });

      const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

      const rowsSrc = (resp.data && resp.data.data) || [];
      const rows = rowsSrc.filter(r => {
        const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
        return date >= startDate && date <= endDate;
      });

      await generateRejectionExcel(rows);
      return;
    }

    // ----- 3: EUROC Admit-Reject (single day) -----
    if (tab === 3) {
      if (region.toLowerCase() !== 'emea') {
        alert('EUROC report is only available for region EMEA. Please select EMEA.');
        return;
      }
      if (!from) {
        alert('Please select a date (From) for EUROC report.');
        return;
      }

      const dateParam = toLocalYMD(new Date(from));
      const params = { region: 'emea', date: dateParam };
      const resp = await axios.get('/api/reports/euroc-admit-rejection', { params });
      const { data } = resp.data || {}; // { admit: [], rejection: [], summary: [] }

      const wb = new ExcelJS.Workbook();

      // Admit sheet
      const admitTitle = `EUROC Admit Report - ${formatDisplayDate(from)}`;
      const ws1 = wb.addWorksheet('EUROC Admit');
      ws1.mergeCells('A1:I1');
      ws1.getCell('A1').value = admitTitle;
      ws1.getCell('A1').font = { bold: true, size: 14 };
      ws1.getCell('A1').alignment = { horizontal: 'center' };

      const admitHeaders = [
        'Sr. No.', 'Date', 'Time', 'Employee Name',
        'Access Card No.', 'Personnel Type', 'Door Name', 'Location', 'Swipe'
      ];
      const hdrRow1 = ws1.addRow(admitHeaders);
      hdrRow1.font = { bold: true };
      hdrRow1.alignment = { vertical: 'middle', horizontal: 'center' };
      hdrRow1.eachCell(c => {
        c.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
      });

      ws1.columns = [
        { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
        { key:'name', width:30 }, { key:'card', width:15 }, { key:'ptype', width:20 },
        { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
      ];




(data.admit || []).forEach((r, idx) => {
  // Build an ISO that represents server wall-clock datetime (use LocaleMessageTime if provided)
  let iso;
  if (r.LocaleMessageTime) {
    iso = r.LocaleMessageTime; // already an ISO with Z
  } else if (r.DateOnly) {
    iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  } else {
    iso = '';
  }

  const dateStr = iso ? formatDateFromServerISO(iso) : '';
  const timeStr = iso ? formatTimeFromServerISO(iso) : '';

  // Insert formatted strings (not Date objects) — preserves exact server date/time
  const row = ws1.addRow([
    idx + 1,
    dateStr,
    timeStr,
    r.ObjectName1 || '',
    r.CardNumber || '',
    r.PersonnelType || '',
    r.Door || r.ObjectName2 || '',
    r.location || '',
    r.Direction || ''
  ]);

  // Keep formatting for header look — but DO NOT set numFmt expecting Excel date objects
  row.getCell(2).alignment = { horizontal: 'left' };
  row.getCell(3).alignment = { horizontal: 'left' };
  row.eachCell(c => {
    c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
    c.alignment = { vertical: 'middle', horizontal: 'left' };
  });
});


      // Rejection sheet
      const ws2 = wb.addWorksheet('EUROC Rejection');
      ws2.mergeCells('A1:J1');
      ws2.getCell('A1').value = `EUROC Rejection Report - ${formatDisplayDate(from)}`;
      ws2.getCell('A1').font = { bold: true, size: 14 };
      ws2.getCell('A1').alignment = { horizontal: 'center' };

      const headerRow2 = ws2.addRow(['Sr. No.', 'Date', 'Time', 'Employee Name', 'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe']);
      headerRow2.font = { bold: true };
      headerRow2.alignment = { vertical: 'middle', horizontal: 'center' };
      headerRow2.eachCell(c => {
        c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
      });

      ws2.columns = [
        { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
        { key:'name', width:30 }, { key:'card', width:15 }, { key:'type', width:15 },
        { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
      ];

(data.rejection || []).forEach((r, idx) => {
  let iso;
  if (r.LocaleMessageTime) {
    iso = r.LocaleMessageTime;
  } else if (r.DateOnly) {
    iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  } else {
    iso = '';
  }

  const dateStr = iso ? formatDateFromServerISO(iso) : '';
  const timeStr = iso ? formatTimeFromServerISO(iso) : '';

  const row = ws2.addRow([
    idx + 1,
    dateStr,
    timeStr,
    r.ObjectName1 || '',
    r.CardNumber || '',
    r.Rejection_Type || '',
    r.Door || '',
    r.location || '',
    r.Direction || ''
  ]);

  row.getCell(2).alignment = { horizontal: 'left' };
  row.getCell(3).alignment = { horizontal: 'left' };
  row.eachCell(c => {
    c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
    c.alignment = { vertical: 'middle', horizontal: 'left' };
  });
});




      // Summary block (same as before)
      const counts = data.summary || [];
      let startRow = 3;
      ws2.getCell(startRow, 11).value = 'Rejection';
      ws2.getCell(startRow, 12).value = 'Count';
      [11, 12].forEach(col => {
        const cell = ws2.getCell(startRow, col);
        cell.font = { bold: true };
        cell.alignment = { horizontal: 'center' };
        cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
      });
      startRow++;
      counts.forEach(c => {
        ws2.getCell(startRow, 11).value = c.Rejection_Type || 'Unknown';
        ws2.getCell(startRow, 12).value = c.Count || 0;
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.alignment = { horizontal: 'left' };
          cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });
        startRow++;
      });
      ws2.getCell(startRow, 11).value = 'Grand Total';
      ws2.getCell(startRow, 12).value = (data.rejection || []).length;
      [11, 12].forEach(col => {
        const cell = ws2.getCell(startRow, col);
        cell.font = { bold: true };
        cell.alignment = { horizontal: 'left' };
        cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
      });

      // Download workbook
      const buf = await wb.xlsx.writeBuffer();
      const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const filename = `EUROC_Admit_Rejection_${dateParam}.xlsx`;
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.click();
      return;
    }


    // ----- 4: Time Duration -----
if (tab === 4) {
  // require both start & end strictly
  if (!from || !to) {
    alert('Please select both Start Date and End Date for Time Duration report.');
    return;
  }
  const startParam = toLocalYMD(new Date(from));
  const endParam = toLocalYMD(new Date(to));
  const params = {
    region,
    startDate: startParam,
    endDate: endParam,
    partition: location ? location.split('.').pop() : 'Default'
  };
  const resp = await axios.get('/api/reports/time-duration', { params });
  await generateTimeDurationExcel(resp.data.data || []);
  return;
}



    // ----- 5: HeadCount / External navigation -----
    if (tab === 5) {
      let url = '';

      if (region === 'laca') {
        if (!location) url = 'http://10.199.22.57:3003/history';
        else {
          const LACA_URLS = {
            'CR.Costa Rica Partition': 'http://10.199.22.57:3003/partition/CR.Costa%20Rica%20Partition/history',
            'MX.Mexico City': 'http://10.199.22.57:3003/partition/MX.Mexico%20City/history',
            'AR.Cordoba': 'http://10.199.22.57:3003/partition/AR.Cordoba/history',
            'PA.Panama City': 'http://10.199.22.57:3003/partition/PA.Panama%20City/history',
            'PE.Lima': 'http://10.199.22.57:3003/partition/PE.Lima/history',
            'BR.Sao Paulo': 'http://10.199.22.57:3003/partition/BR.Sao%20Paulo/history'
          };
          url = LACA_URLS[location] || 'http://10.199.22.57:3003/history';
        }
      } else if (region === 'namer') {
        if (!location) url = 'http://10.199.22.57:3002/history';
        else {
          const NAMER_URLS = {
            'US.Denver': 'http://10.199.22.57:3002/partition/US.CO.OBS/history',
            'US.Miami': 'http://10.199.22.57:3002/partition/US.FL.Miami/history',
            'US.NYC': 'http://10.199.22.57:3002/partition/US.NYC/history',
            'US.Austin': 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default/history'
          };
          url = NAMER_URLS[location] || 'http://10.199.22.57:3002/history';
        }
      } else if (region === 'apac') {
        if (!location) url = 'http://10.199.22.57:3000/history';
        else {
          const APAC_URLS = {
            'APAC.Default': 'http://10.199.22.57:3000/partition/Pune/history',
            'MY.Kuala Lumpur': 'http://10.199.22.57:3000/partition/MY.Kuala Lumpur/history',
            'PH.Manila': 'http://10.199.22.57:3000/partition/PH.Manila/history',
            'JP.Tokyo': 'http://10.199.22.57:3000/history',
            'CN.Beijing': 'http://10.199.22.57:3000/history'
         
          };
          url = APAC_URLS[location] || 'http://10.199.22.57:3000/history';
        }
      } else if (region === 'emea') {
        if (!location) url = 'http://10.199.22.57:3001/history';
        else {
          const EMEA_URLS = {
            'AUT.Vienna': 'http://10.199.22.57:3001/history',
            'DU.Abu Dhabi': 'http://10.199.22.57:3001/history',
            'IE.Dublin': 'http://10.199.22.57:3001/history',
            'IT.Rome': 'http://10.199.22.57:3001/history',
            'LT.Vilnius': 'http://10.199.22.57:3001/history',
            'MA.Casablanca': 'http://10.199.22.57:3001/history',
            'RU.Moscow': 'http://10.199.22.57:3001/history',
            'UK.London': 'http://10.199.22.57:3001/history',
            'ES.Madrid': 'http://10.199.22.57:3001/history'
          };
          url = EMEA_URLS[location] || 'http://10.199.22.57:3001/history';
        }
      }

      if (url) window.location.href = url;
      else alert('Invalid region or location selected.');
      return;
    }

  } catch (err) {
    console.error(err);
    alert('Failed to generate report');
  } finally {
    setLoading(false);
  }
};





const disabled = loading
  || !region
  || (tab === 0 && (!from || !to || selectedEmps.length === 0)) // Daily Access
  || (tab === 1 && (!from || !to)) // Raw
  || (tab === 2 && (!from || !to)) // Rejection - require date range
  || (tab === 3 && !from) // EUROC (single day)
  || (tab === 4 && (!from || !to));


  // helper variable to keep navigation special-case consistent
  const navDisabled = !region || loading;


  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
        {/* Topbar / Header */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            px: 3,
            py: 2,
            borderBottom: '1px solid rgba(255,204,0,0.08)',
            background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
          }}
        >
          <Avatar sx={{ bgcolor: '#000', border: '3px solid #FFCC00', width: 56, height: 56 }}>
            <Typography sx={{ color: '#FFCC00', fontWeight: 900 }}>WU</Typography>
          </Avatar>

          <Box sx={{ flex: 1 }}>
            <Typography variant="h5" sx={{ fontWeight: 900, letterSpacing: 0.6 }}>
              Global Security Operation Center
            </Typography>
            <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
              Reports & Exports — Secure access, fast insights
            </Typography>
          </Box>

          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>



<Button
  startIcon={<DownloadIcon />}
  onClick={handleGenerate}
  // navigation special-case should be tab === 5 (HeadCount)
  disabled={tab === 5 ? navDisabled : disabled}
  sx={{
    bgcolor: '#FFCC00',
    color: '#000',
    fontWeight: 800,
    px: 3,
    py: 1,
    borderRadius: 3,
    boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
    transformOrigin: 'center',
    '&:hover': { bgcolor: '#ffd84d', transform: 'translateY(-2px)' }
  }}
>
  {loading ? 'Loading…'
           : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
</Button>
            
          </Box>
        </Box>

        {/* Main content: Sidebar + Content */}
        <Grid container sx={{ px: 3, py: 4 }} spacing={3}>
          {/* Sidebar */}
          <Grid item xs={12} md={3}>
            <Paper
              elevation={8}
              sx={{
                p: 2.5,
                borderRadius: 3,
                height: { xs: 'auto', md: 'calc(100vh - 150px)' },
                overflow: 'auto',
                background: 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015))',
                border: '1px solid rgba(255,204,0,0.06)'
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
                <Box>
                  <Typography variant="subtitle1" sx={{ fontWeight: 800, color: '#FFCC00' }}>Filters</Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Narrow down by region, date and employees
                  </Typography>
                </Box>
                <IconButton size="small" sx={{ color: '#FFCC00' }}>
                  <FilterListIcon />
                </IconButton>
              </Box>

              <Divider sx={{ my: 1, borderColor: 'rgba(255,204,0,0.06)' }} />

              {/* Region */}
              <Box sx={{ mt: 1 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Region</InputLabel>
                  <Select
                    value={region}
                    onChange={e => { setRegion(e.target.value); setLocation(''); }}
                    input={<OutlinedInput label="Region" />}
                    sx={{
                      color: '#fff',
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.24)' }
                    }}
                  >
                    {REGION_OPTIONS.map(r => <MenuItem key={r} value={r}>{r.toUpperCase()}</MenuItem>)}
                  </Select>
                </FormControl>
              </Box>

              {/* Location */}
              <Box sx={{ mt: 2 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Location</InputLabel>
                  <Select
                    value={location}
                    onChange={e => setLocation(e.target.value)}
                    input={<OutlinedInput label="Location" />}
                    disabled={!region}
                    sx={{
                      color: '#fff',
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                    }}
                  >
                    {(LOCATION_MAP[region] || []).map(loc => <MenuItem key={loc} value={loc}>{loc.split('.').pop()}</MenuItem>)}
                  </Select>
                </FormControl>
              </Box>

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />





              {/* Employee search (only for Raw tab) */}
              {/* {tab === 1 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employee (name or ID)
                  </Typography>
                  <TextField
                    fullWidth
                    placeholder="Type employee name or ID (e.g. 'Jejurkar' or '323471')"
                    label="Search Employee"
                    value={rawSearch}
                    onChange={(e) => setRawSearch(e.target.value)}
                    sx={{
                      '& .MuiInputBase-input': { color: '#fff' },
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                    }}
                    InputLabelProps={{ style: { color: '#FFCC00' } }}
                  />
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                    Leave empty to export all raw rows for the date range.
                  </Typography>
                </Box>
              )} */}





{tab === 1 && (
  <Box sx={{ mt: 2 }}>
    <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
      Employee (name or ID)
    </Typography>
    <TextField
      fullWidth
      placeholder="Type employee name or ID (e.g. 'Jejurkar' or '323471')"
      label="Search Employee"
      value={rawSearch}
      onChange={(e) => setRawSearch(e.target.value)}
      sx={{
        '& .MuiInputBase-input': { color: '#fff' },
        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
      }}
      InputLabelProps={{ style: { color: '#FFCC00' } }}
    />
    <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
      Leave empty to export all raw rows for the date range.
    </Typography>

    {/* --- NEW: Admit/Reject filter --- */}
    <Box sx={{ mt: 2 }}>
      <FormControl fullWidth>
        <InputLabel sx={{ color: '#FFCC00' }}>Admit / Reject</InputLabel>
        <Select
          value={rawAdmitFilter}
          onChange={(e) => setRawAdmitFilter(e.target.value)}
          input={<OutlinedInput label="Admit / Reject" />}
          sx={{
            color: '#fff',
            '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
          }}
        >
          <MenuItem value="all">All (Admitted + Rejected)</MenuItem>
          <MenuItem value="admit">Admitted only</MenuItem>
          <MenuItem value="reject">Rejected only</MenuItem>
        </Select>
      </FormControl>
      <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
        Default = All.
      </Typography>
    </Box>
  </Box>
)}


              {/* Dates */}
              {tab !== 5 && (
                <Box>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Date Range
                  </Typography>
                  <Box sx={{ display: 'grid', gap: 1.25 }}>
                    <TextField
                      label={tab === 0 ? 'From Date' : 'Start Date'}
                      value={from ? from.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowFromCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                    <TextField
                      label={tab === 0 ? 'To Date' : 'End Date'}
                      value={to ? to.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowToCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                  </Box>

                  {/* Static pickers (keeps your existing state handlers) */}
                  {showFromCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={from}
                        onChange={(newValue) => setFrom(newValue)}
                        onAccept={() => setShowFromCal(false)}
                        onClose={() => setShowFromCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                  {showToCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={to}
                        onChange={(newValue) => setTo(newValue)}
                        onAccept={() => setShowToCal(false)}
                        onClose={() => setShowToCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                </Box>
              )}

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />

              {/* Employees (only Daily) */}
              {tab === 0 && (
                <Box>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employees
                  </Typography>
                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Employees</InputLabel>
                    <Select
                      multiple
                      value={selectedEmps}
                      onChange={e => setSelectedEmps(e.target.value)}
                      input={<OutlinedInput label="Employees" />}
                      renderValue={vals => vals.join(', ')}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                      }}
                    >
                      {EMPLOYEE_OPTIONS.map(n => (
                        <MenuItem key={n} value={n}>
                          <Checkbox checked={selectedEmps.includes(n)} />
                          <ListItemText primary={n} />
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              )}

              {/* Helpful hint */}
              <Box sx={{ mt: 3, p: 2, borderRadius: 2, background: 'rgba(255,255,255,0.02)' }}>
                <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                  Tip: For daily exports pick employees & a single day range. For Time Duration choose the required partition via Location.
                </Typography>
              </Box>
            </Paper>
          </Grid>

          {/* Main panel */}
          <Grid item xs={12} md={9}>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              {/* Tabs (visual only) */}
              <Paper
                elevation={3}
                sx={{
                  px: 2,
                  py: 1,
                  borderRadius: 2,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  gap: 2,
                  border: '1px solid rgba(255,204,0,0.04)'
                }}
              >
                <Tabs
                  value={tab}
                  onChange={handleTabChange}
                  sx={{
                    '& .MuiTab-root': {
                      textTransform: 'none',
                      minWidth: 120,
                      fontWeight: 700,
                      color: 'rgba(255,255,255,0.8)'
                    },
                    '& .Mui-selected': { color: '#FFCC00' }
                  }}
                >
                  <Tab icon={<CalendarTodayIcon />} label="Daily Access" />
                  <Tab icon={<PeopleIcon />} label="Raw" />
                  <Tab icon={<PlaceIcon />} label="Rejection" />
                  <Tab icon={<PeopleIcon />} label="EUROC Admit-Reject" />

                  <Tab icon={<CalendarTodayIcon />} label="Time Duration" />
                  <Tab icon={<PeopleIcon />} label="HeadCount" />

                </Tabs>

                <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                  <Button
                    variant="text"
                    startIcon={<FilterListIcon />}
                    sx={{ color: 'rgba(255,255,255,0.65)', textTransform: 'none' }}
                    onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}
                  >
                    Reset View
                  </Button>
                </Box>
              </Paper>

              {/* Action summary + CTA */}
              <Paper elevation={6} sx={{ p: 3, borderRadius: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 2 }}>
                <Box>
                  <Typography variant="h6" sx={{ fontWeight: 900 }}>Export Center</Typography>
                  <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                    Selected Region: <strong style={{ color: '#FFCC00' }}>{region.toUpperCase()}</strong> {location ? `• ${location.split('.').pop()}` : ''}
                  </Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Choose tab, select filters and export reports in Excel.
                  </Typography>
                </Box>

                <Box>

<Button
  startIcon={loading ? <CircularProgress size={20} /> : <DownloadIcon />}
  disabled={tab === 5 ? navDisabled : disabled}
  onClick={handleGenerate}

                    sx={{
                      bgcolor: '#FFCC00',
                      color: '#000',
                      fontWeight: 900,
                      px: 4,
                      py: 1,
                      borderRadius: 3,
                      boxShadow: '0 8px 30px rgba(255,204,0,0.22)',
                      '&:hover': { bgcolor: '#ffd84d', transform: 'translateY(-3px)' }
                    }}
                  >

                     {loading
    ? 'Loading…'
    : (tab === 5
        ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`)
        : 'Export to Excel')}
</Button>

                </Box>
              </Paper>

            </Box>
          </Grid>

        </Grid>
      </Box>
    </LocalizationProvider>
  );

}








//C:\Users\W0024618\Desktop\global-page\frontend\src\App.jsx

import React from 'react';
import { Routes, Route, Navigate, Link } from 'react-router-dom';
import { Box, AppBar, Toolbar, Button } from '@mui/material';

import GlobalPage   from './pages/GlobalPage.jsx';
import VipPage      from './pages/VipPage.jsx';
import ReportsPage  from './pages/ReportsPage.jsx';
import DurationPage from "./pages/DurationPage";

export default function App() {
  return (
    <>
      <Routes>
        <Route path="/"      element={<GlobalPage />} />
        <Route path="/vip"   element={<VipPage />} />
        <Route path="/reports" element={<ReportsPage />} />
        <Route path="*"      element={<Navigate to="/" replace />} />
        <Route path="/duration" element={<DurationPage />} />

      </Routes>
    </>
  );
}










// //C:\Users\W0024618\Desktop\global-page\frontend\src\main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';

// ✅ CssBaseline from @mui/material
import { CssBaseline } from '@mui/material';
// ✅ ThemeProvider from @mui/material/styles
import { ThemeProvider } from '@mui/material/styles';

import { createBrowserRouter, RouterProvider } from 'react-router-dom';
import App from './App.jsx';
import theme from './theme.js';  // our fixed theme.js

const router = createBrowserRouter(
  [{ path: '/*', element: <App /> }],
  {
    future: {
      v7_startTransition: true,
      v7_relativeSplatPath: true,
    },
  }
);

ReactDOM
  .createRoot(document.getElementById('root'))
  .render(
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <RouterProvider router={router} />
    </ThemeProvider>
  );












// frontend/vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

const BACKEND_PY_PORT = process.env.BACKEND_PORT || 8000;
const BACKEND_PY_HOST = `http://localhost:${BACKEND_PY_PORT}`; // Python (ccure)
const NODE_BACKEND = 'http://localhost:3008';                 // Node (headcount + other legacy endpoints)

export default defineConfig({
  plugins: [react()],
  publicDir: path.resolve(__dirname, '../public'),
  resolve: {
    alias: {
      // Do NOT alias @mui/material (let package resolution work normally)
      // Keep emotion aliases to avoid duplicate emotion runtime instances:
      '@emotion/react': path.resolve(__dirname, 'node_modules/@emotion/react'),
      '@emotion/styled': path.resolve(__dirname, 'node_modules/@emotion/styled'),
    },
    // Prevent duplicate copies of MUI / emotion being bundled
    dedupe: ['@mui/material', '@mui/system', '@mui/styled-engine', '@emotion/react']
  },
  optimizeDeps: {
    // help vite pre-bundle these so ESM exports resolve correctly
    include: [
      '@mui/material',
      '@mui/material/styles',
      '@mui/icons-material',
      '@emotion/react',
      '@emotion/styled'
    ]
  },
  server: {
    port: 5173,
    hmr: { overlay: false },
    proxy: {
      '/api/ccure': {
        target: BACKEND_PY_HOST,
        changeOrigin: true,
        secure: false,
        rewrite: (path) => path.replace(/^\/api/, ''),
        timeout: 120000
      },
      '/api': {
        target: NODE_BACKEND,
        changeOrigin: true,
        secure: false,
        timeout: 120000
      }
    }
  }
});



