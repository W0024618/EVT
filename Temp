  // ---------- helpers for Excel formatting ----------
  const HEADER_FILL = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFCCE8FF' } }; // light blue
  const THIN_BORDER = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
  const THICK_BORDER = { top: { style: 'thick' }, left: { style: 'thick' }, bottom: { style: 'thick' }, right: { style: 'thick' } };

  function hideGridLines(ws) {
    try {
      ws.views = [{ showGridLines: false }];
    } catch (e) { /* ignore */ }
  }

  function applyHeaderStyles(row) {
    row.eachCell(cell => {
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.fill = HEADER_FILL;
      cell.border = THICK_BORDER;
    });
  }

  function applyThinBordersToWorksheet(ws, headerRowIndex = 1) {
    ws.eachRow((row, rIdx) => {
      row.eachCell(cell => {
        // skip header row (we already applied thick border)
        if (rIdx === headerRowIndex) return;
        // ensure border exists
        cell.border = THIN_BORDER;
        if (!cell.alignment) cell.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });
  }

  function autosizeColumns(ws) {
    // simple heuristic: compute max text length per column
    const colCount = ws.columnCount || (ws._columns && ws._columns.length) || 0;
    for (let c = 1; c <= colCount; c++) {
      let maxLen = 10; // minimal
      ws.eachRow((row) => {
        const cell = row.getCell(c);
        const v = cell && cell.value !== undefined && cell.value !== null ? String(cell.value) : '';
        if (v.length > maxLen) maxLen = v.length;
      });
      // width heuristic: a little padding, cap to reasonable value
      const width = Math.min(60, Math.max(10, Math.ceil(maxLen * 1.2)));
      try {
        ws.getColumn(c).width = width;
      } catch (e) { /* ignore if impossible */ }
    }
  }
  // ---------- end helpers ----------











  const generateTimeDurationExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Time Duration');

    hideGridLines(ws);

    ws.mergeCells('A1:M1');
    ws.getCell('A1').value =
      `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center', vertical: 'middle' };
    ws.getRow(1).height = 22;

    const headers = [
      'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
      'Partition', 'Text5', 'Year', 'Week', 'Date',
      'First Swipe', 'Last Swipe', 'Duration', 'Category',
      'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
    ];
    const headerRow = ws.addRow(headers);
    applyHeaderStyles(headerRow);

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'ptype', width: 18 },
      { key: 'part', width: 15 },
      { key: 'txt5', width: 20 },
      { key: 'year', width: 8 },
      { key: 'week', width: 6 },
      { key: 'date', width: 12 },
      { key: 'first', width: 16 },
      { key: 'last', width: 16 },
      { key: 'dur', width: 10 },
      { key: 'cat', width: 12 },
      { key: 'dpw', width: 12 },
      { key: 'vdw', width: 14 },
      { key: 'cdw', width: 12 },
      { key: 'def', width: 10 }
    ];

    data.forEach((r, idx) => {
      const first = r.FirstSwipeTime ? new Date(r.FirstSwipeTime) : null;
      const last = r.LastSwipeTime ? new Date(r.LastSwipeTime) : null;
      const date = r.ShiftedDate ? new Date(r.ShiftedDate) : null;
      const row = ws.addRow([
        idx + 1,
        r.ObjectName1,
        r.EmployeeID,
        r.PersonnelType,
        r.PartitionName2,
        r.text5,
        r.YearNumber,
        r.WeekNumber,
        date,
        first,
        last,
        r.DurationHHMM,
        r.TimeDiffCategory,
        r.DaysPresentInWeek,
        r.ViolationDaysInWeek,
        r.CleanDaysInWeek,
        r.Defaulter
      ]);

      if (date) row.getCell(9).numFmt = 'dd-mmm-yy';
      if (first) row.getCell(10).numFmt = 'h:mm:ss AM/PM';
      if (last) row.getCell(11).numFmt = 'h:mm:ss AM/PM';

      row.eachCell(c => {
        c.border = THIN_BORDER;
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    // apply autosize
    autosizeColumns(ws);

    ws.autoFilter = 'A2:Q2';

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    const filename =
      `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;

    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };










  const generateRejectionExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Rejection');

    hideGridLines(ws);

    const title = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}`;
    ws.mergeCells('A1:J1');
    ws.getCell('A1').value = title;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center', vertical: 'middle' };
    ws.getRow(1).height = 22;

    const headers = [
      'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
      'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
    ];
    const headerRow = ws.addRow(headers);
    applyHeaderStyles(headerRow);

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'date', width: 12 },
      { key: 'time', width: 12 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'card', width: 15 },
      { key: 'type', width: 15 },
      { key: 'door', width: 40 },
      { key: 'loc', width: 15 },
      { key: 'swipe', width: 10 }
    ];

    data.forEach((r, idx) => {
      const iso = getServerISO(r);
      const dateStr = iso ? formatDateFromServerISO(iso) : '';
      const timeStr = iso ? formatTimeFromServerISO(iso) : '';

      const row = ws.addRow([
        idx + 1,
        dateStr,
        timeStr,
        r.ObjectName1 || '',
        r.EmployeeID || '',
        r.CardNumber || '',
        r.Rejection_Type || '',
        r.Door || r.ObjectName2 || '',
        r.location || '',
        r.Direction || r.Swipe || ''
      ]);

      row.eachCell(c => {
        c.border = THIN_BORDER;
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    // hide gridlines already done, autosize columns
    autosizeColumns(ws);

    // If there is no data, ensure at least header exists (we already did)
    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const filename = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}.xlsx`;
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };












  const generateRawExcel = async (rows, opts = {}) => {
    const formatTimeFromSwipe = (swipeIso) => {
      if (!swipeIso) return '';
      const dt = new Date(swipeIso);
      if (!isNaN(dt.getTime())) {
        return formatTimeFromServerISO(swipeIso);
      }
      const parts = ('' + swipeIso).split(':').map(p => parseInt(p || 0, 10));
      const hh = parts[0] || 0;
      const mm = parts[1] || 0;
      const ss = parts[2] || 0;
      const ampm = hh >= 12 ? 'PM' : 'AM';
      const hh12 = ((hh + 11) % 12) + 1;
      return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
    };

    const admitFilter = (opts.rawAdmitFilter || 'all').toString().toLowerCase();

    const baseHeaders = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber'];
    const admitCol = 'AdmitCode';
    const rejCol = 'Rejection_Type';
    const tailCols = ['Direction','Door'];

    let headers = [...baseHeaders];
    if (admitFilter === 'all') {
      headers.push(admitCol, ...tailCols, rejCol);
    } else if (admitFilter === 'admit') {
      headers.push(admitCol, ...tailCols);
    } else if (admitFilter === 'reject') {
      headers.push(...tailCols, rejCol);
    } else {
      headers.push(admitCol, ...tailCols, rejCol);
    }

    // If no rows, still create workbook with header row
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Raw');
    hideGridLines(ws);

    // header
    const hdr = ws.addRow(headers);
    applyHeaderStyles(hdr);

    if (rows && rows.length) {
      rows.forEach(r => {
        const iso = getServerISO(r);
        const dateStr = iso ? formatDateFromServerISO(iso) : '';
        const timeStr = iso ? formatTimeFromServerISO(iso) : '';
        const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');
        const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';
        const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

        const fullObj = {
          LocaleMessageTime: localeMsgFormatted,
          DateOnly: dateOnlyFormatted,
          Swipe_Time: swipeTimeFormatted,
          EmployeeID: r.EmployeeID || '',
          ObjectName1: r.ObjectName1 || '',
          PersonnelType: r.PersonnelType || '',
          location: r.location || '',
          CardNumber: r.CardNumber || '',
          AdmitCode: r.AdmitCode || r.Messagetype || '',
          Direction: r.Direction || r.Swipe || '',
          Door: r.Door || r.ObjectName2 || '',
          Rejection_Type: r.Rejection_Type || ''
        };

        const rowVals = headers.map(h => (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '');
        const added = ws.addRow(rowVals);
        added.eachCell(c => {
          c.border = THIN_BORDER;
          c.alignment = { vertical: 'middle', horizontal: 'left' };
        });
      });
    }

    // autosize
    autosizeColumns(ws);

    const filename = buildRawFileName(opts);
    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };













        // keep original EUROC Excel generation (same logic) but with formatting
        const wb = new ExcelJS.Workbook();

        // Admit sheet
        const admitTitle = `EUROC Admit Report - ${formatDisplayDate(from)}`;
        const ws1 = wb.addWorksheet('EUROC Admit');
        hideGridLines(ws1);
        ws1.mergeCells('A1:I1');
        ws1.getCell('A1').value = admitTitle;
        ws1.getCell('A1').font = { bold: true, size: 14 };
        ws1.getCell('A1').alignment = { horizontal: 'center', vertical: 'middle' };
        ws1.getRow(1).height = 22;

        const admitHeaders = [
          'Sr. No.', 'Date', 'Time', 'Employee Name',
          'Access Card No.', 'Personnel Type', 'Door Name', 'Location', 'Swipe'
        ];
        const hdrRow1 = ws1.addRow(admitHeaders);
        applyHeaderStyles(hdrRow1);

        ws1.columns = [
          { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
          { key:'name', width:30 }, { key:'card', width:15 }, { key:'ptype', width:20 },
          { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
        ];

        (data.admit || []).forEach((r, idx) => {
          let iso;
          if (r.LocaleMessageTime) {
            iso = r.LocaleMessageTime;
          } else if (r.DateOnly) {
            iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
          } else {
            iso = '';
          }

          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws1.addRow([
            idx + 1,
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.CardNumber || '',
            r.PersonnelType || '',
            r.Door || r.ObjectName2 || '',
            r.location || '',
            r.Direction || ''
          ]);

          row.eachCell(c => {
            c.border = THIN_BORDER;
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        autosizeColumns(ws1);

        // Rejection sheet
        const ws2 = wb.addWorksheet('EUROC Rejection');
        hideGridLines(ws2);
        ws2.mergeCells('A1:J1');
        ws2.getCell('A1').value = `EUROC Rejection Report - ${formatDisplayDate(from)}`;
        ws2.getCell('A1').font = { bold: true, size: 14 };
        ws2.getCell('A1').alignment = { horizontal: 'center', vertical: 'middle' };
        ws2.getRow(1).height = 22;

        const headerRow2 = ws2.addRow(['Sr. No.', 'Date', 'Time', 'Employee Name', 'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe']);
        applyHeaderStyles(headerRow2);

        ws2.columns = [
          { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
          { key:'name', width:30 }, { key:'card', width:15 }, { key:'type', width:15 },
          { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
        ];

        (data.rejection || []).forEach((r, idx) => {
          let iso;
          if (r.LocaleMessageTime) {
            iso = r.LocaleMessageTime;
          } else if (r.DateOnly) {
            iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
          } else {
            iso = '';
          }

          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws2.addRow([
            idx + 1,
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.CardNumber || '',
            r.Rejection_Type || '',
            r.Door || '',
            r.location || '',
            r.Direction || ''
          ]);

          row.eachCell(c => {
            c.border = THIN_BORDER;
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        autosizeColumns(ws2);

        // Summary block (placed to the right of columns)
        const counts = data.summary || [];
        let startRow = 3;
        ws2.getCell(startRow, 11).value = 'Rejection';
        ws2.getCell(startRow, 12).value = 'Count';
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.font = { bold: true };
          cell.alignment = { horizontal: 'center' };
          cell.border = THIN_BORDER;
          cell.fill = HEADER_FILL;
        });
        startRow++;
        counts.forEach(c => {
          ws2.getCell(startRow, 11).value = c.Rejection_Type || 'Unknown';
          ws2.getCell(startRow, 12).value = c.Count || 0;
          [11, 12].forEach(col => {
            const cell = ws2.getCell(startRow, col);
            cell.alignment = { horizontal: 'left' };
            cell.border = THIN_BORDER;
          });
          startRow++;
        });
        ws2.getCell(startRow, 11).value = 'Grand Total';
        ws2.getCell(startRow, 12).value = (data.rejection || []).length;
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.font = { bold: true };
          cell.alignment = { horizontal: 'left' };
          cell.border = THIN_BORDER;
        });

        const buf = await wb.xlsx.writeBuffer();
        const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const filename = `EUROC_Admit_Rejection_${dateParam}.xlsx`;
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        return;











