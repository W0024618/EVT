AS per Suggestion upadte both file step by step and share me Fully updated file so i can easily swap file each other ..
Dont make unnecessary changes ...


1) Frontend change — show image immediately (replace the big conditional image block)

Find the modal image block in your frontend (the big /* Improved modal image block — prefer ObjectID/GUID and try more fallbacks */ piece). Replace that entire conditional with this version — it shows an image immediately if we can compute a likely URL from modalRow, and still falls back to the existing resolution/verification attempts and the old fallback behavior:




{/* Modal image block — show ASAP using modalRow ids, then improve when modalDetails arrive */}
(() => {
  // helper: candidate image key names (same as before)
  const candidateImageKeys = ['imageUrl','image_url','ImageUrl','image','Image','img','imgUrl','ImagePath','Photo','PhotoUrl','EmployeePhoto','photo','photoUrl'];

  // pick first md (aggregated/raw) row if exists
  const md = (modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0])
            || (modalDetails && modalDetails.raw_swipes && modalDetails.raw_swipes[0])
            || {};

  // try to obtain an explicit image path from md first
  let imgPath = candidateImageKeys.map(k => (md && md[k]) ? md[k] : null).find(Boolean) || null;

  // if not present yet, use any image_url included in full record response (js.image_url -> set below in openEvidence)
  if (!imgPath && modalRow && modalRow.ImageUrl) {
    imgPath = modalRow.ImageUrl;
  }

  // Build ordered id candidates preferring modalRow
  const idCandidates = [];
  if (modalRow && modalRow.EmployeeID) idCandidates.push(String(modalRow.EmployeeID));
  if (modalRow && modalRow.person_uid) idCandidates.push(String(modalRow.person_uid));
  if (md && md.EmployeeID) idCandidates.push(String(md.EmployeeID));
  if (md && md.person_uid) idCandidates.push(String(md.person_uid));
  if (md && md.ObjectID) idCandidates.push(String(md.ObjectID));
  if (md && md.GUID) idCandidates.push(String(md.GUID));

  const uniqIds = idCandidates.filter((v, i) => v && idCandidates.indexOf(v) === i);

  // If still no explicit path, build a likely image endpoint from the top id candidate
  if (!imgPath && uniqIds.length) {
    imgPath = `/employee/${encodeURIComponent(uniqIds[0])}/image`;
  }

  if (imgPath) {
    const imgSrc = resolveApiImageUrl(imgPath) || imgPath;
    return (
      <img
        className="modal-image"
        src={imgSrc}
        alt={sanitizeName(modalRow) || "Employee image"}
        onLoad={(e) => { try { console.info("employee image loaded:", e.target.src); } catch(e){} }}
        onError={async (e) => {
          try {
            e.target.onerror = null;
            console.warn("image load failed for:", e.target.src);

            // cache-busted retry + API variants for all uniqIds
            const tryUrls = [];
            const original = e.target.src;
            tryUrls.push(original + (original.indexOf('?') === -1 ? '?cb=' + Date.now() : '&cb=' + Date.now()));
            uniqIds.forEach(id => {
              if (!id) return;
              const a = resolveApiImageUrl(`/api/employees/${encodeURIComponent(id)}/image`);
              const b = resolveApiImageUrl(`/employee/${encodeURIComponent(id)}/image`);
              if (a && tryUrls.indexOf(a) === -1) tryUrls.push(a);
              if (b && tryUrls.indexOf(b) === -1) tryUrls.push(b);
            });

            let found = null;
            for (const url of tryUrls) {
              try {
                const getr = await fetch(url, { method: 'GET', cache: 'no-store' });
                if (getr && getr.ok) {
                  const ct = (getr.headers.get('content-type') || '').toLowerCase();
                  if (ct.startsWith('image')) { found = url; break; }
                }
              } catch (err) { /* ignore */ }
            }

            if (found) {
              e.target.src = found + (found.indexOf('?') === -1 ? ('?cb=' + Date.now()) : ('&cb=' + Date.now()));
              return;
            }

            // final fallback SVG
            const svg = '<svg xmlns="http://www.w3.org/2000/svg" width="160" height="160"><rect fill="#eef2f7" width="100%" height="100%"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#64748b" font-size="18">No image</text></svg>';
            e.target.src = 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
          } catch (err) {
            try { e.target.style.display = 'none'; } catch (err2) {}
            console.error("image fallback error", err);
          }
        }}
      />
    );
  } else {
    // no id/path available -> simple placeholder (unchanged)
    return (
      <div className="modal-image-placeholder">
        <i className="bi bi-person-square"></i>
        <span>No image</span>
      </div>
    );
  }
})()







Why this fixes it: previously the image block was rendered only when modalDetails existed. That meant the UI waited for the heavy /record JSON to return before even trying to fetch the image. The change uses modalRow identifiers immediately to build /employee/<id>/image and starts the browser fetch instantly.




2) Frontend change — set ImageUrl and EmployeeEmail ASAP inside openEvidence

Edit your openEvidence function: after you receive js from /record?..., set a quick ImageUrl and update modalRow before you do other merging/processing. Insert this code (example shows where to place it — right after const js = await resp.json();):



    const js = await resp.json();

    // QUICK: set an explicit image_url if backend provided or build one from employee id
    const quickImageUrl = js.image_url || js.imageUrl || js.ImageUrl || null;
    const candidateId = (row && (row.EmployeeID || row.person_uid)) || null;
    const builtImage = quickImageUrl || (candidateId ? `/employee/${encodeURIComponent(candidateId)}/image` : null);

    // update modalRow immediately so UI renders email/image ASAP
    setModalRow(prev => Object.assign({}, prev || {}, {
      EmployeeEmail: prev && prev.EmployeeEmail ? prev.EmployeeEmail : (js.meta && (js.meta.email || js.meta.Email) ? (js.meta.email || js.meta.Email) : null),
      Email: prev && prev.Email ? prev.Email : (js.meta && (js.meta.email || js.meta.Email) ? (js.meta.email || js.meta.Email) : null),
      ImageUrl: builtImage || (prev && prev.ImageUrl) || null
    }));





Then your existing logic that extracts newEmail and cardNum can still run; this pre-populates email and image so the modal shows them quickly.




3) Backend: include personnel/email/image_url in /record response (recommended)

Right now /record returns aggregated_rows, raw_swipes, etc. Add personnel enrichment so the frontend doesn’t have to guess identifiers or trigger heavy repeated lookups. In your /record handler (in app.py), after you compute the aggregated_rows and before sending the JSON response, do something like:



# inside /record handler (pseudo-code)
from backend.employeeimage import get_personnel_info  # adjust import path as needed

# choose a candidate token to look up (EmployeeID, person_uid, CardNumber etc)
candidate = request.args.get('employee_id') or (aggregated_rows and aggregated_rows[0].get('EmployeeID')) or None
meta = {}
if candidate:
    try:
        pinfo = get_personnel_info(candidate) or {}
        meta['email'] = pinfo.get('Email') or pinfo.get('EmployeeEmail') or pinfo.get('EmailAddress') or None
        meta['objectid'] = pinfo.get('ObjectID') or None
        meta['guid'] = pinfo.get('GUID') or None
        # add convenient image_url for frontend
        if meta.get('objectid'):
            resp_json['image_url'] = f"/employee/{meta['objectid']}/image"
        elif meta.get('guid'):
            resp_json['image_url'] = f"/employee/{meta['guid']}/image"
        resp_json['meta'] = meta
    except Exception:
        pass





Why: frontend can then set modalRow.ImageUrl = js.image_url and EmployeeEmail = js.meta.email immediately and no guessing is necessary.



4) Backend improvement — cache get_personnel_info to stop repeated DB hits

Your logs show many repeated messages get_personnel_info: found ObjectID=... and multiple Connected to ACVSCore.... Add a simple in-memory cache with TTL in employeeimage.py so repeated calls for the same candidate during a single UI flow are cheap:

Add near top of employeeimage.py:




import time

# simple in-memory cache for personnel lookups
_personnel_cache = {}
_PERSONNEL_CACHE_TTL = int(os.getenv("PERSONNEL_CACHE_TTL", "300"))  # seconds



Wrap the start of get_personnel_info with a quick cache hit:



def get_personnel_info(candidate_identifier: object) -> Dict[str, Any]:
    out: Dict[str, Any] = {}
    if candidate_identifier is None:
        return out

    try:
        key = str(candidate_identifier).strip()
        if key:
            entry = _personnel_cache.get(key)
            if entry and (time.time() - entry['ts'] < _PERSONNEL_CACHE_TTL):
                return entry['val']
    except Exception:
        pass

    # ... existing DB logic here ...

    # before returning, cache the result
    try:
        if key:
            _personnel_cache[key] = {'ts': time.time(), 'val': out}
    except Exception:
        pass

    return out





Why: this drastically reduces repeated DB connections and logs when the UI opens the modal and tries image + personnel resolution multiple times.





5) Small UX suggestions (optional but recommended)
	•	Keep modalLoading spinner for the timeline area only; with the above changes the modal top (image/email) will look instant while timeline/files load.
	•	Consider adding a small loading spinner overlay inside the image container while the image is downloading (so users see that image is on the way).
	•	If you have a dedicated personnel micro-endpoint (e.g. /personnel/<id> returning name/email/objectid/guid), use that from the frontend on modal open to populate email faster (this is optional if you apply the /record enrichment).






