# # backend/app.py
# from flask import Flask, jsonify, request, send_from_directory,jsonify, send_file
# from datetime import datetime, timedelta, date
# from pathlib import Path
# import logging
# import pandas as pd
# import numpy as np
# import joblib
# import math
# import re
# import io
# import base64
# import os
# import difflib
# from io import BytesIO
# from flask import send_file  # add if not present
# from pathlib import Path
# from typing import Optional, List, Dict, Any
# from duration_report import REGION_CONFIG
# from datetime import date, timedelta, datetime
# from flask import jsonify, request
# import logging
# logging.basicConfig(level=logging.INFO)
# #from trend_runner import run_trend_for_date, build_monthly_training, OUTDIR
# from trend_runner import run_trend_for_date, build_monthly_training
# from config.door_zone import map_door_to_zone, BREAK_ZONES, OUT_OF_OFFICE_ZONE


# # app = Flask(__name__)

# OUTDIR = Path("./outputs")

# def _safe_read_csv(fp):
#     try:
#         return pd.read_csv(fp, parse_dates=['LocaleMessageTime'], low_memory=False)
#     except Exception:
#         try:
#             return pd.read_csv(fp, low_memory=False)
#         except Exception:
#             return pd.DataFrame()


# # ---------- Ensure outputs directory exists early (so OVERRIDES_FILE can be defined safely) ----------
# BASE_DIR = Path(__file__).parent.resolve()
# DEFAULT_OUTDIR = BASE_DIR / "outputs"
# DEFAULT_OUTDIR.mkdir(parents=True, exist_ok=True)

# OVERRIDES_FILE = DEFAULT_OUTDIR / "overrides.csv"


# def _load_overrides():
#     if not OVERRIDES_FILE.exists():
#         return {}
#     try:
#         df = pd.read_csv(OVERRIDES_FILE, dtype=str)
#         out = {}
#         for _, r in df.iterrows():
#             emp = str(r.get('EmployeeID') or r.get('person_uid') or '').strip()
#             if not emp:
#                 continue
#             out[emp] = {
#                 'level': str(r.get('OverrideLevel') or '').strip(),
#                 'reason': str(r.get('Reason') or '').strip(),
#                 'ts': str(r.get('Timestamp') or '').strip()
#             }
#         return out
#     except Exception:
#         logging.exception("Failed reading overrides file")
#         return {}

# def _save_override(employee_key, level, reason):
#     now = datetime.now().isoformat()
#     row = {'EmployeeID': employee_key, 'OverrideLevel': level, 'Reason': reason or '', 'Timestamp': now}
#     try:
#         if OVERRIDES_FILE.exists():
#             df = pd.read_csv(OVERRIDES_FILE, dtype=str)
#             # pandas.DataFrame.append is deprecated -> use concat
#             df = pd.concat([df, pd.DataFrame([row])], ignore_index=True)
#         else:
#             df = pd.DataFrame([row])
#         df.to_csv(OVERRIDES_FILE, index=False)
#         return True
#     except Exception:
#         logging.exception("Failed to save override")
#         return False

# def _slug_city(s):
#     """
#     Convert a city/site string into a safe slug: lowercase, alphanumeric+hyphen
#     """
#     if not s:
#         return ''
#     # Remove special chars, spaces to hyphens, lower
#     slug = re.sub(r'[^\w\s-]', '', str(s)).strip().lower()
#     slug = re.sub(r'[\s_]+', '-', slug)
#     return slug


# # --- Use REGION_CONFIG servers to talk to ACVSCore (no separate ACVSCORE_DB_CONFIG) ---
# # ODBC driver variable is already defined later: ODBC_DRIVER (safe to reference only at runtime)

# _acvscore_backoff = {"ts": None, "failed": False}
# _ACVSCORE_BACKOFF_SECONDS = 20

# def _get_acvscore_conn():
#     """
#     Try to connect to ACVSCore by reusing credentials from REGION_CONFIG.
#     Loops through REGION_CONFIG entries and attempts:
#       1) SQL auth (UID/PWD) to database "ACVSCore" using region server + credentials
#       2) If SQL auth fails on that server, try Trusted_Connection (Windows auth) as a fallback
#     If that fails, optionally attempt ACVSCORE_DB_CONFIG if defined (safe: checked via globals()).
#     Returns first successful pyodbc connection or None.
#     Implements a short backoff after recent failure to reduce log noise.
#     """
#     try:
#         import pyodbc
#     except Exception:
#         logging.exception("pyodbc not installed; ACVSCore lookups unavailable.")
#         return None

#     # basic backoff: skip attempts if we just failed recently
#     from datetime import datetime
#     now = datetime.now().timestamp()
#     last = _acvscore_backoff.get("ts")
#     if last and _acvscore_backoff.get("failed") and (now - last) < _ACVSCORE_BACKOFF_SECONDS:
#         logging.debug("Skipping ACVSCore connection attempt (backoff active).")
#         return None

#     # iterate region servers (use the same credentials defined in REGION_CONFIG)
#     tried = []
#     for region_key, rc in (REGION_CONFIG or {}).items():
#         server = rc.get("server")
#         user = rc.get("user")
#         pwd = rc.get("password")
#         if not server:
#             continue

#         # Try SQL auth first if credentials present
#         if user and pwd:
#             tried.append(f"{region_key}@{server}(sql)")
#             conn_str = (
#                 f"DRIVER={{{ODBC_DRIVER}}};"
#                 f"SERVER={server};DATABASE=ACVSCore;UID={user};PWD={pwd};"
#                 "TrustServerCertificate=Yes;"
#             )
#             try:
#                 conn = pyodbc.connect(conn_str, autocommit=True, timeout=5)
#                 logging.info("Connected to ACVSCore on server %s using REGION_CONFIG[%s] (sql auth).", server, region_key)
#                 _acvscore_backoff["ts"] = None
#                 _acvscore_backoff["failed"] = False
#                 return conn
#             except Exception as e:
#                 logging.debug("SQL auth to %s failed: %s", server, e)

#         # Try Trusted Connection fallback on same server
#         tried.append(f"{region_key}@{server}(trusted)")
#         conn_str_trusted = (
#             f"DRIVER={{{ODBC_DRIVER}}};"
#             f"SERVER={server};DATABASE=ACVSCore;Trusted_Connection=yes;"
#             "TrustServerCertificate=Yes;"
#         )
#         try:
#             conn = pyodbc.connect(conn_str_trusted, autocommit=True, timeout=5)
#             logging.info("Connected to ACVSCore on server %s using REGION_CONFIG[%s] (trusted connection).", server, region_key)
#             _acvscore_backoff["ts"] = None
#             _acvscore_backoff["failed"] = False
#             return conn
#         except Exception as e:
#             logging.debug("Trusted connection to %s failed: %s", server, e)
#             continue

#     # Fallback: if a global ACVSCORE_DB_CONFIG exists, try it (safe check)
#     try:
#         if 'ACVSCORE_DB_CONFIG' in globals() and isinstance(globals().get('ACVSCORE_DB_CONFIG'), dict):
#             cfg = globals().get('ACVSCORE_DB_CONFIG')
#             server = cfg.get('server')
#             user = cfg.get('user')
#             pwd = cfg.get('password')
#             database = cfg.get('database', 'ACVSCore')
#             tried.append(f"ACVSCORE_DB_CONFIG@{server}")
#             try:
#                 conn_str = (
#                     f"DRIVER={{{ODBC_DRIVER}}};"
#                     f"SERVER={server};DATABASE={database};UID={user};PWD={pwd};"
#                     "TrustServerCertificate=Yes;"
#                 )
#                 conn = pyodbc.connect(conn_str, autocommit=True, timeout=5)
#                 logging.info("Connected to ACVSCore using ACVSCORE_DB_CONFIG (%s).", server)
#                 _acvscore_backoff["ts"] = None
#                 _acvscore_backoff["failed"] = False
#                 return conn
#             except Exception as e:
#                 logging.debug("ACVSCORE_DB_CONFIG connection failed: %s", e)
#     except Exception:
#         # defensive: do not propagate any errors from fallback logic
#         logging.debug("ACVSCORE_DB_CONFIG fallback not available or failed.")

#     # record failure to backoff
#     _acvscore_backoff["ts"] = now
#     _acvscore_backoff["failed"] = True
#     logging.error("Failed to connect to ACVSCore using REGION_CONFIG servers. Tried: %s", tried)
#     return None


# # ODBC driver (keep existing env-based driver)
# ODBC_DRIVER = os.getenv("ODBC_DRIVER", "ODBC Driver 17 for SQL Server")

# MODELS_DIR = Path(__file__).parent / "models"
# _loaded_models = {}

# def load_model(name):
#     if name in _loaded_models:
#         return _loaded_models[name]
#     p = MODELS_DIR / f"{name}.joblib"
#     if not p.exists():
#         return None
#     data = joblib.load(p)
#     _loaded_models[name] = data
#     return data



# # def get_personnel_info(candidate_identifier: object) -> Dict[str, Any]:
# #     out: Dict[str, Any] = {}
# #     logging.info("get_personnel_info: lookup called with candidate_identifier=%s", candidate_identifier)
# #     if candidate_identifier is None:
# #         logging.debug("get_personnel_info: no candidate provided")
# #         return out
# #     conn = _get_acvscore_conn()
# #     if conn is None:
# #         logging.info("get_personnel_info: ACVSCore connection unavailable (skipping DB lookup)")
# #         return out
# #     try:
# #         cur = conn.cursor()
# #         sql = """
# #             SELECT TOP 1 ObjectID, GUID, Name, EmailAddress, ManagerEmail
# #             FROM ACVSCore.Access.Personnel
# #             WHERE
# #               (CAST(ObjectID AS NVARCHAR(200)) = ?)
# #               OR (GUID = ?)
# #               OR (CAST(Int1 AS NVARCHAR(200)) = ?)
# #               OR (Text12 = ?)
# #               OR (Name = ?)
# #             ORDER BY ObjectID DESC
# #         """
# #         cand = str(candidate_identifier).strip()
# #         params = (cand, cand, cand, cand, cand)
# #         cur.execute(sql, params)
# #         row = cur.fetchone()
# #         if row:
# #             # columns: ObjectID, GUID, Name, EmailAddress, ManagerEmail
# #             try:
# #                 out['ObjectID'] = row[0]
# #                 out['GUID'] = row[1]
# #                 out['Name'] = row[2]
# #                 # canonical email fields (provide aliases for downstream code)
# #                 email_val = row[3] if len(row) > 3 else None
# #                 out['EmailAddress'] = email_val or None
# #                 out['EmployeeEmail'] = email_val or None
# #                 out['Email'] = email_val or None
# #                 out['ManagerEmail'] = row[4] if len(row) > 4 else None
# #             except Exception:
# #                 # defensive assignment by index if tuple smaller
# #                 out = {
# #                     'ObjectID': row[0] if len(row) > 0 else None,
# #                     'GUID': row[1] if len(row) > 1 else None,
# #                     'Name': row[2] if len(row) > 2 else None,
# #                     'EmailAddress': row[3] if len(row) > 3 else None,
# #                     'EmployeeEmail': row[3] if len(row) > 3 else None,
# #                     'Email': row[3] if len(row) > 3 else None,
# #                     'ManagerEmail': row[4] if len(row) > 4 else None
# #                 }
# #             logging.info("get_personnel_info: found personnel row for candidate=%s -> ObjectID=%s Email=%s",
# #                          candidate_identifier, out.get('ObjectID'), out.get('EmailAddress'))
# #         else:
# #             logging.debug("get_personnel_info: no personnel row found for candidate=%s", candidate_identifier)
# #     except Exception:
# #         logging.exception("Failed personnel lookup for candidate: %s", candidate_identifier)
# #     finally:
# #         try:
# #             cur.close()
# #         except Exception:
# #             pass
# #         try:
# #             conn.close()
# #         except Exception:
# #             pass

# #     return out

# def get_personnel_info(candidate_identifier: object) -> Dict[str, Any]:
#     out: Dict[str, Any] = {}
#     logging.info("get_personnel_info: lookup called with candidate_identifier=%s", candidate_identifier)
#     if candidate_identifier is None:
#         logging.debug("get_personnel_info: no candidate provided")
#         return out
#     conn = _get_acvscore_conn()
#     if conn is None:
#         logging.info("get_personnel_info: ACVSCore connection unavailable (skipping DB lookup)")
#         return out
#     try:
#         cur = conn.cursor()
#         sql = """
#             SELECT TOP 1 ObjectID, GUID, Name, EmailAddress, ManagerEmail
#             FROM ACVSCore.Access.Personnel
#             WHERE
#               (CAST(ObjectID AS NVARCHAR(200)) = ?)
#               OR (GUID = ?)
#               OR (CAST(Int1 AS NVARCHAR(200)) = ?)
#               OR (Text12 = ?)
#               OR (Name = ?)
#             ORDER BY ObjectID DESC
#         """
#         cand = str(candidate_identifier).strip()
#         params = (cand, cand, cand, cand, cand)
#         cur.execute(sql, params)
#         row = cur.fetchone()
#         if row:
#             # columns: ObjectID, GUID, Name, EmailAddress, ManagerEmail
#             try:
#                 out['ObjectID'] = row[0]
#                 out['GUID'] = row[1]
#                 out['Name'] = row[2]
#                 # canonical email fields (provide aliases for downstream code)
#                 email_val = row[3] if len(row) > 3 else None
#                 out['EmailAddress'] = email_val or None
#                 out['EmployeeEmail'] = email_val or None
#                 out['Email'] = email_val or None
#                 out['ManagerEmail'] = row[4] if len(row) > 4 else None
#             except Exception:
#                 out = {
#                     'ObjectID': row[0] if len(row) > 0 else None,
#                     'GUID': row[1] if len(row) > 1 else None,
#                     'Name': row[2] if len(row) > 2 else None,
#                     'EmailAddress': row[3] if len(row) > 3 else None,
#                     'EmployeeEmail': row[3] if len(row) > 3 else None,
#                     'Email': row[3] if len(row) > 3 else None,
#                     'ManagerEmail': row[4] if len(row) > 4 else None
#                 }
#             logging.info("get_personnel_info: found personnel row for candidate=%s -> ObjectID=%s Email=%s",
#                          candidate_identifier, out.get('ObjectID'), out.get('EmailAddress'))
#         else:
#             logging.debug("get_personnel_info: no personnel row found for candidate=%s", candidate_identifier)
#     except Exception:
#         logging.exception("Failed personnel lookup for candidate: %s", candidate_identifier)
#     finally:
#         try:
#             cur.close()
#         except Exception:
#             pass
#         try:
#             conn.close()
#         except Exception:
#             pass

#     return out




# def get_person_image_bytes(parent_id) -> Optional[bytes]:
#     logging.info("get_person_image_bytes: lookup for ParentId=%s", parent_id)
#     # 1) try DB (as before) — keep behaviour if available
#     try:
#         conn = _get_acvscore_conn()
#         if conn is not None:
#             try:
#                 cur = conn.cursor()
#                 sql = """
#                     SELECT TOP 1 AI.Image
#                     FROM ACVSCore.Access.Images AI
#                     WHERE AI.ParentId = ?
#                       AND DATALENGTH(AI.Image) > 0
#                     ORDER BY AI.ObjectID DESC
#                 """
#                 cur.execute(sql, (str(parent_id),))
#                 row = cur.fetchone()
#                 if row and row[0] is not None:
#                     logging.info("get_person_image_bytes: image found in DB for ParentId=%s (len=%d)", parent_id, len(row[0]) if row[0] else 0)
#                     try:
#                         b = bytes(row[0])
#                         return b
#                     except Exception:
#                         return row[0]
#             except Exception:
#                 logging.exception("Failed to fetch image for ParentId=%s via DB", parent_id)
#             finally:
#                 try:
#                     cur.close()
#                 except Exception:
#                     pass
#                 try:
#                     conn.close()
#                 except Exception:
#                     pass
#     except Exception:
#         logging.debug("ACVSCore DB unavailable for image lookup; will try filesystem fallbacks for ParentId=%s", parent_id)

#     # 2) Try filesystem fallbacks under DEFAULT_OUTDIR (use typical file extensions)
#     try:
#         # ensure DEFAULT_OUTDIR exists and convert parent_id to safe filename
#         cand_ids = []
#         if parent_id is None:
#             return None
#         pid_raw = str(parent_id).strip()
#         # add raw and numeric-only variants
#         cand_ids.append(pid_raw)
#         try:
#             # if numeric-like, add int form
#             if '.' in pid_raw:
#                 f = float(pid_raw)
#                 if f.is_integer():
#                     cand_ids.append(str(int(f)))
#         except Exception:
#             pass
#         # also try stripped non-alphanumeric variants
#         cand_ids = list(dict.fromkeys(cand_ids))

#         for c in cand_ids:
#             for folder in (Path(DEFAULT_OUTDIR) / "images", Path(DEFAULT_OUTDIR), Path(".")):
#                 if not folder.exists():
#                     continue
#                 for ext in (".jpg", ".jpeg", ".png", ".bmp", ".gif", ".webp"):
#                     fp = folder / (f"{c}{ext}")
#                     logging.debug("get_person_image_bytes: checking path %s", fp)
#                     if fp.exists() and fp.is_file():
#                         logging.info("get_person_image_bytes: loaded image file %s", fp)
#                         try:
#                             return fp.read_bytes()
#                         except Exception:
#                             continue
#                 # also try files where parent_id might be part of filename
#                 for fp in folder.glob(f"*{c}*"):
#                     logging.debug("get_person_image_bytes: checking glob match %s", fp)
#                     if fp.is_file():
#                         try:
#                             b = fp.read_bytes()
#                             if b:
#                                 logging.info("get_person_image_bytes: loaded image via glob %s", fp)
#                                 return b
#                         except Exception:
#                             continue
#     except Exception:
#         logging.exception("Filesystem image lookup failed for ParentId=%s", parent_id)

#     # nothing found
#     return None


# # ---------- New route to serve employee image ----------
# # We'll import send_file later where used; define route after app created.

# # Try to enable CORS
# try:
#     from flask_cors import CORS
#     has_cors = True
# except Exception:
#     CORS = None
#     has_cors = False

# app = Flask(__name__, static_folder=None)
# if has_cors:
#     CORS(app)
# else:
#     logging.warning("flask_cors not available; continuing without CORS.")

# logging.basicConfig(level=logging.INFO)

# # send_file is needed for Excel responses
# from flask import send_file
# try:
#     # optional import; used for styling
#     from openpyxl import load_workbook
#     from openpyxl.styles import Font, Alignment, Border, Side
#     OPENPYXL_AVAILABLE = True
# except Exception:
#     OPENPYXL_AVAILABLE = False

# def _to_python_scalar(x):
#     """
#     Convert numpy/pandas scalar types to built-in Python types and
#     convert NaN-like values to None so JSON is safe.
#     """
#     try:
#         import pandas as _pd
#         if isinstance(x, _pd.Timestamp):
#             return x.to_pydatetime().isoformat()
#     except Exception:
#         pass

#     try:
#         import numpy as _np
#         if isinstance(x, _np.generic):
#             v = x.item()
#             if isinstance(v, float) and _np.isnan(v):
#                 return None
#             return v
#     except Exception:
#         pass

#     try:
#         if isinstance(x, float) and math.isnan(x):
#             return None
#     except Exception:
#         pass

#     if isinstance(x, (datetime,)):
#         return x.isoformat()
#     if isinstance(x, (bool, int, str, type(None), float)):
#         # convert floats NaN handled above
#         return x
#     try:
#         # fallback to string
#         return str(x)
#     except Exception:
#         return None


# _uuid_like_re = re.compile(r'^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$')

# def _looks_like_guid(s):
#     try:
#         if not s or not isinstance(s, str):
#             return False
#         s = s.strip()
#         return bool(_uuid_like_re.match(s)) or s.startswith('name:') or s.startswith('emp:') or s.startswith('uid:')
#     except Exception:
#         return False


# # Helper: format seconds to HH:MM:SS
# def format_seconds_to_hms(seconds):
#     try:
#         if seconds is None:
#             return None
#         # guard against floats and NaN
#         s = int(float(seconds))
#         if s < 0:
#             s = 0
#         hh = s // 3600
#         mm = (s % 3600) // 60
#         ss = s % 60
#         return f"{hh:02d}:{mm:02d}:{ss:02d}"
#     except Exception:
#         return None


# # Placeholder tokens (keep consistent with trend_runner expectations)
# _PLACEHOLDER_STRS = set(['', 'nan', 'na', 'n/a', '-', '—', '–', 'none', 'null'])

# def _is_placeholder_str(s: object) -> bool:
#     try:
#         if s is None:
#             return True
#         st = str(s).strip().lower()
#         return st in _PLACEHOLDER_STRS
#     except Exception:
#         return False


# _CARD_XML_RE = re.compile(r'<Card>([^<]+)</Card>', re.IGNORECASE | re.DOTALL)
# def _extract_card_from_xml_text(txt):
#     try:
#         if not txt or not isinstance(txt, str):
#             return None
#         m = _CARD_XML_RE.search(txt)
#         if m:
#             return m.group(1).strip()
#         m2 = re.search(r'CHUID.*?Card.*?[:=]\s*([0-9A-Za-z\-\_]+)', txt, re.IGNORECASE | re.DOTALL)
#         if m2:
#             return m2.group(1).strip()
#     except Exception:
#         pass
#     return None


# def _resolve_field_from_record(record: dict, candidate_tokens: list):
#     """
#     Search a single row `record` (dict) for likely columns listed in candidate_tokens.
#     Return first non-placeholder value found (converted to Python scalar), else None.
#     """
#     if record is None:
#         return None

#     # 1) exact key matches (case-sensitive & common casing)
#     for key in candidate_tokens:
#         if key in record:
#             v = record.get(key)
#             if v is None:
#                 continue
#             if isinstance(v, float) and math.isnan(v):
#                 continue
#             sval = str(v).strip()
#             if sval and not _is_placeholder_str(sval):
#                 return _to_python_scalar(v)

#     # 2) case-insensitive contains match
#     lower_keys = {k.lower(): k for k in record.keys()}
#     for tok in candidate_tokens:
#         tok_l = tok.lower()
#         for lk, orig_key in lower_keys.items():
#             if tok_l in lk:
#                 v = record.get(orig_key)
#                 if v is None:
#                     continue
#                 if isinstance(v, float) and math.isnan(v):
#                     continue
#                 sval = str(v).strip()
#                 if sval and not _is_placeholder_str(sval):
#                     return _to_python_scalar(v)

#     # 3) xml / value parsing fallback for CardNumber
#     card_like = any(tok.lower() in ('cardnumber', 'chuid', 'card') for tok in candidate_tokens)
#     if card_like:
#         for lk, orig_key in lower_keys.items():
#             if 'xml' in lk or 'xmlmessage' in lk or 'xml_msg' in lk or 'msg' in lk or 'value' == lk:
#                 v = record.get(orig_key)
#                 if v is None:
#                     continue
#                 try:
#                     txt = str(v)
#                     extracted = _extract_card_from_xml_text(txt)
#                     if extracted and not _is_placeholder_str(extracted):
#                         return _to_python_scalar(extracted)
#                 except Exception:
#                     continue

#     # 4) final fallback: first non-placeholder value
#     for k, v in record.items():
#         if v is None:
#             continue
#         if isinstance(v, float) and math.isnan(v):
#             continue
#         sval = str(v).strip()
#         if sval and not _is_placeholder_str(sval):
#             return _to_python_scalar(v)

#     return None


# def _clean_sample_df(df: pd.DataFrame, max_rows: int = 10):
#     """
#     Clean a dataframe for JSON output (convert NaN -> None, pandas types -> native, format datetimes).
#     """
#     if df is None or df.empty:
#         return []
#     df = df.copy()

#     # remove duplicate suffix columns
#     cols_to_fix = [c for c in df.columns if c.endswith('_x') or c.endswith('_y')]
#     for c in cols_to_fix:
#         base = c[:-2]
#         if base in df.columns:
#             try:
#                 df.drop(columns=[c], inplace=True)
#             except Exception:
#                 pass
#         else:
#             try:
#                 df.rename(columns={c: base}, inplace=True)
#             except Exception:
#                 pass

#     # Date normalization
#     if 'Date' in df.columns:
#         try:
#             df['Date'] = pd.to_datetime(df['Date'], errors='coerce').dt.date
#             df['Date'] = df['Date'].apply(lambda d: d.isoformat() if pd.notna(d) else None)
#         except Exception:
#             pass

#     # Datetime columns to ISO strings
#     for dtcol in ('FirstSwipe', 'LastSwipe', 'LocaleMessageTime'):
#         if dtcol in df.columns:
#             try:
#                 df[dtcol] = pd.to_datetime(df[dtcol], errors='coerce')
#                 df[dtcol] = df[dtcol].apply(lambda t: t.to_pydatetime().isoformat() if pd.notna(t) else None)
#             except Exception:
#                 try:
#                     df[dtcol] = df[dtcol].astype(str).replace('NaT', None)
#                 except Exception:
#                     pass

#     # Replace NaN/inf -> None
#     df = df.where(pd.notnull(df), None)

#     # Convert records to safe Python types
#     rows = df.head(max_rows).to_dict(orient='records')
#     cleaned = []
#     for r in rows:
#         out = {}
#         for k, v in r.items():
#             out[k] = _to_python_scalar(v)

#         # Typical fields
#         emp_name = out.get('EmployeeName')
#         emp_id = out.get('EmployeeID') or out.get('EmployeeIdentity')
#         person_uid = out.get('person_uid')

#         # ----- Schema-aware fallback resolution -----
#         if not emp_id:
#             emp_tokens = ['Int1', 'Text12', 'EmployeeID', 'empid', 'id']
#             resolved_emp = _resolve_field_from_record(r, emp_tokens)
#             if resolved_emp is not None:
#                 try:
#                     s = str(resolved_emp).strip()
#                     # remove trailing .0 for floats
#                     if '.' in s:
#                         f = float(s)
#                         if math.isfinite(f) and f.is_integer():
#                             s = str(int(f))
#                     if _looks_like_guid(s):
#                         out['EmployeeID'] = None
#                         emp_id = None
#                     else:
#                         out['EmployeeID'] = s
#                         emp_id = s
#                 except Exception:
#                     if _looks_like_guid(resolved_emp):
#                         out['EmployeeID'] = None
#                         emp_id = None
#                     else:
#                         out['EmployeeID'] = resolved_emp
#                         emp_id = resolved_emp

#         # Prefer Credential.CardNumber / CHUID / Card as CardNumber when missing — reject GUIDs/placeholders
#         if out.get('CardNumber') in (None, '', 'nan'):
#             card_tokens = ['CardNumber', 'CHUID', 'Card', 'card_no', 'cardnum']
#             resolved_card = _resolve_field_from_record(r, card_tokens)
#             if resolved_card is not None:
#                 try:
#                     cs = str(resolved_card).strip()
#                     if _looks_like_guid(cs) or _is_placeholder_str(cs):
#                         out['CardNumber'] = None
#                     else:
#                         out['CardNumber'] = cs
#                 except Exception:
#                     out['CardNumber'] = None

#         # final safety: ensure EmployeeID/CardNumber are not GUID-like tokens
#         if 'EmployeeID' in out and isinstance(out['EmployeeID'], str) and _looks_like_guid(out['EmployeeID']):
#             out['EmployeeID'] = None
#         if 'CardNumber' in out and isinstance(out['CardNumber'], str) and _looks_like_guid(out['CardNumber']):
#             out['CardNumber'] = None

#         # If EmployeeName empty or looks like a GUID, prefer EmployeeID (human id) over GUIDs
#         if (emp_name in (None, '', 'nan')) or (isinstance(emp_name, str) and _looks_like_guid(emp_name)):
#             if emp_id not in (None, '', 'nan') and not _looks_like_guid(emp_id):
#                 out['EmployeeName'] = str(emp_id)
#             else:
#                 out['EmployeeName'] = None

#         cleaned.append(out)
#     return cleaned

# # ----- Helpers added to match commented (Pune) file functionality but multi-city-aware -----

# def _replace_placeholder_strings(obj):
#     """
#     If obj is a DataFrame, replace known placeholder strings with None (NaN).
#     If obj is a scalar/string, return None for placeholder strings else return obj.
#     """
#     if obj is None:
#         return obj
#     try:
#         if isinstance(obj, pd.DataFrame):
#             df = obj.copy()
#             for col in df.columns:
#                 try:
#                     # Replace placeholder strings (case-insensitive)
#                     df[col] = df[col].apply(lambda x: None if _is_placeholder_str(x) else x)
#                 except Exception:
#                     continue
#             return df
#         else:
#             # scalar
#             return None if _is_placeholder_str(obj) else obj
#     except Exception:
#         return obj

# def _normalize_id_local(v):
#     """
#     Normalize an identifier for robust matching/counting:
#     - treat NaN/None/empty as None
#     - strip and convert float-like integers to integer strings
#     """
#     try:
#         if pd.isna(v):
#             return None
#     except Exception:
#         pass
#     if v is None:
#         return None
#     s = str(v).strip()
#     if s == '' or s.lower() == 'nan':
#         return None
#     try:
#         if '.' in s:
#             fv = float(s)
#             if math.isfinite(fv) and fv.is_integer():
#                 s = str(int(fv))
#     except Exception:
#         pass
#     return s





# def _find_swipe_files(outdir: Path, date_obj: Optional[date] = None, city_slug: Optional[str] = None):
#     """
#     Robust swipe-file discovery.
#     - Supports filenames like:
#         - swipes_YYYYMMDD.csv
#         - swipes_<city>_YYYYMMDD.csv
#         - <region>_swipes_YYYYMMDD.csv
#         - <region>_swipes_*.csv
#         - any file containing '_swipes_' or starting with 'swipes'
#         - fallback: any file that ends with _YYYYMMDD.csv
#     - If date_obj is None, returns recent files that look like swipe files.
#     - Returns list of Path objects sorted by mtime (newest first).
#     """
#     p = Path(outdir)
#     files_set = set()
#     try:
#         # Normalize city slug for matching
#         city_slug_l = (city_slug or "").lower().strip()

#         def add_glob(pattern):
#             try:
#                 for fp in p.glob(pattern):
#                     if fp.is_file():
#                         files_set.add(fp)
#             except Exception:
#                 pass

#         if date_obj is None:
#             # recent swipe-like files
#             add_glob("*_swipes_*.csv")        # region_swipes_YYYY or region_swipes_any.csv
#             add_glob("swipes_*.csv")         # swipes_YYYY or swipes_city_YYYY
#             add_glob("*swipes*.csv")         # permissive
#             add_glob("*_swipes.csv")
#             # also include any file that includes 'swipe' (some exporters use 'swipe' singular)
#             add_glob("*swipe*.csv")
#             # city-specific guesses
#             if city_slug_l:
#                 add_glob(f"*{city_slug_l}*_swipes_*.csv")
#                 add_glob(f"*{city_slug_l}*swipes*.csv")
#                 add_glob(f"*{city_slug_l}*.csv")
#         else:
#             target = date_obj.strftime("%Y%m%d")
#             # common patterns observed in pipeline
#             patterns = [
#                 f"*_{target}.csv",                 # anything ending _YYYYMMDD.csv
#                 f"*_swipes_{target}.csv",         # region_swipes_YYYYMMDD.csv or swipes_YYYYMMDD
#                 f"swipes*_{target}.csv",
#                 f"swipes_{target}.csv",
#                 f"*swipes*_{target}.csv",
#                 f"*{city_slug_l}*_{target}.csv",
#                 f"*{city_slug_l}*swipes*_{target}.csv",
#                 f"*{city_slug_l}_{target}.csv"
#             ]
#             for pat in patterns:
#                 add_glob(pat)

#         # final fallback: any CSV in folder that contains '_swipe' (case-insensitive)
#         try:
#             for fp in p.iterdir():
#                 if not fp.is_file():
#                     continue
#                 name = fp.name.lower()
#                 if ('_swipe' in name) or ('swipe' in name and name.endswith('.csv')):
#                     files_set.add(fp)
#         except Exception:
#             pass

#     except Exception:
#         logging.exception("Error while searching for swipe files in %s", outdir)

#     # sort by modification time (most recent first)
#     files = sorted(list(files_set), key=lambda f: f.stat().st_mtime if f.exists() else 0, reverse=True)
#     return files

# # -----------------------
# # Routes
# # -----------------------




# @app.route('/')
# def root():
#     return "Trend Analysis API — Multi-city"

# @app.route('/run', methods=['GET', 'POST'])
# def run_trend():
#     params = {}
#     if request.method == 'GET':
#         params = request.args.to_dict()
#     else:
#         if request.is_json:
#             params = request.get_json(force=True) or {}
#         else:
#             try:
#                 params = request.form.to_dict() or {}
#             except Exception:
#                 params = {}

#     date_str = (params.get('date') or params.get('Date') or '').strip() or None
#     start_str = (params.get('start') or params.get('Start') or '').strip() or None
#     end_str = (params.get('end') or params.get('End') or '').strip() or None

#     dates = []
#     try:
#         if date_str:
#             dt = datetime.strptime(date_str, "%Y-%m-%d").date()
#             dates = [dt]
#         elif start_str and end_str:
#             s = datetime.strptime(start_str, "%Y-%m-%d").date()
#             e = datetime.strptime(end_str, "%Y-%m-%d").date()
#             if e < s:
#                 return jsonify({"error":"end must be >= start"}), 400
#             cur = s
#             while cur <= e:
#                 dates.append(cur)
#                 cur = cur + timedelta(days=1)
#         else:
#             today = datetime.now().date()
#             yesterday = today - timedelta(days=1)
#             dates = [yesterday, today]
#     except Exception as e:
#         return jsonify({"error": f"Invalid date format: {e}"}), 400

#     regions_param = params.get('regions') or params.get('region') or ''
#     if regions_param:
#         regions = [r.strip().lower() for r in re.split(r'[;,|]', str(regions_param)) if r.strip()]
#     else:
#         try:
#             regions = [k.lower() for k in list(REGION_CONFIG.keys())]
#         except Exception:
#             regions = ['apac']

#     valid_regions = []
#     for r in regions:
#         if r in (REGION_CONFIG or {}):
#             valid_regions.append(r)
#         else:
#             logging.debug("Requested region '%s' not in REGION_CONFIG - skipping", r)
#     if not valid_regions:
#         valid_regions = [k.lower() for k in REGION_CONFIG.keys()] if REGION_CONFIG else ['apac']
#     params['_regions_to_run'] = valid_regions

#     city_param = params.get('city') or params.get('site') or params.get('site_name') or None
#     city_slug = _slug_city(city_param) if city_param else None
#     params['_city'] = city_slug

#     combined_rows = []
#     files = []

#     # ---------------------------
#     # Run trend for each requested date
#     # ---------------------------
#     for d in dates:
#         try:
#             if run_trend_for_date is None:
#                 raise RuntimeError("run_trend_for_date helper not available in trend_runner")
#             try:
#                 df = run_trend_for_date(d, regions=valid_regions, outdir=str(DEFAULT_OUTDIR), city=city_slug)
#             except TypeError:
#                 try:
#                     df = run_trend_for_date(d, outdir=str(DEFAULT_OUTDIR))
#                 except Exception:
#                     # Last-resort: try duration_report fallback if available
#                     try:
#                         from duration_report import run_for_date as _dr_run_for_date
#                         region_results = _dr_run_for_date(d, valid_regions, str(DEFAULT_OUTDIR), city_param)
#                         combined_list = []
#                         for rkey, res in (region_results or {}).items():
#                             try:
#                                 df_dur = res.get('durations')
#                                 if df_dur is not None and not df_dur.empty:
#                                     combined_list.append(df_dur)
#                             except Exception:
#                                 continue
#                         df = pd.concat(combined_list, ignore_index=True) if combined_list else pd.DataFrame()
#                     except Exception:
#                         raise
#         except Exception as e:
#             logging.exception("run_trend_for_date failed for %s", d)
#             return jsonify({"error": f"runner failed for {d}: {e}"}), 500

#         csv_path = DEFAULT_OUTDIR / f"trend_{city_slug}_{d.strftime('%Y%m%d')}.csv"
#         if csv_path.exists():
#             files.append(csv_path.name)

#         if df is None or (hasattr(df, 'empty') and df.empty):
#             continue

#         try:
#             df = _replace_placeholder_strings(df)
#         except Exception:
#             pass

#         if 'IsFlagged' not in df.columns:
#             df['IsFlagged'] = False
#         if 'Reasons' not in df.columns:
#             df['Reasons'] = None

#         combined_rows.append(df)

#     # *** Important: combine after loop to avoid UnboundLocalError and extra repeated concat inside loop ***
#     try:
#         combined_df = pd.concat(combined_rows, ignore_index=True) if combined_rows else pd.DataFrame()
#     except Exception:
#         combined_df = pd.DataFrame()

#     try:
#         if not combined_df.empty:
#             if 'person_uid' in combined_df.columns:
#                 raw_unique_person_uids = int(combined_df['person_uid'].dropna().astype(str).nunique())
#             elif 'EmployeeID' in combined_df.columns:
#                 raw_unique_person_uids = int(combined_df['EmployeeID'].dropna().astype(str).nunique())
#             else:
#                 raw_unique_person_uids = int(len(combined_df))
#         else:
#             raw_unique_person_uids = 0
#     except Exception:
#         raw_unique_person_uids = int(len(combined_df)) if combined_df is not None else 0

#     try:
#         if not combined_df.empty and 'IsFlagged' in combined_df.columns:
#             flagged_df = combined_df[combined_df['IsFlagged'] == True].copy()
#         else:
#             flagged_df = pd.DataFrame()
#     except Exception:
#         flagged_df = pd.DataFrame()

#     try:
#         analysis_count = int(raw_unique_person_uids)
#     except Exception:
#         analysis_count = int(len(combined_df)) if combined_df is not None else 0

#     try:
#         flagged_count = int(len(flagged_df))
#         flagged_rate_pct = float((flagged_count / analysis_count * 100.0) if analysis_count and analysis_count > 0 else 0.0)
#     except Exception:
#         flagged_count = int(len(flagged_df))
#         flagged_rate_pct = 0.0

#     try:
#         sample_source = flagged_df if not flagged_df.empty else combined_df
#         samples = _clean_sample_df(sample_source.head(10), max_rows=10) if sample_source is not None and not sample_source.empty else []
#     except Exception:
#         samples = []

#     resp = {
#         "start_date": dates[0].isoformat() if dates else None,
#         "end_date": dates[-1].isoformat() if dates else None,
#         "aggregated_rows_total_raw": int(len(combined_df)),
#         "aggregated_unique_persons": int(analysis_count),
#         "rows": int(analysis_count),
#         "flagged_rows": int(flagged_count),
#         "flagged_rate_percent": float(flagged_rate_pct),
#         "files": files,
#         "sample": (samples[:10] if isinstance(samples, list) else samples),
#         "reasons_count": {},
#         "risk_counts": {},
#         "flagged_persons": (samples if samples else []),
#         "_raw_unique_person_uids": int(raw_unique_person_uids),
#         "regions_run": params.get('_regions_to_run', []),
#         "city_used": city_slug
#     }

#     return jsonify(resp)



# @app.route('/latest', methods=['GET'])
# def latest_results():
#     city_param = request.args.get('city') or request.args.get('site') or 'pune'
#     city_slug = _slug_city(city_param)

#     p = Path(DEFAULT_OUTDIR)
#     csvs = sorted(p.glob(f"trend_{city_slug}_*.csv"), reverse=True)
#     if not csvs:
#         csvs = sorted(p.glob("trend_*.csv"), reverse=True)
#     if not csvs:
#         return jsonify({"error": "no outputs found"}), 404
#     latest = csvs[0]

#     start_date_iso = None
#     end_date_iso = None
#     try:
#         m = re.search(r'(\d{8})', latest.name)
#         if m:
#             ymd = m.group(1)
#             dt = datetime.strptime(ymd, "%Y%m%d").date()
#             start_date_iso = dt.isoformat()
#             end_date_iso = dt.isoformat()
#     except Exception:
#         start_date_iso = None
#         end_date_iso = None

#     try:
#         df = pd.read_csv(latest)
#     except Exception:
#         df = pd.read_csv(latest, dtype=str)

#     df = _replace_placeholder_strings(df)

#     id_candidates = ['person_uid', 'EmployeeID', 'EmployeeIdentity', 'Int1']
#     id_col = next((c for c in id_candidates if c in df.columns), None)

#     def _norm_val_for_latest(v):
#         try:
#             if pd.isna(v):
#                 return None
#         except Exception:
#             pass
#         if v is None:
#             return None
#         s = str(v).strip()
#         if s == '' or s.lower() == 'nan':
#             return None
#         try:
#             if '.' in s:
#                 fv = float(s)
#                 if math.isfinite(fv) and fv.is_integer():
#                     s = str(int(fv))
#         except Exception:
#             pass
#         return s

#     if id_col is None:
#         unique_persons = int(len(df))
#     else:
#         ids_series = df[id_col].apply(_norm_val_for_latest) if id_col in df.columns else pd.Series([None]*len(df))
#         if id_col != 'person_uid' and 'person_uid' in df.columns:
#             ids_series = ids_series.fillna(df['person_uid'].astype(str).replace('nan','').replace('None',''))
#         unique_persons = int(len(set([x for x in ids_series.unique() if x])))

#     # build initial sample (list of dicts)
#     sample = _clean_sample_df(df, max_rows=5)  # returns list




#     # --- Enrich sample rows with EmployeeEmail and imageUrl (best-effort) ---
#     try:
#         if isinstance(sample, list) and sample:
#             # compute base once
#             try:
#                 base = (request.url_root or request.host_url).rstrip('/')
#             except Exception:
#                 base = ''

#             for s in sample:
#                 # ensure keys exist (consistent shape)
#                 s.setdefault('EmployeeEmail', None)
#                 s.setdefault('imageUrl', None)
#                 s.setdefault('HasImage', False)

#                 # pick a lookup token (EmployeeID / person_uid / EmployeeName / EmployeeIdentity)
#                 lookup_token = (
#                     s.get('EmployeeID')
#                     or s.get('person_uid')
#                     or s.get('EmployeeName')
#                     or s.get('EmployeeIdentity')
#                 )

#                 pi = {}
#                 if lookup_token:
#                     try:
#                         pi = get_personnel_info(lookup_token) or {}
#                     except Exception:
#                         pi = {}

#                 # Prefer personnel DB email if available
#                 if pi:
#                     email = pi.get('EmailAddress') or pi.get('EmployeeEmail') or pi.get('Email') or None
#                     if email:
#                         s['EmployeeEmail'] = email

#                     # prefer ObjectID / GUID for images
#                     objid = pi.get('ObjectID') or pi.get('GUID') or None
#                     if objid:
#                         # provide relative image path (frontend resolves with API_BASE)
#                         s['imageUrl'] = f"/employee/{objid}/image"
#                         try:
#                             b = get_person_image_bytes(objid)
#                             s['HasImage'] = True if b else False
#                         except Exception:
#                             s['HasImage'] = False

#                 # fallback: look up email from the CSV rows read (df) if still missing
#                 if not s.get('EmployeeEmail') and isinstance(df, pd.DataFrame):
#                     try:
#                         match_mask = pd.Series(False, index=df.index)
#                         if s.get('person_uid') and 'person_uid' in df.columns:
#                             match_mask |= df['person_uid'].astype(str).str.strip() == str(s.get('person_uid')).strip()
#                         if s.get('EmployeeID') and 'EmployeeID' in df.columns:
#                             match_mask |= df['EmployeeID'].astype(str).str.strip() == str(s.get('EmployeeID')).strip()

#                         if match_mask.any():
#                             idx = df[match_mask].index[0]
#                             for col in ('Email', 'EmailAddress', 'EmployeeEmail', 'WorkEmail', 'EMail'):
#                                 if col in df.columns:
#                                     val = df.at[idx, col]
#                                     if val not in (None, '', 'nan'):
#                                         s['EmployeeEmail'] = val
#                                         break
#                     except Exception:
#                         pass

#                 # Ensure we at least provide a consistent image route (use EmployeeID/person_uid if no ObjectID)
#                 if not s.get('imageUrl'):
#                     empid = s.get('EmployeeID') or s.get('person_uid')
#                     if empid:
#                         s['imageUrl'] = f"/employee/{empid}/image"
#                         # don't try to check bytes here (avoid extra DB hit) — HasImage remains False if unknown

#     except Exception:
#         # if enrichment fails, continue (sample remains as-is)
#         pass


#     resp = {
        
#         "file": latest.name,
#         "rows_raw": int(len(df)),
#         "rows": unique_persons,
#         "sample": sample,
#         "start_date": start_date_iso,
#         "end_date": end_date_iso,
#         "city": city_slug
#     }
#     return jsonify(resp)



# @app.route("/record")
# def record_endpoint():
#     employee_id = request.args.get('employee_id', '').strip()
#     if not employee_id:
#         return jsonify({'error': 'employee_id required'}), 400

#     # 1) find the latest trend CSV that contains this employee
#     trend_files = sorted(OUTDIR.glob("trend_*.csv"), reverse=True)
#     aggregated_rows = []
#     found_date_iso = None
#     for tf in trend_files:
#         try:
#             df = pd.read_csv(tf, dtype=str)
#             # normalise columns that might not exist
#             cols = df.columns.str.lower()
#             # try matching against common id columns
#             mask = pd.Series(False, index=df.index)
#             for col in ('EmployeeID', 'person_uid', 'EmployeeIdentity', 'CardNumber'):
#                 if col in df.columns:
#                     mask = mask | (df[col].astype(str).fillna('') == employee_id)
#             if mask.any():
#                 # convert matched rows to proper dicts
#                 matches = df[mask].to_dict(orient='records')
#                 aggregated_rows = matches
#                 # pick date from the first match (if available)
#                 try:
#                     d = matches[0].get('Date') or matches[0].get('DisplayDate') or None
#                     found_date_iso = d
#                 except Exception:
#                     found_date_iso = None
#                 break
#         except Exception:
#             continue

#     # 2) list raw swipe files (any swipes_*.csv in outputs)
#     raw_swipe_files = [p.name for p in sorted(OUTDIR.glob("swipes_*_*.csv"), reverse=True)]

#     # 3) build raw_swipes filtered for this person & date if possible
#     raw_swipes = []
#     try:
#         # read each swipes CSV and filter rows
#         for swf in OUTDIR.glob("swipes_*_*.csv"):
#             sdf = _safe_read_csv(swf)
#             if sdf.empty:
#                 continue
#             # ensure LocaleMessageTime exists as datetime
#             if 'LocaleMessageTime' in sdf.columns:
#                 sdf['LocaleMessageTime'] = pd.to_datetime(sdf['LocaleMessageTime'], errors='coerce')
#             else:
#                 # try fallback candidates
#                 for cand in ('MessageUTC','MessageTime','Timestamp','timestamp','Date'):
#                     if cand in sdf.columns:
#                         sdf['LocaleMessageTime'] = pd.to_datetime(sdf[cand], errors='coerce')
#                         break
#             # filter rows matching employee by either EmployeeID, person_uid, CardNumber or EmployeeIdentity
#             sel_mask = pd.Series(False, index=sdf.index)
#             for c in ('EmployeeID','person_uid','CardNumber','EmployeeIdentity'):
#                 if c in sdf.columns:
#                     sel_mask = sel_mask | (sdf[c].astype(str).fillna('') == employee_id)
#             filtered = sdf[sel_mask]
#             if filtered.empty:
#                 continue
#             # compute Date/Time and SwipeGapSeconds for the filtered rows (sorted)
#             filtered = filtered.sort_values('LocaleMessageTime')
#             filtered['Date'] = filtered['LocaleMessageTime'].dt.date.astype(str)
#             filtered['Time'] = filtered['LocaleMessageTime'].dt.time.astype(str)
#             filtered['SwipeGapSeconds'] = filtered['LocaleMessageTime'].diff().dt.total_seconds().fillna(0).astype(int)
#             filtered['SwipeGap'] = filtered['SwipeGapSeconds'].apply(lambda s: f"{int(s//3600):02d}:{int((s%3600)//60):02d}:{int(s%60):02d}" if s is not None else "-")
#             # ensure Zone (if not) by mapping Door/Direction using your map_door_to_zone in trend_runner (import it or reimplement)
#             if 'Zone' not in filtered.columns and 'Door' in filtered.columns:
#                 try:
#                     from trend_runner import map_door_to_zone
#                     filtered['Zone'] = filtered.apply(lambda r: map_door_to_zone(r.get('Door'), r.get('Direction')), axis=1)
#                 except Exception:
#                     filtered['Zone'] = filtered.get('Zone', None)
#             # project the columns the frontend expects
#             want = []
#             for c in ('EmployeeName','EmployeeID','CardNumber','Date','Time','SwipeGap','SwipeGapSeconds','Door','Direction','Zone','Note','_source'):
#                 if c in filtered.columns:
#                     want.append(c)
#             if not want:
#                 # fallback: return basic fields
#                 want = list(filtered.columns[:12])
#             rows = filtered[want].to_dict(orient='records')
#             raw_swipes.extend(rows)
#     except Exception:
#         # non fatal - return what we have
#         pass

#     # 4) Enrich aggregated_rows by trying to add Email + imageUrl using trend_runner helper if available
#     try:
#         from trend_runner import _enrich_with_personnel_info
#         if aggregated_rows:
#             agg_df = pd.DataFrame(aggregated_rows)
#             agg_df = _enrich_with_personnel_info(agg_df, image_endpoint_template="/employee/{}/image")
#             aggregated_rows = agg_df.to_dict(orient='records')
#     except Exception:
#         pass

#     return jsonify({
#         'aggregated_rows': aggregated_rows,
#         'raw_swipe_files': raw_swipe_files,
#         'raw_swipes': raw_swipes
#     })



# #Above Working 


# @app.route('/record', methods=['GET'])
# def get_record():
#     """
#     Single unified /record handler:
#     - If no employee id passed, return sample of aggregated rows.
#     - If employee_id/person_uid passed, return enriched aggregated_rows + raw_swipes + raw_swipe_files.
#     Uses DEFAULT_OUTDIR consistently for reading trend and swipe CSVs.
#     """
#     q = request.args.get('employee_id') or request.args.get('person_uid')
#     include_unflagged = str(request.args.get('include_unflagged', '')).lower() in ('1', 'true', 'yes')
#     city_param = request.args.get('city') or request.args.get('site') or 'pune'
#     city_slug = _slug_city(city_param)

#     # Use DEFAULT_OUTDIR consistently (this module-level variable is created earlier)
#     p = Path(DEFAULT_OUTDIR)
#     csvs = sorted(p.glob(f"trend_{city_slug}_*.csv"), reverse=True)
#     if not csvs:
#         csvs = sorted(p.glob("trend_*.csv"), reverse=True)
#     if not csvs:
#         # no trend files -> return empty result set gracefully
#         return jsonify({'aggregated_rows': [], 'raw_swipe_files': [], 'raw_swipes': []}), 200

#     # build a single DataFrame with all matching trend files
#     df_list = []
#     for fp in csvs:
#         try:
#             tmp = pd.read_csv(fp, parse_dates=['Date', 'FirstSwipe', 'LastSwipe'])
#         except Exception:
#             try:
#                 tmp = pd.read_csv(fp, dtype=str)
#                 if 'Date' in tmp.columns:
#                     tmp['Date'] = pd.to_datetime(tmp['Date'], errors='coerce').dt.date
#             except Exception:
#                 continue
#         df_list.append(tmp)
#     if not df_list:
#         return jsonify({'aggregated_rows': [], 'raw_swipe_files': [], 'raw_swipes': []}), 200
#     df = pd.concat(df_list, ignore_index=True)
#     df = _replace_placeholder_strings(df)

#     # if no query param, return cleaned sample (head)
#     if q is None:
#         cleaned = _clean_sample_df(df, max_rows=10)
#         return jsonify({'aggregated_rows': cleaned, 'raw_swipe_files': [], 'raw_swipes': []}), 200

#     # Normalize query
#     q_str = str(q).strip()
#     def normalize_series(s):
#         if s is None:
#             return pd.Series([''] * len(df))
#         s = s.fillna('').astype(str).str.strip()
#         def _norm_val(v):
#             if not v:
#                 return ''
#             try:
#                 if '.' in v:
#                     fv = float(v)
#                     if fv.is_integer():
#                         return str(int(fv))
#             except Exception:
#                 pass
#             return v
#         return s.map(_norm_val)

#     # find matching rows
#     found_mask = pd.Series(False, index=df.index)
#     if 'EmployeeID' in df.columns:
#         emp_series = normalize_series(df['EmployeeID'])
#         found_mask = found_mask | (emp_series == q_str)
#     if 'person_uid' in df.columns:
#         uid_series = normalize_series(df['person_uid'])
#         found_mask = found_mask | (uid_series == q_str)
#     if 'Int1' in df.columns and not found_mask.any():
#         int1_series = normalize_series(df['Int1'])
#         found_mask = found_mask | (int1_series == q_str)

#     if not found_mask.any():
#         # try numeric match
#         try:
#             q_numeric = float(q_str)
#             if 'EmployeeID' in df.columns:
#                 emp_numeric = pd.to_numeric(df['EmployeeID'], errors='coerce')
#                 found_mask = found_mask | (emp_numeric == q_numeric)
#             if 'Int1' in df.columns and not found_mask.any():
#                 int_numeric = pd.to_numeric(df['Int1'], errors='coerce')
#                 found_mask = found_mask | (int_numeric == q_numeric)
#         except Exception:
#             pass

#     matched = df[found_mask].copy()
#     if matched.empty:
#         return jsonify({'aggregated_rows': [], 'raw_swipe_files': [], 'raw_swipes': []}), 200

#     # Clean matched rows for JSON and enrichment
#     cleaned_matched = _clean_sample_df(matched, max_rows=len(matched))

#     # Enrich matched rows: email / image / explanations
#     # Try to find personnel info using multiple candidate tokens (but avoid DB hits for obvious missing tokens)
#     try:
#         # lazy import helpers from trend_runner if available (safe)
#         from trend_runner import compute_violation_days_map, _strip_uid_prefix as _strip_uid_prefix_tr
#         violation_map = compute_violation_days_map(str(DEFAULT_OUTDIR), 90, datetime.now().date())
#     except Exception:
#         violation_map = {}
#         _strip_uid_prefix_tr = (lambda x: x)

#     matched_indexed = matched.reset_index(drop=True)

#     # For each cleaned row build candidate and enrich
#     for idx_c, cleaned in enumerate(cleaned_matched):
#         candidate_row = None
#         try:
#             # 1) try to match by person_uid/EmployeeID/EmployeeName
#             if cleaned.get('person_uid') and 'person_uid' in matched_indexed.columns:
#                 mr = matched_indexed[matched_indexed['person_uid'].astype(str).str.strip() == str(cleaned['person_uid']).strip()]
#                 if not mr.empty:
#                     candidate_row = mr.iloc[0].to_dict()

#             if candidate_row is None and cleaned.get('EmployeeID') and 'EmployeeID' in matched_indexed.columns:
#                 mr = matched_indexed[matched_indexed['EmployeeID'].astype(str).str.strip() == str(cleaned['EmployeeID']).strip()]
#                 if not mr.empty:
#                     candidate_row = mr.iloc[0].to_dict()

#             if candidate_row is None and cleaned.get('EmployeeName') and 'EmployeeName' in matched_indexed.columns:
#                 mr = matched_indexed[matched_indexed['EmployeeName'].astype(str).str.strip().str.lower() == str(cleaned['EmployeeName']).strip().lower()]
#                 if not mr.empty:
#                     candidate_row = mr.iloc[0].to_dict()

#             # 2) fallback to other columns
#             if candidate_row is None and not matched_indexed.empty:
#                 for ccol in ('CardNumber', 'EmployeeIdentity', 'Int1', 'Text12', 'ObjectIdentity1', 'ObjectID', 'GUID'):
#                     if ccol in matched_indexed.columns and cleaned.get(ccol) not in (None, '', 'nan'):
#                         mr = matched_indexed[matched_indexed[ccol].astype(str).str.strip() == str(cleaned.get(ccol)).strip()]
#                         if not mr.empty:
#                             candidate_row = mr.iloc[0].to_dict()
#                             break

#             # 3) last resort — pick first
#             if candidate_row is None and not matched_indexed.empty:
#                 candidate_row = matched_indexed.iloc[0].to_dict()
#         except Exception:
#             candidate_row = None

#         # Build explanation text if present
#         violation_expl = None
#         try:
#             if candidate_row:
#                 violation_expl = candidate_row.get('Explanation') or candidate_row.get('explanation') or None

#             if not violation_expl:
#                 reasons = cleaned.get('Reasons') or (candidate_row.get('Reasons') if candidate_row else None)
#                 if reasons:
#                     parts = [p.strip() for p in re.split(r'[;,\|]', str(reasons)) if p.strip()]
#                     mapped = []
#                     for p in parts:
#                         try:
#                             if 'SCENARIO_EXPLANATIONS' in globals() and p in SCENARIO_EXPLANATIONS:
#                                 mapped.append(SCENARIO_EXPLANATIONS[p](candidate_row or {}))
#                             else:
#                                 mapped.append(p.replace("_", " ").replace(">=", "≥"))
#                         except Exception:
#                             mapped.append(p)
#                     violation_expl = " ".join(mapped) if mapped else None

#             # remove GUIDs inside explanation if possible
#             if violation_expl:
#                 try:
#                     emp_name_for_expl = None
#                     if candidate_row:
#                         emp_name_for_expl = candidate_row.get('EmployeeName') or candidate_row.get('employee_name') or candidate_row.get('ObjectName1')
#                     if not emp_name_for_expl:
#                         emp_name_for_expl = cleaned.get('EmployeeName')
#                     if emp_name_for_expl:
#                         violation_expl = GUID_IN_TEXT_RE.sub(str(emp_name_for_expl), str(violation_expl))
#                 except Exception:
#                     pass
#         except Exception:
#             violation_expl = None

#         # violation days lookup (if available)
#         try:
#             candidates = []
#             for k in ('EmployeeID', 'person_uid', 'EmployeeIdentity', 'CardNumber', 'Int1', 'Text12'):
#                 if cleaned.get(k) not in (None, '', 'nan'):
#                     candidates.append(cleaned.get(k))
#             if candidate_row:
#                 for k in ('EmployeeID','person_uid','EmployeeIdentity','CardNumber','Int1','Text12'):
#                     if candidate_row.get(k) not in (None,'','nan'):
#                         candidates.append(candidate_row.get(k))
#             vdays = 0
#             if violation_map:
#                 for c in candidates:
#                     if c is None:
#                         continue
#                     n = _normalize_id_local(c)
#                     if n and n in violation_map:
#                         vdays = int(violation_map.get(n, 0))
#                         break
#                     try:
#                         stripped = _strip_uid_prefix_tr(str(n))
#                         if stripped != n and stripped in violation_map:
#                             vdays = int(violation_map.get(stripped, 0))
#                             break
#                     except Exception:
#                         pass
#         except Exception:
#             vdays = 0

#         # Personnel lookup: attempt DB lookup only if we have useful tokens (avoid unnecessary DB hits)
#         personnel_info = {}
#         try:
#             lookup_candidates = []
#             if candidate_row:
#                 for k in ('EmployeeObjID','EmployeeObjId','EmployeeIdentity','ObjectID','GUID','EmployeeID','Int1','Text12','EmployeeName'):
#                     if candidate_row.get(k) not in (None,'','nan'):
#                         lookup_candidates.append(candidate_row.get(k))
#             for k in ('EmployeeID','person_uid','EmployeeName'):
#                 if cleaned.get(k) not in (None,'','nan'):
#                     lookup_candidates.append(cleaned.get(k))

#             for cand in lookup_candidates:
#                 if cand is None:
#                     continue
#                 try:
#                     info = get_personnel_info(cand)
#                     if info and (info.get('ObjectID') is not None or info.get('EmailAddress') is not None or info.get('ManagerEmail') is not None):
#                         personnel_info = info
#                         break
#                 except Exception:
#                     continue

#             # Extra fallback: try by EmployeeID explicitly
#             if not personnel_info:
#                 try:
#                     cand = cleaned.get('EmployeeID') or cleaned.get('EmployeeIdentity')
#                     if cand:
#                         info = get_personnel_info(cand)
#                         if info and (info.get('ObjectID') is not None or info.get('EmailAddress') is not None):
#                             personnel_info = info
#                 except Exception:
#                     pass
#         except Exception:
#             personnel_info = {}

#         # Attach computed fields (robust)
#         try:
#             cleaned['ViolationDaysLast90'] = int(vdays or 0)
#             cleaned['ViolationExplanation'] = violation_expl
#             cleaned['Explanation'] = violation_expl or cleaned.get('ViolationExplanation') or None

#             # Ensure EmployeeName
#             try:
#                 if (not cleaned.get('EmployeeName')) or _looks_like_guid(cleaned.get('EmployeeName')):
#                     if candidate_row and candidate_row.get('EmployeeName') and not _looks_like_guid(candidate_row.get('EmployeeName')):
#                         cleaned['EmployeeName'] = candidate_row.get('EmployeeName')
#                     elif personnel_info and personnel_info.get('Name'):
#                         cleaned['EmployeeName'] = personnel_info.get('Name')
#             except Exception:
#                 pass

#             # Populate EmployeeEmail robustly: prefer personnel_info, then candidate_row, then matched_indexed source row
#             email_val = None
#             if personnel_info:
#                 email_val = personnel_info.get('EmailAddress') or personnel_info.get('Email')
#             if not email_val and candidate_row:
#                 for fk in ('Email', 'EmailAddress', 'EmployeeEmail', 'WorkEmail', 'EMail'):
#                     if candidate_row.get(fk) not in (None, '', 'nan'):
#                         email_val = candidate_row.get(fk)
#                         break
#             if not email_val:
#                 # try the matched_indexed first row
#                 for col in ('Email', 'EmailAddress', 'EmployeeEmail', 'WorkEmail', 'EMail'):
#                     if col in matched_indexed.columns:
#                         try:
#                             val = matched_indexed.iloc[0].get(col)
#                             if val not in (None, '', 'nan'):
#                                 email_val = val
#                                 break
#                         except Exception:
#                             continue

#             # Final fallback: sanitize value
#             cleaned['EmployeeEmail'] = (email_val if email_val not in (None, '', 'nan') else None) or cleaned.get('EmployeeEmail') or None

#             # IMAGE resolution: prefer personnel_info.ObjectID then candidate_row fields, otherwise EmployeeID/person_uid
#             try:
#                 img_obj = None
#                 if personnel_info and personnel_info.get('ObjectID') is not None:
#                     img_obj = personnel_info.get('ObjectID')
#                 elif candidate_row:
#                     for k in ('EmployeeObjID', 'EmployeeObjId', 'ObjectID', 'ObjectIdentity1'):
#                         if candidate_row.get(k) not in (None, '', 'nan'):
#                             img_obj = candidate_row.get(k)
#                             break

#                 try:
#                     base = (request.url_root or request.host_url).rstrip('/')
#                 except Exception:
#                     base = ''

#                 if img_obj:
#                     if base:
#                         cleaned['imageUrl'] = f"{base}/employee/{img_obj}/image"
#                     else:
#                         cleaned['imageUrl'] = f"/employee/{img_obj}/image"
#                     try:
#                         b = get_person_image_bytes(img_obj)
#                         cleaned['HasImage'] = True if b else False
#                     except Exception:
#                         cleaned['HasImage'] = False
#                 else:
#                     emp_for_img = cleaned.get('EmployeeID') or cleaned.get('person_uid') or None
#                     if emp_for_img:
#                         if base:
#                             cleaned['imageUrl'] = f"{base}/employee/{emp_for_img}/image"
#                         else:
#                             cleaned['imageUrl'] = f"/employee/{emp_for_img}/image"
#                         try:
#                             b = get_person_image_bytes(emp_for_img)
#                             cleaned['HasImage'] = True if b else False
#                         except Exception:
#                             cleaned['HasImage'] = False
#                     else:
#                         cleaned['imageUrl'] = None
#                         cleaned['HasImage'] = False

#             except Exception:
#                 cleaned['imageUrl'] = cleaned.get('imageUrl') or None
#                 cleaned['HasImage'] = cleaned.get('HasImage') or False

#             # ensure EmployeeID surfaced if absent
#             if not cleaned.get('EmployeeID') and candidate_row:
#                 for k in ('EmployeeID','Int1','Text12','EmployeeIdentity'):
#                     if candidate_row.get(k) not in (None, '', 'nan'):
#                         cleaned['EmployeeID'] = candidate_row.get(k)
#                         break

#         except Exception:
#             # safe defaults if enrichment fails
#             cleaned.setdefault('EmployeeEmail', None)
#             cleaned.setdefault('imageUrl', None)
#             cleaned.setdefault('HasImage', False)

#     # Build raw_swipes timeline (scan swipe files using DEFAULT_OUTDIR)
#     raw_files = set()
#     raw_swipes_out = []
#     seen_swipe_keys = set()
#     def _append_swipe(out_row, source_name):
#         key = (
#             out_row.get('Date') or '',
#             out_row.get('Time') or '',
#             (out_row.get('Door') or '').strip(),
#             (out_row.get('Direction') or '').strip(),
#             (out_row.get('CardNumber') or out_row.get('Card') or '').strip()
#         )
#         if key in seen_swipe_keys:
#             return
#         seen_swipe_keys.add(key)
#         out_row['_source'] = source_name
#         raw_swipes_out.append(out_row)

#     # dates discovered from matched rows
#     dates_to_scan = set()
#     for _, agg_row in matched.iterrows():
#         try:
#             if 'Date' in agg_row and pd.notna(agg_row['Date']):
#                 try:
#                     d = pd.to_datetime(agg_row['Date']).date()
#                     dates_to_scan.add(d)
#                 except Exception:
#                     pass
#             for col in ('FirstSwipe','LastSwipe'):
#                 if col in agg_row and pd.notna(agg_row[col]):
#                     try:
#                         d = pd.to_datetime(agg_row[col]).date()
#                         dates_to_scan.add(d)
#                     except Exception:
#                         pass
#         except Exception:
#             continue
#     if not dates_to_scan:
#         dates_to_scan = {None}

#     for d in dates_to_scan:
#         candidates = _find_swipe_files(DEFAULT_OUTDIR, date_obj=d, city_slug=city_slug)
#         if not candidates:
#             candidates = _find_swipe_files(DEFAULT_OUTDIR, date_obj=d, city_slug=None)

#         for fp in candidates:
#             raw_files.add(fp.name)
#             try:
#                 try:
#                     raw_df = pd.read_csv(fp, parse_dates=['LocaleMessageTime'])
#                 except Exception:
#                     raw_df = pd.read_csv(fp, dtype=str)
#             except Exception:
#                 continue

#             raw_df = _replace_placeholder_strings(raw_df)
#             # lower->orig mapping
#             cols_lower = {c.lower(): c for c in raw_df.columns}
#             tcol = cols_lower.get('localemessagetime') or cols_lower.get('messagetime') or cols_lower.get('timestamp') or cols_lower.get('time') or None
#             emp_col = cols_lower.get('int1') or cols_lower.get('employeeid') or cols_lower.get('employeeidentity') or cols_lower.get('employee_id') or None
#             name_col = cols_lower.get('employeename') or cols_lower.get('objectname1') or cols_lower.get('employee_name') or None
#             card_col = cols_lower.get('cardnumber') or cols_lower.get('card') or cols_lower.get('chuid') or cols_lower.get('value') or None
#             door_col = cols_lower.get('door') or cols_lower.get('doorname') or cols_lower.get('door_name') or None
#             dir_col = cols_lower.get('direction') or cols_lower.get('directionname') or cols_lower.get('direction_name') or None
#             note_col = cols_lower.get('rejection_type') or cols_lower.get('note') or cols_lower.get('source') or None
#             person_uid_col = cols_lower.get('person_uid')

#             mask = pd.Series(False, index=raw_df.index)
#             if person_uid_col and person_uid_col in raw_df.columns:
#                 mask = mask | (raw_df[person_uid_col].astype(str).str.strip() == str(q).strip())
#             if emp_col and emp_col in raw_df.columns:
#                 mask = mask | (raw_df[emp_col].astype(str).str.strip() == str(q).strip())
#             if not mask.any() and emp_col and emp_col in raw_df.columns:
#                 try:
#                     q_numeric = float(q)
#                     emp_numeric = pd.to_numeric(raw_df[emp_col], errors='coerce')
#                     mask = mask | (emp_numeric == q_numeric)
#                 except Exception:
#                     pass
#             if not mask.any() and name_col and name_col in raw_df.columns:
#                 try:
#                     mask = mask | (raw_df[name_col].astype(str).str.strip().str.lower() == str(q).strip().lower())
#                 except Exception:
#                     pass

#             if not mask.any():
#                 continue

#             filtered = raw_df[mask].copy()
#             if filtered.empty:
#                 continue

#             if tcol and tcol in filtered.columns:
#                 try:
#                     filtered[tcol] = pd.to_datetime(filtered[tcol], errors='coerce')
#                 except Exception:
#                     pass

#             if tcol and tcol in filtered.columns:
#                 filtered = filtered.sort_values(by=tcol)
#                 filtered['_prev_ts'] = filtered[tcol].shift(1)
#                 try:
#                     filtered['_swipe_gap_seconds'] = (filtered[tcol] - filtered['_prev_ts']).dt.total_seconds().fillna(0).astype(float)
#                 except Exception:
#                     filtered['_swipe_gap_seconds'] = 0.0
#                 try:
#                     cur_dates = filtered[tcol].dt.date
#                     prev_dates = cur_dates.shift(1)
#                     day_start_mask = (prev_dates != cur_dates) | (filtered['_prev_ts'].isna())
#                     filtered.loc[day_start_mask, '_swipe_gap_seconds'] = 0.0
#                 except Exception:
#                     pass
#             else:
#                 filtered['_swipe_gap_seconds'] = 0.0

#             try:
#                 if door_col and door_col in filtered.columns:
#                     if dir_col and dir_col in filtered.columns:
#                         filtered['_zone'] = filtered.apply(lambda rr: map_door_to_zone(rr.get(door_col), rr.get(dir_col)), axis=1)
#                     else:
#                         filtered['_zone'] = filtered[door_col].apply(lambda dv: map_door_to_zone(dv, None))
#                 else:
#                     filtered['_zone'] = filtered.get('PartitionName2', None)
#             except Exception:
#                 filtered['_zone'] = None

#             for _, r in filtered.iterrows():
#                 out = {}
#                 out['EmployeeName'] = _to_python_scalar(r.get(name_col)) if name_col and name_col in filtered.columns else _to_python_scalar(matched.iloc[0].get('EmployeeName') if not matched.empty else q)
#                 # employee id
#                 emp_val = None
#                 if emp_col and emp_col in filtered.columns:
#                     emp_val = _to_python_scalar(r.get(emp_col))
#                 else:
#                     for cand in ('Int1','Text12','EmployeeID','EmployeeIdentity','empid','id'):
#                         if cand.lower() in cols_lower:
#                             emp_val = _to_python_scalar(r.get(cols_lower[cand.lower()]))
#                             if emp_val not in (None,'','nan'):
#                                 break
#                     if emp_val in (None,'','nan'):
#                         emp_val = _to_python_scalar(matched.iloc[0].get('EmployeeID') if not matched.empty else None)
#                 if emp_val is not None:
#                     try:
#                         s = str(emp_val).strip()
#                         if '.' in s:
#                             f = float(s)
#                             if math.isfinite(f) and f.is_integer():
#                                 s = str(int(f))
#                         if _looks_like_guid(s) or _is_placeholder_str(s):
#                             emp_val = None
#                         else:
#                             emp_val = s
#                     except Exception:
#                         if _looks_like_guid(emp_val):
#                             emp_val = None
#                 out['EmployeeID'] = emp_val

#                 # Card number
#                 card_val = None
#                 if card_col and card_col in filtered.columns:
#                     card_val = _to_python_scalar(r.get(card_col))
#                 else:
#                     for cand in ('CardNumber','CHUID','Card','card_no','cardnum','value','xmlmessage'):
#                         if cand.lower() in cols_lower:
#                             card_val = _to_python_scalar(r.get(cols_lower[cand.lower()]))
#                             if card_val not in (None,'','nan'):
#                                 break
#                     if card_val in (None,'','nan'):
#                         card_val = _to_python_scalar(matched.iloc[0].get('CardNumber') if not matched.empty else None)
#                 if card_val is not None:
#                     try:
#                         cs = str(card_val).strip()
#                         if _looks_like_guid(cs) or _is_placeholder_str(cs):
#                             card_val = None
#                         else:
#                             card_val = cs
#                     except Exception:
#                         card_val = None
#                 out['CardNumber'] = card_val
#                 out['Card'] = card_val

#                 # timestamps
#                 if tcol and tcol in filtered.columns:
#                     ts = r.get(tcol)
#                     try:
#                         ts_py = pd.to_datetime(ts)
#                         out['Date'] = ts_py.date().isoformat()
#                         out['Time'] = ts_py.time().isoformat()
#                         out['LocaleMessageTime'] = ts_py.isoformat()
#                     except Exception:
#                         txt = str(r.get(tcol))
#                         out['Date'] = txt[:10]
#                         out['Time'] = txt[11:19] if len(txt) >= 19 else txt
#                         out['LocaleMessageTime'] = txt
#                 else:
#                     out['Date'] = None
#                     out['Time'] = None
#                     out['LocaleMessageTime'] = None

#                 out['SwipeGapSeconds'] = float(r.get('_swipe_gap_seconds')) if '_swipe_gap_seconds' in r else 0.0
#                 out['SwipeGap'] = format_seconds_to_hms(out['SwipeGapSeconds'])
#                 out['Door'] = _to_python_scalar(r.get(door_col)) if (door_col and door_col in filtered.columns) else None
#                 out['Direction'] = _to_python_scalar(r.get(dir_col)) if (dir_col and dir_col in filtered.columns) else _to_python_scalar(r.get('Direction')) if 'Direction' in r else None
#                 out['Note'] = _to_python_scalar(r.get(note_col)) if (note_col and note_col in filtered.columns) else None
#                 try:
#                     out['Zone'] = _to_python_scalar(r.get('_zone')) if '_zone' in r else map_door_to_zone(out['Door'], out['Direction'])
#                 except Exception:
#                     out['Zone'] = None
#                 out['PartitionName2'] = _to_python_scalar(r.get('PartitionName2')) if 'PartitionName2' in filtered.columns else None
#                 out['_source_file'] = fp.name
#                 _append_swipe(out, fp.name)

#     return jsonify({
#         "aggregated_rows": cleaned_matched,
#         "raw_swipe_files": sorted(list(raw_files)),
#         "raw_swipes": raw_swipes_out
#     }), 200



# @app.route('/record/export', methods=['GET'])
# def export_record_excel():
#     q = request.args.get('employee_id') or request.args.get('person_uid')
#     date_str = request.args.get('date')
#     city_param = request.args.get('city') or request.args.get('site') or 'pune'
#     city_slug = _slug_city(city_param)

#     if not q:
#         return jsonify({"error":"employee_id or person_uid is required"}), 400

#     p = Path(DEFAULT_OUTDIR)
#     files_to_scan = []
#     if date_str:
#         try:
#             dd = pd.to_datetime(date_str).date()
#             files_to_scan = _find_swipe_files(DEFAULT_OUTDIR, date_obj=dd, city_slug=city_slug)
#         except Exception:
#             return jsonify({"error":"invalid date format, expected YYYY-MM-DD"}), 400
#     else:
#         files_to_scan = _find_swipe_files(DEFAULT_OUTDIR, date_obj=None, city_slug=city_slug)
#     if not files_to_scan:
#         # show any available swipe-style files to help frontend debugging
#         avail = _find_swipe_files(DEFAULT_OUTDIR, date_obj=None, city_slug=None)
#         avail_names = [f.name for f in avail] if avail else []
#         logging.info(
#             "export_record_excel: no files matched for date=%s city=%s; available swipe files=%s",
#             date_str, city_slug, avail_names
#         )
#         return jsonify({
#             "error": "no raw swipe files found for requested date / outputs",
#             "available_swipe_files": avail_names
#         }), 404

#     all_rows = []
#     for fp in files_to_scan:
#         try:
#             raw_df = pd.read_csv(fp, dtype=str, parse_dates=['LocaleMessageTime'])
#         except Exception:
#             try:
#                 raw_df = pd.read_csv(fp, dtype=str)
#             except Exception:
#                 continue

#         raw_df = _replace_placeholder_strings(raw_df)
#         cols_lower = {c.lower(): c for c in raw_df.columns}
#         tcol = cols_lower.get('localemessagetime') or cols_lower.get('messagetime') or cols_lower.get('timestamp') or cols_lower.get('time') or None
#         emp_col = cols_lower.get('int1') or cols_lower.get('employeeid') or cols_lower.get('employeeidentity') or cols_lower.get('employee_id') or None
#         name_col = cols_lower.get('employeename') or cols_lower.get('objectname1') or cols_lower.get('employee_name') or None
#         card_col = cols_lower.get('cardnumber') or cols_lower.get('card') or cols_lower.get('chuid') or cols_lower.get('value') or None
#         door_col = cols_lower.get('door') or cols_lower.get('doorname') or cols_lower.get('door_name') or None
#         dir_col = cols_lower.get('direction') or cols_lower.get('directionname') or cols_lower.get('direction_name') or None
#         note_col = cols_lower.get('rejection_type') or cols_lower.get('note') or cols_lower.get('source') or None
#         person_uid_col = cols_lower.get('person_uid')

#         mask = pd.Series(False, index=raw_df.index)
#         if person_uid_col and person_uid_col in raw_df.columns:
#             mask = mask | (raw_df[person_uid_col].astype(str).str.strip() == str(q).strip())
#         if emp_col and emp_col in raw_df.columns:
#             mask = mask | (raw_df[emp_col].astype(str).str.strip() == str(q).strip())
#         if not mask.any() and emp_col and emp_col in raw_df.columns:
#             try:
#                 q_numeric = float(q)
#                 emp_numeric = pd.to_numeric(raw_df[emp_col], errors='coerce')
#                 mask = mask | (emp_numeric == q_numeric)
#             except Exception:
#                 pass
#         if not mask.any() and name_col and name_col in raw_df.columns:
#             mask = mask | (raw_df[name_col].astype(str).str.strip().str.lower() == str(q).strip().lower())

#         if not mask.any():
#             continue

#         filtered = raw_df[mask].copy()
#         if filtered.empty:
#             continue

#         if tcol and tcol in filtered.columns:
#             try:
#                 filtered[tcol] = pd.to_datetime(filtered[tcol], errors='coerce')
#             except Exception:
#                 pass

#         if tcol and tcol in filtered.columns:
#             filtered = filtered.sort_values(by=tcol)
#             filtered['_prev_ts'] = filtered[tcol].shift(1)
#             try:
#                 filtered['_swipe_gap_seconds'] = (filtered[tcol] - filtered['_prev_ts']).dt.total_seconds().fillna(0).astype(float)
#             except Exception:
#                 filtered['_swipe_gap_seconds'] = 0.0
#         else:
#             filtered['_swipe_gap_seconds'] = 0.0

#         try:
#             if door_col and door_col in filtered.columns:
#                 if dir_col and dir_col in filtered.columns:
#                     filtered['_zone'] = filtered.apply(lambda rr: map_door_to_zone(rr.get(door_col), rr.get(dir_col)), axis=1)
#                 else:
#                     filtered['_zone'] = filtered[door_col].apply(lambda dv: map_door_to_zone(dv, None))
#             else:
#                 filtered['_zone'] = filtered.get('PartitionName2', None)
#         except Exception:
#             filtered['_zone'] = None

#         for _, r in filtered.iterrows():
#             row = {}
#             row['EmployeeName'] = _to_python_scalar(r.get(name_col)) if (name_col and name_col in filtered.columns) else None
#             emp_val = None
#             if emp_col and emp_col in filtered.columns:
#                 emp_val = _to_python_scalar(r.get(emp_col))
#             else:
#                 for cand in ('int1','text12','employeeid','employee_identity','employeeidentity'):
#                     if cand in cols_lower and cols_lower[cand] in filtered.columns:
#                         emp_val = _to_python_scalar(r.get(cols_lower[cand]))
#                         if emp_val:
#                             break
#             row['EmployeeID'] = emp_val
#             row['Card'] = _to_python_scalar(r.get(card_col)) if (card_col and card_col in filtered.columns) else None

#             if tcol and tcol in filtered.columns:
#                 ts = r.get(tcol)
#                 try:
#                     ts_py = pd.to_datetime(ts)
#                     row['Date'] = ts_py.date().isoformat()
#                     row['Time'] = ts_py.time().isoformat()
#                     row['LocaleMessageTime'] = ts_py.isoformat()
#                 except Exception:
#                     txt = str(r.get(tcol))
#                     row['Date'] = txt[:10]
#                     row['Time'] = txt[11:19] if len(txt) >= 19 else None
#                     row['LocaleMessageTime'] = txt
#             else:
#                 row['Date'] = None
#                 row['Time'] = None
#                 row['LocaleMessageTime'] = None

#             row['SwipeGapSeconds'] = float(r.get('_swipe_gap_seconds')) if '_swipe_gap_seconds' in r else 0.0
#             row['SwipeGap'] = format_seconds_to_hms(row['SwipeGapSeconds'])
#             row['Door'] = _to_python_scalar(r.get(door_col)) if (door_col and door_col in filtered.columns) else None
#             row['Direction'] = _to_python_scalar(r.get(dir_col)) if (dir_col and dir_col in filtered.columns) else None
#             row['Note'] = _to_python_scalar(r.get(note_col)) if (note_col and note_col in filtered.columns) else None
#             try:
#                 zone_val = r.get('_zone') if '_zone' in r else None
#                 if zone_val is None:
#                     zone_val = map_door_to_zone(row['Door'], row['Direction'])
#                 row['Zone'] = _to_python_scalar(zone_val)
#             except Exception:
#                 row['Zone'] = None
#             row['PartitionName2'] = _to_python_scalar(r.get('PartitionName2')) if 'PartitionName2' in filtered.columns else None
#             row['_source_file'] = fp.name
#             all_rows.append(row)

#     if not all_rows:
#         return jsonify({"error":"no swipe rows matched the requested employee/date"}), 404

#     df_out = pd.DataFrame(all_rows)
#     details_cols = ['EmployeeName','EmployeeID','Door','Direction','Zone','Date','LocaleMessageTime','SwipeGapSeconds','PartitionName2','_source_file']
#     timeline_cols = ['EmployeeName','EmployeeID','Card','Date','Time','SwipeGapSeconds','Door','Direction','Zone','Note','_source_file']

#     details_df = df_out[[c for c in details_cols if c in df_out.columns]].copy()
#     timeline_df = df_out[[c for c in timeline_cols if c in df_out.columns]].copy()

#     output = io.BytesIO()
#     try:
#         with pd.ExcelWriter(output, engine='openpyxl') as writer:
#             details_df.to_excel(writer, sheet_name='Details — Evidence', index=False)
#             timeline_df.to_excel(writer, sheet_name='Swipe timeline', index=False)
#             writer.save()
#             output.seek(0)
#     except Exception as e:
#         logging.exception("Failed to create Excel: %s", e)
#         return jsonify({"error":"failed to create excel"}), 500

#     if OPENPYXL_AVAILABLE:
#         try:
#             wb = load_workbook(output)
#             thin = Side(border_style="thin", color="000000")
#             thick = Side(border_style="medium", color="000000")
#             for ws in wb.worksheets:
#                 header = ws[1]
#                 for cell in header:
#                     cell.font = Font(bold=True)
#                     cell.alignment = Alignment(horizontal="center", vertical="center")
#                     cell.border = Border(top=thick, left=thick, right=thick, bottom=thick)
#                 for row in ws.iter_rows(min_row=2, max_row=ws.max_row, min_col=1, max_col=ws.max_column):
#                     for cell in row:
#                         cell.alignment = Alignment(horizontal="center", vertical="center")
#                         cell.border = Border(top=thin, left=thin, right=thin, bottom=thin)
#                 for col in ws.columns:
#                     max_len = 0
#                     col_letter = col[0].column_letter
#                     for cell in col:
#                         try:
#                             v = str(cell.value) if cell.value is not None else ""
#                         except Exception:
#                             v = ""
#                         if len(v) > max_len:
#                             max_len = len(v)
#                     width = min(max(10, max_len + 2), 50)
#                     ws.column_dimensions[col_letter].width = width
#             out2 = io.BytesIO()
#             wb.save(out2)
#             out2.seek(0)
#             return send_file(out2, as_attachment=True,
#                              download_name=f"evidence_{str(q).replace(' ','_')}_{date_str or 'all'}.xlsx",
#                              mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
#         except Exception:
#             logging.exception("Excel styling failed, returning raw file")
#             output.seek(0)
#             return send_file(output, as_attachment=True,
#                              download_name=f"evidence_{str(q).replace(' ','_')}_{date_str or 'all'}.xlsx",
#                              mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
#     else:
#         output.seek(0)
#         return send_file(output, as_attachment=True,
#                          download_name=f"evidence_{str(q).replace(' ','_')}_{date_str or 'all'}.xlsx",
#                          mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

# @app.route('/swipes/<filename>', methods=['GET'])
# def download_swipes(filename):
#     fp = DEFAULT_OUTDIR / filename
#     if not fp.exists():
#         return jsonify({"error":"file not found"}), 404
#     return send_from_directory(str(DEFAULT_OUTDIR), filename, as_attachment=True)

# @app.route('/train', methods=['GET'])
# def build_training_endpoint():
#     end_date_str = request.args.get('end_date')
#     months = int(request.args.get('months') or 3)
#     min_unique = int(request.args.get('min_unique') or 1000)
#     try:
#         if end_date_str:
#             end_date = datetime.strptime(end_date_str, "%Y-%m-%d").date()
#         else:
#             end_date = datetime.now().date()
#     except Exception as e:
#         return jsonify({"error": f"invalid end_date: {e}"}), 400

#     try:
#         if build_monthly_training is None:
#             raise RuntimeError("build_monthly_training not available")
#         csv_path = build_monthly_training(end_date=end_date, months=months, min_unique_employees=min_unique, outdir=str(DEFAULT_OUTDIR))
#         if csv_path is None:
#             return jsonify({"error":"no training CSV produced (no data)"}), 500
#         return jsonify({"training_csv": str(csv_path)})
#     except Exception as e:
#         logging.exception("build_monthly_training failed")
#         return jsonify({"error": str(e)}), 500


# # @app.route("/employee/<pid>/image")
# # def employee_image(pid):
# #     """
# #     Return image bytes for a person id used by frontend imageUrl template.
# #     If you already have get_person_image_bytes(pid) helper, this will call it.
# #     """
# #     try:
# #         # try to call app-level helper if present
# #         import importlib
# #         appmod = importlib.import_module('app')  # adjust module name if helper is in another module
# #         gpib = getattr(appmod, 'get_person_image_bytes', None)
# #         if gpib:
# #             data = gpib(pid)  # should return bytes or None
# #             if data:
# #                 return send_file(BytesIO(data), mimetype='image/jpeg')
# #     except Exception:
# #         logging.exception("employee_image route failed")
# #     # fallback: 404 — frontend shows placeholder if not found
# #     return ('', 404)



# # chatbot helpers (kept mostly as-is)
# try:
#     from trend_runner import _read_past_trend_csvs, _normalize_id_val, SCENARIO_EXPLANATIONS
# except Exception:
#     _read_past_trend_csvs = None
#     _normalize_id_val = None
#     SCENARIO_EXPLANATIONS = {}

# def _load_latest_trend_df(outdir: Path, city: str = "pune"):
#     city_slug = _slug_city(city)
#     csvs = sorted(outdir.glob(f"trend_{city_slug}_*.csv"), reverse=True)
#     if not csvs:
#         csvs = sorted(outdir.glob("trend_*.csv"), reverse=True)
#     if not csvs:
#         return None, None
#     latest = csvs[0]
#     try:
#         df = pd.read_csv(latest)
#     except Exception:
#         df = pd.read_csv(latest, dtype=str)
#     df = _replace_placeholder_strings(df)
#     return df, latest.name

# def _find_person_rows(identifier: str, days: int = 90, outdir: Path = DEFAULT_OUTDIR):
#     if _normalize_id_val:
#         norm = _normalize_id_val(identifier)
#     else:
#         norm = str(identifier).strip()
#         if '.' in norm:
#             try:
#                 f = float(norm)
#                 if f.is_integer():
#                     norm = str(int(f))
#             except Exception:
#                 pass
#     today = datetime.now().date()
#     try:
#         if _read_past_trend_csvs:
#             past = _read_past_trend_csvs(str(outdir), days, today)
#         else:
#             files = sorted(Path(outdir).glob("trend_pune_*.csv"), reverse=True)
#             dfs = []
#             cutoff = today - timedelta(days=days)
#             for fp in files:
#                 try:
#                     tmp = pd.read_csv(fp, parse_dates=['Date'])
#                     tmp['Date'] = pd.to_datetime(tmp['Date'], errors='coerce').dt.date
#                     tmp = tmp[tmp['Date'].apply(lambda d: d is not None and d >= cutoff and d <= today)]
#                     dfs.append(tmp)
#                 except Exception:
#                     try:
#                         tmp = pd.read_csv(fp, dtype=str)
#                         if 'Date' in tmp.columns:
#                             tmp['Date'] = pd.to_datetime(tmp['Date'], errors='coerce').dt.date
#                             tmp = tmp[tmp['Date'].apply(lambda d: d is not None and d >= cutoff and d <= today)]
#                             dfs.append(tmp)
#                     except Exception:
#                         continue
#             past = pd.concat(dfs, ignore_index=True) if dfs else pd.DataFrame()
#     except Exception:
#         past = pd.DataFrame()

#     if past is None or past.empty:
#         return pd.DataFrame()

#     past = _replace_placeholder_strings(past)
#     match_mask = pd.Series(False, index=past.index)
#     for col in ('EmployeeID','person_uid','EmployeeIdentity','CardNumber','Int1','Text12'):
#         if col in past.columns:
#             try:
#                 match_mask = match_mask | (past[col].astype(str).fillna('').str.strip() == str(norm).strip())
#             except Exception:
#                 continue

#     if not match_mask.any():
#         try:
#             qnum = float(norm)
#             for col in ('EmployeeID','Int1'):
#                 if col in past.columns:
#                     try:
#                         numcol = pd.to_numeric(past[col], errors='coerce')
#                         match_mask = match_mask | (numcol == qnum)
#                     except Exception:
#                         continue
#         except Exception:
#             pass

#     if not match_mask.any() and 'EmployeeName' in past.columns:
#         names = past['EmployeeName'].dropna().astype(str).unique().tolist()
#         close = difflib.get_close_matches(str(identifier), names, n=5, cutoff=0.7)
#         if close:
#             match_mask = match_mask | past['EmployeeName'].astype(str).isin(close)

#     return past[match_mask].copy()

# def _explain_scenario_code(code):
#     if not code:
#         return None
#     code = str(code).strip()
#     if code in SCENARIO_EXPLANATIONS:
#         try:
#             fn = SCENARIO_EXPLANATIONS.get(code)
#             try:
#                 txt = fn({})
#                 return txt
#             except Exception:
#                 return code.replace("_", " ").replace(">= ", "≥ ")
#         except Exception:
#             return code.replace("_", " ").replace(">= ", "≥ ")
#     return code.replace("_", " ").replace(">=", "≥")

# def _map_score_to_label_fallback(score: float):
#     try:
#         s = float(score)
#     except Exception:
#         return (0.0, "Low")
#     if s >= 0.75:
#         return (s, "High")
#     if s >= 0.4:
#         return (s, "Medium")
#     return (s, "Low")

# @app.route('/chatbot/query', methods=['POST'])
# def chatbot_query():
#     payload = request.get_json(force=True)
#     q = (payload.get('q') or '').strip()
#     if not q:
#         return jsonify({"error":"query text 'q' required"}), 400
#     lang = payload.get('lang')
#     q_l = q.lower().strip()

#     if re.search(r"\bwho is (high|low) risk\b", q_l) or re.search(r"\b(high|low) risk (people|persons|people) (today)?\b", q_l):
#         want = 'high' if 'high' in q_l else 'low' if 'low' in q_l else None
#         df, fname = _load_latest_trend_df(DEFAULT_OUTDIR)
#         if df is None:
#             return jsonify({"answer": "No trend data available.", "evidence": []})
#         if 'RiskLevel' not in df.columns:
#             if 'RiskScore' in df.columns:
#                 def _map_rs(s):
#                     try:
#                         if pd.isna(s):
#                             return 'Low'
#                     except Exception:
#                         pass
#                     try:
#                         if 'map_score_to_label' in globals() and callable(globals().get('map_score_to_label')):
#                             try:
#                                 return globals().get('map_score_to_label')(float(s))[1]
#                             except Exception:
#                                 pass
#                         return _map_score_to_label_fallback(float(s))[1]
#                     except Exception:
#                         return 'Low'
#                 df['RiskLevel'] = df['RiskScore'].apply(lambda s: _map_rs(s))
#             else:
#                 df['RiskLevel'] = df.get('RiskLevel', 'Low')
#         if want == 'high':
#             sel = df[df['RiskLevel'].astype(str).str.lower() == 'high']
#         elif want == 'low':
#             sel = df[df['RiskLevel'].astype(str).str.lower() == 'low']
#         else:
#             sel = df
#         names = sel['EmployeeName'].dropna().astype(str).unique().tolist()
#         if not names:
#             ans = f"No {want} risk persons found in the latest data." if want else "No persons found."
#             return jsonify({"answer": ans, "evidence": []})
#         else:
#             ans = f"{want.capitalize()} risk persons today: " + ", ".join(names[:40])
#             sample = _clean_sample_df(sel.head(10), max_rows=10)
#             return jsonify({"answer": ans, "evidence": sample})

#     m = re.match(r".*\bexplain\s+([A-Za-z0-9_\-]+)\b.*", q_l)
#     if m:
#         code = m.group(1).strip()
#         explanation = _explain_scenario_code(code)
#         ans = f"Explanation for '{code}': {explanation}"
#         return jsonify({"answer": ans, "evidence": []})

#     if 'trend details' in q_l or 'top reasons' in q_l or 'trend details for today' in q_l:
#         df, fname = _load_latest_trend_df(DEFAULT_OUTDIR)
#         if df is None:
#             return jsonify({"answer":"No trend data available.","evidence":[]})
#         if 'Reasons' in df.columns:
#             reasons = {}
#             for v in df['Reasons'].dropna().astype(str):
#                 for part in re.split(r'[;,\|]', v):
#                     key = part.strip()
#                     if key and not _is_placeholder_str(key):
#                         reasons[key] = reasons.get(key, 0) + 1
#             top = sorted(reasons.items(), key=lambda x: x[1], reverse=True)[:10]
#             if not top:
#                 return jsonify({"answer":"No reason counts available today.","evidence":[]})
#             ans = "Top reasons today: " + ", ".join([f"{k} ({c})" for k,c in top])
#             sample = []
#             try:
#                 top_reasons = [k for k,_ in top]
#                 mask = df['Reasons'].astype(str).apply(lambda s: any(tr in s for tr in top_reasons))
#                 sample_df = df[mask].head(10)
#                 sample = _clean_sample_df(sample_df, max_rows=10)
#             except Exception:
#                 sample = []
#             return jsonify({"answer": ans, "evidence": sample})

#     m = re.match(r".*\bshow (?:me )?([A-Za-z0-9\-\:\s]+?) (?:for )?(?:last )?(\d+)\s*days\b", q_l)
#     if not m:
#         m = re.match(r".*\b(show|display)\s+(?:me\s+)?([A-Za-z0-9\-\:\s]+?)\s+last\s+(\d+)\s*days\b", q_l)
#     if m:
#         if len(m.groups()) == 2:
#             identifier, days = m.group(1).strip(), int(m.group(2))
#         else:
#             identifier = m.group(1).strip()
#             days = int(m.group(2))
#         rows = _find_person_rows(identifier, days=days, outdir=DEFAULT_OUTDIR)
#         if rows is None or rows.empty:
#             return jsonify({"answer": f"No records found for '{identifier}' in last {days} days.", "evidence": []})
#         flagged = rows[rows.get('IsFlagged', False) == True] if 'IsFlagged' in rows.columns else pd.DataFrame()
#         flagged_count = int(len(flagged))
#         total_days = int(len(rows))
#         latest_row = rows.sort_values('Date', ascending=False).iloc[0].to_dict()
#         name = latest_row.get('EmployeeName') or latest_row.get('person_uid') or latest_row.get('EmployeeID')
#         ans = f"Found {total_days} day(s) for {name} in the last {days} days. Flagged days: {flagged_count}."
#         sample = _clean_sample_df(rows.sort_values('Date', ascending=False).head(10), max_rows=10)
#         return jsonify({"answer": ans, "evidence": sample})

#     if 'present today' in q_l or 'who is present today' in q_l:
#         df, fname = _load_latest_trend_df(DEFAULT_OUTDIR)
#         if df is None:
#             return jsonify({"answer":"No trend data available.","evidence":[]})
#         if 'PresentToday' in df.columns:
#             present = df[df['PresentToday'] == True]
#             names = present['EmployeeName'].dropna().unique().tolist()
#             ans = f"Present today: {', '.join(names[:40]) if names else 'None'}"
#             sample = _clean_sample_df(present.head(10), max_rows=10)
#             return jsonify({"answer": ans, "evidence": sample})
#         else:
#             return jsonify({"answer":"PresentToday field not available in latest trends.","evidence":[]})

#     hint = "I can answer: 'Who is high risk today', 'Who is low risk today', 'Show me <EmployeeID|Name> last 90 days', 'Explain <scenario_code>', 'Trend details for today — top reasons'."
#     return jsonify({"answer": f"I can help with trend & risk questions. I recognized: {q}. Try: {hint}", "evidence":[]})

# @app.route('/employee/<empid>/image', methods=['GET'])
# def serve_employee_image(empid):
#     if empid is None:
#         return jsonify({"error": "employee id required"}), 400
#     try:
#         img_bytes = get_person_image_bytes(empid)
#         # If no image found, return a small inline SVG placeholder so <img> can still render
#         if not img_bytes:
#             svg = (
#                 '<svg xmlns="http://www.w3.org/2000/svg" width="160" height="160">'
#                 '<rect fill="#eef2f7" width="100%" height="100%"/>'
#                 '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#64748b" font-size="18">'
#                 'No image</text></svg>'
#             )
#             bio = io.BytesIO(svg.encode('utf-8'))
#             bio.seek(0)
#             resp = send_file(bio, mimetype='image/svg+xml')
#             resp.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
#             return resp

#         # detect content type heuristically (jpeg/png/bmp)
#         header = img_bytes[:8] if isinstance(img_bytes, (bytes, bytearray)) else bytes(img_bytes)[:8]
#         content_type = 'application/octet-stream'
#         try:
#             if len(header) >= 2 and header[0] == 0xFF and header[1] == 0xD8:
#                 content_type = 'image/jpeg'
#             elif header.startswith(b'\x89PNG\r\n\x1a\n'):
#                 content_type = 'image/png'
#             elif header.startswith(b'BM'):
#                 content_type = 'image/bmp'
#             else:
#                 content_type = 'application/octet-stream'
#         except Exception:
#             content_type = 'application/octet-stream'

#         bio = io.BytesIO(img_bytes if isinstance(img_bytes, (bytes, bytearray)) else bytes(img_bytes))
#         bio.seek(0)
#         resp = send_file(bio, mimetype=content_type)
#         resp.headers['Cache-Control'] = 'private, max-age=300'
#         return resp
#     except Exception:
#         logging.exception("Error serving image for employee %s", empid)
#         return jsonify({"error": "failed to serve image"}), 500

# # run
# if __name__ == "__main__":
#     app.run(host="0.0.0.0", port=8002, debug=True)


















# backend/app.py
from flask import Flask, jsonify, request, send_from_directory, jsonify, send_file
from datetime import datetime, timedelta, date
from pathlib import Path
import logging
import pandas as pd
import numpy as np
import joblib
import math
import re
import io
import base64
import os
import difflib
from io import BytesIO
from flask import send_file  # add if not present
from pathlib import Path
from typing import Optional, List, Dict, Any
from duration_report import REGION_CONFIG
from datetime import date, timedelta, datetime
from flask import jsonify, request
import logging
logging.basicConfig(level=logging.INFO)
#from trend_runner import run_trend_for_date, build_monthly_training, OUTDIR
from trend_runner import run_trend_for_date, build_monthly_training, _enrich_with_personnel_info
from config.door_zone import map_door_to_zone, BREAK_ZONES, OUT_OF_OFFICE_ZONE


# app = Flask(__name__)

OUTDIR = Path("./outputs")

def _safe_read_csv(fp):
    try:
        return pd.read_csv(fp, parse_dates=['LocaleMessageTime'], low_memory=False)
    except Exception:
        try:
            return pd.read_csv(fp, low_memory=False)
        except Exception:
            return pd.DataFrame()


# ---------- Ensure outputs directory exists early (so OVERRIDES_FILE can be defined safely) ----------
BASE_DIR = Path(__file__).parent.resolve()
DEFAULT_OUTDIR = BASE_DIR / "outputs"
DEFAULT_OUTDIR.mkdir(parents=True, exist_ok=True)

OVERRIDES_FILE = DEFAULT_OUTDIR / "overrides.csv"


def _load_overrides():
    if not OVERRIDES_FILE.exists():
        return {}
    try:
        df = pd.read_csv(OVERRIDES_FILE, dtype=str)
        out = {}
        for _, r in df.iterrows():
            emp = str(r.get('EmployeeID') or r.get('person_uid') or '').strip()
            if not emp:
                continue
            out[emp] = {
                'level': str(r.get('OverrideLevel') or '').strip(),
                'reason': str(r.get('Reason') or '').strip(),
                'ts': str(r.get('Timestamp') or '').strip()
            }
        return out
    except Exception:
        logging.exception("Failed reading overrides file")
        return {}

def _save_override(employee_key, level, reason):
    now = datetime.now().isoformat()
    row = {'EmployeeID': employee_key, 'OverrideLevel': level, 'Reason': reason or '', 'Timestamp': now}
    try:
        if OVERRIDES_FILE.exists():
            df = pd.read_csv(OVERRIDES_FILE, dtype=str)
            # pandas.DataFrame.append is deprecated -> use concat
            df = pd.concat([df, pd.DataFrame([row])], ignore_index=True)
        else:
            df = pd.DataFrame([row])
        df.to_csv(OVERRIDES_FILE, index=False)
        return True
    except Exception:
        logging.exception("Failed to save override")
        return False

def _slug_city(s):
    """
    Convert a city/site string into a safe slug: lowercase, alphanumeric+hyphen
    """
    if not s:
        return ''
    # Remove special chars, spaces to hyphens, lower
    slug = re.sub(r'[^\w\s-]', '', str(s)).strip().lower()
    slug = re.sub(r'[\s_]+', '-', slug)
    return slug


# --- Use REGION_CONFIG servers to talk to ACVSCore (no separate ACVSCORE_DB_CONFIG) ---
# ODBC driver variable is already defined later: ODBC_DRIVER (safe to reference only at runtime)

_acvscore_backoff = {"ts": None, "failed": False}
_ACVSCORE_BACKOFF_SECONDS = 20

def _get_acvscore_conn():
    """
    Try to connect to ACVSCore by reusing credentials from REGION_CONFIG.
    Loops through REGION_CONFIG entries and attempts:
      1) SQL auth (UID/PWD) to database "ACVSCore" using region server + credentials
      2) If SQL auth fails on that server, try Trusted_Connection (Windows auth) as a fallback
    If that fails, optionally attempt ACVSCORE_DB_CONFIG if defined (safe: checked via globals()).
    Returns first successful pyodbc connection or None.
    Implements a short backoff after recent failure to reduce log noise.
    """
    try:
        import pyodbc
    except Exception:
        logging.exception("pyodbc not installed; ACVSCore lookups unavailable.")
        return None

    # basic backoff: skip attempts if we just failed recently
    from datetime import datetime
    now = datetime.now().timestamp()
    last = _acvscore_backoff.get("ts")
    if last and _acvscore_backoff.get("failed") and (now - last) < _ACVSCORE_BACKOFF_SECONDS:
        logging.debug("Skipping ACVSCore connection attempt (backoff active).")
        return None

    # iterate region servers (use the same credentials defined in REGION_CONFIG)
    tried = []
    for region_key, rc in (REGION_CONFIG or {}).items():
        server = rc.get("server")
        user = rc.get("user")
        pwd = rc.get("password")
        if not server:
            continue

        # Try SQL auth first if credentials present
        if user and pwd:
            tried.append(f"{region_key}@{server}(sql)")
            conn_str = (
                f"DRIVER={{{ODBC_DRIVER}}};"
                f"SERVER={server};DATABASE=ACVSCore;UID={user};PWD={pwd};"
                "TrustServerCertificate=Yes;"
            )
            try:
                conn = pyodbc.connect(conn_str, autocommit=True, timeout=5)
                logging.info("Connected to ACVSCore on server %s using REGION_CONFIG[%s] (sql auth).", server, region_key)
                _acvscore_backoff["ts"] = None
                _acvscore_backoff["failed"] = False
                return conn
            except Exception as e:
                logging.debug("SQL auth to %s failed: %s", server, e)

        # Try Trusted Connection fallback on same server
        tried.append(f"{region_key}@{server}(trusted)")
        conn_str_trusted = (
            f"DRIVER={{{ODBC_DRIVER}}};"
            f"SERVER={server};DATABASE=ACVSCore;Trusted_Connection=yes;"
            "TrustServerCertificate=Yes;"
        )
        try:
            conn = pyodbc.connect(conn_str_trusted, autocommit=True, timeout=5)
            logging.info("Connected to ACVSCore on server %s using REGION_CONFIG[%s] (trusted connection).", server, region_key)
            _acvscore_backoff["ts"] = None
            _acvscore_backoff["failed"] = False
            return conn
        except Exception as e:
            logging.debug("Trusted connection to %s failed: %s", server, e)
            continue

    # Fallback: if a global ACVSCORE_DB_CONFIG exists, try it (safe check)
    try:
        if 'ACVSCORE_DB_CONFIG' in globals() and isinstance(globals().get('ACVSCORE_DB_CONFIG'), dict):
            cfg = globals().get('ACVSCORE_DB_CONFIG')
            server = cfg.get('server')
            user = cfg.get('user')
            pwd = cfg.get('password')
            database = cfg.get('database', 'ACVSCore')
            tried.append(f"ACVSCORE_DB_CONFIG@{server}")
            try:
                conn_str = (
                    f"DRIVER={{{ODBC_DRIVER}}};"
                    f"SERVER={server};DATABASE={database};UID={user};PWD={pwd};"
                    "TrustServerCertificate=Yes;"
                )
                conn = pyodbc.connect(conn_str, autocommit=True, timeout=5)
                logging.info("Connected to ACVSCore using ACVSCORE_DB_CONFIG (%s).", server)
                _acvscore_backoff["ts"] = None
                _acvscore_backoff["failed"] = False
                return conn
            except Exception as e:
                logging.debug("ACVSCORE_DB_CONFIG connection failed: %s", e)
    except Exception:
        # defensive: do not propagate any errors from fallback logic
        logging.debug("ACVSCORE_DB_CONFIG fallback not available or failed.")

    # record failure to backoff
    _acvscore_backoff["ts"] = now
    _acvscore_backoff["failed"] = True
    logging.error("Failed to connect to ACVSCore using REGION_CONFIG servers. Tried: %s", tried)
    return None


# ODBC driver (keep existing env-based driver)
ODBC_DRIVER = os.getenv("ODBC_DRIVER", "ODBC Driver 17 for SQL Server")

MODELS_DIR = Path(__file__).parent / "models"
_loaded_models = {}

def load_model(name):
    if name in _loaded_models:
        return _loaded_models[name]
    p = MODELS_DIR / f"{name}.joblib"
    if not p.exists():
        return None
    data = joblib.load(p)
    _loaded_models[name] = data
    return data



def get_personnel_info(candidate_identifier: object) -> Dict[str, Any]:
    out: Dict[str, Any] = {}
    logging.info("get_personnel_info: lookup called with candidate_identifier=%s", candidate_identifier)
    if candidate_identifier is None:
        logging.debug("get_personnel_info: no candidate provided")
        return out
    conn = _get_acvscore_conn()
    if conn is None:
        logging.info("get_personnel_info: ACVSCore connection unavailable (skipping DB lookup)")
        return out
    try:
        cur = conn.cursor()
        sql = """
            SELECT TOP 1 ObjectID, GUID, Name, EmailAddress, ManagerEmail
            FROM ACVSCore.Access.Personnel
            WHERE
              (CAST(ObjectID AS NVARCHAR(200)) = ?)
              OR (GUID = ?)
              OR (CAST(Int1 AS NVARCHAR(200)) = ?)
              OR (Text12 = ?)
              OR (Name = ?)
            ORDER BY ObjectID DESC
        """
        cand = str(candidate_identifier).strip()
        params = (cand, cand, cand, cand, cand)
        cur.execute(sql, params)
        row = cur.fetchone()
        if row:
            # columns: ObjectID, GUID, Name, EmailAddress, ManagerEmail
            try:
                out['ObjectID'] = row[0]
                out['GUID'] = row[1]
                out['Name'] = row[2]
                # canonical email fields (provide aliases for downstream code)
                email_val = row[3] if len(row) > 3 else None
                out['EmailAddress'] = email_val or None
                out['EmployeeEmail'] = email_val or None
                out['Email'] = email_val or None
                out['ManagerEmail'] = row[4] if len(row) > 4 else None
            except Exception:
                out = {
                    'ObjectID': row[0] if len(row) > 0 else None,
                    'GUID': row[1] if len(row) > 1 else None,
                    'Name': row[2] if len(row) > 2 else None,
                    'EmailAddress': row[3] if len(row) > 3 else None,
                    'EmployeeEmail': row[3] if len(row) > 3 else None,
                    'Email': row[3] if len(row) > 3 else None,
                    'ManagerEmail': row[4] if len(row) > 4 else None
                }
            logging.info("get_personnel_info: found personnel row for candidate=%s -> ObjectID=%s Email=%s",
                         candidate_identifier, out.get('ObjectID'), out.get('EmailAddress'))
        else:
            logging.debug("get_personnel_info: no personnel row found for candidate=%s", candidate_identifier)
    except Exception:
        logging.exception("Failed personnel lookup for candidate: %s", candidate_identifier)
    finally:
        try:
            cur.close()
        except Exception:
            pass
        try:
            conn.close()
        except Exception:
            pass

    return out




def get_person_image_bytes(parent_id) -> Optional[bytes]:
    logging.info("get_person_image_bytes: lookup for ParentId=%s", parent_id)
    # 1) try DB (as before) — keep behaviour if available
    try:
        conn = _get_acvscore_conn()
        if conn is not None:
            try:
                cur = conn.cursor()
                sql = """
                    SELECT TOP 1 AI.Image
                    FROM ACVSCore.Access.Images AI
                    WHERE AI.ParentId = ?
                      AND DATALENGTH(AI.Image) > 0
                    ORDER BY AI.ObjectID DESC
                """
                cur.execute(sql, (str(parent_id),))
                row = cur.fetchone()
                if row and row[0] is not None:
                    logging.info("get_person_image_bytes: image found in DB for ParentId=%s (len=%d)", parent_id, len(row[0]) if row[0] else 0)
                    try:
                        b = bytes(row[0])
                        return b
                    except Exception:
                        return row[0]
            except Exception:
                logging.exception("Failed to fetch image for ParentId=%s via DB", parent_id)
            finally:
                try:
                    cur.close()
                except Exception:
                    pass
                try:
                    conn.close()
                except Exception:
                    pass
    except Exception:
        logging.debug("ACVSCore DB unavailable for image lookup; will try filesystem fallbacks for ParentId=%s", parent_id)

    # 2) Try filesystem fallbacks under DEFAULT_OUTDIR (use typical file extensions)
    try:
        # ensure DEFAULT_OUTDIR exists and convert parent_id to safe filename
        cand_ids = []
        if parent_id is None:
            return None
        pid_raw = str(parent_id).strip()
        # add raw and numeric-only variants
        cand_ids.append(pid_raw)
        try:
            # if numeric-like, add int form
            if '.' in pid_raw:
                f = float(pid_raw)
                if f.is_integer():
                    cand_ids.append(str(int(f)))
        except Exception:
            pass
        # also try stripped non-alphanumeric variants
        cand_ids = list(dict.fromkeys(cand_ids))

        for c in cand_ids:
            for folder in (Path(DEFAULT_OUTDIR) / "images", Path(DEFAULT_OUTDIR), Path(".")):
                if not folder.exists():
                    continue
                for ext in (".jpg", ".jpeg", ".png", ".bmp", ".gif", ".webp"):
                    fp = folder / (f"{c}{ext}")
                    logging.debug("get_person_image_bytes: checking path %s", fp)
                    if fp.exists() and fp.is_file():
                        logging.info("get_person_image_bytes: loaded image file %s", fp)
                        try:
                            return fp.read_bytes()
                        except Exception:
                            continue
                # also try files where parent_id might be part of filename
                for fp in folder.glob(f"*{c}*"):
                    logging.debug("get_person_image_bytes: checking glob match %s", fp)
                    if fp.is_file():
                        try:
                            b = fp.read_bytes()
                            if b:
                                logging.info("get_person_image_bytes: loaded image via glob %s", fp)
                                return b
                        except Exception:
                            continue
    except Exception:
        logging.exception("Filesystem image lookup failed for ParentId=%s", parent_id)

    # nothing found
    return None


# ---------- New route to serve employee image ----------
# We'll import send_file later where used; define route after app created.

# Try to enable CORS
try:
    from flask_cors import CORS
    has_cors = True
except Exception:
    CORS = None
    has_cors = False

app = Flask(__name__, static_folder=None)
if has_cors:
    CORS(app)
else:
    logging.warning("flask_cors not available; continuing without CORS.")

logging.basicConfig(level=logging.INFO)

# send_file is needed for Excel responses
from flask import send_file
try:
    # optional import; used for styling
    from openpyxl import load_workbook
    from openpyxl.styles import Font, Alignment, Border, Side
    OPENPYXL_AVAILABLE = True
except Exception:
    OPENPYXL_AVAILABLE = False

def _to_python_scalar(x):
    """
    Convert numpy/pandas scalar types to built-in Python types and
    convert NaN-like values to None so JSON is safe.
    """
    try:
        import pandas as _pd
        if isinstance(x, _pd.Timestamp):
            return x.to_pydatetime().isoformat()
    except Exception:
        pass

    try:
        import numpy as _np
        if isinstance(x, _np.generic):
            v = x.item()
            if isinstance(v, float) and _np.isnan(v):
                return None
            return v
    except Exception:
        pass

    try:
        if isinstance(x, float) and math.isnan(x):
            return None
    except Exception:
        pass

    if isinstance(x, (datetime,)):
        return x.isoformat()
    if isinstance(x, (bool, int, str, type(None), float)):
        # convert floats NaN handled above
        return x
    try:
        # fallback to string
        return str(x)
    except Exception:
        return None


_uuid_like_re = re.compile(r'^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$')

def _looks_like_guid(s):
    try:
        if not s or not isinstance(s, str):
            return False
        s = s.strip()
        return bool(_uuid_like_re.match(s)) or s.startswith('name:') or s.startswith('emp:') or s.startswith('uid:')
    except Exception:
        return False


# Helper: format seconds to HH:MM:SS
def format_seconds_to_hms(seconds):
    try:
        if seconds is None:
            return None
        # guard against floats and NaN
        s = int(float(seconds))
        if s < 0:
            s = 0
        hh = s // 3600
        mm = (s % 3600) // 60
        ss = s % 60
        return f"{hh:02d}:{mm:02d}:{ss:02d}"
    except Exception:
        return None


# Placeholder tokens (keep consistent with trend_runner expectations)
_PLACEHOLDER_STRS = set(['', 'nan', 'na', 'n/a', '-', '—', '–', 'none', 'null'])

def _is_placeholder_str(s: object) -> bool:
    try:
        if s is None:
            return True
        st = str(s).strip().lower()
        return st in _PLACEHOLDER_STRS
    except Exception:
        return False


_CARD_XML_RE = re.compile(r'<Card>([^<]+)</Card>', re.IGNORECASE | re.DOTALL)
def _extract_card_from_xml_text(txt):
    try:
        if not txt or not isinstance(txt, str):
            return None
        m = _CARD_XML_RE.search(txt)
        if m:
            return m.group(1).strip()
        m2 = re.search(r'CHUID.*?Card.*?[:=]\s*([0-9A-Za-z\-\_]+)', txt, re.IGNORECASE | re.DOTALL)
        if m2:
            return m2.group(1).strip()
    except Exception:
        pass
    return None


def _resolve_field_from_record(record: dict, candidate_tokens: list):
    """
    Search a single row `record` (dict) for likely columns listed in candidate_tokens.
    Return first non-placeholder value found (converted to Python scalar), else None.
    """
    if record is None:
        return None

    # 1) exact key matches (case-sensitive & common casing)
    for key in candidate_tokens:
        if key in record:
            v = record.get(key)
            if v is None:
                continue
            if isinstance(v, float) and math.isnan(v):
                continue
            sval = str(v).strip()
            if sval and not _is_placeholder_str(sval):
                return _to_python_scalar(v)

    # 2) case-insensitive contains match
    lower_keys = {k.lower(): k for k in record.keys()}
    for tok in candidate_tokens:
        tok_l = tok.lower()
        for lk, orig_key in lower_keys.items():
            if tok_l in lk:
                v = record.get(orig_key)
                if v is None:
                    continue
                if isinstance(v, float) and math.isnan(v):
                    continue
                sval = str(v).strip()
                if sval and not _is_placeholder_str(sval):
                    return _to_python_scalar(v)

    # 3) xml / value parsing fallback for CardNumber
    card_like = any(tok.lower() in ('cardnumber', 'chuid', 'card') for tok in candidate_tokens)
    if card_like:
        for lk, orig_key in lower_keys.items():
            if 'xml' in lk or 'xmlmessage' in lk or 'xml_msg' in lk or 'msg' in lk or 'value' == lk:
                v = record.get(orig_key)
                if v is None:
                    continue
                try:
                    txt = str(v)
                    extracted = _extract_card_from_xml_text(txt)
                    if extracted and not _is_placeholder_str(extracted):
                        return _to_python_scalar(extracted)
                except Exception:
                    continue

    # 4) final fallback: first non-placeholder value
    for k, v in record.items():
        if v is None:
            continue
        if isinstance(v, float) and math.isnan(v):
            continue
        sval = str(v).strip()
        if sval and not _is_placeholder_str(sval):
            return _to_python_scalar(v)

    return None


def _clean_sample_df(df: pd.DataFrame, max_rows: int = 10):
    """
    Clean a dataframe for JSON output (convert NaN -> None, pandas types -> native, format datetimes).
    """
    if df is None or df.empty:
        return []
    df = df.copy()

    # remove duplicate suffix columns
    cols_to_fix = [c for c in df.columns if c.endswith('_x') or c.endswith('_y')]
    for c in cols_to_fix:
        base = c[:-2]
        if base in df.columns:
            try:
                df.drop(columns=[c], inplace=True)
            except Exception:
                pass
        else:
            try:
                df.rename(columns={c: base}, inplace=True)
            except Exception:
                pass

    # Date normalization
    if 'Date' in df.columns:
        try:
            df['Date'] = pd.to_datetime(df['Date'], errors='coerce').dt.date
            df['Date'] = df['Date'].apply(lambda d: d.isoformat() if pd.notna(d) else None)
        except Exception:
            pass

    # Datetime columns to ISO strings
    for dtcol in ('FirstSwipe', 'LastSwipe', 'LocaleMessageTime'):
        if dtcol in df.columns:
            try:
                df[dtcol] = pd.to_datetime(df[dtcol], errors='coerce')
                df[dtcol] = df[dtcol].apply(lambda t: t.to_pydatetime().isoformat() if pd.notna(t) else None)
            except Exception:
                try:
                    df[dtcol] = df[dtcol].astype(str).replace('NaT', None)
                except Exception:
                    pass

    # Replace NaN/inf -> None
    df = df.where(pd.notnull(df), None)

    # Convert records to safe Python types
    rows = df.head(max_rows).to_dict(orient='records')
    cleaned = []
    for r in rows:
        out = {}
        for k, v in r.items():
            out[k] = _to_python_scalar(v)

        # Typical fields
        emp_name = out.get('EmployeeName')
        emp_id = out.get('EmployeeID') or out.get('EmployeeIdentity')
        person_uid = out.get('person_uid')

        # ----- Schema-aware fallback resolution -----
        if not emp_id:
            emp_tokens = ['Int1', 'Text12', 'EmployeeID', 'empid', 'id']
            resolved_emp = _resolve_field_from_record(r, emp_tokens)
            if resolved_emp is not None:
                try:
                    s = str(resolved_emp).strip()
                    # remove trailing .0 for floats
                    if '.' in s:
                        f = float(s)
                        if math.isfinite(f) and f.is_integer():
                            s = str(int(f))
                    if _looks_like_guid(s):
                        out['EmployeeID'] = None
                        emp_id = None
                    else:
                        out['EmployeeID'] = s
                        emp_id = s
                except Exception:
                    if _looks_like_guid(resolved_emp):
                        out['EmployeeID'] = None
                        emp_id = None
                    else:
                        out['EmployeeID'] = resolved_emp
                        emp_id = resolved_emp

        # Prefer Credential.CardNumber / CHUID / Card as CardNumber when missing — reject GUIDs/placeholders
        if out.get('CardNumber') in (None, '', 'nan'):
            card_tokens = ['CardNumber', 'CHUID', 'Card', 'card_no', 'cardnum']
            resolved_card = _resolve_field_from_record(r, card_tokens)
            if resolved_card is not None:
                try:
                    cs = str(resolved_card).strip()
                    if _looks_like_guid(cs) or _is_placeholder_str(cs):
                        out['CardNumber'] = None
                    else:
                        out['CardNumber'] = cs
                except Exception:
                    out['CardNumber'] = None

        # final safety: ensure EmployeeID/CardNumber are not GUID-like tokens
        if 'EmployeeID' in out and isinstance(out['EmployeeID'], str) and _looks_like_guid(out['EmployeeID']):
            out['EmployeeID'] = None
        if 'CardNumber' in out and isinstance(out['CardNumber'], str) and _looks_like_guid(out['CardNumber']):
            out['CardNumber'] = None

        # If EmployeeName empty or looks like a GUID, prefer EmployeeID (human id) over GUIDs
        if (emp_name in (None, '', 'nan')) or (isinstance(emp_name, str) and _looks_like_guid(emp_name)):
            if emp_id not in (None, '', 'nan') and not _looks_like_guid(emp_id):
                out['EmployeeName'] = str(emp_id)
            else:
                out['EmployeeName'] = None

        cleaned.append(out)
    return cleaned

# ----- Helpers added to match commented (Pune) file functionality but multi-city-aware -----

def _replace_placeholder_strings(obj):
    """
    If obj is a DataFrame, replace known placeholder strings with None (NaN).
    If obj is a scalar/string, return None for placeholder strings else return obj.
    """
    if obj is None:
        return obj
    try:
        if isinstance(obj, pd.DataFrame):
            df = obj.copy()
            for col in df.columns:
                try:
                    # Replace placeholder strings (case-insensitive)
                    df[col] = df[col].apply(lambda x: None if _is_placeholder_str(x) else x)
                except Exception:
                    continue
            return df
        else:
            # scalar
            return None if _is_placeholder_str(obj) else obj
    except Exception:
        return obj

def _normalize_id_local(v):
    """
    Normalize an identifier for robust matching/counting:
    - treat NaN/None/empty as None
    - strip and convert float-like integers to integer strings
    """
    try:
        if pd.isna(v):
            return None
    except Exception:
        pass
    if v is None:
        return None
    s = str(v).strip()
    if s == '' or s.lower() == 'nan':
        return None
    try:
        if '.' in s:
            fv = float(s)
            if math.isfinite(fv) and fv.is_integer():
                s = str(int(fv))
    except Exception:
        pass
    return s





def _find_swipe_files(outdir: Path, date_obj: Optional[date] = None, city_slug: Optional[str] = None):
    """
    Robust swipe-file discovery.
    - Supports filenames like:
        - swipes_YYYYMMDD.csv
        - swipes_<city>_YYYYMMDD.csv
        - <region>_swipes_YYYYMMDD.csv
        - <region>_swipes_*.csv
        - any file containing '_swipes_' or starting with 'swipes'
        - fallback: any file that ends with _YYYYMMDD.csv
    - If date_obj is None, returns recent files that look like swipe files.
    - Returns list of Path objects sorted by mtime (newest first).
    """
    p = Path(outdir)
    files_set = set()
    try:
        # Normalize city slug for matching
        city_slug_l = (city_slug or "").lower().strip()

        def add_glob(pattern):
            try:
                for fp in p.glob(pattern):
                    if fp.is_file():
                        files_set.add(fp)
            except Exception:
                pass

        if date_obj is None:
            # recent swipe-like files
            add_glob("*_swipes_*.csv")        # region_swipes_YYYY or region_swipes_any.csv
            add_glob("swipes_*.csv")         # swipes_YYYY or swipes_city_YYYY
            add_glob("*swipes*.csv")         # permissive
            add_glob("*_swipes.csv")
            # also include any file that includes 'swipe' (some exporters use 'swipe' singular)
            add_glob("*swipe*.csv")
            # city-specific guesses
            if city_slug_l:
                add_glob(f"*{city_slug_l}*_swipes_*.csv")
                add_glob(f"*{city_slug_l}*swipes*.csv")
                add_glob(f"*{city_slug_l}*.csv")
        else:
            target = date_obj.strftime("%Y%m%d")
            # common patterns observed in pipeline
            patterns = [
                f"*_{target}.csv",                 # anything ending _YYYYMMDD.csv
                f"*_swipes_{target}.csv",         # region_swipes_YYYYMMDD.csv or swipes_YYYYMMDD
                f"swipes*_{target}.csv",
                f"swipes_{target}.csv",
                f"*swipes*_{target}.csv",
                f"*{city_slug_l}*_{target}.csv",
                f"*{city_slug_l}*swipes*_{target}.csv",
                f"*{city_slug_l}_{target}.csv"
            ]
            for pat in patterns:
                add_glob(pat)

        # final fallback: any CSV in folder that contains '_swipe' (case-insensitive)
        try:
            for fp in p.iterdir():
                if not fp.is_file():
                    continue
                name = fp.name.lower()
                if ('_swipe' in name) or ('swipe' in name and name.endswith('.csv')):
                    files_set.add(fp)
        except Exception:
            pass

    except Exception:
        logging.exception("Error while searching for swipe files in %s", outdir)

    # sort by modification time (most recent first)
    files = sorted(list(files_set), key=lambda f: f.stat().st_mtime if f.exists() else 0, reverse=True)
    return files

# -----------------------
# Routes
# -----------------------




@app.route('/')
def root():
    return "Trend Analysis API — Multi-city"

@app.route('/run', methods=['GET', 'POST'])
def run_trend():
    params = {}
    if request.method == 'GET':
        params = request.args.to_dict()
    else:
        if request.is_json:
            params = request.get_json(force=True) or {}
        else:
            try:
                params = request.form.to_dict() or {}
            except Exception:
                params = {}

    date_str = (params.get('date') or params.get('Date') or '').strip() or None
    start_str = (params.get('start') or params.get('Start') or '').strip() or None
    end_str = (params.get('end') or params.get('End') or '').strip() or None

    dates = []
    try:
        if date_str:
            dt = datetime.strptime(date_str, "%Y-%m-%d").date()
            dates = [dt]
        elif start_str and end_str:
            s = datetime.strptime(start_str, "%Y-%m-%d").date()
            e = datetime.strptime(end_str, "%Y-%m-%d").date()
            if e < s:
                return jsonify({"error":"end must be >= start"}), 400
            cur = s
            while cur <= e:
                dates.append(cur)
                cur = cur + timedelta(days=1)
        else:
            today = datetime.now().date()
            yesterday = today - timedelta(days=1)
            dates = [yesterday, today]
    except Exception as e:
        return jsonify({"error": f"Invalid date format: {e}"}), 400

    regions_param = params.get('regions') or params.get('region') or ''
    if regions_param:
        regions = [r.strip().lower() for r in re.split(r'[;,|]', str(regions_param)) if r.strip()]
    else:
        try:
            regions = [k.lower() for k in list(REGION_CONFIG.keys())]
        except Exception:
            regions = ['apac']

    valid_regions = []
    for r in regions:
        if r in (REGION_CONFIG or {}):
            valid_regions.append(r)
        else:
            logging.debug("Requested region '%s' not in REGION_CONFIG - skipping", r)
    if not valid_regions:
        valid_regions = [k.lower() for k in REGION_CONFIG.keys()] if REGION_CONFIG else ['apac']
    params['_regions_to_run'] = valid_regions

    city_param = params.get('city') or params.get('site') or params.get('site_name') or None
    city_slug = _slug_city(city_param) if city_param else None
    params['_city'] = city_slug

    combined_rows = []
    files = []

    # ---------------------------
    # Run trend for each requested date
    # ---------------------------
    for d in dates:
        try:
            if run_trend_for_date is None:
                raise RuntimeError("run_trend_for_date helper not available in trend_runner")
            try:
                df = run_trend_for_date(d, regions=valid_regions, outdir=str(DEFAULT_OUTDIR), city=city_slug)
            except TypeError:
                try:
                    df = run_trend_for_date(d, outdir=str(DEFAULT_OUTDIR))
                except Exception:
                    # Last-resort: try duration_report fallback if available
                    try:
                        from duration_report import run_for_date as _dr_run_for_date
                        region_results = _dr_run_for_date(d, valid_regions, str(DEFAULT_OUTDIR), city_param)
                        combined_list = []
                        for rkey, res in (region_results or {}).items():
                            try:
                                df_dur = res.get('durations')
                                if df_dur is not None and not df_dur.empty:
                                    combined_list.append(df_dur)
                            except Exception:
                                continue
                        df = pd.concat(combined_list, ignore_index=True) if combined_list else pd.DataFrame()
                    except Exception:
                        raise
        except Exception as e:
            logging.exception("run_trend_for_date failed for %s", d)
            return jsonify({"error": f"runner failed for {d}: {e}"}), 500

        csv_path = DEFAULT_OUTDIR / f"trend_{city_slug}_{d.strftime('%Y%m%d')}.csv"
        if csv_path.exists():
            files.append(csv_path.name)

        if df is None or (hasattr(df, 'empty') and df.empty):
            continue

        try:
            df = _replace_placeholder_strings(df)
        except Exception:
            pass

        if 'IsFlagged' not in df.columns:
            df['IsFlagged'] = False
        if 'Reasons' not in df.columns:
            df['Reasons'] = None

        combined_rows.append(df)

    # *** Important: combine after loop to avoid UnboundLocalError and extra repeated concat inside loop ***
    try:
        combined_df = pd.concat(combined_rows, ignore_index=True) if combined_rows else pd.DataFrame()
    except Exception:
        combined_df = pd.DataFrame()

    try:
        if not combined_df.empty:
            if 'person_uid' in combined_df.columns:
                raw_unique_person_uids = int(combined_df['person_uid'].dropna().astype(str).nunique())
            elif 'EmployeeID' in combined_df.columns:
                raw_unique_person_uids = int(combined_df['EmployeeID'].dropna().astype(str).nunique())
            else:
                raw_unique_person_uids = int(len(combined_df))
        else:
            raw_unique_person_uids = 0
    except Exception:
        raw_unique_person_uids = int(len(combined_df)) if combined_df is not None else 0

    try:
        if not combined_df.empty and 'IsFlagged' in combined_df.columns:
            flagged_df = combined_df[combined_df['IsFlagged'] == True].copy()
        else:
            flagged_df = pd.DataFrame()
    except Exception:
        flagged_df = pd.DataFrame()

    try:
        analysis_count = int(raw_unique_person_uids)
    except Exception:
        analysis_count = int(len(combined_df)) if combined_df is not None else 0

    try:
        flagged_count = int(len(flagged_df))
        flagged_rate_pct = float((flagged_count / analysis_count * 100.0) if analysis_count and analysis_count > 0 else 0.0)
    except Exception:
        flagged_count = int(len(flagged_df))
        flagged_rate_pct = 0.0

    try:
        sample_source = flagged_df if not flagged_df.empty else combined_df
        samples = _clean_sample_df(sample_source.head(10), max_rows=10) if sample_source is not None and not sample_source.empty else []
    except Exception:
        samples = []

    # -----------------------------
    # NEW: Enrich the sample rows with EmployeeEmail and imageUrl using trend_runner helper
    # -----------------------------
    try:
        if isinstance(samples, list) and samples:
            try:
                base = (request.url_root or request.host_url).rstrip('/')
            except Exception:
                base = ''
            try:
                # build a small dataframe and call trend_runner enrichment helper
                tmp_df = pd.DataFrame(samples)
                # pass a fully-qualified image endpoint template so frontend img src works directly
                template = "/employee/{}/image"
                if base:
                    # result will be like: http://host:port/employee/<id>/image
                    template = f"{base}/employee/{{}}/image"
                enriched = _enrich_with_personnel_info(tmp_df, image_endpoint_template=template)
                # ensure Python native types and safe values via cleaning function
                enriched_clean = _clean_sample_df(enriched, max_rows=len(enriched))
                samples = enriched_clean
            except Exception:
                logging.exception("Failed to enrich /run sample with personnel info (non-fatal).")
    except Exception:
        logging.exception("Sample enrichment failed (non-fatal).")

    resp = {
        "start_date": dates[0].isoformat() if dates else None,
        "end_date": dates[-1].isoformat() if dates else None,
        "aggregated_rows_total_raw": int(len(combined_df)),
        "aggregated_unique_persons": int(analysis_count),
        "rows": int(analysis_count),
        "flagged_rows": int(flagged_count),
        "flagged_rate_percent": float(flagged_rate_pct),
        "files": files,
        "sample": (samples[:10] if isinstance(samples, list) else samples),
        "reasons_count": {},
        "risk_counts": {},
        "flagged_persons": (samples if samples else []),
        "_raw_unique_person_uids": int(raw_unique_person_uids),
        "regions_run": params.get('_regions_to_run', []),
        "city_used": city_slug
    }

    return jsonify(resp)



@app.route('/latest', methods=['GET'])
def latest_results():
    city_param = request.args.get('city') or request.args.get('site') or 'pune'
    city_slug = _slug_city(city_param)

    p = Path(DEFAULT_OUTDIR)
    csvs = sorted(p.glob(f"trend_{city_slug}_*.csv"), reverse=True)
    if not csvs:
        csvs = sorted(p.glob("trend_*.csv"), reverse=True)
    if not csvs:
        return jsonify({"error": "no outputs found"}), 404
    latest = csvs[0]

    start_date_iso = None
    end_date_iso = None
    try:
        m = re.search(r'(\d{8})', latest.name)
        if m:
            ymd = m.group(1)
            dt = datetime.strptime(ymd, "%Y%m%d").date()
            start_date_iso = dt.isoformat()
            end_date_iso = dt.isoformat()
    except Exception:
        start_date_iso = None
        end_date_iso = None

    try:
        df = pd.read_csv(latest)
    except Exception:
        df = pd.read_csv(latest, dtype=str)

    df = _replace_placeholder_strings(df)

    id_candidates = ['person_uid', 'EmployeeID', 'EmployeeIdentity', 'Int1']
    id_col = next((c for c in id_candidates if c in df.columns), None)

    def _norm_val_for_latest(v):
        try:
            if pd.isna(v):
                return None
        except Exception:
            pass
        if v is None:
            return None
        s = str(v).strip()
        if s == '' or s.lower() == 'nan':
            return None
        try:
            if '.' in s:
                fv = float(s)
                if math.isfinite(fv) and fv.is_integer():
                    s = str(int(fv))
        except Exception:
            pass
        return s

    if id_col is None:
        unique_persons = int(len(df))
    else:
        ids_series = df[id_col].apply(_norm_val_for_latest) if id_col in df.columns else pd.Series([None]*len(df))
        if id_col != 'person_uid' and 'person_uid' in df.columns:
            ids_series = ids_series.fillna(df['person_uid'].astype(str).replace('nan','').replace('None',''))
        unique_persons = int(len(set([x for x in ids_series.unique() if x])))

    # build initial sample (list of dicts)
    sample = _clean_sample_df(df, max_rows=5)  # returns list




    # --- Enrich sample rows with EmployeeEmail and imageUrl (best-effort) ---
    try:
        if isinstance(sample, list) and sample:
            # compute base once
            try:
                base = (request.url_root or request.host_url).rstrip('/')
            except Exception:
                base = ''

            for s in sample:
                # ensure keys exist (consistent shape)
                s.setdefault('EmployeeEmail', None)
                s.setdefault('imageUrl', None)
                s.setdefault('HasImage', False)

                # pick a lookup token (EmployeeID / person_uid / EmployeeName / EmployeeIdentity)
                lookup_token = (
                    s.get('EmployeeID')
                    or s.get('person_uid')
                    or s.get('EmployeeName')
                    or s.get('EmployeeIdentity')
                )

                pi = {}
                if lookup_token:
                    try:
                        pi = get_personnel_info(lookup_token) or {}
                    except Exception:
                        pi = {}

                # Prefer personnel DB email if available
                if pi:
                    email = pi.get('EmailAddress') or pi.get('EmployeeEmail') or pi.get('Email') or None
                    if email:
                        s['EmployeeEmail'] = email

                    # prefer ObjectID / GUID for images
                    objid = pi.get('ObjectID') or pi.get('GUID') or None
                    if objid:
                        # provide relative image path (frontend resolves with API_BASE)
                        s['imageUrl'] = f"/employee/{objid}/image"
                        try:
                            b = get_person_image_bytes(objid)
                            s['HasImage'] = True if b else False
                        except Exception:
                            s['HasImage'] = False

                # fallback: look up email from the CSV rows read (df) if still missing
                if not s.get('EmployeeEmail') and isinstance(df, pd.DataFrame):
                    try:
                        match_mask = pd.Series(False, index=df.index)
                        if s.get('person_uid') and 'person_uid' in df.columns:
                            match_mask |= df['person_uid'].astype(str).str.strip() == str(s.get('person_uid')).strip()
                        if s.get('EmployeeID') and 'EmployeeID' in df.columns:
                            match_mask |= df['EmployeeID'].astype(str).str.strip() == str(s.get('EmployeeID')).strip()

                        if match_mask.any():
                            idx = df[match_mask].index[0]
                            for col in ('Email', 'EmailAddress', 'EmployeeEmail', 'WorkEmail', 'EMail'):
                                if col in df.columns:
                                    val = df.at[idx, col]
                                    if val not in (None, '', 'nan'):
                                        s['EmployeeEmail'] = val
                                        break
                    except Exception:
                        pass

                # Ensure we at least provide a consistent image route (use EmployeeID/person_uid if no ObjectID)
                if not s.get('imageUrl'):
                    empid = s.get('EmployeeID') or s.get('person_uid')
                    if empid:
                        s['imageUrl'] = f"/employee/{empid}/image"
                        # don't try to check bytes here (avoid extra DB hit) — HasImage remains False if unknown

    except Exception:
        # if enrichment fails, continue (sample remains as-is)
        pass


    resp = {
        
        "file": latest.name,
        "rows_raw": int(len(df)),
        "rows": unique_persons,
        "sample": sample,
        "start_date": start_date_iso,
        "end_date": end_date_iso,
        "city": city_slug
    }
    return jsonify(resp)



@app.route("/record")
def record_endpoint():
    employee_id = request.args.get('employee_id', '').strip()
    if not employee_id:
        return jsonify({'error': 'employee_id required'}), 400

    # 1) find the latest trend CSV that contains this employee
    trend_files = sorted(OUTDIR.glob("trend_*.csv"), reverse=True)
    aggregated_rows = []
    found_date_iso = None
    for tf in trend_files:
        try:
            df = pd.read_csv(tf, dtype=str)
            # normalise columns that might not exist
            cols = df.columns.str.lower()
            # try matching against common id columns
            mask = pd.Series(False, index=df.index)
            for col in ('EmployeeID', 'person_uid', 'EmployeeIdentity', 'CardNumber'):
                if col in df.columns:
                    mask = mask | (df[col].astype(str).fillna('') == employee_id)
            if mask.any():
                # convert matched rows to proper dicts
                matches = df[mask].to_dict(orient='records')
                aggregated_rows = matches
                # pick date from the first match (if available)
                try:
                    d = matches[0].get('Date') or matches[0].get('DisplayDate') or None
                    found_date_iso = d
                except Exception:
                    found_date_iso = None
                break
        except Exception:
            continue

    # 2) list raw swipe files (any swipes_*.csv in outputs)
    raw_swipe_files = [p.name for p in sorted(OUTDIR.glob("swipes_*_*.csv"), reverse=True)]

    # 3) build raw_swipes filtered for this person & date if possible
    raw_swipes = []
    try:
        # read each swipes CSV and filter rows
        for swf in OUTDIR.glob("swipes_*_*.csv"):
            sdf = _safe_read_csv(swf)
            if sdf.empty:
                continue
            # ensure LocaleMessageTime exists as datetime
            if 'LocaleMessageTime' in sdf.columns:
                sdf['LocaleMessageTime'] = pd.to_datetime(sdf['LocaleMessageTime'], errors='coerce')
            else:
                # try fallback candidates
                for cand in ('MessageUTC','MessageTime','Timestamp','timestamp','Date'):
                    if cand in sdf.columns:
                        sdf['LocaleMessageTime'] = pd.to_datetime(sdf[cand], errors='coerce')
                        break
            # filter rows matching employee by either EmployeeID, person_uid, CardNumber or EmployeeIdentity
            sel_mask = pd.Series(False, index=sdf.index)
            for c in ('EmployeeID','person_uid','CardNumber','EmployeeIdentity'):
                if c in sdf.columns:
                    sel_mask = sel_mask | (sdf[c].astype(str).fillna('') == employee_id)
            filtered = sdf[sel_mask]
            if filtered.empty:
                continue
            # compute Date/Time and SwipeGapSeconds for the filtered rows (sorted)
            filtered = filtered.sort_values('LocaleMessageTime')
            filtered['Date'] = filtered['LocaleMessageTime'].dt.date.astype(str)
            filtered['Time'] = filtered['LocaleMessageTime'].dt.time.astype(str)
            filtered['SwipeGapSeconds'] = filtered['LocaleMessageTime'].diff().dt.total_seconds().fillna(0).astype(int)
            filtered['SwipeGap'] = filtered['SwipeGapSeconds'].apply(lambda s: f"{int(s//3600):02d}:{int((s%3600)//60):02d}:{int(s%60):02d}" if s is not None else "-")
            # ensure Zone (if not) by mapping Door/Direction using your map_door_to_zone in trend_runner (import it or reimplement)
            if 'Zone' not in filtered.columns and 'Door' in filtered.columns:
                try:
                    from trend_runner import map_door_to_zone
                    filtered['Zone'] = filtered.apply(lambda r: map_door_to_zone(r.get('Door'), r.get('Direction')), axis=1)
                except Exception:
                    filtered['Zone'] = filtered.get('Zone', None)
            # project the columns the frontend expects
            want = []
            for c in ('EmployeeName','EmployeeID','CardNumber','Date','Time','SwipeGap','SwipeGapSeconds','Door','Direction','Zone','Note','_source'):
                if c in filtered.columns:
                    want.append(c)
            if not want:
                # fallback: return basic fields
                want = list(filtered.columns[:12])
            rows = filtered[want].to_dict(orient='records')
            raw_swipes.extend(rows)
    except Exception:
        # non fatal - return what we have
        pass

    # 4) Enrich aggregated_rows by trying to add Email + imageUrl using trend_runner helper if available
    try:
        from trend_runner import _enrich_with_personnel_info
        if aggregated_rows:
            agg_df = pd.DataFrame(aggregated_rows)
            agg_df = _enrich_with_personnel_info(agg_df, image_endpoint_template="/employee/{}/image")
            aggregated_rows = agg_df.to_dict(orient='records')
    except Exception:
        pass

    return jsonify({
        'aggregated_rows': aggregated_rows,
        'raw_swipe_files': raw_swipe_files,
        'raw_swipes': raw_swipes
    })



#Above Working 


@app.route('/record', methods=['GET'])
def get_record():
    """
    Single unified /record handler:
    - If no employee id passed, return sample of aggregated rows.
    - If employee_id/person_uid passed, return enriched aggregated_rows + raw_swipes + raw_swipe_files.
    Uses DEFAULT_OUTDIR consistently for reading trend and swipe CSVs.
    """
    q = request.args.get('employee_id') or request.args.get('person_uid')
    include_unflagged = str(request.args.get('include_unflagged', '')).lower() in ('1', 'true', 'yes')
    city_param = request.args.get('city') or request.args.get('site') or 'pune'
    city_slug = _slug_city(city_param)

    # Use DEFAULT_OUTDIR consistently (this module-level variable is created earlier)
    p = Path(DEFAULT_OUTDIR)
    csvs = sorted(p.glob(f"trend_{city_slug}_*.csv"), reverse=True)
    if not csvs:
        csvs = sorted(p.glob("trend_*.csv"), reverse=True)
    if not csvs:
        # no trend files -> return empty result set gracefully
        return jsonify({'aggregated_rows': [], 'raw_swipe_files': [], 'raw_swipes': []}), 200

    # build a single DataFrame with all matching trend files
    df_list = []
    for fp in csvs:
        try:
            tmp = pd.read_csv(fp, parse_dates=['Date', 'FirstSwipe', 'LastSwipe'])
        except Exception:
            try:
                tmp = pd.read_csv(fp, dtype=str)
                if 'Date' in tmp.columns:
                    tmp['Date'] = pd.to_datetime(tmp['Date'], errors='coerce').dt.date
            except Exception:
                continue
        df_list.append(tmp)
    if not df_list:
        return jsonify({'aggregated_rows': [], 'raw_swipe_files': [], 'raw_swipes': []}), 200
    df = pd.concat(df_list, ignore_index=True)
    df = _replace_placeholder_strings(df)

    # if no query param, return cleaned sample (head)
    if q is None:
        cleaned = _clean_sample_df(df, max_rows=10)
        return jsonify({'aggregated_rows': cleaned, 'raw_swipe_files': [], 'raw_swipes': []}), 200

    # Normalize query
    q_str = str(q).strip()
    def normalize_series(s):
        if s is None:
            return pd.Series([''] * len(df))
        s = s.fillna('').astype(str).str.strip()
        def _norm_val(v):
            if not v:
                return ''
            try:
                if '.' in v:
                    fv = float(v)
                    if fv.is_integer():
                        return str(int(fv))
            except Exception:
                pass
            return v
        return s.map(_norm_val)

    # find matching rows
    found_mask = pd.Series(False, index=df.index)
    if 'EmployeeID' in df.columns:
        emp_series = normalize_series(df['EmployeeID'])
        found_mask = found_mask | (emp_series == q_str)
    if 'person_uid' in df.columns:
        uid_series = normalize_series(df['person_uid'])
        found_mask = found_mask | (uid_series == q_str)
    if 'Int1' in df.columns and not found_mask.any():
        int1_series = normalize_series(df['Int1'])
        found_mask = found_mask | (int1_series == q_str)

    if not found_mask.any():
        # try numeric match
        try:
            q_numeric = float(q_str)
            if 'EmployeeID' in df.columns:
                emp_numeric = pd.to_numeric(df['EmployeeID'], errors='coerce')
                found_mask = found_mask | (emp_numeric == q_numeric)
            if 'Int1' in df.columns and not found_mask.any():
                int_numeric = pd.to_numeric(df['Int1'], errors='coerce')
                found_mask = found_mask | (int_numeric == q_numeric)
        except Exception:
            pass

    matched = df[found_mask].copy()
    if matched.empty:
        return jsonify({'aggregated_rows': [], 'raw_swipe_files': [], 'raw_swipes': []}), 200

    # Clean matched rows for JSON and enrichment
    cleaned_matched = _clean_sample_df(matched, max_rows=len(matched))

    # Enrich matched rows: email / image / explanations
    # Try to find personnel info using multiple candidate tokens (but avoid DB hits for obvious missing tokens)
    try:
        # lazy import helpers from trend_runner if available (safe)
        from trend_runner import compute_violation_days_map, _strip_uid_prefix as _strip_uid_prefix_tr
        violation_map = compute_violation_days_map(str(DEFAULT_OUTDIR), 90, datetime.now().date())
    except Exception:
        violation_map = {}
        _strip_uid_prefix_tr = (lambda x: x)

    matched_indexed = matched.reset_index(drop=True)

    # For each cleaned row build candidate and enrich
    for idx_c, cleaned in enumerate(cleaned_matched):
        candidate_row = None
        try:
            # 1) try to match by person_uid/EmployeeID/EmployeeName
            if cleaned.get('person_uid') and 'person_uid' in matched_indexed.columns:
                mr = matched_indexed[matched_indexed['person_uid'].astype(str).str.strip() == str(cleaned['person_uid']).strip()]
                if not mr.empty:
                    candidate_row = mr.iloc[0].to_dict()

            if candidate_row is None and cleaned.get('EmployeeID') and 'EmployeeID' in matched_indexed.columns:
                mr = matched_indexed[matched_indexed['EmployeeID'].astype(str).str.strip() == str(cleaned['EmployeeID']).strip()]
                if not mr.empty:
                    candidate_row = mr.iloc[0].to_dict()

            if candidate_row is None and cleaned.get('EmployeeName') and 'EmployeeName' in matched_indexed.columns:
                mr = matched_indexed[matched_indexed['EmployeeName'].astype(str).str.strip().str.lower() == str(cleaned['EmployeeName']).strip().lower()]
                if not mr.empty:
                    candidate_row = mr.iloc[0].to_dict()

            # 2) fallback to other columns
            if candidate_row is None and not matched_indexed.empty:
                for ccol in ('CardNumber', 'EmployeeIdentity', 'Int1', 'Text12', 'ObjectIdentity1', 'ObjectID', 'GUID'):
                    if ccol in matched_indexed.columns and cleaned.get(ccol) not in (None, '', 'nan'):
                        mr = matched_indexed[matched_indexed[ccol].astype(str).str.strip() == str(cleaned.get(ccol)).strip()]
                        if not mr.empty:
                            candidate_row = mr.iloc[0].to_dict()
                            break

            # 3) last resort — pick first
            if candidate_row is None and not matched_indexed.empty:
                candidate_row = matched_indexed.iloc[0].to_dict()
        except Exception:
            candidate_row = None

        # Build explanation text if present
        violation_expl = None
        try:
            if candidate_row:
                violation_expl = candidate_row.get('Explanation') or candidate_row.get('explanation') or None

            if not violation_expl:
                reasons = cleaned.get('Reasons') or (candidate_row.get('Reasons') if candidate_row else None)
                if reasons:
                    parts = [p.strip() for p in re.split(r'[;,\|]', str(reasons)) if p.strip()]
                    mapped = []
                    for p in parts:
                        try:
                            if 'SCENARIO_EXPLANATIONS' in globals() and p in SCENARIO_EXPLANATIONS:
                                mapped.append(SCENARIO_EXPLANATIONS[p](candidate_row or {}))
                            else:
                                mapped.append(p.replace("_", " ").replace(">=", "≥"))
                        except Exception:
                            mapped.append(p)
                    violation_expl = " ".join(mapped) if mapped else None

            # remove GUIDs inside explanation if possible
            if violation_expl:
                try:
                    emp_name_for_expl = None
                    if candidate_row:
                        emp_name_for_expl = candidate_row.get('EmployeeName') or candidate_row.get('employee_name') or candidate_row.get('ObjectName1')
                    if not emp_name_for_expl:
                        emp_name_for_expl = cleaned.get('EmployeeName')
                    if emp_name_for_expl:
                        violation_expl = GUID_IN_TEXT_RE.sub(str(emp_name_for_expl), str(violation_expl))
                except Exception:
                    pass
        except Exception:
            violation_expl = None

        # violation days lookup (if available)
        try:
            candidates = []
            for k in ('EmployeeID', 'person_uid', 'EmployeeIdentity', 'CardNumber', 'Int1', 'Text12'):
                if cleaned.get(k) not in (None, '', 'nan'):
                    candidates.append(cleaned.get(k))
            if candidate_row:
                for k in ('EmployeeID','person_uid','EmployeeIdentity','CardNumber','Int1','Text12'):
                    if candidate_row.get(k) not in (None,'','nan'):
                        candidates.append(candidate_row.get(k))
            vdays = 0
            if violation_map:
                for c in candidates:
                    if c is None:
                        continue
                    n = _normalize_id_local(c)
                    if n and n in violation_map:
                        vdays = int(violation_map.get(n, 0))
                        break
                    try:
                        stripped = _strip_uid_prefix_tr(str(n))
                        if stripped != n and stripped in violation_map:
                            vdays = int(violation_map.get(stripped, 0))
                            break
                    except Exception:
                        pass
        except Exception:
            vdays = 0

        # Personnel lookup: attempt DB lookup only if we have useful tokens (avoid unnecessary DB hits)
        personnel_info = {}
        try:
            lookup_candidates = []
            if candidate_row:
                for k in ('EmployeeObjID','EmployeeObjId','EmployeeIdentity','ObjectID','GUID','EmployeeID','Int1','Text12','EmployeeName'):
                    if candidate_row.get(k) not in (None,'','nan'):
                        lookup_candidates.append(candidate_row.get(k))
            for k in ('EmployeeID','person_uid','EmployeeName'):
                if cleaned.get(k) not in (None,'','nan'):
                    lookup_candidates.append(cleaned.get(k))

            for cand in lookup_candidates:
                if cand is None:
                    continue
                try:
                    info = get_personnel_info(cand)
                    if info and (info.get('ObjectID') is not None or info.get('EmailAddress') is not None or info.get('ManagerEmail') is not None):
                        personnel_info = info
                        break
                except Exception:
                    continue

            # Extra fallback: try by EmployeeID explicitly
            if not personnel_info:
                try:
                    cand = cleaned.get('EmployeeID') or cleaned.get('EmployeeIdentity')
                    if cand:
                        info = get_personnel_info(cand)
                        if info and (info.get('ObjectID') is not None or info.get('EmailAddress') is not None):
                            personnel_info = info
                except Exception:
                    pass
        except Exception:
            personnel_info = {}

        # Attach computed fields (robust)
        try:
            cleaned['ViolationDaysLast90'] = int(vdays or 0)
            cleaned['ViolationExplanation'] = violation_expl
            cleaned['Explanation'] = violation_expl or cleaned.get('ViolationExplanation') or None

            # Ensure EmployeeName
            try:
                if (not cleaned.get('EmployeeName')) or _looks_like_guid(cleaned.get('EmployeeName')):
                    if candidate_row and candidate_row.get('EmployeeName') and not _looks_like_guid(candidate_row.get('EmployeeName')):
                        cleaned['EmployeeName'] = candidate_row.get('EmployeeName')
                    elif personnel_info and personnel_info.get('Name'):
                        cleaned['EmployeeName'] = personnel_info.get('Name')
            except Exception:
                pass

            # Populate EmployeeEmail robustly: prefer personnel_info, then candidate_row, then matched_indexed source row
            email_val = None
            if personnel_info:
                email_val = personnel_info.get('EmailAddress') or personnel_info.get('Email')
            if not email_val and candidate_row:
                for fk in ('Email', 'EmailAddress', 'EmployeeEmail', 'WorkEmail', 'EMail'):
                    if candidate_row.get(fk) not in (None, '', 'nan'):
                        email_val = candidate_row.get(fk)
                        break
            if not email_val:
                # try the matched_indexed first row
                for col in ('Email', 'EmailAddress', 'EmployeeEmail', 'WorkEmail', 'EMail'):
                    if col in matched_indexed.columns:
                        try:
                            val = matched_indexed.iloc[0].get(col)
                            if val not in (None, '', 'nan'):
                                email_val = val
                                break
                        except Exception:
                            continue

            # Final fallback: sanitize value
            cleaned['EmployeeEmail'] = (email_val if email_val not in (None, '', 'nan') else None) or cleaned.get('EmployeeEmail') or None

            # IMAGE resolution: prefer personnel_info.ObjectID then candidate_row fields, otherwise EmployeeID/person_uid
            try:
                img_obj = None
                if personnel_info and personnel_info.get('ObjectID') is not None:
                    img_obj = personnel_info.get('ObjectID')
                elif candidate_row:
                    for k in ('EmployeeObjID', 'EmployeeObjId', 'ObjectID', 'ObjectIdentity1'):
                        if candidate_row.get(k) not in (None, '', 'nan'):
                            img_obj = candidate_row.get(k)
                            break

                try:
                    base = (request.url_root or request.host_url).rstrip('/')
                except Exception:
                    base = ''

                if img_obj:
                    if base:
                        cleaned['imageUrl'] = f"{base}/employee/{img_obj}/image"
                    else:
                        cleaned['imageUrl'] = f"/employee/{img_obj}/image"
                    try:
                        b = get_person_image_bytes(img_obj)
                        cleaned['HasImage'] = True if b else False
                    except Exception:
                        cleaned['HasImage'] = False
                else:
                    emp_for_img = cleaned.get('EmployeeID') or cleaned.get('person_uid') or None
                    if emp_for_img:
                        if base:
                            cleaned['imageUrl'] = f"{base}/employee/{emp_for_img}/image"
                        else:
                            cleaned['imageUrl'] = f"/employee/{emp_for_img}/image"
                        try:
                            b = get_person_image_bytes(emp_for_img)
                            cleaned['HasImage'] = True if b else False
                        except Exception:
                            cleaned['HasImage'] = False
                    else:
                        cleaned['imageUrl'] = None
                        cleaned['HasImage'] = False

            except Exception:
                cleaned['imageUrl'] = cleaned.get('imageUrl') or None
                cleaned['HasImage'] = cleaned.get('HasImage') or False

            # ensure EmployeeID surfaced if absent
            if not cleaned.get('EmployeeID') and candidate_row:
                for k in ('EmployeeID','Int1','Text12','EmployeeIdentity'):
                    if candidate_row.get(k) not in (None, '', 'nan'):
                        cleaned['EmployeeID'] = candidate_row.get(k)
                        break

        except Exception:
            # safe defaults if enrichment fails
            cleaned.setdefault('EmployeeEmail', None)
            cleaned.setdefault('imageUrl', None)
            cleaned.setdefault('HasImage', False)

    # Build raw_swipes timeline (scan swipe files using DEFAULT_OUTDIR)
    raw_files = set()
    raw_swipes_out = []
    seen_swipe_keys = set()
    def _append_swipe(out_row, source_name):
        key = (
            out_row.get('Date') or '',
            out_row.get('Time') or '',
            (out_row.get('Door') or '').strip(),
            (out_row.get('Direction') or '').strip(),
            (out_row.get('CardNumber') or out_row.get('Card') or '').strip()
        )
        if key in seen_swipe_keys:
            return
        seen_swipe_keys.add(key)
        out_row['_source'] = source_name
        raw_swipes_out.append(out_row)

    # dates discovered from matched rows
    dates_to_scan = set()
    for _, agg_row in matched.iterrows():
        try:
            if 'Date' in agg_row and pd.notna(agg_row['Date']):
                try:
                    d = pd.to_datetime(agg_row['Date']).date()
                    dates_to_scan.add(d)
                except Exception:
                    pass
            for col in ('FirstSwipe','LastSwipe'):
                if col in agg_row and pd.notna(agg_row[col]):
                    try:
                        d = pd.to_datetime(agg_row[col]).date()
                        dates_to_scan.add(d)
                    except Exception:
                        pass
        except Exception:
            continue
    if not dates_to_scan:
        dates_to_scan = {None}

    for d in dates_to_scan:
        candidates = _find_swipe_files(DEFAULT_OUTDIR, date_obj=d, city_slug=city_slug)
        if not candidates:
            candidates = _find_swipe_files(DEFAULT_OUTDIR, date_obj=d, city_slug=None)

        for fp in candidates:
            raw_files.add(fp.name)
            try:
                try:
                    raw_df = pd.read_csv(fp, parse_dates=['LocaleMessageTime'])
                except Exception:
                    raw_df = pd.read_csv(fp, dtype=str)
            except Exception:
                continue

            raw_df = _replace_placeholder_strings(raw_df)
            # lower->orig mapping
            cols_lower = {c.lower(): c for c in raw_df.columns}
            tcol = cols_lower.get('localemessagetime') or cols_lower.get('messagetime') or cols_lower.get('timestamp') or cols_lower.get('time') or None
            emp_col = cols_lower.get('int1') or cols_lower.get('employeeid') or cols_lower.get('employeeidentity') or cols_lower.get('employee_id') or None
            name_col = cols_lower.get('employeename') or cols_lower.get('objectname1') or cols_lower.get('employee_name') or None
            card_col = cols_lower.get('cardnumber') or cols_lower.get('card') or cols_lower.get('chuid') or cols_lower.get('value') or None
            door_col = cols_lower.get('door') or cols_lower.get('doorname') or cols_lower.get('door_name') or None
            dir_col = cols_lower.get('direction') or cols_lower.get('directionname') or cols_lower.get('direction_name') or None
            note_col = cols_lower.get('rejection_type') or cols_lower.get('note') or cols_lower.get('source') or None
            person_uid_col = cols_lower.get('person_uid')

            mask = pd.Series(False, index=raw_df.index)
            if person_uid_col and person_uid_col in raw_df.columns:
                mask = mask | (raw_df[person_uid_col].astype(str).str.strip() == str(q).strip())
            if emp_col and emp_col in raw_df.columns:
                mask = mask | (raw_df[emp_col].astype(str).str.strip() == str(q).strip())
            if not mask.any() and emp_col and emp_col in raw_df.columns:
                try:
                    q_numeric = float(q)
                    emp_numeric = pd.to_numeric(raw_df[emp_col], errors='coerce')
                    mask = mask | (emp_numeric == q_numeric)
                except Exception:
                    pass
            if not mask.any() and name_col and name_col in raw_df.columns:
                try:
                    mask = mask | (raw_df[name_col].astype(str).str.strip().str.lower() == str(q).strip().lower())
                except Exception:
                    pass

            if not mask.any():
                continue

            filtered = raw_df[mask].copy()
            if filtered.empty:
                continue

            if tcol and tcol in filtered.columns:
                try:
                    filtered[tcol] = pd.to_datetime(filtered[tcol], errors='coerce')
                except Exception:
                    pass

            if tcol and tcol in filtered.columns:
                filtered = filtered.sort_values(by=tcol)
                filtered['_prev_ts'] = filtered[tcol].shift(1)
                try:
                    filtered['_swipe_gap_seconds'] = (filtered[tcol] - filtered['_prev_ts']).dt.total_seconds().fillna(0).astype(float)
                except Exception:
                    filtered['_swipe_gap_seconds'] = 0.0
                try:
                    cur_dates = filtered[tcol].dt.date
                    prev_dates = cur_dates.shift(1)
                    day_start_mask = (prev_dates != cur_dates) | (filtered['_prev_ts'].isna())
                    filtered.loc[day_start_mask, '_swipe_gap_seconds'] = 0.0
                except Exception:
                    pass
            else:
                filtered['_swipe_gap_seconds'] = 0.0

            try:
                if door_col and door_col in filtered.columns:
                    if dir_col and dir_col in filtered.columns:
                        filtered['_zone'] = filtered.apply(lambda rr: map_door_to_zone(rr.get(door_col), rr.get(dir_col)), axis=1)
                    else:
                        filtered['_zone'] = filtered.get(door_col, None)
            except Exception:
                filtered['_zone'] = None

            for _, r in filtered.iterrows():
                out = {}
                out['EmployeeName'] = _to_python_scalar(r.get(name_col)) if name_col and name_col in filtered.columns else _to_python_scalar(matched.iloc[0].get('EmployeeName') if not matched.empty else q)
                # employee id
                emp_val = None
                if emp_col and emp_col in filtered.columns:
                    emp_val = _to_python_scalar(r.get(emp_col))
                else:
                    for cand in ('Int1','Text12','EmployeeID','EmployeeIdentity','empid','id'):
                        if cand.lower() in cols_lower:
                            emp_val = _to_python_scalar(r.get(cols_lower[cand.lower()]))
                            if emp_val not in (None,'','nan'):
                                break
                    if emp_val in (None,'','nan'):
                        emp_val = _to_python_scalar(matched.iloc[0].get('EmployeeID') if not matched.empty else None)
                if emp_val is not None:
                    try:
                        s = str(emp_val).strip()
                        if '.' in s:
                            f = float(s)
                            if math.isfinite(f) and f.is_integer():
                                s = str(int(f))
                        if _looks_like_guid(s) or _is_placeholder_str(s):
                            emp_val = None
                        else:
                            emp_val = s
                    except Exception:
                        if _looks_like_guid(emp_val):
                            emp_val = None
                out['EmployeeID'] = emp_val

                # Card number
                card_val = None
                if card_col and card_col in filtered.columns:
                    card_val = _to_python_scalar(r.get(card_col))
                else:
                    for cand in ('CardNumber','CHUID','Card','card_no','cardnum','value','xmlmessage'):
                        if cand.lower() in cols_lower:
                            card_val = _to_python_scalar(r.get(cols_lower[cand.lower()]))
                            if card_val not in (None,'','nan'):
                                break
                    if card_val in (None,'','nan'):
                        card_val = _to_python_scalar(matched.iloc[0].get('CardNumber') if not matched.empty else None)
                if card_val is not None:
                    try:
                        cs = str(card_val).strip()
                        if _looks_like_guid(cs) or _is_placeholder_str(cs):
                            card_val = None
                        else:
                            card_val = cs
                    except Exception:
                        card_val = None
                out['CardNumber'] = card_val
                out['Card'] = card_val

                # timestamps
                if tcol and tcol in filtered.columns:
                    ts = r.get(tcol)
                    try:
                        ts_py = pd.to_datetime(ts)
                        out['Date'] = ts_py.date().isoformat()
                        out['Time'] = ts_py.time().isoformat()
                        out['LocaleMessageTime'] = ts_py.isoformat()
                    except Exception:
                        txt = str(r.get(tcol))
                        out['Date'] = txt[:10]
                        out['Time'] = txt[11:19] if len(txt) >= 19 else txt
                        out['LocaleMessageTime'] = txt
                else:
                    out['Date'] = None
                    out['Time'] = None
                    out['LocaleMessageTime'] = None

                out['SwipeGapSeconds'] = float(r.get('_swipe_gap_seconds')) if '_swipe_gap_seconds' in r else 0.0
                out['SwipeGap'] = format_seconds_to_hms(out['SwipeGapSeconds'])
                out['Door'] = _to_python_scalar(r.get(door_col)) if (door_col and door_col in filtered.columns) else None
                out['Direction'] = _to_python_scalar(r.get(dir_col)) if (dir_col and dir_col in filtered.columns) else _to_python_scalar(r.get('Direction')) if 'Direction' in r else None
                out['Note'] = _to_python_scalar(r.get(note_col)) if (note_col and note_col in filtered.columns) else None
                try:
                    out['Zone'] = _to_python_scalar(r.get('_zone')) if '_zone' in r else map_door_to_zone(out['Door'], out['Direction'])
                except Exception:
                    out['Zone'] = None
                out['PartitionName2'] = _to_python_scalar(r.get('PartitionName2')) if 'PartitionName2' in filtered.columns else None
                out['_source_file'] = fp.name
                _append_swipe(out, fp.name)

    return jsonify({
        "aggregated_rows": cleaned_matched,
        "raw_swipe_files": sorted(list(raw_files)),
        "raw_swipes": raw_swipes_out
    }), 200



@app.route('/record/export', methods=['GET'])
def export_record_excel():
    q = request.args.get('employee_id') or request.args.get('person_uid')
    date_str = request.args.get('date')
    city_param = request.args.get('city') or request.args.get('site') or 'pune'
    city_slug = _slug_city(city_param)

    if not q:
        return jsonify({"error":"employee_id or person_uid is required"}), 400

    p = Path(DEFAULT_OUTDIR)
    files_to_scan = []
    if date_str:
        try:
            dd = pd.to_datetime(date_str).date()
            files_to_scan = _find_swipe_files(DEFAULT_OUTDIR, date_obj=dd, city_slug=city_slug)
        except Exception:
            return jsonify({"error":"invalid date format, expected YYYY-MM-DD"}), 400
    else:
        files_to_scan = _find_swipe_files(DEFAULT_OUTDIR, date_obj=None, city_slug=city_slug)
    if not files_to_scan:
        # show any available swipe-style files to help frontend debugging
        avail = _find_swipe_files(DEFAULT_OUTDIR, date_obj=None, city_slug=None)
        avail_names = [f.name for f in avail] if avail else []
        logging.info(
            "export_record_excel: no files matched for date=%s city=%s; available swipe files=%s",
            date_str, city_slug, avail_names
        )
        return jsonify({
            "error": "no raw swipe files found for requested date / outputs",
            "available_swipe_files": avail_names
        }), 404

    all_rows = []
    for fp in files_to_scan:
        try:
            raw_df = pd.read_csv(fp, dtype=str, parse_dates=['LocaleMessageTime'])
        except Exception:
            try:
                raw_df = pd.read_csv(fp, dtype=str)
            except Exception:
                continue

        raw_df = _replace_placeholder_strings(raw_df)
        cols_lower = {c.lower(): c for c in raw_df.columns}
        tcol = cols_lower.get('localemessagetime') or cols_lower.get('messagetime') or cols_lower.get('timestamp') or cols_lower.get('time') or None
        emp_col = cols_lower.get('int1') or cols_lower.get('employeeid') or cols_lower.get('employeeidentity') or cols_lower.get('employee_id') or None
        name_col = cols_lower.get('employeename') or cols_lower.get('objectname1') or cols_lower.get('employee_name') or None
        card_col = cols_lower.get('cardnumber') or cols_lower.get('card') or cols_lower.get('chuid') or cols_lower.get('value') or None
        door_col = cols_lower.get('door') or cols_lower.get('doorname') or cols_lower.get('door_name') or None
        dir_col = cols_lower.get('direction') or cols_lower.get('directionname') or cols_lower.get('direction_name') or None
        note_col = cols_lower.get('rejection_type') or cols_lower.get('note') or cols_lower.get('source') or None
        person_uid_col = cols_lower.get('person_uid')

        mask = pd.Series(False, index=raw_df.index)
        if person_uid_col and person_uid_col in raw_df.columns:
            mask = mask | (raw_df[person_uid_col].astype(str).str.strip() == str(q).strip())
        if emp_col and emp_col in raw_df.columns:
            mask = mask | (raw_df[emp_col].astype(str).str.strip() == str(q).strip())
        if not mask.any() and emp_col and emp_col in raw_df.columns:
            try:
                q_numeric = float(q)
                emp_numeric = pd.to_numeric(raw_df[emp_col], errors='coerce')
                mask = mask | (emp_numeric == q_numeric)
            except Exception:
                pass
        if not mask.any() and name_col and name_col in raw_df.columns:
            mask = mask | (raw_df[name_col].astype(str).str.strip().str.lower() == str(q).strip().lower())

        if not mask.any():
            continue

        filtered = raw_df[mask].copy()
        if filtered.empty:
            continue

        if tcol and tcol in filtered.columns:
            try:
                filtered[tcol] = pd.to_datetime(filtered[tcol], errors='coerce')
            except Exception:
                pass

        if tcol and tcol in filtered.columns:
            filtered = filtered.sort_values(by=tcol)
            filtered['_prev_ts'] = filtered[tcol].shift(1)
            try:
                filtered['_swipe_gap_seconds'] = (filtered[tcol] - filtered['_prev_ts']).dt.total_seconds().fillna(0).astype(float)
            except Exception:
                filtered['_swipe_gap_seconds'] = 0.0
        else:
            filtered['_swipe_gap_seconds'] = 0.0

        try:
            if door_col and door_col in filtered.columns:
                if dir_col and dir_col in filtered.columns:
                    filtered['_zone'] = filtered.apply(lambda rr: map_door_to_zone(rr.get(door_col), rr.get(dir_col)), axis=1)
                else:
                    filtered['_zone'] = filtered[door_col].apply(lambda dv: map_door_to_zone(dv, None))
            else:
                filtered['_zone'] = filtered.get('PartitionName2', None)
        except Exception:
            filtered['_zone'] = None

        for _, r in filtered.iterrows():
            row = {}
            row['EmployeeName'] = _to_python_scalar(r.get(name_col)) if (name_col and name_col in filtered.columns) else None
            emp_val = None
            if emp_col and emp_col in filtered.columns:
                emp_val = _to_python_scalar(r.get(emp_col))
            else:
                for cand in ('int1','text12','employeeid','employee_identity','employeeidentity'):
                    if cand in cols_lower and cols_lower[cand] in filtered.columns:
                        emp_val = _to_python_scalar(r.get(cols_lower[cand]))
                        if emp_val:
                            break
            row['EmployeeID'] = emp_val
            row['Card'] = _to_python_scalar(r.get(card_col)) if (card_col and card_col in filtered.columns) else None

            if tcol and tcol in filtered.columns:
                ts = r.get(tcol)
                try:
                    ts_py = pd.to_datetime(ts)
                    row['Date'] = ts_py.date().isoformat()
                    row['Time'] = ts_py.time().isoformat()
                    row['LocaleMessageTime'] = ts_py.isoformat()
                except Exception:
                    txt = str(r.get(tcol))
                    row['Date'] = txt[:10]
                    row['Time'] = txt[11:19] if len(txt) >= 19 else None
                    row['LocaleMessageTime'] = txt
            else:
                row['Date'] = None
                row['Time'] = None
                row['LocaleMessageTime'] = None

            row['SwipeGapSeconds'] = float(r.get('_swipe_gap_seconds')) if '_swipe_gap_seconds' in r else 0.0
            row['SwipeGap'] = format_seconds_to_hms(row['SwipeGapSeconds'])
            row['Door'] = _to_python_scalar(r.get(door_col)) if (door_col and door_col in filtered.columns) else None
            row['Direction'] = _to_python_scalar(r.get(dir_col)) if (dir_col and dir_col in filtered.columns) else None
            row['Note'] = _to_python_scalar(r.get(note_col)) if (note_col and note_col in filtered.columns) else None
            try:
                zone_val = r.get('_zone') if '_zone' in r else None
                if zone_val is None:
                    zone_val = map_door_to_zone(row['Door'], row['Direction'])
                row['Zone'] = _to_python_scalar(zone_val)
            except Exception:
                row['Zone'] = None
            row['PartitionName2'] = _to_python_scalar(r.get('PartitionName2')) if 'PartitionName2' in filtered.columns else None
            row['_source_file'] = fp.name
            all_rows.append(row)

    if not all_rows:
        return jsonify({"error":"no swipe rows matched the requested employee/date"}), 404

    df_out = pd.DataFrame(all_rows)
    details_cols = ['EmployeeName','EmployeeID','Door','Direction','Zone','Date','LocaleMessageTime','SwipeGapSeconds','PartitionName2','_source_file']
    timeline_cols = ['EmployeeName','EmployeeID','Card','Date','Time','SwipeGapSeconds','Door','Direction','Zone','Note','_source_file']

    details_df = df_out[[c for c in details_cols if c in df_out.columns]].copy()
    timeline_df = df_out[[c for c in timeline_cols if c in df_out.columns]].copy()

    output = io.BytesIO()
    try:
        with pd.ExcelWriter(output, engine='openpyxl') as writer:
            details_df.to_excel(writer, sheet_name='Details — Evidence', index=False)
            timeline_df.to_excel(writer, sheet_name='Swipe timeline', index=False)
            writer.save()
            output.seek(0)
    except Exception as e:
        logging.exception("Failed to create Excel: %s", e)
        return jsonify({"error":"failed to create excel"}), 500

    if OPENPYXL_AVAILABLE:
        try:
            wb = load_workbook(output)
            thin = Side(border_style="thin", color="000000")
            thick = Side(border_style="medium", color="000000")
            for ws in wb.worksheets:
                header = ws[1]
                for cell in header:
                    cell.font = Font(bold=True)
                    cell.alignment = Alignment(horizontal="center", vertical="center")
                    cell.border = Border(top=thick, left=thick, right=thick, bottom=thick)
                for row in ws.iter_rows(min_row=2, max_row=ws.max_row, min_col=1, max_col=ws.max_column):
                    for cell in row:
                        cell.alignment = Alignment(horizontal="center", vertical="center")
                        cell.border = Border(top=thin, left=thin, right=thin, bottom=thin)
                for col in ws.columns:
                    max_len = 0
                    col_letter = col[0].column_letter
                    for cell in col:
                        try:
                            v = str(cell.value) if cell.value is not None else ""
                        except Exception:
                            v = ""
                        if len(v) > max_len:
                            max_len = len(v)
                    width = min(max(10, max_len + 2), 50)
                    ws.column_dimensions[col_letter].width = width
            out2 = io.BytesIO()
            wb.save(out2)
            out2.seek(0)
            return send_file(out2, as_attachment=True,
                             download_name=f"evidence_{str(q).replace(' ','_')}_{date_str or 'all'}.xlsx",
                             mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
        except Exception:
            logging.exception("Excel styling failed, returning raw file")
            output.seek(0)
            return send_file(output, as_attachment=True,
                             download_name=f"evidence_{str(q).replace(' ','_')}_{date_str or 'all'}.xlsx",
                             mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
    else:
        output.seek(0)
        return send_file(output, as_attachment=True,
                         download_name=f"evidence_{str(q).replace(' ','_')}_{date_str or 'all'}.xlsx",
                         mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

@app.route('/swipes/<filename>', methods=['GET'])
def download_swipes(filename):
    fp = DEFAULT_OUTDIR / filename
    if not fp.exists():
        return jsonify({"error":"file not found"}), 404
    return send_from_directory(str(DEFAULT_OUTDIR), filename, as_attachment=True)

@app.route('/train', methods=['GET'])
def build_training_endpoint():
    end_date_str = request.args.get('end_date')
    months = int(request.args.get('months') or 3)
    min_unique = int(request.args.get('min_unique') or 1000)
    try:
        if end_date_str:
            end_date = datetime.strptime(end_date_str, "%Y-%m-%d").date()
        else:
            end_date = datetime.now().date()
    except Exception as e:
        return jsonify({"error": f"invalid end_date: {e}"}), 400

    try:
        if build_monthly_training is None:
            raise RuntimeError("build_monthly_training not available")
        csv_path = build_monthly_training(end_date=end_date, months=months, min_unique_employees=min_unique, outdir=str(DEFAULT_OUTDIR))
        if csv_path is None:
            return jsonify({"error":"no training CSV produced (no data)"}), 500
        return jsonify({"training_csv": str(csv_path)})
    except Exception as e:
        logging.exception("build_monthly_training failed")
        return jsonify({"error": str(e)}), 500


# @app.route("/employee/<pid>/image")
# def employee_image(pid):
#     """
#     Return image bytes for a person id used by frontend imageUrl template.
#     If you already have get_person_image_bytes(pid) helper, this will call it.
#     """
#     try:
#         # try to call app-level helper if present
#         import importlib
#         appmod = importlib.import_module('app')  # adjust module name if helper is in another module
#         gpib = getattr(appmod, 'get_person_image_bytes', None)
#         if gpib:
#             data = gpib(pid)  # should return bytes or None
#             if data:
#                 return send_file(BytesIO(data), mimetype='image/jpeg')
#     except Exception:
#         logging.exception("employee_image route failed")
#     # fallback: 404 — frontend shows placeholder if not found
#     return ('', 404)



# chatbot helpers (kept mostly as-is)
try:
    from trend_runner import _read_past_trend_csvs, _normalize_id_val, SCENARIO_EXPLANATIONS
except Exception:
    _read_past_trend_csvs = None
    _normalize_id_val = None
    SCENARIO_EXPLANATIONS = {}

def _load_latest_trend_df(outdir: Path, city: str = "pune"):
    city_slug = _slug_city(city)
    csvs = sorted(outdir.glob(f"trend_{city_slug}_*.csv"), reverse=True)
    if not csvs:
        csvs = sorted(outdir.glob("trend_*.csv"), reverse=True)
    if not csvs:
        return None, None
    latest = csvs[0]
    try:
        df = pd.read_csv(latest)
    except Exception:
        df = pd.read_csv(latest, dtype=str)
    df = _replace_placeholder_strings(df)
    return df, latest.name

def _find_person_rows(identifier: str, days: int = 90, outdir: Path = DEFAULT_OUTDIR):
    if _normalize_id_val:
        norm = _normalize_id_val(identifier)
    else:
        norm = str(identifier).strip()
        if '.' in norm:
            try:
                f = float(norm)
                if f.is_integer():
                    norm = str(int(f))
            except Exception:
                pass
    today = datetime.now().date()
    try:
        if _read_past_trend_csvs:
            past = _read_past_trend_csvs(str(outdir), days, today)
        else:
            files = sorted(Path(outdir).glob("trend_pune_*.csv"), reverse=True)
            dfs = []
            cutoff = today - timedelta(days=days)
            for fp in files:
                try:
                    tmp = pd.read_csv(fp, parse_dates=['Date'])
                    tmp['Date'] = pd.to_datetime(tmp['Date'], errors='coerce').dt.date
                    tmp = tmp[tmp['Date'].apply(lambda d: d is not None and d >= cutoff and d <= today)]
                    dfs.append(tmp)
                except Exception:
                    try:
                        tmp = pd.read_csv(fp, dtype=str)
                        if 'Date' in tmp.columns:
                            tmp['Date'] = pd.to_datetime(tmp['Date'], errors='coerce').dt.date
                            tmp = tmp[tmp['Date'].apply(lambda d: d is not None and d >= cutoff and d <= today)]
                            dfs.append(tmp)
                    except Exception:
                        continue
            past = pd.concat(dfs, ignore_index=True) if dfs else pd.DataFrame()
    except Exception:
        past = pd.DataFrame()

    if past is None or past.empty:
        return pd.DataFrame()

    past = _replace_placeholder_strings(past)
    match_mask = pd.Series(False, index=past.index)
    for col in ('EmployeeID','person_uid','EmployeeIdentity','CardNumber','Int1','Text12'):
        if col in past.columns:
            try:
                match_mask = match_mask | (past[col].astype(str).fillna('').str.strip() == str(norm).strip())
            except Exception:
                continue

    if not match_mask.any():
        try:
            qnum = float(norm)
            for col in ('EmployeeID','Int1'):
                if col in past.columns:
                    try:
                        numcol = pd.to_numeric(past[col], errors='coerce')
                        match_mask = match_mask | (numcol == qnum)
                    except Exception:
                        continue
        except Exception:
            pass

    if not match_mask.any() and 'EmployeeName' in past.columns:
        names = past['EmployeeName'].dropna().astype(str).unique().tolist()
        close = difflib.get_close_matches(str(identifier), names, n=5, cutoff=0.7)
        if close:
            match_mask = match_mask | past['EmployeeName'].astype(str).isin(close)

    return past[match_mask].copy()

def _explain_scenario_code(code):
    if not code:
        return None
    code = str(code).strip()
    if code in SCENARIO_EXPLANATIONS:
        try:
            fn = SCENARIO_EXPLANATIONS.get(code)
            try:
                txt = fn({})
                return txt
            except Exception:
                return code.replace("_", " ").replace(">= ", "≥ ")
        except Exception:
            return code.replace("_", " ").replace(">= ", "≥ ")
    return code.replace("_", " ").replace(">=", "≥")

def _map_score_to_label_fallback(score: float):
    try:
        s = float(score)
    except Exception:
        return (0.0, "Low")
    if s >= 0.75:
        return (s, "High")
    if s >= 0.4:
        return (s, "Medium")
    return (s, "Low")

@app.route('/chatbot/query', methods=['POST'])
def chatbot_query():
    payload = request.get_json(force=True)
    q = (payload.get('q') or '').strip()
    if not q:
        return jsonify({"error":"query text 'q' required"}), 400
    lang = payload.get('lang')
    q_l = q.lower().strip()

    if re.search(r"\bwho is (high|low) risk\b", q_l) or re.search(r"\b(high|low) risk (people|persons|people) (today)?\b", q_l):
        want = 'high' if 'high' in q_l else 'low' if 'low' in q_l else None
        df, fname = _load_latest_trend_df(DEFAULT_OUTDIR)
        if df is None:
            return jsonify({"answer": "No trend data available.", "evidence": []})
        if 'RiskLevel' not in df.columns:
            if 'RiskScore' in df.columns:
                def _map_rs(s):
                    try:
                        if pd.isna(s):
                            return 'Low'
                    except Exception:
                        pass
                    try:
                        if 'map_score_to_label' in globals() and callable(globals().get('map_score_to_label')):
                            try:
                                return globals().get('map_score_to_label')(float(s))[1]
                            except Exception:
                                pass
                        return _map_score_to_label_fallback(float(s))[1]
                    except Exception:
                        return 'Low'
                df['RiskLevel'] = df['RiskScore'].apply(lambda s: _map_rs(s))
            else:
                df['RiskLevel'] = df.get('RiskLevel', 'Low')
        if want == 'high':
            sel = df[df['RiskLevel'].astype(str).str.lower() == 'high']
        elif want == 'low':
            sel = df[df['RiskLevel'].astype(str).str.lower() == 'low']
        else:
            sel = df
        names = sel['EmployeeName'].dropna().astype(str).unique().tolist()
        if not names:
            ans = f"No {want} risk persons found in the latest data." if want else "No persons found."
            return jsonify({"answer": ans, "evidence": []})
        else:
            ans = f"{want.capitalize()} risk persons today: " + ", ".join(names[:40])
            sample = _clean_sample_df(sel.head(10), max_rows=10)
            return jsonify({"answer": ans, "evidence": sample})

    m = re.match(r".*\bexplain\s+([A-Za-z0-9_\-]+)\b.*", q_l)
    if m:
        code = m.group(1).strip()
        explanation = _explain_scenario_code(code)
        ans = f"Explanation for '{code}': {explanation}"
        return jsonify({"answer": ans, "evidence": []})

    if 'trend details' in q_l or 'top reasons' in q_l or 'trend details for today' in q_l:
        df, fname = _load_latest_trend_df(DEFAULT_OUTDIR)
        if df is None:
            return jsonify({"answer":"No trend data available.","evidence":[]})
        if 'Reasons' in df.columns:
            reasons = {}
            for v in df['Reasons'].dropna().astype(str):
                for part in re.split(r'[;,\|]', v):
                    key = part.strip()
                    if key and not _is_placeholder_str(key):
                        reasons[key] = reasons.get(key, 0) + 1
            top = sorted(reasons.items(), key=lambda x: x[1], reverse=True)[:10]
            if not top:
                return jsonify({"answer":"No reason counts available today.","evidence":[]})
            ans = "Top reasons today: " + ", ".join([f"{k} ({c})" for k,c in top])
            sample = []
            try:
                top_reasons = [k for k,_ in top]
                mask = df['Reasons'].astype(str).apply(lambda s: any(tr in s for tr in top_reasons))
                sample_df = df[mask].head(10)
                sample = _clean_sample_df(sample_df, max_rows=10)
            except Exception:
                sample = []
            return jsonify({"answer": ans, "evidence": sample})

    m = re.match(r".*\bshow (?:me )?([A-Za-z0-9\-\:\s]+?) (?:for )?(?:last )?(\d+)\s*days\b", q_l)
    if not m:
        m = re.match(r".*\b(show|display)\s+(?:me\s+)?([A-Za-z0-9\-\:\s]+?)\s+last\s+(\d+)\s*days\b", q_l)
    if m:
        if len(m.groups()) == 2:
            identifier, days = m.group(1).strip(), int(m.group(2))
        else:
            identifier = m.group(1).strip()
            days = int(m.group(2))
        rows = _find_person_rows(identifier, days=days, outdir=DEFAULT_OUTDIR)
        if rows is None or rows.empty:
            return jsonify({"answer": f"No records found for '{identifier}' in last {days} days.", "evidence": []})
        flagged = rows[rows.get('IsFlagged', False) == True] if 'IsFlagged' in rows.columns else pd.DataFrame()
        flagged_count = int(len(flagged))
        total_days = int(len(rows))
        latest_row = rows.sort_values('Date', ascending=False).iloc[0].to_dict()
        name = latest_row.get('EmployeeName') or latest_row.get('person_uid') or latest_row.get('EmployeeID')
        ans = f"Found {total_days} day(s) for {name} in the last {days} days. Flagged days: {flagged_count}."
        sample = _clean_sample_df(rows.sort_values('Date', ascending=False).head(10), max_rows=10)
        return jsonify({"answer": ans, "evidence": sample})

    if 'present today' in q_l or 'who is present today' in q_l:
        df, fname = _load_latest_trend_df(DEFAULT_OUTDIR)
        if df is None:
            return jsonify({"answer":"No trend data available.","evidence":[]})
        if 'PresentToday' in df.columns:
            present = df[df['PresentToday'] == True]
            names = present['EmployeeName'].dropna().unique().tolist()
            ans = f"Present today: {', '.join(names[:40]) if names else 'None'}"
            sample = _clean_sample_df(present.head(10), max_rows=10)
            return jsonify({"answer": ans, "evidence": sample})
        else:
            return jsonify({"answer":"PresentToday field not available in latest trends.","evidence":[]})

    hint = "I can answer: 'Who is high risk today', 'Who is low risk today', 'Show me <EmployeeID|Name> last 90 days', 'Explain <scenario_code>', 'Trend details for today — top reasons'."
    return jsonify({"answer": f"I can help with trend & risk questions. I recognized: {q}. Try: {hint}", "evidence":[]})

@app.route('/employee/<empid>/image', methods=['GET'])
def serve_employee_image(empid):
    if empid is None:
        return jsonify({"error": "employee id required"}), 400
    try:
        img_bytes = get_person_image_bytes(empid)
        # If no image found, return a small inline SVG placeholder so <img> can still render
        if not img_bytes:
            svg = (
                '<svg xmlns="http://www.w3.org/2000/svg" width="160" height="160">'
                '<rect fill="#eef2f7" width="100%" height="100%"/>'
                '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#64748b" font-size="18">'
                'No image</text></svg>'
            )
            bio = io.BytesIO(svg.encode('utf-8'))
            bio.seek(0)
            resp = send_file(bio, mimetype='image/svg+xml')
            resp.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
            return resp

        # detect content type heuristically (jpeg/png/bmp)
        header = img_bytes[:8] if isinstance(img_bytes, (bytes, bytearray)) else bytes(img_bytes)[:8]
        content_type = 'application/octet-stream'
        try:
            if len(header) >= 2 and header[0] == 0xFF and header[1] == 0xD8:
                content_type = 'image/jpeg'
            elif header.startswith(b'\x89PNG\r\n\x1a\n'):
                content_type = 'image/png'
            elif header.startswith(b'BM'):
                content_type = 'image/bmp'
            else:
                content_type = 'application/octet-stream'
        except Exception:
            content_type = 'application/octet-stream'

        bio = io.BytesIO(img_bytes if isinstance(img_bytes, (bytes, bytearray)) else bytes(img_bytes))
        bio.seek(0)
        resp = send_file(bio, mimetype=content_type)
        resp.headers['Cache-Control'] = 'private, max-age=300'
        return resp
    except Exception:
        logging.exception("Error serving image for employee %s", empid)
        return jsonify({"error": "failed to serve image"}), 500

# run
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8002, debug=True)

