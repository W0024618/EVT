Now Fix this error carefully

(.venv) PS C:\Users\W0024618\Desktop\Trend Analysis\backend> python app.py
>>
>>
Traceback (most recent call last):
  File "C:\Users\W0024618\Desktop\Trend Analysis\backend\app.py", line 27, in <module>
    from employeeimage import get_person_image_bytes, get_personnel_info
  File "C:\Users\W0024618\Desktop\Trend Analysis\backend\employeeimage.py", line 354
    try:
SyntaxError: expected 'except' or 'finally' block
(.venv) PS C:\Users\W0024618\Desktop\Trend Analysis\backend> 




# backend/employeeimage.py
from __future__ import annotations
import logging
import os
import base64
from pathlib import Path
from typing import Optional, Dict, Any

try:
    import pyodbc
except Exception:
    pyodbc = None

# read REGION_CONFIG from duration_report if available (fallback to empty)
try:
    from duration_report import REGION_CONFIG
except Exception:
    REGION_CONFIG = {}

ODBC_DRIVER = os.getenv("ODBC_DRIVER", "ODBC Driver 17 for SQL Server")
DEFAULT_OUTDIR = Path(__file__).resolve().parent / "outputs"


_uuid_like_re = None
try:
    import re
    _uuid_like_re = re.compile(r'^[0-9A-Fa-f]{8}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{12}$')
except Exception:
    _uuid_like_re = None


def _looks_like_guid(s: object) -> bool:
    try:
        if s is None:
            return False
        st = str(s).strip()
        if not st:
            return False
        if _uuid_like_re:
            return bool(_uuid_like_re.match(st))
        return False
    except Exception:
        return False


# Small helper like the one in duration_report/app to strip emp:/uid: prefixes
def _strip_person_uid_prefix(token: object) -> Optional[str]:
    if token is None:
        return None
    try:
        s = str(token).strip()
        if not s:
            return None
        if ':' in s:
            prefix, rest = s.split(':', 1)
            if prefix.lower() in ('emp', 'uid', 'name'):
                rest = rest.strip()
                if rest:
                    return rest
        return s
    except Exception:
        return None


# --- DB connection helper (tries servers defined in REGION_CONFIG) ---
_acvscore_backoff = {"ts": None, "failed": False}
_ACVSCORE_BACKOFF_SECONDS = 20

def _get_acvscore_conn(timeout: int = 5):
    """
    Try to connect to ACVSCore on servers declared in REGION_CONFIG.
    Returns pyodbc connection or None.
    """
    try:
        import time
        now = time.time()
        last = _acvscore_backoff.get("ts")
        if last and _acvscore_backoff.get("failed") and (now - last) < _ACVSCORE_BACKOFF_SECONDS:
            logging.debug("Backoff active for ACVSCore connection attempts.")
            return None
    except Exception:
        pass

    if pyodbc is None:
        logging.debug("pyodbc not available - cannot connect to ACVSCore.")
        return None

    tried = []
    for rkey, rc in (REGION_CONFIG or {}).items():
        server = rc.get("server")
        user = rc.get("user")
        pwd = rc.get("password")
        if not server:
            continue

        # try SQL auth if credentials present
        if user and pwd:
            tried.append(f"{rkey}@{server}(sql)")
            conn_str = (
                f"DRIVER={{{ODBC_DRIVER}}};"
                f"SERVER={server};DATABASE=ACVSCore;UID={user};PWD={pwd};"
                "TrustServerCertificate=Yes;"
            )
            try:
                conn = pyodbc.connect(conn_str, autocommit=True, timeout=timeout)
                logging.info("Connected to ACVSCore on %s using SQL auth (region %s).", server, rkey)
                _acvscore_backoff["failed"] = False
                _acvscore_backoff["ts"] = None
                return conn
            except Exception:
                logging.debug("SQL auth to %s failed", server)

        # try trusted connection fallback
        tried.append(f"{rkey}@{server}(trusted)")
        conn_str_trusted = (
            f"DRIVER={{{ODBC_DRIVER}}};"
            f"SERVER={server};DATABASE=ACVSCore;Trusted_Connection=yes;"
            "TrustServerCertificate=Yes;"
        )
        try:
            conn = pyodbc.connect(conn_str_trusted, autocommit=True, timeout=timeout)
            logging.info("Connected to ACVSCore on %s using trusted connection (region %s).", server, rkey)
            _acvscore_backoff["failed"] = False
            _acvscore_backoff["ts"] = None
            return conn
        except Exception:
            logging.debug("Trusted connection to %s failed", server)
            continue

    # mark backoff
    try:
        import time
        _acvscore_backoff["ts"] = time.time()
        _acvscore_backoff["failed"] = True
    except Exception:
        pass
    logging.error("Failed ACVSCore connection attempts: %s", tried)
    return None


def get_personnel_info(candidate_identifier: object) -> Dict[str, Any]:
    """
    Best-effort personnel lookup in ACVSCore.Access.Personnel.
    Returns dict with keys: ObjectID, GUID, Name, EmailAddress, EmployeeEmail, ManagerEmail (when found).
    If DB not available, returns empty dict.
    """
    out = {}
    if candidate_identifier is None:
        return out

    conn = _get_acvscore_conn()
    if conn is None:
        logging.debug("get_personnel_info: ACVSCore unavailable.")
        return out

    try:
        cur = conn.cursor()
        sql = """
            SELECT TOP 1 ObjectID, GUID, Name, EmailAddress, ManagerEmail
            FROM ACVSCore.Access.Personnel
            WHERE
              (CAST(ObjectID AS NVARCHAR(200)) = ?)
              OR (GUID = ?)
              OR (CAST(Int1 AS NVARCHAR(200)) = ?)
              OR (Text12 = ?)
              OR (Name = ?)
            ORDER BY ObjectID DESC
        """
        cand = str(candidate_identifier).strip()
        cand_guid = cand if _looks_like_guid(cand) else None
        params = (cand, cand_guid, cand, cand, cand)
        cur.execute(sql, params)
        row = cur.fetchone()
        if row:
            try:
                out['ObjectID'] = row[0]
                out['GUID'] = row[1]
                out['Name'] = row[2]
                email_val = row[3] if len(row) > 3 else None
                out['EmailAddress'] = email_val or None
                out['EmployeeEmail'] = email_val or None
                out['ManagerEmail'] = row[4] if len(row) > 4 else None
                logging.info("get_personnel_info: found ObjectID=%s Email=%s for candidate=%s", out.get('ObjectID'), out.get('EmailAddress'), candidate_identifier)
            except Exception:
                logging.exception("get_personnel_info: failed to parse db row")
    except Exception:
        logging.exception("get_personnel_info: db query failed for %s", candidate_identifier)
    finally:
        try:
            cur.close()
        except Exception:
            pass
        try:
            conn.close()
        except Exception:
            pass
    return out


def get_person_image_bytes(parent_id) -> Optional[bytes]:
    """
    Try to fetch an employee image for the given parent id. Order:
      1) DB (ACVSCore.Access.Images)
      2) Filesystem under outputs/images, outputs, repo/images, repo root, cwd
      3) Base64 text files (.b64/.txt)
    Returns image bytes or None.
    """
    if parent_id is None:
        return None

    # DB attempt
    try:
        conn = _get_acvscore_conn()
        if conn is not None:
            try:
                cur = conn.cursor()
                sql = """
                    SELECT TOP 1 AI.Image
                    FROM ACVSCore.Access.Images AI
                    WHERE AI.ParentId = ?
                      AND DATALENGTH(AI.Image) > 0
                    ORDER BY AI.ObjectID DESC
                """
                # build candidate parent ids (strip prefixes, try int string variants, emp_ prefix)
                cand_parent_ids = []
                raw_pid = str(parent_id).strip()
                cand_parent_ids.append(raw_pid)
                stripped = _strip_person_uid_prefix(raw_pid)
                if stripped and stripped != raw_pid:
                    cand_parent_ids.append(stripped)
                try:
                    if stripped and '.' in stripped:
                        f = float(stripped)
                        if f.is_integer():
                            cand_parent_ids.append(str(int(f)))
                except Exception:
                    pass
                try:
                    if stripped and stripped.isdigit():
                        cand_parent_ids.append(f"emp_{stripped}")
                except Exception:
                    pass

                # dedupe preserve order
                seen = set()
                cand_parent_ids = [x for x in cand_parent_ids if x and (not (x in seen or seen.add(x)))]

                for pid_try in cand_parent_ids:
                    try:
                        cur.execute(sql, (str(pid_try),))
                        row = cur.fetchone()
                        if row and row[0] is not None:
                            try:
                                b = bytes(row[0])
                                logging.info("get_person_image_bytes: DB image found for ParentId=%s (len=%d)", pid_try, len(b))
                                return b
                            except Exception:
                                logging.exception("get_person_image_bytes: convert DB image to bytes failed for %s", pid_try)
                                return row[0]
                    except Exception:
                        logging.debug("get_person_image_bytes: db fetch failed for ParentId=%s", pid_try)
                        continue
            except Exception:
                logging.exception("get_person_image_bytes: query failed")
            finally:
                try:
                    cur.close()
                except Exception:
                    pass
                try:
                    conn.close()
                except Exception:
                    pass
    except Exception:
        logging.exception("get_person_image_bytes: unexpected DB path error")

    # Filesystem fallback
    try:
        pid_raw = str(parent_id).strip()
        cand_ids = [pid_raw]
        # numeric int form
        try:
            f = float(pid_raw)
            if f.is_integer():
                int_form = str(int(f))
                if int_form not in cand_ids:
                    cand_ids.append(int_form)
        except Exception:
            pass
        try:
            if pid_raw.isdigit():
                cand_ids.append(f"emp_{pid_raw}")
                if len(pid_raw) < 8:
                    cand_ids.append(pid_raw.zfill(8))
        except Exception:
            pass
        cand_ids = list(dict.fromkeys(cand_ids))

        candidate_dirs = [
            (Path(DEFAULT_OUTDIR) / "images"),
            Path(DEFAULT_OUTDIR),
            Path(__file__).resolve().parent / "images",
            Path(__file__).resolve().parent,
            Path.cwd()
        ]
        exts = (".jpg", ".jpeg", ".png", ".bmp", ".gif", ".webp")
        b64_exts = (".b64", ".txt")

        for c in cand_ids:
            for folder in candidate_dirs:
                try:
                    if not folder.exists():
                        continue
                except Exception:
                    continue

                for ext in exts:
                    fp = folder / f"{c}{ext}"
                    try:
                        if fp.exists() and fp.is_file():
                            logging.info("get_person_image_bytes: found file %s", fp)
                            try:
                                return fp.read_bytes()
                            except Exception:
                                logging.exception("get_person_image_bytes: failed reading %s", fp)
                                continue
                    except Exception:
                        continue

                for ext in b64_exts:
                    fp = folder / f"{c}{ext}"
                    try:
                        if fp.exists() and fp.is_file():
                            logging.info("get_person_image_bytes: found base64 file %s", fp)
                            try:
                                txt = fp.read_text(encoding='utf-8', errors='ignore').strip()
                                if txt:
                                    if ',' in txt and txt.startswith('data:'):
                                        try:
                                            b64 = txt.split(',', 1)[1]
                                            return base64.b64decode(b64)
                                        except Exception:
                                            pass
                                    try:
                                        return base64.b64decode(txt)
                                    except Exception:
                                        logging.exception("get_person_image_bytes: base64 decode failed for %s", fp)
                                        continue
                            except Exception:
                                logging.exception("get_person_image_bytes: failed reading base64 file %s", fp)
                                continue

                # glob fallback
                try:
                    for fp in folder.glob(f"*{c}*"):
                        if fp.is_file():
                            try:
                                b = fp.read_bytes()
                                if b:
                                    logging.info("get_person_image_bytes: loaded image via glob %s", fp)
                                    return b
                            except Exception:
                                logging.exception("get_person_image_bytes: failed reading glob file %s", fp)
                                continue
                except Exception:
                    logging.exception("get_person_image_bytes: glob check failed in %s for token %s", folder, c)
                    continue
    except Exception:
        logging.exception("get_person_image_bytes: filesystem search failed for ParentId=%s", parent_id)

    logging.debug("get_person_image_bytes: no image found for ParentId=%s", parent_id)
    return None


