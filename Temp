// C:\Users\W0024618\Desktop\global-page\backend\config\dbConfig.js
import sql from 'mssql';

// shared options
const commonOpts = {
  options: {
    encrypt: true,
    trustServerCertificate: true
  },
  // increase timeouts (milliseconds)
  // requestTimeout: maximum time for a single request to complete
  requestTimeout: 300000,      // 5 minutes
  // connectionTimeout: time to wait while establishing connection
  connectionTimeout: 30000,    // 30 seconds
  // pool defaults
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  }
};

// lowercase keys only
const regions = {
  apac: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUPNQ0986V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  },
  emea: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUFRA0986V',
    database: 'ACVSUJournal_00011028',
    ...commonOpts
  },
  laca: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUSJO0986V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  },
  namer: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUDEN0891V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  }
};

// cache of connected pools by key: `${regionKey}_${database}`
const pools = {};

/**
 * Parse a database name for a numeric suffix in the form: "<base>_<digits>"
 * If match -> returns { base: "<base>_", num: <Number>, width: <digits length> }
 * If not match -> returns null
 */
function parseDbWithNumericSuffix(dbName) {
  if (!dbName || typeof dbName !== 'string') return null;
  const m = dbName.match(/^(.*?_)(\d+)$/);
  if (!m) return null;
  const base = m[1]; // includes trailing underscore
  const numStr = m[2];
  const num = parseInt(numStr, 10);
  return { base, num, width: numStr.length };
}

/**
 * Build a database name given parsed result and target number, preserving zero padding.
 */
function buildDbName(parsed, targetNum) {
  const padded = String(targetNum).padStart(parsed.width, '0');
  return `${parsed.base}${padded}`;
}

/**
 * Create/return (cached) a connected pool for the supplied region config object,
 * overriding the database name if overrideDatabase is provided.
 *
 * pools are cached using key: `${regionKey}_${databaseName}`
 */
async function ensurePoolForDatabase(regionKey, cfg, overrideDatabase) {
  const dbName = overrideDatabase || cfg.database;
  const cacheKey = `${regionKey}_${dbName}`;
  if (pools[cacheKey]) {
    // if pool exists but not connected (closed), attempt reconnect
    try {
      if (pools[cacheKey]._connected === false) {
        // re-connect
        pools[cacheKey] = await new sql.ConnectionPool({ ...cfg, database: dbName }).connect();
      }
      return pools[cacheKey];
    } catch (e) {
      // If reconnect fails, delete and fall through to create new
      delete pools[cacheKey];
    }
  }

  // create new pool for this dbName
  const poolCfg = { ...cfg, database: dbName };
  const pool = await new sql.ConnectionPool(poolCfg).connect();
  pools[cacheKey] = pool;
  return pool;
}

/**
 * Return single pool for the configured database of a region (backwards-compatible).
 * @param {string} regionKey  one of the keys in `regions`, case-insensitive
 * @returns {Promise<sql.ConnectionPool>}
 */
export async function getPool(regionKey) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) {
    throw new Error(`Unknown region: ${regionKey}`);
  }
  // ensure and return pool for the configured database (primary)
  return ensurePoolForDatabase(key, cfg, cfg.database);
}

/**
 * Return an array of pools for the region: [current, current-1, current-2, current-3, current-4]
 * If the configured database name doesn't have a numeric suffix, only the configured DB is returned.
 *
 * @param {string} regionKey
 * @returns {Promise<sql.ConnectionPool[]>}
 */
export async function getRegionPools(regionKey) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) {
    throw new Error(`Unknown region: ${regionKey}`);
  }

  const parsed = parseDbWithNumericSuffix(cfg.database);
  if (!parsed) {
    // cannot parse numeric suffix, return only primary
    const p = await ensurePoolForDatabase(key, cfg, cfg.database);
    return [p];
  }

  // Build list: current, current-1, current-2, current-3, current-4 (but do not create DB names <= 0)
  const nums = [
    parsed.num,
    parsed.num - 1,
    parsed.num - 2,
    parsed.num - 3,
    parsed.num - 4
  ].filter(n => n > 0);
  const dbNames = nums.map(n => buildDbName(parsed, n));

  // Ensure pools for each dbName (in configured order). If connect fails for a specific DB,
  // log and continue so caller receives the pools that succeeded.
  const createdPools = [];
  for (const dbName of dbNames) {
    try {
      const p = await ensurePoolForDatabase(key, cfg, dbName);
      createdPools.push(p);
    } catch (err) {
      // If connection to a previous DB fails, log and continue (do not block other pools)
      // This is safer in production where older DB might be offline.
      // Caller will receive the pools that succeeded.
      // eslint-disable-next-line no-console
      console.warn(`Failed to connect to ${dbName} for region ${key}:`, err.message || err);
    }
  }

  // If none succeeded (very unlikely), still attempt primary (configured) DB as fallback
  if (createdPools.length === 0) {
    const primary = await ensurePoolForDatabase(key, cfg, cfg.database);
    return [primary];
  }

  return createdPools;
}

/**
 * Convenience: returns the first available pool among [current, n-1, n-2, n-3, n-4].
 * Falls back to primary configured DB if none of the parsed names connected successfully.
 *
 * @param {string} regionKey
 * @returns {Promise<sql.ConnectionPool>}
 */
export async function getAnyPool(regionKey) {
  const poolsArr = await getRegionPools(regionKey);
  if (poolsArr && poolsArr.length) return poolsArr[0];
  // fallback to single primary pool
  return getPool(regionKey);
}

export { sql };

















// C:\Users\W0024618\Desktop\global-page\backend\config\dbConfig.js
import sql from 'mssql';

// shared options
const commonOpts = {
  options: {
    encrypt: true,
    trustServerCertificate: true
  },
  // increase timeouts (milliseconds)
  // requestTimeout: maximum time for a single request to complete
  requestTimeout: 300000,      // 5 minutes
  // connectionTimeout: time to wait while establishing connection
  connectionTimeout: 30000,    // 30 seconds
  // pool defaults
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  }
};

// lowercase keys only
const regions = {
  apac: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUPNQ0986V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  },
  emea: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUFRA0986V',
    database: 'ACVSUJournal_00011028',
    ...commonOpts
  },
  laca: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUSJO0986V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  },
  namer: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUDEN0891V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  }
};

// cache of connected pools by key: `${regionKey}_${database}`
const pools = {};

/**
 * Parse a database name for a numeric suffix in the form: "<base>_<digits>"
 * If match -> returns { base: "<base>_", num: <Number>, width: <digits length> }
 * If not match -> returns null
 */
function parseDbWithNumericSuffix(dbName) {
  if (!dbName || typeof dbName !== 'string') return null;
  const m = dbName.match(/^(.*?_)(\d+)$/);
  if (!m) return null;
  const base = m[1]; // includes trailing underscore
  const numStr = m[2];
  const num = parseInt(numStr, 10);
  return { base, num, width: numStr.length };
}

/**
 * Build a database name given parsed result and target number, preserving zero padding.
 */
function buildDbName(parsed, targetNum) {
  const padded = String(targetNum).padStart(parsed.width, '0');
  return `${parsed.base}${padded}`;
}

/**
 * Create/return (cached) a connected pool for the supplied region config object,
 * overriding the database name if overrideDatabase is provided.
 *
 * pools are cached using key: `${regionKey}_${databaseName}`
 */
async function ensurePoolForDatabase(regionKey, cfg, overrideDatabase) {
  const dbName = overrideDatabase || cfg.database;
  const cacheKey = `${regionKey}_${dbName}`;
  if (pools[cacheKey]) {
    // if pool exists but not connected (closed), attempt reconnect
    try {
      if (pools[cacheKey]._connected === false) {
        // re-connect
        pools[cacheKey] = await new sql.ConnectionPool({ ...cfg, database: dbName }).connect();
      }
      return pools[cacheKey];
    } catch (e) {
      // If reconnect fails, delete and fall through to create new
      delete pools[cacheKey];
    }
  }

  // create new pool for this dbName
  const poolCfg = { ...cfg, database: dbName };
  const pool = await new sql.ConnectionPool(poolCfg).connect();
  pools[cacheKey] = pool;
  return pool;
}

/**
 * Return single pool for the configured database of a region (backwards-compatible).
 * @param {string} regionKey  one of the keys in `regions`, case-insensitive
 * @returns {Promise<sql.ConnectionPool>}
 */
export async function getPool(regionKey) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) {
    throw new Error(`Unknown region: ${regionKey}`);
  }
  // ensure and return pool for the configured database (primary)
  return ensurePoolForDatabase(key, cfg, cfg.database);
}

/**
 * Return an array of pools for the region: [current, current-1, current-2]
 * If the configured database name doesn't have a numeric suffix, only the configured DB is returned.
 *
 * @param {string} regionKey
 * @returns {Promise<sql.ConnectionPool[]>}
 */
export async function getRegionPools(regionKey) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) {
    throw new Error(`Unknown region: ${regionKey}`);
  }

  const parsed = parseDbWithNumericSuffix(cfg.database);
  if (!parsed) {
    // cannot parse numeric suffix, return only primary
    const p = await ensurePoolForDatabase(key, cfg, cfg.database);
    return [p];
  }

  // Build list: current, current-1, current-2 (but do not create DB names <= 0)
  const nums = [parsed.num, parsed.num - 1, parsed.num - 2].filter(n => n > 0);
  const dbNames = nums.map(n => buildDbName(parsed, n));

  // Ensure pools for each dbName (in configured order). If connect fails for a specific DB,
  // let the error propagate so the caller can decide - alternatively we could swallow errors
  // and return only successful ones; for now we attempt to create them and throw if connection fails.
  const createdPools = [];
  for (const dbName of dbNames) {
    try {
      const p = await ensurePoolForDatabase(key, cfg, dbName);
      createdPools.push(p);
    } catch (err) {
      // If connection to a previous DB fails, log and continue (do not block other pools)
      // This is safer in production where older DB might be offline.
      // Caller will receive the pools that succeeded.
      // eslint-disable-next-line no-console
      console.warn(`Failed to connect to ${dbName} for region ${key}:`, err.message || err);
    }
  }

  // If none succeeded (very unlikely), still attempt primary (configured) DB as fallback
  if (createdPools.length === 0) {
    const primary = await ensurePoolForDatabase(key, cfg, cfg.database);
    return [primary];
  }

  return createdPools;
}

/**
 * Convenience: returns the first available pool among [current, n-1, n-2].
 * Falls back to primary configured DB if none of the parsed names connected successfully.
 *
 * @param {string} regionKey
 * @returns {Promise<sql.ConnectionPool>}
 */
export async function getAnyPool(regionKey) {
  const poolsArr = await getRegionPools(regionKey);
  if (poolsArr && poolsArr.length) return poolsArr[0];
  // fallback to single primary pool
  return getPool(regionKey);
}

export { sql };

















Now i want to update dbConfig.js like When new Database is created i want use 3 Database 
for ex - Database is Henerate like  Current is ACVSUJournal_00010029
now When new created ACVSUJournal_00010030 , 31 in same series 
So use Current latest data base alos n-2  use three databases for all 
update below file carefully ....





//C:\Users\W0024618\Desktop\global-page\backend\config\dbConfig.js
import sql from 'mssql';

// shared options
const commonOpts = {
  options: {
    encrypt: true,
    trustServerCertificate: true
  },
  // increase timeouts (milliseconds)
  // requestTimeout: maximum time for a single request to complete
  requestTimeout: 300000,      // 5 minutes
  // connectionTimeout: time to wait while establishing connection
  connectionTimeout: 30000,    // 30 seconds
  // pool defaults
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  }
};

// lowercase keys only
const regions = {
  apac: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUPNQ0986V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  },
  emea: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUFRA0986V',
    database: 'ACVSUJournal_00011028',
    ...commonOpts
  },
  laca: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUSJO0986V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  },
  namer: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUDEN0891V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  }
};

const pools = {};

/**
 * @param {string} regionKey  one of the keys in `regions`, case-insensitive
 */
export async function getPool(regionKey) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) {
    throw new Error(`Unknown region: ${regionKey}`);
  }
  if (!pools[key]) {
    pools[key] = await new sql.ConnectionPool(cfg).connect();
  }
  return pools[key];
}

export { sql };




