{
  "users": [
    {
      "username": "Lloyds Das",
      "employeeId": "314345",
      "password": "password123",
      "permissions": {
        "can_grant": true,
        "global_access": true,
        "device_health": true,
        "headcount": true,
        "headcount.apac": true,
        "headcount.emea": true,
        "headcount.laca": true,
        "headcount.namer": true,
        "ert": true,
        "associate_verify": true,
        "gsoc_reports": true,
        "global_duration": true,
        "upload_active_employees": true,
        "upload_active_contractors": true,
        "export_compare": true
      }
    },
    {
      "username": "Pandey, Sonu",
      "employeeId": "326131",
      "password": "password123",
      "permissions": {
        "can_grant": true,
        "global_access": true,
        "device_health": true,
        "headcount": true,
        "headcount.apac": true,
        "headcount.emea": true,
        "headcount.laca": true,
        "headcount.namer": true,
        "ert": true,
        "associate_verify": true,
        "gsoc_reports": true,
        "global_duration": true,
        "upload_active_employees": true,
        "upload_active_contractors": true,
        "export_compare": true
      }
    },
    {
      "username": "Diwate, Swapnil",
      "employeeId": "W0024618",
      "password": "password123",
      "permissions": {
        "can_grant": true,
        "global_access": true,
        "device_health": true,
        "headcount": true,
        "headcount.apac": true,
        "headcount.emea": true,
        "headcount.laca": true,
        "headcount.namer": true,
        "ert": true,
        "associate_verify": true,
        "gsoc_reports": true,
        "global_duration": true,
        "upload_active_employees": true,
        "upload_active_contractors": true,
        "export_compare": true
      }
    },
    {
      "username": "Dhobale, Abhishek",
      "employeeId": "W0025562",
      "password": "password123",
      "permissions": {
        "ert": true
      }
    }
  ]
}























import React, { useEffect, useState } from 'react';
import { Box, Paper, TextField, Button, Typography, Checkbox, FormControlLabel, Grid, Alert } from '@mui/material';
import axios from 'axios';
import { useAuth } from '../context/AuthContext';

// Define available page keys (map to UI names)
// Added granular keys: headcount.<region>, gsoc_reports.<report>, upload/export perms, global_access
const PAGES = [
  { key: 'global_access', label: 'Global Access (all pages)' },
  { key: 'device_health', label: 'Device Health Dashboard' },
  { key: 'headcount', label: 'HeadCount (any region)' },
  { key: 'headcount.apac', label: 'HeadCount — APAC' },
  { key: 'headcount.emea', label: 'HeadCount — EMEA' },
  { key: 'headcount.laca', label: 'HeadCount — LACA' },
  { key: 'headcount.namer', label: 'HeadCount — NAMER' },
  { key: 'headcount.partition.pune', label: 'HeadCount — Pune (partition)' },

  { key: 'ert', label: 'ERT Members' },
  { key: 'associate_verify', label: 'Associate Verification Tool' },

  // GSOC reports per-report keys
  { key: 'gsoc_reports', label: 'GSOC Reports (all)' },
  { key: 'gsoc_reports.daily_access', label: 'GSOC — Daily Access' },
  { key: 'gsoc_reports.raw', label: 'GSOC — Raw' },
  { key: 'gsoc_reports.rejection', label: 'GSOC — Rejection' },
  { key: 'gsoc_reports.euroc', label: 'GSOC — EUROC Admit/Reject' },
  { key: 'gsoc_reports.time_duration', label: 'GSOC — Time Duration' },
  { key: 'gsoc_reports.headcount', label: 'GSOC — HeadCount (external nav)' },

  // Upload / export permissions
  { key: 'upload_active_employees', label: 'Upload Active Employee Sheet' },
  { key: 'upload_active_contractors', label: 'Upload Active Contractor Sheet' },
  { key: 'export_compare', label: 'Export Comparison (Missing vs CCURE)' },

  { key: 'global_duration', label: 'Duration Page (global)' },
  { key: 'can_grant', label: 'Grant permissions (admin)' },
];

export default function AccessManager() {
  const auth = useAuth();
  const [employeeId, setEmployeeId] = useState('');
  const [employeeName, setEmployeeName] = useState('');
  const [checked, setChecked] = useState({});
  const [status, setStatus] = useState(null);

  useEffect(() => {
    // nothing heavy here
  }, []);

  if (!auth.canGrant) {
    return <Box sx={{ p: 3 }}><Alert severity="error">You don't have grant permissions.</Alert></Box>;
  }

  const handleCheck = (k) => {
    setChecked(prev => ({ ...prev, [k]: !prev[k] }));
  };

  const handleGrant = async () => {
    if (!employeeId && !employeeName) {
      setStatus({ type: 'error', msg: 'Enter Employee ID or name to grant access' });
      return;
    }
    setStatus({ type: 'info', msg: 'Granting...' });
    try {
      const pages = Object.keys(checked).filter(k => checked[k]);
      await axios.post('/api/auth/grant', { grantee_employee_id: employeeId, grantee_name: employeeName, pages });
      setStatus({ type: 'success', msg: 'Granted successfully' });
      auth.refresh();
    } catch (err) {
      console.error(err);
      setStatus({ type: 'error', msg: err?.response?.data?.detail || err?.message || 'Grant failed' });
    }
  };

  const handleRevoke = async () => {
    if (!employeeId && !employeeName) {
      setStatus({ type: 'error', msg: 'Enter Employee ID or name to revoke access' });
      return;
    }
    setStatus({ type: 'info', msg: 'Revoking...' });
    try {
      const pages = Object.keys(checked).filter(k => checked[k]);
      await axios.post('/api/auth/revoke', { grantee_employee_id: employeeId, grantee_name: employeeName, pages });
      setStatus({ type: 'success', msg: 'Revoked successfully' });
      auth.refresh();
    } catch (err) {
      console.error(err);
      setStatus({ type: 'error', msg: err?.response?.data?.detail || err?.message || 'Revoke failed' });
    }
  };

  const selectAll = () => {
    const obj = {};
    PAGES.forEach(p => obj[p.key] = true);
    setChecked(obj);
  };
  const clearAll = () => setChecked({});

  return (
    <Box sx={{ p: 3 }}>
      <Paper sx={{ p: 3 }}>
        <Typography variant="h6" sx={{ mb: 2 }}>Access Manager — Grant / Revoke Pages</Typography>

        {status && <Alert severity={status.type} sx={{ mb: 2 }}>{status.msg}</Alert>}

        <Grid container spacing={2}>
          <Grid item xs={12} md={6}>
            <TextField fullWidth label="Employee ID (e.g. W0025562)" value={employeeId} onChange={e => setEmployeeId(e.target.value)} helperText="EmployeeID or login"/>
          </Grid>
          <Grid item xs={12} md={6}>
            <TextField fullWidth label="Employee Name (optional)" value={employeeName} onChange={e => setEmployeeName(e.target.value)} />
          </Grid>

          <Grid item xs={12}>
            <Typography sx={{ mb: 1, fontWeight: 700 }}>Pages to grant / revoke</Typography>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
              {PAGES.map(p => (
                <FormControlLabel
                  key={p.key}
                  control={<Checkbox checked={!!checked[p.key]} onChange={() => handleCheck(p.key)} />}
                  label={p.label}
                />
              ))}
            </Box>

            <Box sx={{ display: 'flex', gap: 1, mt: 2 }}>
              <Button variant="outlined" onClick={selectAll}>Select all</Button>
              <Button variant="outlined" onClick={clearAll}>Clear</Button>
              <Button variant="contained" color="primary" onClick={handleGrant}>Grant access</Button>
              <Button variant="contained" color="error" onClick={handleRevoke}>Revoke access</Button>
            </Box>

            <Typography variant="caption" sx={{ display: 'block', mt: 2, color: 'text.secondary' }}>
              Granting will call backend and store the mapping. Revoking will remove access. After changes, this UI refreshes current user's permissions (if affected).
            </Typography>
          </Grid>
        </Grid>
      </Paper>
    </Box>
  );
}
























// src/pages/ReportsPage.jsx
import React, { useState } from 'react';
import {
  Box, FormControl, InputLabel, Select, OutlinedInput,
  Checkbox, ListItemText, MenuItem, Button,
  CircularProgress, Typography, TextField, Tabs, Tab, Grid, Paper, IconButton, Divider
} from '@mui/material';

import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import axios from 'axios';
import ExcelJS from 'exceljs';
import * as XLSX from 'xlsx';
import { useAuth } from '../context/AuthContext';

import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import PlaceIcon from '@mui/icons-material/Place';
import PeopleIcon from '@mui/icons-material/People';
import DownloadIcon from '@mui/icons-material/CloudDownload';
import FilterListIcon from '@mui/icons-material/FilterList';
import Avatar from '@mui/material/Avatar';

// Static lists
const EMPLOYEE_OPTIONS = [
  'Vainilaitis, Valdas',
  'Tomasevic, Kazimez',
  'Sesickis, Janas',
  'Valiunas, Sigitas',
  'JANCUKOVIC, VACLAVA',
  'Kalpokiene, Alina',
  'Korkus, Vanda',
  'Kvaraciejiene, Maryte',
  'ZNAMEROVSKIS, DARIUS'
];

const REGION_OPTIONS = ['global', 'apac', 'emea', 'laca', 'namer'];
const LOCATION_MAP = {
  apac: ['APAC.Default', 'JP.Tokyo', 'PH.Manila', 'MY.Kuala Lumpur'],
  emea: ['AUT.Vienna', 'DU.Abu Dhab', 'IE.Dublin', 'IT.Rome', 'LT.Vilnius', 'MA.Casablanca', 'RU.Moscow', 'UK.London', 'ES.Madrid'],
  laca: ['AR.Cordoba', 'CR.Costa Rica Partition', 'MX.Mexico City', 'PE.Lima', 'BR.Sao Paulo', 'PA.Panama City'],
  namer: ['US.NYC', 'US.FL.Miami', 'USA/Canada Default', 'US.CO.OBS'],
  global: []
};

function formatDisplayDate(date) {
  const d = new Date(date);
  const day = d.getDate();
  const suf = day % 10 === 1 && day !== 11 ? 'st'
    : day % 10 === 2 && day !== 12 ? 'nd'
      : day % 10 === 3 && day !== 13 ? 'rd' : 'th';
  const mon = d.toLocaleString('default', { month: 'long' });
  return `${day}${suf} ${mon} ${d.getFullYear()}`;
}

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');

function formatDateFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  const y = dt.getUTCFullYear();
  const m = dt.getUTCMonth(); // 0..11
  const d = dt.getUTCDate();
  const yrShort = String(y).slice(-2);
  return `${pad2(d)}-${MONTH_ABBR[m]}-${yrShort}`;         // e.g. "12-Aug-25"
}

function formatTimeFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  let hh = dt.getUTCHours();   // use UTC parts so we trust server wall-clock
  const mm = dt.getUTCMinutes();
  const ss = dt.getUTCSeconds();
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1;
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;        // e.g. "12:01:24 AM"
}

function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10); // "YYYY-MM-DD"
  if (!swipeIso) {
    return `${datePart}T00:00:00.000Z`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000Z`;
  }
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000Z`;
}

function formatShortRange(fromDate, toDate) {
  if (!fromDate || !toDate) return '';
  const f = formatDisplayDate(fromDate);
  const t = formatDisplayDate(toDate);
  const [fDay, fMon] = f.split(' ');
  const [tDay, tMon] = t.split(' ');

  if (fMon === tMon) {
    return `${fDay} to ${tDay} ${fMon}`;
  }
  return `${fDay} ${fMon} to ${tDay} ${tMon}`;
}

function buildRawFileName({ region, location, rawSearch, from, to }) {
  const shortRange = formatShortRange(from, to);
  const regionPart = (region || '').toUpperCase();
  const locPart = location ? `-${location.split('.').pop()}` : '';
  const prefix = rawSearch && rawSearch.toString().trim() ? `${rawSearch.toString().trim()} ` : '';
  const base = `${regionPart}${locPart} Raw report ${shortRange}`;
  const safeBase = base.replace(/[\/\\:\*\?"<>\|]+/g, '').replace(/\s+/g, ' ').trim();
  return `${prefix}${safeBase}.xlsx`;
}

// returns a server-wall-clock ISO for a row: prefer LocaleMessageTime, else DateOnly+Swipe_Time
const getServerISO = (r) => {
  if (!r) return '';
  if (r.LocaleMessageTime) return r.LocaleMessageTime;
  if (r.DateOnly) return buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  return '';
};

// returns YYYY-MM-DD for server wall-clock (used for filtering)
const getServerYMD = (r) => {
  const iso = getServerISO(r);
  if (!iso) return '';
  return iso.slice(0, 10);
};

// Helper — convert "YYYY-MM-DD..." (ISO) into a local midnight Date (avoids UTC shift)
const isoDateOnlyToLocalDate = (iso) => {
  if (!iso) return null;
  const s = iso.toString().slice(0, 10);
  const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
  return new Date(y, m - 1, d);
};

// Build a Date that preserves the server-provided wall-clock values.
// If swipeTime is an ISO (with Z), read UTC components and use them as local values.
const buildLocalDateFromDateOnlyAndSwipe = (dateOnly, swipeTime) => {
  if (!dateOnly) return null;
  const dateStr = dateOnly.toString().slice(0, 10);
  const [yy, mm, dd] = dateStr.split('-').map(n => parseInt(n, 10));

  let hh = 0, min = 0, ss = 0;
  if (swipeTime) {
    const parsed = new Date(swipeTime);
    if (!isNaN(parsed.getTime())) {
      hh = parsed.getUTCHours();
      min = parsed.getUTCMinutes();
      ss = parsed.getUTCSeconds();
    } else {
      const parts = swipeTime.split(':').map(p => parseInt(p, 10));
      if (parts.length >= 2) {
        hh = parts[0] || 0;
        min = parts[1] || 0;
        ss = parts[2] || 0;
      }
    }
  }
  return new Date(yy, mm - 1, dd, hh, min, ss);
};

export default function ReportsPage() {
  const auth = useAuth();

  // --- state ---
  const [tab, setTab] = useState(0);

  const [region, setRegion] = useState('emea');
  const [location, setLocation] = useState('');
  const [from, setFrom] = useState(null);
  const [to, setTo] = useState(null);
  const [showFromCal, setShowFromCal] = useState(false);
  const [showToCal, setShowToCal] = useState(false);
  const [selectedEmps, setSelectedEmps] = useState([]);
  const [loading, setLoading] = useState(false);

  const [rawSearch, setRawSearch] = useState('');
  const [rawAdmitFilter, setRawAdmitFilter] = useState('all');

  // Handle tab switch (Daily / Raw / Rejection)
  const handleTabChange = (_, v) => {
    setTab(v);
    // reset filters
    setRegion('emea');
    setLocation('');
    setFrom(null);
    setTo(null);
    setSelectedEmps([]);
    setRawSearch('');
    setRawAdmitFilter('all');
  };

  /** Time Duration Excel generator */
  const generateTimeDurationExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Time Duration');

    ws.mergeCells('A1:M1');
    ws.getCell('A1').value =
      `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };

    const headers = [
      'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
      'Partition', 'Text5', 'Year', 'Week', 'Date',
      'First Swipe', 'Last Swipe', 'Duration', 'Category',
      'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'ptype', width: 18 },
      { key: 'part', width: 15 },
      { key: 'txt5', width: 20 },
      { key: 'year', width: 8 },
      { key: 'week', width: 6 },
      { key: 'date', width: 12 },
      { key: 'first', width: 16 },
      { key: 'last', width: 16 },
      { key: 'dur', width: 10 },
      { key: 'cat', width: 12 },
      { key: 'dpw', width: 12 },
      { key: 'vdw', width: 14 },
      { key: 'cdw', width: 12 },
      { key: 'def', width: 10 }
    ];

    data.forEach((r, idx) => {
      const first = new Date(r.FirstSwipeTime);
      const last = new Date(r.LastSwipeTime);
      const date = new Date(r.ShiftedDate);
      const row = ws.addRow([
        idx + 1,
        r.ObjectName1,
        r.EmployeeID,
        r.PersonnelType,
        r.PartitionName2,
        r.text5,
        r.YearNumber,
        r.WeekNumber,
        date,
        first,
        last,
        r.DurationHHMM,
        r.TimeDiffCategory,
        r.DaysPresentInWeek,
        r.ViolationDaysInWeek,
        r.CleanDaysInWeek,
        r.Defaulter
      ]);

      row.getCell(9).numFmt = 'dd-mmm-yy';
      row.getCell(10).numFmt = 'h:mm:ss AM/PM';
      row.getCell(11).numFmt = 'h:mm:ss AM/PM';

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    ws.autoFilter = 'A2:Q2';

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    const filename =
      `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;

    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  // Daily Access Excel
  const generateDailyAccessExcel = async allRows => {
    const wb = new ExcelJS.Workbook();

    for (const emp of selectedEmps) {
      const ws = wb.addWorksheet(emp.substring(0, 31));
      const headers = [
        'Date', 'Time', 'Name', 'Contractor ID', 'Card No',
        'Door Name', 'Message Type', 'Partition', 'Swipe'
      ];
      ws.addRow(headers);
      const hdr = ws.getRow(1);
      hdr.font = { bold: true };
      hdr.alignment = { vertical: 'middle', horizontal: 'center' };
      hdr.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });

      ws.columns = [
        { key: 'date', width: 12 },
        { key: 'time', width: 12 },
        { key: 'name', width: 25 },
        { key: 'id', width: 15 },
        { key: 'card', width: 15 },
        { key: 'door', width: 40 },
        { key: 'msg', width: 15 },
        { key: 'part', width: 15 },
        { key: 'swipe', width: 10 }
      ];

      const rows = allRows.filter(r => r.ObjectName1 === emp);
      if (!rows.length) {
        ws.mergeCells('A2', 'I2');
        ws.getCell('A2').value = 'There is no swipe records found in Ccure';
        ws.getCell('A2').alignment = { horizontal: 'center' };
      } else {
        rows.forEach(r => {
          const iso = getServerISO(r);
          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws.addRow([
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.EmployeeID || '',
            r.CardNumber || '',
            r.Door || r.ObjectName2 || '',
            r.AdmitCode || r.Messagetype || '',
            r.location || '',
            r.Swipe || r.Direction || ''
          ]);

          row.getCell(1).alignment = { horizontal: 'left' };
          row.getCell(2).alignment = { horizontal: 'left' };

          row.eachCell(c => {
            c.border = {
              top: { style: 'thin' }, left: { style: 'thin' },
              bottom: { style: 'thin' }, right: { style: 'thin' }
            };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });
      }
      ws.autoFilter = 'A1:I1';
    }

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const filename = `Daily Access Report(${formatDisplayDate(from)} to ${formatDisplayDate(to)}).xlsx`;
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  // Rejection Excel
  const generateRejectionExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Rejection');

    const title = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}`;
    ws.mergeCells('A1:J1');
    ws.getCell('A1').value = title;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };

    const headers = [
      'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
      'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'date', width: 12 },
      { key: 'time', width: 12 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'card', width: 15 },
      { key: 'type', width: 15 },
      { key: 'door', width: 40 },
      { key: 'loc', width: 15 },
      { key: 'swipe', width: 10 }
    ];

    data.forEach((r, idx) => {
      const iso = getServerISO(r);
      const dateStr = iso ? formatDateFromServerISO(iso) : '';
      const timeStr = iso ? formatTimeFromServerISO(iso) : '';

      const row = ws.addRow([
        idx + 1,
        dateStr,
        timeStr,
        r.ObjectName1 || '',
        r.EmployeeID || '',
        r.CardNumber || '',
        r.Rejection_Type || '',
        r.Door || r.ObjectName2 || '',
        r.location || '',
        r.Direction || r.Swipe || ''
      ]);

      row.getCell(2).alignment = { horizontal: 'left' };
      row.getCell(3).alignment = { horizontal: 'left' };

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    const counts = data.reduce((a, r) => {
      const k = r.Rejection_Type || 'Unknown';
      a[k] = (a[k] || 0) + 1; return a;
    }, {});
    let rowIdx = 3;
    ws.getCell(rowIdx, 11).value = 'Rejection';
    ws.getCell(rowIdx, 12).value = 'Count';
    [11, 12].forEach(c => {
      const cell = ws.getCell(rowIdx, c);
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'center' };
      cell.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });
    rowIdx++;
    Object.entries(counts).forEach(([type, cnt]) => {
      ws.getCell(rowIdx, 11).value = type;
      ws.getCell(rowIdx, 12).value = cnt;
      [11, 12].forEach(c => {
        const cell = ws.getCell(rowIdx, c);
        cell.alignment = { horizontal: 'left' };
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });
      rowIdx++;
    });
    ws.getCell(rowIdx, 11).value = 'Total';
    ws.getCell(rowIdx, 12).value = data.length;
    [11, 12].forEach(c => {
      const cell = ws.getCell(rowIdx, c);
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'left' };
      cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
    });

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const filename = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}.xlsx`;
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  // generateRawExcel
  const generateRawExcel = async (rows, opts = {}) => {
    const formatTimeFromSwipe = (swipeIso) => {
      if (!swipeIso) return '';
      const dt = new Date(swipeIso);
      if (!isNaN(dt.getTime())) {
        return formatTimeFromServerISO(swipeIso);
      }
      const parts = ('' + swipeIso).split(':').map(p => parseInt(p || 0, 10));
      const hh = parts[0] || 0;
      const mm = parts[1] || 0;
      const ss = parts[2] || 0;
      const ampm = hh >= 12 ? 'PM' : 'AM';
      const hh12 = ((hh + 11) % 12) + 1;
      return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
    };

    const admitFilter = (opts.rawAdmitFilter || 'all').toString().toLowerCase();

    const baseHeaders = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber'];
    const admitCol = 'AdmitCode';
    const rejCol = 'Rejection_Type';
    const tailCols = ['Direction','Door'];

    let headers = [...baseHeaders];
    if (admitFilter === 'all') {
      headers.push(admitCol);
      headers.push(...tailCols);
      headers.push(rejCol);
    } else if (admitFilter === 'admit') {
      headers.push(admitCol);
      headers.push(...tailCols);
    } else if (admitFilter === 'reject') {
      headers.push(...tailCols);
      headers.push(rejCol);
    } else {
      headers.push(admitCol);
      headers.push(...tailCols);
      headers.push(rejCol);
    }

    if (!rows || !rows.length) {
      const wbEmpty = XLSX.utils.book_new();
      const wsEmpty = XLSX.utils.aoa_to_sheet([headers]);
      XLSX.utils.book_append_sheet(wbEmpty, wsEmpty, 'Raw');
      const fileNameEmpty = buildRawFileName(opts);
      XLSX.writeFile(wbEmpty, fileNameEmpty);
      return;
    }

    const rowsForSheet = rows.map(r => {
      const iso = getServerISO(r);
      const dateStr = iso ? formatDateFromServerISO(iso) : '';
      const timeStr = iso ? formatTimeFromServerISO(iso) : '';
      const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');
      const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';
      const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

      const fullObj = {
        LocaleMessageTime: localeMsgFormatted,
        DateOnly: dateOnlyFormatted,
        Swipe_Time: swipeTimeFormatted,
        EmployeeID: r.EmployeeID || '',
        ObjectName1: r.ObjectName1 || '',
        PersonnelType: r.PersonnelType || '',
        location: r.location || '',
        CardNumber: r.CardNumber || '',
        AdmitCode: r.AdmitCode || r.Messagetype || '',
        Direction: r.Direction || r.Swipe || '',
        Door: r.Door || r.ObjectName2 || '',
        Rejection_Type: r.Rejection_Type || ''
      };

      const picked = {};
      headers.forEach(h => {
        picked[h] = (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '';
      });
      return picked;
    });

    const ws = XLSX.utils.json_to_sheet(rowsForSheet, { header: headers });
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Raw');

    const filename = buildRawFileName(opts);
    XLSX.writeFile(wb, filename);
  };

  // --- Permission helpers ---
  const exportPermsForTab = () => {
    if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
    if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
    if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
    if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
    if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
    if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
    return ['gsoc_reports'];
  };

  // disabled conditions - UI-level validations (permission gating done separately)
  const disabled = loading
    || !region
    || (tab === 0 && (!from || !to || selectedEmps.length === 0))
    || (tab === 1 && (!from || !to))
    || (tab === 2 && (!from || !to))
    || (tab === 3 && !from)
    || (tab === 4 && (!from || !to));

  const navDisabled = !region || loading;

  const exportAllowed = auth.hasPermission(exportPermsForTab());

  // --- Generate handler with permission check up-front ---
  const handleGenerate = async () => {
    // Permission gating: determine required permission for each tab
    const requirePermissionForTab = () => {
      if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
      if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
      if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
      if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
      if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
      if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
      return ['gsoc_reports'];
    };

    if (!auth.hasPermission(requirePermissionForTab())) {
      alert('You do not have permission to generate this report.');
      return;
    }

    setLoading(true);
    try {
      const baseParams = { region, location: location || undefined };

      // Helper: format dates in local time without timezone conversion for API parameters
      const formatLocalDate = (date, endOfDay = false) => {
        const d = new Date(date);
        if (endOfDay) d.setHours(23, 59, 59, 999);
        else d.setHours(0, 0, 0, 0);
        const pad = n => n.toString().padStart(2, '0');
        return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}` +
               `T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      };

      const toLocalYMD = date => `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`;

      // ----- 0: Daily Access -----
      if (tab === 0) {
        const params = {
          ...baseParams,
          from: formatLocalDate(from),
          to: formatLocalDate(to, true),
          employees: selectedEmps.join(',')
        };
        const resp = await axios.get('/api/reports/daily-access', { params });

        const startDate = new Date(from); startDate.setHours(8, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(8, 0, 0, 0);

        const rows = (resp.data && resp.data.data) || [];
        const filtered = rows.filter(r => {
          const dt = new Date(r.LocaleMessageTime);
          return dt >= startDate && dt < endDate;
        });

        await generateDailyAccessExcel(filtered);
        return;
      }

      // ----- 1: Raw -----
      if (tab === 1) {
        const params = {
          ...baseParams,
          startDate: formatLocalDate(from),
          endDate: formatLocalDate(to, true),
          admitFilter: rawAdmitFilter
        };
        const resp = await axios.get('/api/reports/raw', { params });
        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

        const rowsSrc = (resp.data && resp.data.data) || [];
        const rows = rowsSrc.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          return date >= startDate && date <= endDate;
        });

        let filtered = rows;
        if (rawSearch && rawSearch.trim() !== '') {
          const s = rawSearch.trim().toLowerCase();
          filtered = rows.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            return id.includes(s) || name.includes(s);
          });
        }

        await generateRawExcel(filtered, { region, location, rawSearch, from, to, rawAdmitFilter });
        return;
      }

      // ----- 2: Rejection -----
      if (tab === 2) {
        const params = { ...baseParams, startDate: formatLocalDate(from), endDate: formatLocalDate(to, true) };
        const resp = await axios.get('/api/reports/rejection', { params });

        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

        const rowsSrc = (resp.data && resp.data.data) || [];
        const rows = rowsSrc.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          return date >= startDate && date <= endDate;
        });

        await generateRejectionExcel(rows);
        return;
      }

      // ----- 3: EUROC Admit-Reject (single day) -----
      if (tab === 3) {
        if (region.toLowerCase() !== 'emea') {
          alert('EUROC report is only available for region EMEA. Please select EMEA.');
          return;
        }
        if (!from) {
          alert('Please select a date (From) for EUROC report.');
          return;
        }

        const dateParam = toLocalYMD(new Date(from));
        const params = { region: 'emea', date: dateParam };
        const resp = await axios.get('/api/reports/euroc-admit-rejection', { params });
        const { data } = resp.data || {};

        const wb = new ExcelJS.Workbook();

        // Admit sheet
        const admitTitle = `EUROC Admit Report - ${formatDisplayDate(from)}`;
        const ws1 = wb.addWorksheet('EUROC Admit');
        ws1.mergeCells('A1:I1');
        ws1.getCell('A1').value = admitTitle;
        ws1.getCell('A1').font = { bold: true, size: 14 };
        ws1.getCell('A1').alignment = { horizontal: 'center' };

        const admitHeaders = [
          'Sr. No.', 'Date', 'Time', 'Employee Name',
          'Access Card No.', 'Personnel Type', 'Door Name', 'Location', 'Swipe'
        ];
        const hdrRow1 = ws1.addRow(admitHeaders);
        hdrRow1.font = { bold: true };
        hdrRow1.alignment = { vertical: 'middle', horizontal: 'center' };
        hdrRow1.eachCell(c => {
          c.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
        });

        ws1.columns = [
          { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
          { key:'name', width:30 }, { key:'card', width:15 }, { key:'ptype', width:20 },
          { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
        ];

        (data.admit || []).forEach((r, idx) => {
          let iso;
          if (r.LocaleMessageTime) {
            iso = r.LocaleMessageTime;
          } else if (r.DateOnly) {
            iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
          } else {
            iso = '';
          }

          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws1.addRow([
            idx + 1,
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.CardNumber || '',
            r.PersonnelType || '',
            r.Door || r.ObjectName2 || '',
            r.location || '',
            r.Direction || ''
          ]);

          row.getCell(2).alignment = { horizontal: 'left' };
          row.getCell(3).alignment = { horizontal: 'left' };
          row.eachCell(c => {
            c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        // Rejection sheet
        const ws2 = wb.addWorksheet('EUROC Rejection');
        ws2.mergeCells('A1:J1');
        ws2.getCell('A1').value = `EUROC Rejection Report - ${formatDisplayDate(from)}`;
        ws2.getCell('A1').font = { bold: true, size: 14 };
        ws2.getCell('A1').alignment = { horizontal: 'center' };

        const headerRow2 = ws2.addRow(['Sr. No.', 'Date', 'Time', 'Employee Name', 'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe']);
        headerRow2.font = { bold: true };
        headerRow2.alignment = { vertical: 'middle', horizontal: 'center' };
        headerRow2.eachCell(c => {
          c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });

        ws2.columns = [
          { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
          { key:'name', width:30 }, { key:'card', width:15 }, { key:'type', width:15 },
          { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
        ];

        (data.rejection || []).forEach((r, idx) => {
          let iso;
          if (r.LocaleMessageTime) {
            iso = r.LocaleMessageTime;
          } else if (r.DateOnly) {
            iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
          } else {
            iso = '';
          }

          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws2.addRow([
            idx + 1,
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.CardNumber || '',
            r.Rejection_Type || '',
            r.Door || '',
            r.location || '',
            r.Direction || ''
          ]);

          row.getCell(2).alignment = { horizontal: 'left' };
          row.getCell(3).alignment = { horizontal: 'left' };
          row.eachCell(c => {
            c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        // Summary block
        const counts = data.summary || [];
        let startRow = 3;
        ws2.getCell(startRow, 11).value = 'Rejection';
        ws2.getCell(startRow, 12).value = 'Count';
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.font = { bold: true };
          cell.alignment = { horizontal: 'center' };
          cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });
        startRow++;
        counts.forEach(c => {
          ws2.getCell(startRow, 11).value = c.Rejection_Type || 'Unknown';
          ws2.getCell(startRow, 12).value = c.Count || 0;
          [11, 12].forEach(col => {
            const cell = ws2.getCell(startRow, col);
            cell.alignment = { horizontal: 'left' };
            cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
          });
          startRow++;
        });
        ws2.getCell(startRow, 11).value = 'Grand Total';
        ws2.getCell(startRow, 12).value = (data.rejection || []).length;
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.font = { bold: true };
          cell.alignment = { horizontal: 'left' };
          cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });

        const buf = await wb.xlsx.writeBuffer();
        const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const filename = `EUROC_Admit_Rejection_${dateParam}.xlsx`;
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        return;
      }

      // ----- 4: Time Duration -----
      if (tab === 4) {
        if (!from || !to) {
          alert('Please select both Start Date and End Date for Time Duration report.');
          return;
        }
        const startParam = toLocalYMD(new Date(from));
        const endParam = toLocalYMD(new Date(to));
        const params = {
          region,
          startDate: startParam,
          endDate: endParam,
          partition: location ? location.split('.').pop() : 'Default'
        };
        const resp = await axios.get('/api/reports/time-duration', { params });
        await generateTimeDurationExcel(resp.data.data || []);
        return;
      }

      // ----- 5: HeadCount / External navigation -----
      if (tab === 5) {
        // final permission check (region specific)
        const permCandidates = [`headcount.${region}`, 'headcount', 'global_access'];
        if (!auth.hasPermission(permCandidates)) {
          alert(`You do not have permission to view HeadCount for ${region.toUpperCase()}.`);
          setLoading(false);
          return;
        }

        let url = '';

        if (region === 'laca') {
          if (!location) url = 'http://10.199.22.57:3003/history';
          else {
            const LACA_URLS = {
              'CR.Costa Rica Partition': 'http://10.199.22.57:3003/partition/CR.Costa%20Rica%20Partition/history',
              'MX.Mexico City': 'http://10.199.22.57:3003/partition/MX.Mexico%20City/history',
              'AR.Cordoba': 'http://10.199.22.57:3003/partition/AR.Cordoba/history',
              'PA.Panama City': 'http://10.199.22.57:3003/partition/PA.Panama%20City/history',
              'PE.Lima': 'http://10.199.22.57:3003/partition/PE.Lima/history',
              'BR.Sao Paulo': 'http://10.199.22.57:3003/partition/BR.Sao%20Paulo/history'
            };
            url = LACA_URLS[location] || 'http://10.199.22.57:3003/history';
          }
        } else if (region === 'namer') {
          if (!location) url = 'http://10.199.22.57:3002/history';
          else {
            const NAMER_URLS = {
              'US.Denver': 'http://10.199.22.57:3002/partition/US.CO.OBS/history',
              'US.Miami': 'http://10.199.22.57:3002/partition/US.FL.Miami/history',
              'US.NYC': 'http://10.199.22.57:3002/partition/US.NYC/history',
              'US.Austin': 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default/history'
            };
            url = NAMER_URLS[location] || 'http://10.199.22.57:3002/history';
          }
        } else if (region === 'apac') {
          if (!location) url = 'http://10.199.22.57:3000/history';
          else {
            const APAC_URLS = {
              'APAC.Default': 'http://10.199.22.57:3000/partition/Pune/history',
              'MY.Kuala Lumpur': 'http://10.199.22.57:3000/partition/MY.Kuala Lumpur/history',
              'PH.Manila': 'http://10.199.22.57:3000/partition/PH.Manila/history',
              'JP.Tokyo': 'http://10.199.22.57:3000/history',
              'CN.Beijing': 'http://10.199.22.57:3000/history'
            };
            url = APAC_URLS[location] || 'http://10.199.22.57:3000/history';
          }
        } else if (region === 'emea') {
          if (!location) url = 'http://10.199.22.57:3001/history';
          else {
            const EMEA_URLS = {
              'AUT.Vienna': 'http://10.199.22.57:3001/history',
              'DU.Abu Dhabi': 'http://10.199.22.57:3001/history',
              'IE.Dublin': 'http://10.199.22.57:3001/history',
              'IT.Rome': 'http://10.199.22.57:3001/history',
              'LT.Vilnius': 'http://10.199.22.57:3001/history',
              'MA.Casablanca': 'http://10.199.22.57:3001/history',
              'RU.Moscow': 'http://10.199.22.57:3001/history',
              'UK.London': 'http://10.199.22.57:3001/history',
              'ES.Madrid': 'http://10.199.22.57:3001/history'
            };
            url = EMEA_URLS[location] || 'http://10.199.22.57:3001/history';
          }
        }

        if (url) window.location.href = url;
        else alert('Invalid region or location selected.');
        return;
      }

    } catch (err) {
      console.error(err);
      alert('Failed to generate report');
    } finally {
      setLoading(false);
    }
  };

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
        {/* Topbar / Header */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            px: 3,
            py: 2,
            borderBottom: '1px solid rgba(255,204,0,0.08)',
            background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
          }}
        >
          <Avatar sx={{ bgcolor: '#000', border: '3px solid #FFCC00', width: 56, height: 56 }}>
            <Typography sx={{ color: '#FFCC00', fontWeight: 900 }}>WU</Typography>
          </Avatar>

          <Box sx={{ flex: 1 }}>
            <Typography variant="h5" sx={{ fontWeight: 900, letterSpacing: 0.6 }}>
              Global Security Operation Center
            </Typography>
            <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
              Reports & Exports — Secure access, fast insights
            </Typography>
          </Box>

          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
            <Button
              startIcon={<DownloadIcon />}
              onClick={handleGenerate}
              disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
              sx={{
                bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                color: '#000',
                fontWeight: 800,
                px: 3,
                py: 1,
                borderRadius: 3,
                boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
                transformOrigin: 'center',
                '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-2px)' : 'none' }
              }}
            >
              {loading ? 'Loading…'
                : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
            </Button>
          </Box>
        </Box>

        {/* Main content: Sidebar + Content */}
        <Grid container sx={{ px: 3, py: 4 }} spacing={3}>
          {/* Sidebar */}
          <Grid item xs={12} md={3}>
            <Paper
              elevation={8}
              sx={{
                p: 2.5,
                borderRadius: 3,
                height: { xs: 'auto', md: 'calc(100vh - 150px)' },
                overflow: 'auto',
                background: 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015))',
                border: '1px solid rgba(255,204,0,0.06)'
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
                <Box>
                  <Typography variant="subtitle1" sx={{ fontWeight: 800, color: '#FFCC00' }}>Filters</Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Narrow down by region, date and employees
                  </Typography>
                </Box>
                <IconButton size="small" sx={{ color: '#FFCC00' }}>
                  <FilterListIcon />
                </IconButton>
              </Box>

              <Divider sx={{ my: 1, borderColor: 'rgba(255,204,0,0.06)' }} />

              {/* Region */}
              <Box sx={{ mt: 1 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Region</InputLabel>
                  <Select
                    value={region}
                    onChange={e => { setRegion(e.target.value); setLocation(''); }}
                    input={<OutlinedInput label="Region" />}
                    sx={{
                      color: '#fff',
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.24)' }
                    }}
                  >
                    {REGION_OPTIONS.map(r => <MenuItem key={r} value={r}>{r.toUpperCase()}</MenuItem>)}
                  </Select>
                </FormControl>
              </Box>

              {/* Location */}
              <Box sx={{ mt: 2 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Location</InputLabel>
                  <Select
                    value={location}
                    onChange={e => setLocation(e.target.value)}
                    input={<OutlinedInput label="Location" />}
                    disabled={!region}
                    sx={{
                      color: '#fff',
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                    }}
                  >
                    {(LOCATION_MAP[region] || []).map(loc => <MenuItem key={loc} value={loc}>{loc.split('.').pop()}</MenuItem>)}
                  </Select>
                </FormControl>
              </Box>

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />

              {tab === 1 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employee (name or ID)
                  </Typography>
                  <TextField
                    fullWidth
                    placeholder="Type employee name or ID (e.g. 'Jejurkar' or '323471')"
                    label="Search Employee"
                    value={rawSearch}
                    onChange={(e) => setRawSearch(e.target.value)}
                    sx={{
                      '& .MuiInputBase-input': { color: '#fff' },
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                    }}
                    InputLabelProps={{ style: { color: '#FFCC00' } }}
                  />
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                    Leave empty to export all raw rows for the date range.
                  </Typography>

                  <Box sx={{ mt: 2 }}>
                    <FormControl fullWidth>
                      <InputLabel sx={{ color: '#FFCC00' }}>Admit / Reject</InputLabel>
                      <Select
                        value={rawAdmitFilter}
                        onChange={(e) => setRawAdmitFilter(e.target.value)}
                        input={<OutlinedInput label="Admit / Reject" />}
                        sx={{
                          color: '#fff',
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                        }}
                      >
                        <MenuItem value="all">All (Admitted + Rejected)</MenuItem>
                        <MenuItem value="admit">Admitted only</MenuItem>
                        <MenuItem value="reject">Rejected only</MenuItem>
                      </Select>
                    </FormControl>
                    <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                      Default = All.
                    </Typography>
                  </Box>
                </Box>
              )}

              {/* Dates */}
              {tab !== 5 && (
                <Box>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Date Range
                  </Typography>
                  <Box sx={{ display: 'grid', gap: 1.25 }}>
                    <TextField
                      label={tab === 0 ? 'From Date' : 'Start Date'}
                      value={from ? from.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowFromCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                    <TextField
                      label={tab === 0 ? 'To Date' : 'End Date'}
                      value={to ? to.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowToCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                  </Box>

                  {showFromCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={from}
                        onChange={(newValue) => setFrom(newValue)}
                        onAccept={() => setShowFromCal(false)}
                        onClose={() => setShowFromCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                  {showToCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={to}
                        onChange={(newValue) => setTo(newValue)}
                        onAccept={() => setShowToCal(false)}
                        onClose={() => setShowToCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                </Box>
              )}

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />

              {tab === 0 && (
                <Box>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employees
                  </Typography>
                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Employees</InputLabel>
                    <Select
                      multiple
                      value={selectedEmps}
                      onChange={e => setSelectedEmps(e.target.value)}
                      input={<OutlinedInput label="Employees" />}
                      renderValue={vals => vals.join(', ')}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                      }}
                    >
                      {EMPLOYEE_OPTIONS.map(n => (
                        <MenuItem key={n} value={n}>
                          <Checkbox checked={selectedEmps.includes(n)} />
                          <ListItemText primary={n} />
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              )}

              <Box sx={{ mt: 3, p: 2, borderRadius: 2, background: 'rgba(255,255,255,0.02)' }}>
                <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                  Tip: For daily exports pick employees & a single day range. For Time Duration choose the required partition via Location.
                </Typography>
              </Box>
            </Paper>
          </Grid>

          {/* Main panel */}
          <Grid item xs={12} md={9}>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              <Paper
                elevation={3}
                sx={{
                  px: 2,
                  py: 1,
                  borderRadius: 2,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  gap: 2,
                  border: '1px solid rgba(255,204,0,0.04)'
                }}
              >
                <Tabs
                  value={tab}
                  onChange={handleTabChange}
                  sx={{
                    '& .MuiTab-root': {
                      textTransform: 'none',
                      minWidth: 120,
                      fontWeight: 700,
                      color: 'rgba(255,255,255,0.8)'
                    },
                    '& .Mui-selected': { color: '#FFCC00' }
                  }}
                >
                  <Tab icon={<CalendarTodayIcon />} label="Daily Access" />
                  <Tab icon={<PeopleIcon />} label="Raw" />
                  <Tab icon={<PlaceIcon />} label="Rejection" />
                  <Tab icon={<PeopleIcon />} label="EUROC Admit-Reject" />
                  <Tab icon={<CalendarTodayIcon />} label="Time Duration" />
                  <Tab icon={<PeopleIcon />} label="HeadCount" />
                </Tabs>

                <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                  <Button
                    variant="text"
                    startIcon={<FilterListIcon />}
                    sx={{ color: 'rgba(255,255,255,0.65)', textTransform: 'none' }}
                    onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}
                  >
                    Reset View
                  </Button>
                </Box>
              </Paper>

              <Paper elevation={6} sx={{ p: 3, borderRadius: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 2 }}>
                <Box>
                  <Typography variant="h6" sx={{ fontWeight: 900 }}>Export Center</Typography>
                  <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                    Selected Region: <strong style={{ color: '#FFCC00' }}>{region.toUpperCase()}</strong> {location ? `• ${location.split('.').pop()}` : ''}
                  </Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Choose tab, select filters and export reports in Excel.
                  </Typography>
                </Box>

                <Box>
                  <Button
                    startIcon={loading ? <CircularProgress size={20} /> : <DownloadIcon />}
                    disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
                    onClick={handleGenerate}
                    sx={{
                      bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                      color: '#000',
                      fontWeight: 900,
                      px: 4,
                      py: 1,
                      borderRadius: 3,
                      boxShadow: '0 8px 30px rgba(255,204,0,0.22)',
                      '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-3px)' : 'none' }
                    }}
                  >
                    {loading
                      ? 'Loading…'
                      : (tab === 5
                          ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`)
                          : 'Export to Excel')}
                  </Button>
                </Box>
              </Paper>

            </Box>
          </Grid>

        </Grid>
      </Box>
    </LocalizationProvider>
  );
}



















I dont understand How i update Reports page check both file carefully and share me fully updated file so i can easily swap file each other..



// (At top of file - add useAuth import)
import { useAuth } from '../context/AuthContext';

// ... existing imports / helpers unchanged ...

export default function ReportsPage() {
  const auth = useAuth();

  // --- state ---
  const [tab, setTab] = useState(0);

  // ... rest of your state unchanged ...

  const handleGenerate = async () => {
    // Permission gating: determine required permission for each tab
    const requirePermissionForTab = () => {
      if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
      if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
      if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
      if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
      if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
      if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
      return ['gsoc_reports'];
    };

    if (!auth.hasPermission(requirePermissionForTab())) {
      alert('You do not have permission to generate this report.');
      return;
    }

    setLoading(true);
    try {
      const baseParams = { region, location: location || undefined };

      // ... rest of generation logic unchanged, but before navigation in tab 5 we re-check permissions

      // ----- 5: HeadCount / External navigation -----
      if (tab === 5) {
        // final check (region specific)
        const permCandidates = [`headcount.${region}`, 'headcount', 'global_access'];
        if (!auth.hasPermission(permCandidates)) {
          alert(`You do not have permission to view HeadCount for ${region.toUpperCase()}.`);
          setLoading(false);
          return;
        }

        let url = '';

        // ... existing URL building logic unchanged ...

        if (url) window.location.href = url;
        else alert('Invalid region or location selected.');
        return;
      }

      // (all other tabs proceed as before)
    } catch (err) {
      console.error(err);
      alert('Failed to generate report');
    } finally {
      setLoading(false);
    }
  };

  // disabled conditions - include permission check
  const disabled = loading
    || !region
    || (tab === 0 && (!from || !to || selectedEmps.length === 0)) // Daily Access
    || (tab === 1 && (!from || !to)) // Raw
    || (tab === 2 && (!from || !to)) // Rejection - require date range
    || (tab === 3 && !from) // EUROC (single day)
    || (tab === 4 && (!from || !to));

  const navDisabled = !region || loading;

  // Compute Export button text/disabled w.r.t permission
  const exportPermsForTab = () => {
    if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
    if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
    if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
    if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
    if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
    if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
    return ['gsoc_reports'];
  };

  const exportAllowed = auth.hasPermission(exportPermsForTab());

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
        {/* Topbar / Header */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            px: 3,
            py: 2,
            borderBottom: '1px solid rgba(255,204,0,0.08)',
            background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
          }}
        >
          {/* ... header unchanged ... */}
          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
            <Button
              startIcon={<DownloadIcon />}
              onClick={handleGenerate}
              disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
              sx={{
                bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                color: '#000',
                fontWeight: 800,
                px: 3,
                py: 1,
                borderRadius: 3,
                boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
                transformOrigin: 'center',
                '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-2px)' : 'none' }
              }}
            >
              {loading ? 'Loading…'
                       : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
            </Button>
          </Box>
        </Box>

        {/* ... remainder of UI unchanged, but internal generate handlers already guarded */}











// src/pages/ReportsPage.jsx
import React, { useState } from 'react';
import {
  Box, FormControl, InputLabel, Select, OutlinedInput,
  Checkbox, ListItemText, MenuItem, Button,
  CircularProgress, Typography, TextField, Tabs, Tab, Grid, Paper, Drawer, IconButton, Divider, List, ListItem, ListItemIcon, Avatar, Collapse
} from '@mui/material';

import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import axios from 'axios';
import ExcelJS from 'exceljs';
import * as XLSX from 'xlsx';
import { useAuth } from '../context/AuthContext';



import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import PlaceIcon from '@mui/icons-material/Place';
import PeopleIcon from '@mui/icons-material/People';
import DownloadIcon from '@mui/icons-material/CloudDownload';
import FilterListIcon from '@mui/icons-material/FilterList';
// Static lists
const EMPLOYEE_OPTIONS = [
  'Vainilaitis, Valdas',
  'Tomasevic, Kazimez',
  'Sesickis, Janas',
  'Valiunas, Sigitas',
  'JANCUKOVIC, VACLAVA',
  'Kalpokiene, Alina',
  'Korkus, Vanda',
  'Kvaraciejiene, Maryte',
  'ZNAMEROVSKIS, DARIUS'

];


const REGION_OPTIONS = ['global', 'apac', 'emea', 'laca', 'namer'];
const LOCATION_MAP = {
  apac: ['APAC.Default', 'JP.Tokyo', 'PH.Manila', 'MY.Kuala Lumpur'],
  emea: ['AUT.Vienna', 'DU.Abu Dhab', 'IE.Dublin', 'IT.Rome', 'LT.Vilnius', 'MA.Casablanca', 'RU.Moscow', 'UK.London', 'ES.Madrid'],
  laca: ['AR.Cordoba', 'CR.Costa Rica Partition', 'MX.Mexico City', 'PE.Lima', 'BR.Sao Paulo', 'PA.Panama City'],
  namer: ['US.NYC', 'US.FL.Miami', 'USA/Canada Default', 'US.CO.OBS'],
  global: [] // optional — location select will be disabled when global is chosen
};



function formatDisplayDate(date) {
  const d = new Date(date);
  const day = d.getDate();
  const suf = day % 10 === 1 && day !== 11 ? 'st'
    : day % 10 === 2 && day !== 12 ? 'nd'
      : day % 10 === 3 && day !== 13 ? 'rd' : 'th';
  const mon = d.toLocaleString('default', { month: 'long' });
  return `${day}${suf} ${mon} ${d.getFullYear()}`;
}



// helpers: format server-provided ISO as display strings (use UTC getters so Z times are treated as server wall-clock)
const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');

function formatDateFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  const y = dt.getUTCFullYear();
  const m = dt.getUTCMonth(); // 0..11
  const d = dt.getUTCDate();
  const yrShort = String(y).slice(-2);
  return `${pad2(d)}-${MONTH_ABBR[m]}-${yrShort}`;         // e.g. "12-Aug-25"
}

function formatTimeFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  let hh = dt.getUTCHours();   // use UTC parts so we trust server wall-clock
  const mm = dt.getUTCMinutes();
  const ss = dt.getUTCSeconds();
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1; // convert 0->12, 13->1 etc.
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;        // e.g. "12:01:24 AM"
}

// for DateOnly + Swipe_Time situation: build ISO string where date comes from DateOnly and time from Swipe_Time UTC
function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  // dateOnlyIso = "2025-08-12T00:00:00.000Z"
  // swipeIso = "1970-01-01T00:01:24.000Z" (time)
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10); // "YYYY-MM-DD"
  if (!swipeIso) {
    return `${datePart}T00:00:00.000Z`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000Z`;
  }
  // fallback if swipeIso is "HH:mm:ss"
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000Z`;
}




function formatShortRange(fromDate, toDate) {
  if (!fromDate || !toDate) return '';
  const f = formatDisplayDate(fromDate); // e.g. "1st August 2025"
  const t = formatDisplayDate(toDate);   // e.g. "13th August 2025"
  const [fDay, fMon, fYear] = f.split(' ');
  const [tDay, tMon, tYear] = t.split(' ');

  if (fMon === tMon && fYear === tYear) {
    return `${fDay} to ${tDay} ${fMon}`; // "1st to 13th August"
  }
  // different month or year -> show both months
  return `${fDay} ${fMon} to ${tDay} ${tMon}`;
}

// --- helper: build raw report filename per your rules ---

function buildRawFileName({ region, location, rawSearch, from, to }) {
  const shortRange = formatShortRange(from, to);
  const regionPart = (region || '').toUpperCase();
  const locPart = location ? `-${location.split('.').pop()}` : '';
  const prefix = rawSearch && rawSearch.toString().trim() ? `${rawSearch.toString().trim()} ` : '';
  // Keep "Raw report" text exactly as requested
  const base = `${regionPart}${locPart} Raw report ${shortRange}`;
  // sanitize for filesystem (remove problematic chars)
  const safeBase = base.replace(/[\/\\:\*\?"<>\|]+/g, '').replace(/\s+/g, ' ').trim();
  return `${prefix}${safeBase}.xlsx`;
}



export default function ReportsPage() {
   const auth = useAuth();

  // --- state ---
    const [tab, setTab] = useState(0);


  const [region, setRegion] = useState('emea');
  const [location, setLocation] = useState('');
  const [from, setFrom] = useState(null);
  const [to, setTo] = useState(null);
  const [showFromCal, setShowFromCal] = useState(false);
  const [showToCal, setShowToCal] = useState(false);
  const [selectedEmps, setSelectedEmps] = useState([]);
  const [loading, setLoading] = useState(false);


    // helper — convert "YYYY-MM-DD..." (ISO) into a local midnight Date (avoids UTC shift)
  const isoDateOnlyToLocalDate = (iso) => {
    if (!iso) return null;
    const s = iso.toString().slice(0, 10);
    const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
    return new Date(y, m - 1, d);
  };


// Build a Date that preserves the server-provided wall-clock values.
// If swipeTime is an ISO (with Z), read UTC components and use them as local values.
const buildLocalDateFromDateOnlyAndSwipe = (dateOnly, swipeTime) => {
  if (!dateOnly) return null;

  // parse YYYY-MM-DD (first 10 chars)
  const dateStr = dateOnly.toString().slice(0, 10);
  const [yy, mm, dd] = dateStr.split('-').map(n => parseInt(n, 10));

  let hh = 0, min = 0, ss = 0;
  if (swipeTime) {
    const parsed = new Date(swipeTime);
    if (!isNaN(parsed.getTime())) {
      // Use UTC getters so we interpret the ISO(Z) as server wall-clock values
      hh = parsed.getUTCHours();
      min = parsed.getUTCMinutes();
      ss = parsed.getUTCSeconds();
    } else {
      // fallback to "HH:mm[:ss]" format parsing
      const parts = swipeTime.split(':').map(p => parseInt(p, 10));
      if (parts.length >= 2) {
        hh = parts[0] || 0;
        min = parts[1] || 0;
        ss = parts[2] || 0;
      }
    }
  }

  // Construct a local Date that has the same displayed Y/M/D HH:MM:SS as the server's values.
  return new Date(yy, mm - 1, dd, hh, min, ss);
};



// returns a server-wall-clock ISO for a row: prefer LocaleMessageTime, else DateOnly+Swipe_Time
const getServerISO = (r) => {
  if (!r) return '';
  if (r.LocaleMessageTime) return r.LocaleMessageTime;
  if (r.DateOnly) return buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  return '';
};

// returns YYYY-MM-DD for server wall-clock (used for filtering)
const getServerYMD = (r) => {
  const iso = getServerISO(r);
  if (!iso) return '';
  return iso.slice(0, 10); // "YYYY-MM-DD"
};



  // Handle tab switch (Daily / Raw / Rejection)
  const handleTabChange = (_, v) => {
    setTab(v);
    // reset all filters
    setRegion('emea');
    setLocation('');
    setFrom(null);
    setTo(null);
    setSelectedEmps([]);
  };



  /** Time Duration Excel generator */
  const generateTimeDurationExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Time Duration');

    // Title row
    ws.mergeCells('A1:M1');

ws.getCell('A1').value =
  `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
      
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };
    // Header row
    const headers = [
      'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
      'Partition', 'Text5', 'Year', 'Week', 'Date',
      'First Swipe', 'Last Swipe', 'Duration', 'Category',
      'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    // Columns widths
    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'ptype', width: 18 },
      { key: 'part', width: 15 },
      { key: 'txt5', width: 20 },
      { key: 'year', width: 8 },
      { key: 'week', width: 6 },
      { key: 'date', width: 12 },
      { key: 'first', width: 16 },
      { key: 'last', width: 16 },
      { key: 'dur', width: 10 },
      { key: 'cat', width: 12 },
      { key: 'dpw', width: 12 },
      { key: 'vdw', width: 14 },
      { key: 'cdw', width: 12 },
      { key: 'def', width: 10 }
    ];




    data.forEach((r, idx) => {
      const first = new Date(r.FirstSwipeTime);
      const last = new Date(r.LastSwipeTime);
      const date = new Date(r.ShiftedDate);
      const row = ws.addRow([
        idx + 1,
        r.ObjectName1,
        r.EmployeeID,
        r.PersonnelType,
        r.PartitionName2,
        r.text5,
        r.YearNumber,
        r.WeekNumber,
        date,
        first,
        last,
        r.DurationHHMM,
        r.TimeDiffCategory,
        r.DaysPresentInWeek,
        r.ViolationDaysInWeek,
        r.CleanDaysInWeek,
        r.Defaulter
      ]);

      // Date & time formatting
      row.getCell(9).numFmt = 'dd-mmm-yy';
      row.getCell(10).numFmt = 'h:mm:ss AM/PM';
      row.getCell(11).numFmt = 'h:mm:ss AM/PM';

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    ws.autoFilter = 'A2:Q2';

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

   const filename =
  `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;


    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };




  // // --- Excel for Daily Access (unchanged) ---
  
const generateDailyAccessExcel = async allRows => {
  const wb = new ExcelJS.Workbook();

  for (const emp of selectedEmps) {
    const ws = wb.addWorksheet(emp.substring(0, 31));
    const headers = [
      'Date', 'Time', 'Name', 'Contractor ID', 'Card No',
      'Door Name', 'Message Type', 'Partition', 'Swipe'
    ];
    ws.addRow(headers);
    const hdr = ws.getRow(1);
    hdr.font = { bold: true };
    hdr.alignment = { vertical: 'middle', horizontal: 'center' };
    hdr.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'date', width: 12 },
      { key: 'time', width: 12 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'card', width: 15 },
      { key: 'door', width: 40 },
      { key: 'msg', width: 15 },
      { key: 'part', width: 15 },
      { key: 'swipe', width: 10 }
    ];

    const rows = allRows.filter(r => r.ObjectName1 === emp);
    if (!rows.length) {
      ws.mergeCells('A2', 'I2');
      ws.getCell('A2').value = 'There is no swipe records found in Ccure';
      ws.getCell('A2').alignment = { horizontal: 'center' };
    } else {
      rows.forEach(r => {
        const iso = getServerISO(r); // server wall-clock ISO or ''
        const dateStr = iso ? formatDateFromServerISO(iso) : '';
        const timeStr = iso ? formatTimeFromServerISO(iso) : '';

        const row = ws.addRow([
          dateStr,
          timeStr,
          r.ObjectName1 || '',
          r.EmployeeID || '',
          r.CardNumber || '',
          r.Door || r.ObjectName2 || '',
          r.AdmitCode || r.Messagetype || '',
          r.location || '',
          r.Swipe || r.Direction || ''
        ]);

        // treat them as strings to preserve server wall-clock display
        row.getCell(1).alignment = { horizontal: 'left' };
        row.getCell(2).alignment = { horizontal: 'left' };

        row.eachCell(c => {
          c.border = {
            top: { style: 'thin' }, left: { style: 'thin' },
            bottom: { style: 'thin' }, right: { style: 'thin' }
          };
          c.alignment = { vertical: 'middle', horizontal: 'left' };
        });
      });
    }
    ws.autoFilter = 'A1:I1';
  }

  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const filename = `Daily Access Report(${formatDisplayDate(from)} to ${formatDisplayDate(to)}).xlsx`;
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
};


  // // --- Excel for Rejection (unchanged except UTC->local fix) ---

const generateRejectionExcel = async data => {
  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Rejection');

  const title = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}`;
  ws.mergeCells('A1:J1');
  ws.getCell('A1').value = title;
  ws.getCell('A1').font = { bold: true, size: 14 };
  ws.getCell('A1').alignment = { horizontal: 'center' };

  const headers = [
    'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
    'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
  ];
  const headerRow = ws.addRow(headers);
  headerRow.font = { bold: true };
  headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
  headerRow.eachCell(c => {
    c.border = {
      top: { style: 'thin' }, left: { style: 'thin' },
      bottom: { style: 'thin' }, right: { style: 'thin' }
    };
  });

  ws.columns = [
    { key: 'sr', width: 8 },
    { key: 'date', width: 12 },
    { key: 'time', width: 12 },
    { key: 'name', width: 25 },
    { key: 'id', width: 15 },
    { key: 'card', width: 15 },
    { key: 'type', width: 15 },
    { key: 'door', width: 40 },
    { key: 'loc', width: 15 },
    { key: 'swipe', width: 10 }
  ];

  data.forEach((r, idx) => {
    const iso = getServerISO(r);
    const dateStr = iso ? formatDateFromServerISO(iso) : '';
    const timeStr = iso ? formatTimeFromServerISO(iso) : '';

    const row = ws.addRow([
      idx + 1,
      dateStr,
      timeStr,
      r.ObjectName1 || '',
      r.EmployeeID || '',
      r.CardNumber || '',
      r.Rejection_Type || '',
      r.Door || r.ObjectName2 || '',
      r.location || '',
      r.Direction || r.Swipe || ''
    ]);

    row.getCell(2).alignment = { horizontal: 'left' };
    row.getCell(3).alignment = { horizontal: 'left' };

    row.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
      c.alignment = { vertical: 'middle', horizontal: 'left' };
    });
  });

  // Summary (unchanged but leaves numbers as numbers)
  const counts = data.reduce((a, r) => {
    const k = r.Rejection_Type || 'Unknown';
    a[k] = (a[k] || 0) + 1; return a;
  }, {});
  let rowIdx = 3;
  ws.getCell(rowIdx, 11).value = 'Rejection';
  ws.getCell(rowIdx, 12).value = 'Count';
  [11, 12].forEach(c => {
    const cell = ws.getCell(rowIdx, c);
    cell.font = { bold: true };
    cell.alignment = { horizontal: 'center' };
    cell.border = {
      top: { style: 'thin' }, left: { style: 'thin' },
      bottom: { style: 'thin' }, right: { style: 'thin' }
    };
  });
  rowIdx++;
  Object.entries(counts).forEach(([type, cnt]) => {
    ws.getCell(rowIdx, 11).value = type;
    ws.getCell(rowIdx, 12).value = cnt;
    [11, 12].forEach(c => {
      const cell = ws.getCell(rowIdx, c);
      cell.alignment = { horizontal: 'left' };
      cell.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });
    rowIdx++;
  });
  ws.getCell(rowIdx, 11).value = 'Total';
  ws.getCell(rowIdx, 12).value = data.length;
  [11, 12].forEach(c => {
    const cell = ws.getCell(rowIdx, c);
    cell.font = { bold: true };
    cell.alignment = { horizontal: 'left' };
    cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
  });

  // Download
  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const filename = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}.xlsx`;
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
};

  const [rawSearch, setRawSearch] = useState(''); // search string for Raw report (name or id)
  const [rawAdmitFilter, setRawAdmitFilter] = useState('all'); // 'all' | 'admit' | 'reject'




// generateRawExcel(rows, opts)
const generateRawExcel = async (rows, opts = {}) => {
  // helper: format time coming from Swipe_Time (handles ISO or "HH:mm[:ss]" fallback)
  const formatTimeFromSwipe = (swipeIso) => {
    if (!swipeIso) return '';
    // try ISO parse first
    const dt = new Date(swipeIso);
    if (!isNaN(dt.getTime())) {
      return formatTimeFromServerISO(swipeIso);
    }
    // fallback: parse "HH:mm" or "HH:mm:ss"
    const parts = ('' + swipeIso).split(':').map(p => parseInt(p || 0, 10));
    const hh = parts[0] || 0;
    const mm = parts[1] || 0;
    const ss = parts[2] || 0;
    const ampm = hh >= 12 ? 'PM' : 'AM';
    const hh12 = ((hh + 11) % 12) + 1;
    return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
  };

  // determine which columns to include based on filter
  const admitFilter = (opts.rawAdmitFilter || 'all').toString().toLowerCase(); // 'all'|'admit'|'reject'

  // base columns always present
  const baseHeaders = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber'];
  // conditional columns
  const admitCol = 'AdmitCode';
  const rejCol = 'Rejection_Type';
  // always include these at end
  const tailCols = ['Direction','Door'];

  // build final headers in requested order
  let headers = [...baseHeaders];
  if (admitFilter === 'all') {
    headers.push(admitCol);
    headers.push(...tailCols);
    headers.push(rejCol);
  } else if (admitFilter === 'admit') {
    // admitted only -> hide Rejection_Type
    headers.push(admitCol);
    headers.push(...tailCols);
  } else if (admitFilter === 'reject') {
    // rejected only -> hide AdmitCode
    headers.push(...tailCols);
    headers.push(rejCol);
  } else {
    // defensive fallback - include both
    headers.push(admitCol);
    headers.push(...tailCols);
    headers.push(rejCol);
  }

  if (!rows || !rows.length) {
    // fallback: write an empty workbook with dynamic headers
    const wbEmpty = XLSX.utils.book_new();
    const wsEmpty = XLSX.utils.aoa_to_sheet([headers]);
    XLSX.utils.book_append_sheet(wbEmpty, wsEmpty, 'Raw');
    const fileNameEmpty = buildRawFileName(opts);
    XLSX.writeFile(wbEmpty, fileNameEmpty);
    return;
  }

  // Build rows for sheet mapping only included headers
  const rowsForSheet = rows.map(r => {
    // Build server-wall-clock ISO for the row (LocaleMessageTime preferred)
    const iso = getServerISO(r); // LocaleMessageTime || DateOnly+Swipe_Time
    const dateStr = iso ? formatDateFromServerISO(iso) : '';
    const timeStr = iso ? formatTimeFromServerISO(iso) : '';
    const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');

    // Format DateOnly as DD-MMM-YY (if present), otherwise blank
    const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';

    // Format Swipe_Time as h:mm:ss AM/PM — handle ISO or HH:mm fallback
    const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

    // Build a full object then pick keys according to headers to control column inclusion order
    const fullObj = {
      LocaleMessageTime: localeMsgFormatted,
      DateOnly: dateOnlyFormatted,
      Swipe_Time: swipeTimeFormatted,
      EmployeeID: r.EmployeeID || '',
      ObjectName1: r.ObjectName1 || '',
      PersonnelType: r.PersonnelType || '',
      location: r.location || '',
      CardNumber: r.CardNumber || '',
      AdmitCode: r.AdmitCode || r.Messagetype || '',
      Direction: r.Direction || r.Swipe || '',
      Door: r.Door || r.ObjectName2 || '',
      Rejection_Type: r.Rejection_Type || ''
    };

    // pick only the requested headers
    const picked = {};
    headers.forEach(h => {
      // ensure we always provide a string/empty when key missing
      picked[h] = (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '';
    });
    return picked;
  });

  // create workbook/sheet with ordered headers
  const ws = XLSX.utils.json_to_sheet(rowsForSheet, { header: headers });
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Raw');

  // build filename per your examples
  const filename = buildRawFileName(opts);

  XLSX.writeFile(wb, filename);
};




const handleGenerate = async () => {
  setLoading(true);
  try {
    const baseParams = { region, location: location || undefined };

    // Helper: format dates in local time without timezone conversion for API parameters
    const formatLocalDate = (date, endOfDay = false) => {
      const d = new Date(date);
      if (endOfDay) d.setHours(23, 59, 59, 999);
      else d.setHours(0, 0, 0, 0);
      const pad = n => n.toString().padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}` +
             `T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    };

    // Helper: convert ISO date-only string (YYYY-MM-DD...) into a local midnight Date (avoids UTC shift)
    const isoDateOnlyToLocalDate = (iso) => {
      if (!iso) return null;
      const s = iso.toString().slice(0, 10); // YYYY-MM-DD
      const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
      return new Date(y, m - 1, d);
    };

    const pad2 = n => n.toString().padStart(2, '0');
    const toLocalYMD = date => `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`;




    // // // ----- 0: Daily Access -----
    if (tab === 0) {
      const params = {
        ...baseParams,
        from: formatLocalDate(from),
        to: formatLocalDate(to, true),
        employees: selectedEmps.join(',')
      };
      const resp = await axios.get('/api/reports/daily-access', { params });

      const startDate = new Date(from); startDate.setHours(8, 0, 0, 0);
      const endDate = new Date(to); endDate.setHours(8, 0, 0, 0);

      const rows = (resp.data && resp.data.data) || [];
      const filtered = rows.filter(r => {
        const dt = new Date(r.LocaleMessageTime);
        return dt >= startDate && dt < endDate;
      });

      await generateDailyAccessExcel(filtered);
      return;
    }


    // ----- 1: Raw -----
    if (tab === 1) {

const params = {
  ...baseParams,
  startDate: formatLocalDate(from),
  endDate: formatLocalDate(to, true),
  admitFilter: rawAdmitFilter  // <-- pass the UI value ('all'|'admit'|'reject')
};
const resp = await axios.get('/api/reports/raw', { params });
      const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

      const rowsSrc = (resp.data && resp.data.data) || [];
      const rows = rowsSrc.filter(r => {
        const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
        return date >= startDate && date <= endDate;
      });

      let filtered = rows;
      if (rawSearch && rawSearch.trim() !== '') {
        const s = rawSearch.trim().toLowerCase();
        filtered = rows.filter(r => {
          const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
          const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
          return id.includes(s) || name.includes(s);
        });
      }


// await generateRawExcel(filtered, { region, location, rawSearch, from, to });

await generateRawExcel(filtered, { region, location, rawSearch, from, to, rawAdmitFilter });


      return;
    }




    // ----- 2: Rejection -----
    if (tab === 2) {
      const params = { ...baseParams, startDate: formatLocalDate(from), endDate: formatLocalDate(to, true) };
      const resp = await axios.get('/api/reports/rejection', { params });

      const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
      const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

      const rowsSrc = (resp.data && resp.data.data) || [];
      const rows = rowsSrc.filter(r => {
        const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
        return date >= startDate && date <= endDate;
      });

      await generateRejectionExcel(rows);
      return;
    }

    // ----- 3: EUROC Admit-Reject (single day) -----
    if (tab === 3) {
      if (region.toLowerCase() !== 'emea') {
        alert('EUROC report is only available for region EMEA. Please select EMEA.');
        return;
      }
      if (!from) {
        alert('Please select a date (From) for EUROC report.');
        return;
      }

      const dateParam = toLocalYMD(new Date(from));
      const params = { region: 'emea', date: dateParam };
      const resp = await axios.get('/api/reports/euroc-admit-rejection', { params });
      const { data } = resp.data || {}; // { admit: [], rejection: [], summary: [] }

      const wb = new ExcelJS.Workbook();

      // Admit sheet
      const admitTitle = `EUROC Admit Report - ${formatDisplayDate(from)}`;
      const ws1 = wb.addWorksheet('EUROC Admit');
      ws1.mergeCells('A1:I1');
      ws1.getCell('A1').value = admitTitle;
      ws1.getCell('A1').font = { bold: true, size: 14 };
      ws1.getCell('A1').alignment = { horizontal: 'center' };

      const admitHeaders = [
        'Sr. No.', 'Date', 'Time', 'Employee Name',
        'Access Card No.', 'Personnel Type', 'Door Name', 'Location', 'Swipe'
      ];
      const hdrRow1 = ws1.addRow(admitHeaders);
      hdrRow1.font = { bold: true };
      hdrRow1.alignment = { vertical: 'middle', horizontal: 'center' };
      hdrRow1.eachCell(c => {
        c.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
      });

      ws1.columns = [
        { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
        { key:'name', width:30 }, { key:'card', width:15 }, { key:'ptype', width:20 },
        { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
      ];




(data.admit || []).forEach((r, idx) => {
  // Build an ISO that represents server wall-clock datetime (use LocaleMessageTime if provided)
  let iso;
  if (r.LocaleMessageTime) {
    iso = r.LocaleMessageTime; // already an ISO with Z
  } else if (r.DateOnly) {
    iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  } else {
    iso = '';
  }

  const dateStr = iso ? formatDateFromServerISO(iso) : '';
  const timeStr = iso ? formatTimeFromServerISO(iso) : '';

  // Insert formatted strings (not Date objects) — preserves exact server date/time
  const row = ws1.addRow([
    idx + 1,
    dateStr,
    timeStr,
    r.ObjectName1 || '',
    r.CardNumber || '',
    r.PersonnelType || '',
    r.Door || r.ObjectName2 || '',
    r.location || '',
    r.Direction || ''
  ]);

  // Keep formatting for header look — but DO NOT set numFmt expecting Excel date objects
  row.getCell(2).alignment = { horizontal: 'left' };
  row.getCell(3).alignment = { horizontal: 'left' };
  row.eachCell(c => {
    c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
    c.alignment = { vertical: 'middle', horizontal: 'left' };
  });
});


      // Rejection sheet
      const ws2 = wb.addWorksheet('EUROC Rejection');
      ws2.mergeCells('A1:J1');
      ws2.getCell('A1').value = `EUROC Rejection Report - ${formatDisplayDate(from)}`;
      ws2.getCell('A1').font = { bold: true, size: 14 };
      ws2.getCell('A1').alignment = { horizontal: 'center' };

      const headerRow2 = ws2.addRow(['Sr. No.', 'Date', 'Time', 'Employee Name', 'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe']);
      headerRow2.font = { bold: true };
      headerRow2.alignment = { vertical: 'middle', horizontal: 'center' };
      headerRow2.eachCell(c => {
        c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
      });

      ws2.columns = [
        { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
        { key:'name', width:30 }, { key:'card', width:15 }, { key:'type', width:15 },
        { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
      ];

(data.rejection || []).forEach((r, idx) => {
  let iso;
  if (r.LocaleMessageTime) {
    iso = r.LocaleMessageTime;
  } else if (r.DateOnly) {
    iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  } else {
    iso = '';
  }

  const dateStr = iso ? formatDateFromServerISO(iso) : '';
  const timeStr = iso ? formatTimeFromServerISO(iso) : '';

  const row = ws2.addRow([
    idx + 1,
    dateStr,
    timeStr,
    r.ObjectName1 || '',
    r.CardNumber || '',
    r.Rejection_Type || '',
    r.Door || '',
    r.location || '',
    r.Direction || ''
  ]);

  row.getCell(2).alignment = { horizontal: 'left' };
  row.getCell(3).alignment = { horizontal: 'left' };
  row.eachCell(c => {
    c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
    c.alignment = { vertical: 'middle', horizontal: 'left' };
  });
});




      // Summary block (same as before)
      const counts = data.summary || [];
      let startRow = 3;
      ws2.getCell(startRow, 11).value = 'Rejection';
      ws2.getCell(startRow, 12).value = 'Count';
      [11, 12].forEach(col => {
        const cell = ws2.getCell(startRow, col);
        cell.font = { bold: true };
        cell.alignment = { horizontal: 'center' };
        cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
      });
      startRow++;
      counts.forEach(c => {
        ws2.getCell(startRow, 11).value = c.Rejection_Type || 'Unknown';
        ws2.getCell(startRow, 12).value = c.Count || 0;
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.alignment = { horizontal: 'left' };
          cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });
        startRow++;
      });
      ws2.getCell(startRow, 11).value = 'Grand Total';
      ws2.getCell(startRow, 12).value = (data.rejection || []).length;
      [11, 12].forEach(col => {
        const cell = ws2.getCell(startRow, col);
        cell.font = { bold: true };
        cell.alignment = { horizontal: 'left' };
        cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
      });

      // Download workbook
      const buf = await wb.xlsx.writeBuffer();
      const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const filename = `EUROC_Admit_Rejection_${dateParam}.xlsx`;
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.click();
      return;
    }


    // ----- 4: Time Duration -----
if (tab === 4) {
  // require both start & end strictly
  if (!from || !to) {
    alert('Please select both Start Date and End Date for Time Duration report.');
    return;
  }
  const startParam = toLocalYMD(new Date(from));
  const endParam = toLocalYMD(new Date(to));
  const params = {
    region,
    startDate: startParam,
    endDate: endParam,
    partition: location ? location.split('.').pop() : 'Default'
  };
  const resp = await axios.get('/api/reports/time-duration', { params });
  await generateTimeDurationExcel(resp.data.data || []);
  return;
}



    // ----- 5: HeadCount / External navigation -----
    if (tab === 5) {
      let url = '';

      if (region === 'laca') {
        if (!location) url = 'http://10.199.22.57:3003/history';
        else {
          const LACA_URLS = {
            'CR.Costa Rica Partition': 'http://10.199.22.57:3003/partition/CR.Costa%20Rica%20Partition/history',
            'MX.Mexico City': 'http://10.199.22.57:3003/partition/MX.Mexico%20City/history',
            'AR.Cordoba': 'http://10.199.22.57:3003/partition/AR.Cordoba/history',
            'PA.Panama City': 'http://10.199.22.57:3003/partition/PA.Panama%20City/history',
            'PE.Lima': 'http://10.199.22.57:3003/partition/PE.Lima/history',
            'BR.Sao Paulo': 'http://10.199.22.57:3003/partition/BR.Sao%20Paulo/history'
          };
          url = LACA_URLS[location] || 'http://10.199.22.57:3003/history';
        }
      } else if (region === 'namer') {
        if (!location) url = 'http://10.199.22.57:3002/history';
        else {
          const NAMER_URLS = {
            'US.Denver': 'http://10.199.22.57:3002/partition/US.CO.OBS/history',
            'US.Miami': 'http://10.199.22.57:3002/partition/US.FL.Miami/history',
            'US.NYC': 'http://10.199.22.57:3002/partition/US.NYC/history',
            'US.Austin': 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default/history'
          };
          url = NAMER_URLS[location] || 'http://10.199.22.57:3002/history';
        }
      } else if (region === 'apac') {
        if (!location) url = 'http://10.199.22.57:3000/history';
        else {
          const APAC_URLS = {
            'APAC.Default': 'http://10.199.22.57:3000/partition/Pune/history',
            'MY.Kuala Lumpur': 'http://10.199.22.57:3000/partition/MY.Kuala Lumpur/history',
            'PH.Manila': 'http://10.199.22.57:3000/partition/PH.Manila/history',
            'JP.Tokyo': 'http://10.199.22.57:3000/history',
            'CN.Beijing': 'http://10.199.22.57:3000/history'
         
          };
          url = APAC_URLS[location] || 'http://10.199.22.57:3000/history';
        }
      } else if (region === 'emea') {
        if (!location) url = 'http://10.199.22.57:3001/history';
        else {
          const EMEA_URLS = {
            'AUT.Vienna': 'http://10.199.22.57:3001/history',
            'DU.Abu Dhabi': 'http://10.199.22.57:3001/history',
            'IE.Dublin': 'http://10.199.22.57:3001/history',
            'IT.Rome': 'http://10.199.22.57:3001/history',
            'LT.Vilnius': 'http://10.199.22.57:3001/history',
            'MA.Casablanca': 'http://10.199.22.57:3001/history',
            'RU.Moscow': 'http://10.199.22.57:3001/history',
            'UK.London': 'http://10.199.22.57:3001/history',
            'ES.Madrid': 'http://10.199.22.57:3001/history'
          };
          url = EMEA_URLS[location] || 'http://10.199.22.57:3001/history';
        }
      }

      if (url) window.location.href = url;
      else alert('Invalid region or location selected.');
      return;
    }

  } catch (err) {
    console.error(err);
    alert('Failed to generate report');
  } finally {
    setLoading(false);
  }
};





const disabled = loading
  || !region
  || (tab === 0 && (!from || !to || selectedEmps.length === 0)) // Daily Access
  || (tab === 1 && (!from || !to)) // Raw
  || (tab === 2 && (!from || !to)) // Rejection - require date range
  || (tab === 3 && !from) // EUROC (single day)
  || (tab === 4 && (!from || !to));


  // helper variable to keep navigation special-case consistent
  const navDisabled = !region || loading;


  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
        {/* Topbar / Header */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            px: 3,
            py: 2,
            borderBottom: '1px solid rgba(255,204,0,0.08)',
            background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
          }}
        >
          <Avatar sx={{ bgcolor: '#000', border: '3px solid #FFCC00', width: 56, height: 56 }}>
            <Typography sx={{ color: '#FFCC00', fontWeight: 900 }}>WU</Typography>
          </Avatar>

          <Box sx={{ flex: 1 }}>
            <Typography variant="h5" sx={{ fontWeight: 900, letterSpacing: 0.6 }}>
              Global Security Operation Center
            </Typography>
            <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
              Reports & Exports — Secure access, fast insights
            </Typography>
          </Box>

          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>



<Button
  startIcon={<DownloadIcon />}
  onClick={handleGenerate}
  // navigation special-case should be tab === 5 (HeadCount)
  disabled={tab === 5 ? navDisabled : disabled}
  sx={{
    bgcolor: '#FFCC00',
    color: '#000',
    fontWeight: 800,
    px: 3,
    py: 1,
    borderRadius: 3,
    boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
    transformOrigin: 'center',
    '&:hover': { bgcolor: '#ffd84d', transform: 'translateY(-2px)' }
  }}
>
  {loading ? 'Loading…'
           : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
</Button>
            
          </Box>
        </Box>

        {/* Main content: Sidebar + Content */}
        <Grid container sx={{ px: 3, py: 4 }} spacing={3}>
          {/* Sidebar */}
          <Grid item xs={12} md={3}>
            <Paper
              elevation={8}
              sx={{
                p: 2.5,
                borderRadius: 3,
                height: { xs: 'auto', md: 'calc(100vh - 150px)' },
                overflow: 'auto',
                background: 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015))',
                border: '1px solid rgba(255,204,0,0.06)'
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
                <Box>
                  <Typography variant="subtitle1" sx={{ fontWeight: 800, color: '#FFCC00' }}>Filters</Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Narrow down by region, date and employees
                  </Typography>
                </Box>
                <IconButton size="small" sx={{ color: '#FFCC00' }}>
                  <FilterListIcon />
                </IconButton>
              </Box>

              <Divider sx={{ my: 1, borderColor: 'rgba(255,204,0,0.06)' }} />

              {/* Region */}
              <Box sx={{ mt: 1 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Region</InputLabel>
                  <Select
                    value={region}
                    onChange={e => { setRegion(e.target.value); setLocation(''); }}
                    input={<OutlinedInput label="Region" />}
                    sx={{
                      color: '#fff',
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.24)' }
                    }}
                  >
                    {REGION_OPTIONS.map(r => <MenuItem key={r} value={r}>{r.toUpperCase()}</MenuItem>)}
                  </Select>
                </FormControl>
              </Box>

              {/* Location */}
              <Box sx={{ mt: 2 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Location</InputLabel>
                  <Select
                    value={location}
                    onChange={e => setLocation(e.target.value)}
                    input={<OutlinedInput label="Location" />}
                    disabled={!region}
                    sx={{
                      color: '#fff',
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                    }}
                  >
                    {(LOCATION_MAP[region] || []).map(loc => <MenuItem key={loc} value={loc}>{loc.split('.').pop()}</MenuItem>)}
                  </Select>
                </FormControl>
              </Box>

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />





              {/* Employee search (only for Raw tab) */}
              {/* {tab === 1 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employee (name or ID)
                  </Typography>
                  <TextField
                    fullWidth
                    placeholder="Type employee name or ID (e.g. 'Jejurkar' or '323471')"
                    label="Search Employee"
                    value={rawSearch}
                    onChange={(e) => setRawSearch(e.target.value)}
                    sx={{
                      '& .MuiInputBase-input': { color: '#fff' },
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                    }}
                    InputLabelProps={{ style: { color: '#FFCC00' } }}
                  />
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                    Leave empty to export all raw rows for the date range.
                  </Typography>
                </Box>
              )} */}





{tab === 1 && (
  <Box sx={{ mt: 2 }}>
    <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
      Employee (name or ID)
    </Typography>
    <TextField
      fullWidth
      placeholder="Type employee name or ID (e.g. 'Jejurkar' or '323471')"
      label="Search Employee"
      value={rawSearch}
      onChange={(e) => setRawSearch(e.target.value)}
      sx={{
        '& .MuiInputBase-input': { color: '#fff' },
        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
      }}
      InputLabelProps={{ style: { color: '#FFCC00' } }}
    />
    <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
      Leave empty to export all raw rows for the date range.
    </Typography>

    {/* --- NEW: Admit/Reject filter --- */}
    <Box sx={{ mt: 2 }}>
      <FormControl fullWidth>
        <InputLabel sx={{ color: '#FFCC00' }}>Admit / Reject</InputLabel>
        <Select
          value={rawAdmitFilter}
          onChange={(e) => setRawAdmitFilter(e.target.value)}
          input={<OutlinedInput label="Admit / Reject" />}
          sx={{
            color: '#fff',
            '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
          }}
        >
          <MenuItem value="all">All (Admitted + Rejected)</MenuItem>
          <MenuItem value="admit">Admitted only</MenuItem>
          <MenuItem value="reject">Rejected only</MenuItem>
        </Select>
      </FormControl>
      <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
        Default = All.
      </Typography>
    </Box>
  </Box>
)}


              {/* Dates */}
              {tab !== 5 && (
                <Box>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Date Range
                  </Typography>
                  <Box sx={{ display: 'grid', gap: 1.25 }}>
                    <TextField
                      label={tab === 0 ? 'From Date' : 'Start Date'}
                      value={from ? from.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowFromCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                    <TextField
                      label={tab === 0 ? 'To Date' : 'End Date'}
                      value={to ? to.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowToCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                  </Box>

                  {/* Static pickers (keeps your existing state handlers) */}
                  {showFromCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={from}
                        onChange={(newValue) => setFrom(newValue)}
                        onAccept={() => setShowFromCal(false)}
                        onClose={() => setShowFromCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                  {showToCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={to}
                        onChange={(newValue) => setTo(newValue)}
                        onAccept={() => setShowToCal(false)}
                        onClose={() => setShowToCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                </Box>
              )}

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />

              {/* Employees (only Daily) */}
              {tab === 0 && (
                <Box>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employees
                  </Typography>
                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Employees</InputLabel>
                    <Select
                      multiple
                      value={selectedEmps}
                      onChange={e => setSelectedEmps(e.target.value)}
                      input={<OutlinedInput label="Employees" />}
                      renderValue={vals => vals.join(', ')}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                      }}
                    >
                      {EMPLOYEE_OPTIONS.map(n => (
                        <MenuItem key={n} value={n}>
                          <Checkbox checked={selectedEmps.includes(n)} />
                          <ListItemText primary={n} />
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              )}

              {/* Helpful hint */}
              <Box sx={{ mt: 3, p: 2, borderRadius: 2, background: 'rgba(255,255,255,0.02)' }}>
                <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                  Tip: For daily exports pick employees & a single day range. For Time Duration choose the required partition via Location.
                </Typography>
              </Box>
            </Paper>
          </Grid>

          {/* Main panel */}
          <Grid item xs={12} md={9}>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              {/* Tabs (visual only) */}
              <Paper
                elevation={3}
                sx={{
                  px: 2,
                  py: 1,
                  borderRadius: 2,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  gap: 2,
                  border: '1px solid rgba(255,204,0,0.04)'
                }}
              >
                <Tabs
                  value={tab}
                  onChange={handleTabChange}
                  sx={{
                    '& .MuiTab-root': {
                      textTransform: 'none',
                      minWidth: 120,
                      fontWeight: 700,
                      color: 'rgba(255,255,255,0.8)'
                    },
                    '& .Mui-selected': { color: '#FFCC00' }
                  }}
                >
                  <Tab icon={<CalendarTodayIcon />} label="Daily Access" />
                  <Tab icon={<PeopleIcon />} label="Raw" />
                  <Tab icon={<PlaceIcon />} label="Rejection" />
                  <Tab icon={<PeopleIcon />} label="EUROC Admit-Reject" />

                  <Tab icon={<CalendarTodayIcon />} label="Time Duration" />
                  <Tab icon={<PeopleIcon />} label="HeadCount" />

                </Tabs>

                <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                  <Button
                    variant="text"
                    startIcon={<FilterListIcon />}
                    sx={{ color: 'rgba(255,255,255,0.65)', textTransform: 'none' }}
                    onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}
                  >
                    Reset View
                  </Button>
                </Box>
              </Paper>

              {/* Action summary + CTA */}
              <Paper elevation={6} sx={{ p: 3, borderRadius: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 2 }}>
                <Box>
                  <Typography variant="h6" sx={{ fontWeight: 900 }}>Export Center</Typography>
                  <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                    Selected Region: <strong style={{ color: '#FFCC00' }}>{region.toUpperCase()}</strong> {location ? `• ${location.split('.').pop()}` : ''}
                  </Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Choose tab, select filters and export reports in Excel.
                  </Typography>
                </Box>

                <Box>

<Button
  startIcon={loading ? <CircularProgress size={20} /> : <DownloadIcon />}
  disabled={tab === 5 ? navDisabled : disabled}
  onClick={handleGenerate}

                    sx={{
                      bgcolor: '#FFCC00',
                      color: '#000',
                      fontWeight: 900,
                      px: 4,
                      py: 1,
                      borderRadius: 3,
                      boxShadow: '0 8px 30px rgba(255,204,0,0.22)',
                      '&:hover': { bgcolor: '#ffd84d', transform: 'translateY(-3px)' }
                    }}
                  >

                     {loading
    ? 'Loading…'
    : (tab === 5
        ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`)
        : 'Export to Excel')}
</Button>

                </Box>
              </Paper>

            </Box>
          </Grid>

        </Grid>
      </Box>
    </LocalizationProvider>
  );

}






