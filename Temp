PS C:\Users\W0024618\Desktop\global-page\backend> npm run start:backend

> cd backend && node index.js

üåç Global-backend listening on http://localhost:3008
PS C:\Users\W0024618\Desktop\global-page\backend> npm run start:backend

> global-page@1.0.0 start:backend
> cd backend && node index.js

üåç Global-backend listening on http://localhost:3008
PS C:\Users\W0024618\Desktop\global-page\backend> npm run start:backend

> global-page@1.0.0 start:backend
> cd backend && node index.js

üåç Global-backend listening on http://localhost:3008
Query failed on pool (db=ACVSUJournal_00010029) for region apac: Maximum call stack size exceeded
Query failed on pool (db=ACVSUJournal_00010027) for region apac: Maximum call stack size exceeded
Query failed on pool (db=ACVSUJournal_00010029) for region apac: Maximum call stack size exceeded
Query failed on pool (db=ACVSUJournal_00010028) for region apac: Maximum call stack size exceeded

<--- Last few GCs --->

[1364:00000201FFAF5000]   464860 ms: Mark-Compact 4051.6 (4138.3) -> 4038.9 (4141.5) MB, pooled: 0 MB, 3537.52 / 0.00 ms  (average mu = 0.207, current mu = 0.037) allocation failure; scavenge might not succeed
[1364:00000201FFAF5000]   471444 ms: Mark-Compact 4054.6 (4141.5) -> 4042.0 (4144.5) MB, pooled: 0 MB, 6492.10 / 0.00 ms  (average mu = 0.089, current mu = 0.014) allocation failure; scavenge might not succeed


<--- JS stacktrace --->

FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory
----- Native stack trace -----

 1: 00007FF6CD61542D node::SetCppgcReference+17693
 2: 00007FF6CD578248 SSL_get_quiet_shutdown+102712
 3: 00007FF6CE0FED41 v8::Isolate::ReportExternalAllocationLimitReached+65
 4: 00007FF6CE0EB9C6 v8::Function::Experimental_IsNopFunction+2870
 5: 00007FF6CDF38B10 v8::internal::StrongRootAllocatorBase::StrongRootAllocatorBase+31456
 6: 00007FF6CDF35B7A v8::internal::StrongRootAllocatorBase::StrongRootAllocatorBase+19274
 7: 00007FF6CDF4B3D1 v8::Isolate::GetHeapProfiler+7793
 8: 00007FF6CDF4BC78 v8::Isolate::GetHeapProfiler+10008
 9: 00007FF6CDF5C92B v8::Isolate::GetHeapProfiler+78795
10: 00007FF6CDC25A1B v8::base::AddressSpaceReservation::AddressSpaceReservation+322075
11: 00007FF66E16D4BA
PS C:\Users\W0024618\Desktop\global-page\backend> npm run start:backend

> global-page@1.0.0 start:backend
> cd backend && node index.js

üåç Global-backend listening on http://localhost:3008
Query failed on pool (db=ACVSUJournal_00010025) for region apac: Maximum call stack size exceeded
PS C:\Users\W0024618\Desktop\global-page\backend> ^C
PS C:\Users\W0024618\Desktop\global-page\backend> ^C
PS C:\Users\W0024618\Desktop\global-page\backend> npm run start:backend

> global-page@1.0.0 start:backend
> cd backend && node index.js

üåç Global-backend listening on http://localhost:3008
Query failed on pool (db=ACVSUJournal_00010025) for region apac: Maximum call stack size exceeded
Query failed on pool (db=ACVSUJournal_00010026) for region apac: Maximum call stack size exceeded
Query failed on pool (db=ACVSUJournal_00010025) for region apac: Maximum call stack size exceeded
PS C:\Users\W0024618\Desktop\global-page\backend> npm run start:backend

> global-page@1.0.0 start:backend
> cd backend && node index.js

üåç Global-backend listening on http://localhost:3008
Query failed on pool (db=ACVSUJournal_00010027) for region apac: Maximum call stack size exceeded
Query failed on pool (db=ACVSUJournal_00010026) for region apac: Maximum call stack size exceeded
Query failed on pool (db=ACVSUJournal_00010028) for region apac: Maximum call stack size exceeded
Query failed on pool (db=ACVSUJournal_00010027) for region apac: Maximum call stack size exceeded




// C:\Users\W0024618\Desktop\global-page\backend\config\dbConfig.js
import sql from 'mssql';

// shared options
const commonOpts = {
  options: {
    encrypt: true,
    trustServerCertificate: true
  },
  // increase timeouts (milliseconds)
  // requestTimeout: maximum time for a single request to complete
  requestTimeout: 300000,      // 5 minutes
  // connectionTimeout: time to wait while establishing connection
  connectionTimeout: 30000,    // 30 seconds
  // pool defaults
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  }
};

// lowercase keys only
const regions = {
  apac: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUPNQ0986V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  },
  emea: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUFRA0986V',
    database: 'ACVSUJournal_00011028',
    ...commonOpts
  },
  laca: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUSJO0986V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  },
  namer: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUDEN0891V',
    database: 'ACVSUJournal_00010029',
    ...commonOpts
  }
};

// cache of connected pools by key: `${regionKey}_${database}`
const pools = {};

/**
 * Parse a database name for a numeric suffix in the form: "<base>_<digits>"
 * If match -> returns { base: "<base>_", num: <Number>, width: <digits length> }
 * If not match -> returns null
 */
function parseDbWithNumericSuffix(dbName) {
  if (!dbName || typeof dbName !== 'string') return null;
  const m = dbName.match(/^(.*?_)(\d+)$/);
  if (!m) return null;
  const base = m[1]; // includes trailing underscore
  const numStr = m[2];
  const num = parseInt(numStr, 10);
  return { base, num, width: numStr.length };
}

/**
 * Build a database name given parsed result and target number, preserving zero padding.
 */
function buildDbName(parsed, targetNum) {
  const padded = String(targetNum).padStart(parsed.width, '0');
  return `${parsed.base}${padded}`;
}

/**
 * Create/return (cached) a connected pool for the supplied region config object,
 * overriding the database name if overrideDatabase is provided.
 *
 * pools are cached using key: `${regionKey}_${databaseName}`
 */
async function ensurePoolForDatabase(regionKey, cfg, overrideDatabase) {
  const dbName = overrideDatabase || cfg.database;
  const cacheKey = `${regionKey}_${dbName}`;
  if (pools[cacheKey]) {
    // if pool exists but not connected (closed), attempt reconnect
    try {
      if (pools[cacheKey]._connected === false) {
        // re-connect
        pools[cacheKey] = await new sql.ConnectionPool({ ...cfg, database: dbName }).connect();
      }
      return pools[cacheKey];
    } catch (e) {
      // If reconnect fails, delete and fall through to create new
      delete pools[cacheKey];
    }
  }

  // create new pool for this dbName
  const poolCfg = { ...cfg, database: dbName };
  const pool = await new sql.ConnectionPool(poolCfg).connect();
  pools[cacheKey] = pool;
  return pool;
}

/**
 * Return single pool for the configured database of a region (backwards-compatible).
 * @param {string} regionKey  one of the keys in `regions`, case-insensitive
 * @returns {Promise<sql.ConnectionPool>}
 */
export async function getPool(regionKey) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) {
    throw new Error(`Unknown region: ${regionKey}`);
  }
  // ensure and return pool for the configured database (primary)
  return ensurePoolForDatabase(key, cfg, cfg.database);
}

/**
 * Return an array of pools for the region: [current, current-1, current-2, current-3, current-4]
 * If the configured database name doesn't have a numeric suffix, only the configured DB is returned.
 *
 * @param {string} regionKey
 * @returns {Promise<sql.ConnectionPool[]>}
 */
export async function getRegionPools(regionKey) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) {
    throw new Error(`Unknown region: ${regionKey}`);
  }

  const parsed = parseDbWithNumericSuffix(cfg.database);
  if (!parsed) {
    // cannot parse numeric suffix, return only primary
    const p = await ensurePoolForDatabase(key, cfg, cfg.database);
    return [p];
  }

  // Build list: current, current-1, current-2, current-3, current-4 (but do not create DB names <= 0)
  const nums = [
    parsed.num,
    parsed.num - 1,
    parsed.num - 2,
    parsed.num - 3,
    parsed.num - 4
  ].filter(n => n > 0);
  const dbNames = nums.map(n => buildDbName(parsed, n));

  // Ensure pools for each dbName (in configured order). If connect fails for a specific DB,
  // log and continue so caller receives the pools that succeeded.
  const createdPools = [];
  for (const dbName of dbNames) {
    try {
      const p = await ensurePoolForDatabase(key, cfg, dbName);
      createdPools.push(p);
    } catch (err) {
      // If connection to a previous DB fails, log and continue (do not block other pools)
      // This is safer in production where older DB might be offline.
      // Caller will receive the pools that succeeded.
      // eslint-disable-next-line no-console
      console.warn(`Failed to connect to ${dbName} for region ${key}:`, err.message || err);
    }
  }

  // If none succeeded (very unlikely), still attempt primary (configured) DB as fallback
  if (createdPools.length === 0) {
    const primary = await ensurePoolForDatabase(key, cfg, cfg.database);
    return [primary];
  }

  return createdPools;
}

/**
 * Convenience: returns the first available pool among [current, n-1, n-2, n-3, n-4].
 * Falls back to primary configured DB if none of the parsed names connected successfully.
 *
 * @param {string} regionKey
 * @returns {Promise<sql.ConnectionPool>}
 */
export async function getAnyPool(regionKey) {
  const poolsArr = await getRegionPools(regionKey);
  if (poolsArr && poolsArr.length) return poolsArr[0];
  // fallback to single primary pool
  return getPool(regionKey);
}

export { sql };







// C:\Users\W0024618\Desktop\global-page\backend\services\reportService.js

import { getPool, getRegionPools, sql } from '../config/dbConfig.js';

/**
 * Utility helper: execute the same parameterized query across all available region pools
 * returned by getRegionPools(region), collect rows and return concatenated array.
 *
 * - buildReq is a function(req) => { query: string } where it can bind inputs to req and return query text.
 * - If a pool connection/query fails, it logs a warning and continues with others.
 */
async function queryAcrossRegionPools(region, buildReq) {
  const pools = await getRegionPools(region);
  const allRows = [];
  for (const pool of pools) {
    try {
      const req = pool.request();
      req.timeout = 300000;
      const q = buildReq(req); // buildReq should set inputs on req and return query text
      const { recordset } = await req.query(q);
      if (recordset && recordset.length) {
        allRows.push(...recordset);
      }
    } catch (err) {
      // Non-fatal for now: log and continue. Caller receives combined available data.
      // eslint-disable-next-line no-console
      console.warn(`Query failed on pool (db=${pool.config.database}) for region ${region}:`, err.message || err);
    }
  }
  return allRows;
}

// ------------------------- light-weight functions -------------------------

export async function listLocations(region) {
  if (!region) throw new Error('region required');
  const pool = await getPool(region);
  const req = pool.request();
  // get distinct PartitionName2 values
  const q = `SELECT DISTINCT PartitionName2 FROM ACVSUJournalLog WHERE PartitionName2 IS NOT NULL ORDER BY PartitionName2`;
  const { recordset } = await req.query(q);
  return (recordset || []).map(r => r.PartitionName2).filter(Boolean);
}

/**
 * Search employees by name or employee id fragment
 */
export async function searchEmployees(region = 'emea', q = '') {
  const pool = await getPool(region);
  const req = pool.request();
  const like = `%${q}%`;
  req.input('q', sql.NVarChar(200), like);

  const query = `
    SELECT TOP (200)
      CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR(50)) END AS EmployeeID,
      ISNULL(t2.Text1, '') AS Name
    FROM ACVSCore.Access.Personnel AS t2
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId = t3.ObjectID
    WHERE (t2.Text1 LIKE @q) OR (CAST(t2.Int1 AS NVARCHAR(50)) LIKE @q) OR (t2.Text12 LIKE @q)
    ORDER BY t2.Text1;
  `;
  const { recordset } = await req.query(query);
  return (recordset || []).map(r => ({ EmployeeID: r.EmployeeID, Name: r.Name }));
}

// ------------------------- rawReport (now across region pools) -------------------------

export async function rawReport(region, { startDate, endDate, location, admitFilter = 'all' }) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;
  const admitFilterParam = String(admitFilter || 'all');

  const buildReq = (req) => {
    req.input('location', sql.NVarChar(200), locationParam);
    req.input('startDate', sql.Date, startDate);
    req.input('endDate', sql.Date, endDate);
    req.input('admitFilter', sql.NVarChar(20), admitFilterParam);

    // NOTE: no database prefix here; we'll run this query on each pool which is already connected to its DB.
    const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    AND (
      UPPER(ISNULL(@admitFilter,'all')) = 'ALL'
      OR (UPPER(@admitFilter) = 'ADMIT'  AND t1.MessageType = 'CardAdmitted')
      OR (UPPER(@admitFilter) = 'REJECT' AND t1.MessageType = 'CardRejected')
    )
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM CombinedQuery
ORDER BY LocaleMessageTime ASC;
`;
    return query;
  };

  const rows = await queryAcrossRegionPools(region, buildReq);
  // The per-pool queries were already ordered by LocaleMessageTime ASC; after concatenation, ensure global order.
  rows.sort((a, b) => {
    const ta = new Date(a.LocaleMessageTime || a.DateOnly || 0).getTime();
    const tb = new Date(b.LocaleMessageTime || b.DateOnly || 0).getTime();
    return ta - tb;
  });
  return rows;
}

// ------------------------- rejectionReport (across region pools) -------------------------

export async function rejectionReport(region, { startDate, endDate, location } = {}) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;

  const buildReq = (req) => {
    req.input('location', sql.NVarChar(200), locationParam);
    req.input('startDate', sql.Date, startDate);
    req.input('endDate', sql.Date, endDate);

    const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType = 'CardRejected'
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
),
Unified AS (
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Lost'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Clearance'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type IN ('CardDisabled','Disabled')
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Stolen'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Expired'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'PIN'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'UnknownCard'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'SiteCode'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'NotActivated'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'FacilityCode'
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM Unified
ORDER BY LocaleMessageTime DESC;
`;
    return query;
  };

  const rows = await queryAcrossRegionPools(region, buildReq);
  // Ensure unified ordering (descending)
  rows.sort((a, b) => {
    const ta = new Date(a.LocaleMessageTime || a.DateOnly || 0).getTime();
    const tb = new Date(b.LocaleMessageTime || b.DateOnly || 0).getTime();
    return tb - ta;
  });
  return rows;
}

// ------------------------- dailyAccessReportEMEA (across last DBs) -------------------------

export async function dailyAccessReportEMEA({ from, to, employees = '' }) {
  const region = 'emea'; // function is specifically EMEA
  const employeesParam = (employees && String(employees).trim()) ? String(employees).trim() : null;
  const startDate = from;
  const endDate = to;

  const buildReq = (req) => {
    req.input('fromDate', sql.Date, startDate);
    req.input('toDate', sql.Date, endDate);
    req.input('employees', sql.NVarChar(sql.MAX), employeesParam);

    // Note: removed the explicit database prefix - we'll run this on each pool DB
    const query = `

  -- expects parameters: @fromDate (DATE), @toDate (DATE), @employees (NVARCHAR(MAX) | NULL)
DECLARE @empCSV NVARCHAR(MAX) = @employees;

;WITH EmpList AS (
  SELECT LTRIM(RTRIM(value)) AS emp
  FROM STRING_SPLIT(ISNULL(@empCSV,''), ',')
  WHERE LTRIM(RTRIM(value)) <> ''
)

-- Raw rows: compute LocaleMessageTime once and use OUTER APPLY to avoid duplicate shreddes
, RawSwipes AS (
  SELECT
    t1.ObjectName1,
    t1.ObjectName2,
    t1.MessageType,
    t2.Text12       AS EmployeeID,
    CAST(t2.Int1 AS NVARCHAR(50)) AS NumericEmployeeID,
    t3.Name         AS PersonnelType,
    t1.PartitionName2 AS PartitionName2,

    -- compute local wall-clock once (DO NOT change sign here; using your -1 * MessageLocaleOffset)
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,

    -- direction/value picked by OUTER APPLY (single row)
    CASE
      WHEN dir.Value = 'InDirection'  THEN 'IN'
      WHEN dir.Value = 'OutDirection' THEN 'OUT'
      ELSE 'Unknown'
    END AS Swipe,

    card.Value AS CardNumber
  FROM ACVSUJournalLog AS t1
  INNER JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  INNER JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID

  -- pick at most one direction shred row (InDirection/OutDirection)
  OUTER APPLY (
    SELECT TOP (1) s.Value
    FROM ACVSUJournalLogxmlShred AS s
    WHERE s.GUID = t1.XmlGUID
      AND s.Value IN ('InDirection','OutDirection')
  ) AS dir

  -- pick at most one numeric card value (exclude direction values, ensure numeric)
  OUTER APPLY (
    SELECT TOP (1) s.Value
    FROM ACVSUJournalLogxmlShred AS s
    WHERE s.GUID = t1.XmlGUID
      AND s.Value NOT IN ('InDirection','OutDirection')
      AND s.Value NOT LIKE '%[^0-9]%'
      AND s.Value IS NOT NULL
      AND LTRIM(RTRIM(s.Value)) <> ''
  ) AS card
)

-- Strict time window: >= 08:00 on @fromDate, and < 08:00 on @toDate
, Windowed AS (
  SELECT *
  FROM RawSwipes
  WHERE
    LocaleMessageTime >= DATEADD(HOUR, 8, CAST(@fromDate AS DATETIME))
    AND LocaleMessageTime <  DATEADD(HOUR, 8, CAST(@toDate AS DATETIME))
    AND Swipe IN ('IN','OUT') -- only real swipes
)

-- final projection + optional employee filter (supports CSV of names or IDs)
SELECT
  ObjectName1,
  ObjectName2,
  PersonnelType,
  EmployeeID,
  NumericEmployeeID,
  PartitionName2 AS location,
  MessageType AS Messagetype,
  Swipe,
  CardNumber,
  LocaleMessageTime
FROM Windowed w
WHERE
  (
    @empCSV IS NULL
    OR LTRIM(RTRIM(@empCSV)) = ''
    OR EXISTS (
      SELECT 1
      FROM EmpList e
      WHERE
        e.emp = LTRIM(RTRIM(w.ObjectName1))
        OR e.emp = w.EmployeeID
        OR e.emp = w.NumericEmployeeID
    )
  )
ORDER BY LocaleMessageTime;
`;
    return query;
  };

  const rows = await queryAcrossRegionPools(region, buildReq);
  // global ordering
  rows.sort((a, b) => {
    const ta = new Date(a.LocaleMessageTime || 0).getTime();
    const tb = new Date(b.LocaleMessageTime || 0).getTime();
    return ta - tb;
  });
  return rows;
}

// ------------------------- inOutReport (kept single-pool; unchanged) -------------------------

export async function inOutReport(region, { year, month, doors }) {
  const pool = await getPool(region);
  const req = pool.request();
  req.timeout = 300000;

  req.input('TargetYear', sql.Int, year);
  req.input('TargetMonth', sql.Int, month);
  doors.forEach((d, i) => req.input(`door${i}`, sql.NVarChar, d));
  const doorList = doors.map((_, i) => `@door${i}`).join(',');

  const query = `
WITH CombinedQuery AS (
  SELECT
    DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
    t1.ObjectName1,
    t1.PartitionName2    AS location,
    t5_card.CardNumber,
    t5_dir.value         AS Direction,
    CASE
      WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
      ELSE CAST(t2.Int1 AS NVARCHAR)
    END                    AS EmployeeID,
    t3.Name               AS PersonnelType
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID
    AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml AS t_xml
    ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard
    ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  WHERE
    YEAR(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetYear
    AND MONTH(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetMonth
    AND t1.ObjectName2 IN (${doorList})
)
SELECT
  FORMAT(LocaleMessageTime,'yyyy-MM')    AS Month,
  ObjectName1                           AS EmployeeName,
  EmployeeID,
  PersonnelType,
  location,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)  AS In_Count,
  SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS Out_Count,
  COUNT(*)                                                 AS TotalSwipes,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)
  - SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS InOut_Difference
FROM CombinedQuery
GROUP BY FORMAT(LocaleMessageTime,'yyyy-MM'),
         ObjectName1, EmployeeID, PersonnelType, location
ORDER BY Month DESC, EmployeeName;
`;

  const { recordset } = await req.query(query);
  return recordset;
}

// ------------------------- timeDurationReport (now across region pools) -------------------------

export async function timeDurationReport(region, { partition = 'Default', startDate }) {
  const pools = await getRegionPools(region);
  const allRows = [];
  for (const pool of pools) {
    try {
      const req = pool.request();
      req.timeout = 300000;

      const fullPartition = `${region.toUpperCase()}.${partition}`;
      req.input('partition', sql.NVarChar, fullPartition);
      req.input('startDate', sql.Date, startDate);

      // IMPORTANT: removed explicit DB prefix here, run on each pool
      const query = `

SELECT 
    t1.[ObjectName1],
    t1.[ObjectName2],
    t1.[PartitionName2],
    CASE
        WHEN t2.[Int1] = 0 THEN t2.[Text12]
        ELSE CAST(t2.[Int1] AS NVARCHAR)
    END AS EmployeeID,
    t3.[Name] AS PersonnelType,
    t2.text5,
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    DATEADD(HOUR, -2, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) AS AdjustedMessageTime
INTO 
    #CombinedEmployeeData
FROM 
    ACVSUJournalLog AS t1
INNER JOIN 
    ACVSCore.Access.Personnel AS t2
    ON t1.ObjectIdentity1 = t2.GUID
INNER JOIN 
    ACVSCore.Access.PersonnelType AS t3
    ON t2.[PersonnelTypeId] = t3.[ObjectID];

-- Step 2: Daily duration per employee
WITH DailyDurations AS (
    SELECT 
        [ObjectName1],
        PersonnelType,
        EmployeeID,
        [PartitionName2],
        text5,
        CONVERT(DATE, AdjustedMessageTime) AS ShiftedDate,
        DATEPART(WEEK, AdjustedMessageTime) AS WeekNumber,
        DATEPART(YEAR, AdjustedMessageTime) AS YearNumber,
        MIN(LocaleMessageTime) AS FirstSwipeTime,
        MAX(LocaleMessageTime) AS LastSwipeTime,
        DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) AS DurationMinutes,
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) / 60 AS NVARCHAR), 2)
        + ':' +
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) % 60 AS NVARCHAR), 2) AS DurationHHMM,
        CASE 
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 5 THEN '<5mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 10 THEN '<10mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 20 THEN '<20mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 30 THEN '<30mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 60 THEN '<1hr'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 120 THEN 'Less than <2hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 180 THEN 'Less than <3hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 240 THEN 'Less than <4hrs'
            ELSE '4+ hrs'
        END AS TimeDiffCategory
    FROM 
        #CombinedEmployeeData
  WHERE CONVERT(DATE, AdjustedMessageTime) >= @startDate
   AND [PartitionName2] = @partition
        AND PersonnelType IN ('Employee', 'Terminated Personnel')
    GROUP BY 
        [ObjectName1], EmployeeID, PersonnelType, text5, [PartitionName2],
        CONVERT(DATE, AdjustedMessageTime),
        DATEPART(WEEK, AdjustedMessageTime),
        DATEPART(YEAR, AdjustedMessageTime)
),

-- Step 3: Weekly summary
WeeklySummary AS (
    SELECT 
        EmployeeID,
        [ObjectName1],
        PersonnelType,
        text5,
        [PartitionName2],
        YearNumber,
        WeekNumber,
        COUNT(DISTINCT ShiftedDate) AS DaysPresentInWeek,
        SUM(CASE WHEN DurationMinutes < 240 THEN 1 ELSE 0 END) AS ViolationDaysInWeek
    FROM 
        DailyDurations
    GROUP BY 
        EmployeeID, [ObjectName1], PersonnelType, text5, [PartitionName2], YearNumber, WeekNumber
)

-- Step 4: Final output with daily duration, category, and defaulter flag
SELECT 
    dd.EmployeeID,
    dd.ObjectName1,
    dd.PersonnelType,
    dd.text5,
    dd.PartitionName2,
    dd.YearNumber,
    dd.WeekNumber,
    dd.ShiftedDate,
    dd.FirstSwipeTime,
    dd.LastSwipeTime,
    dd.DurationHHMM,
    dd.TimeDiffCategory,
    ws.DaysPresentInWeek,
    ws.ViolationDaysInWeek,
    (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) AS CleanDaysInWeek,
    CASE
        WHEN (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) < 3 THEN 'Yes'
        ELSE 'No'
    END AS Defaulter
FROM 
    DailyDurations dd
JOIN 
    WeeklySummary ws
    ON dd.EmployeeID = ws.EmployeeID
    AND dd.WeekNumber = ws.WeekNumber
    AND dd.YearNumber = ws.YearNumber
ORDER BY 
    dd.YearNumber DESC, dd.WeekNumber DESC, dd.EmployeeID, dd.ShiftedDate;
  `;

      const { recordset } = await req.query(query);
      if (recordset && recordset.length) {
        allRows.push(...recordset);
      }
    } catch (err) {
      // log and continue with other DBs
      // eslint-disable-next-line no-console
      console.warn(`timeDurationReport query failed on db=${pool.config.database}:`, err.message || err);
    }
  }

  // sort/return aggregated rows (if needed)
  allRows.sort((a, b) => {
    const keyA = `${a.YearNumber || 0}-${a.WeekNumber || 0}-${a.EmployeeID || ''}-${(a.ShiftedDate || '')}`;
    const keyB = `${b.YearNumber || 0}-${b.WeekNumber || 0}-${b.EmployeeID || ''}-${(b.ShiftedDate || '')}`;
    return keyB.localeCompare(keyA); // maintain original ORDER BY Year desc, Week desc...
  });

  return allRows;
}

// ------------------------- eurocAdmitRejectionReport (multi-resultset) -------------------------

export async function eurocAdmitRejectionReport(region, { reportDate }) {
  // This query returns 3 resultsets in original code. We must collect them across DBs and then merge.
  const pools = await getRegionPools(region);
  const admitRows = [];
  const rejectRows = [];
  const summaryMap = {}; // Rejection_Type => count

  for (const pool of pools) {
    try {
      const req = pool.request();
      req.timeout = 300000;
      req.input('location', sql.NVarChar, 'LT.Vilnius');
      req.input('reportDate', sql.Date, reportDate);

      const query = `
/* (same as before but no DB prefixes) */
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    AND t1.PartitionName2 = @location
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @reportDate
)

SELECT
  LocaleMessageTime,
  CONVERT(date, LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  MessageType
INTO #Combined
FROM CombinedQuery;

SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  ROW_NUMBER() OVER (PARTITION BY ISNULL(EmployeeID, CardNumber) ORDER BY LocaleMessageTime ASC) AS rn
INTO #Admits
FROM #Combined
WHERE MessageType = 'CardAdmitted'
  AND PersonnelType IN('Employee', 'Terminated Personnel');

SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
INTO #Rejections
FROM #Combined
WHERE MessageType = 'CardRejected';

-- resultset 1
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Admits
WHERE rn = 1
ORDER BY LocaleMessageTime ASC;

-- resultset 2
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Rejections
ORDER BY LocaleMessageTime ASC;

-- resultset 3
SELECT
  ISNULL(Rejection_Type, 'Unknown') AS Rejection_Type,
  COUNT(*) AS CountVal
FROM #Rejections
GROUP BY ISNULL(Rejection_Type, 'Unknown')
ORDER BY CountVal DESC;

DROP TABLE IF EXISTS #Admits;
DROP TABLE IF EXISTS #Rejections;
DROP TABLE IF EXISTS #Combined;
`;
      const result = await req.query(query);
      const recordsets = result.recordsets || [];
      // recordsets[0] = admits, [1] = rejections, [2] = summary
      const admits = (recordsets[0] || []).map(r => ({
        LocaleMessageTime: r.LocaleMessageTime,
        DateOnly: r.DateOnly,
        Swipe_Time: r.Swipe_Time,
        ObjectName1: r.ObjectName1,
        EmployeeID: r.EmployeeID,
        PersonnelType: r.PersonnelType,
        CardNumber: r.CardNumber,
        Door: r.Door,
        location: r.location,
        Direction: r.Direction
      }));
      const rejects = (recordsets[1] || []).map(r => ({
        LocaleMessageTime: r.LocaleMessageTime,
        DateOnly: r.DateOnly,
        Swipe_Time: r.Swipe_Time,
        ObjectName1: r.ObjectName1,
        EmployeeID: r.EmployeeID,
        PersonnelType: r.PersonnelType,
        CardNumber: r.CardNumber,
        Rejection_Type: r.Rejection_Type,
        Door: r.Door,
        location: r.location,
        Direction: r.Direction
      }));
      const summary = (recordsets[2] || []).map(r => ({ Rejection_Type: r.Rejection_Type, Count: r.CountVal }));

      if (admits.length) admitRows.push(...admits);
      if (rejects.length) rejectRows.push(...rejects);
      summary.forEach(s => {
        summaryMap[s.Rejection_Type] = (summaryMap[s.Rejection_Type] || 0) + (s.Count || 0);
      });
    } catch (err) {
      // log and continue
      // eslint-disable-next-line no-console
      console.warn(`euroc query failed on db=${pool.config.database}:`, err.message || err);
    }
  }

  // Sort admit & reject rows by time ascending to mimic single-db behavior
  admitRows.sort((a, b) => new Date(a.LocaleMessageTime || 0) - new Date(b.LocaleMessageTime || 0));
  rejectRows.sort((a, b) => new Date(a.LocaleMessageTime || 0) - new Date(b.LocaleMessageTime || 0));

  // convert summaryMap into array
  const summaryRows = Object.entries(summaryMap).map(([k, v]) => ({ Rejection_Type: k, Count: v }));

  return { admit: admitRows, rejection: rejectRows, summary: summaryRows };
}














































