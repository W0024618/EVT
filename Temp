// AGGREGATION: group by EmployeeID / person_uid / fallback (name + card)
function buildAggregated(rowsArr) {
  var map = new Map();
  (rowsArr || []).forEach(function (r) {
    var id = r.EmployeeID || r.person_uid || (sanitizeName(r) + '|' + (r.CardNumber || r.Card || ''));
    var key = String(id);
    if (!map.has(key)) {
      map.set(key, {
        EmployeeName: sanitizeName(r),
        EmployeeID: r.EmployeeID || r.person_uid || "",
        CardNumber: r.CardNumber || r.Card || "",
        ViolationCount: 0,
        ReasonsSet: new Set(),
        ViolationDaysLast90: 0,
        FirstRow: r,
        _rows: []
      });
    }
    var agg = map.get(key);
    agg.ViolationCount += 1;
    agg._rows.push(r);

    // collect reasons
    var reasonsField = r.Reasons || r.DetectedScenarios || r.Detected || "";
    String(reasonsField).split(";").map(function (s) { return s.trim(); }).filter(Boolean).forEach(function (p) { agg.ReasonsSet.add(p); });

    // pick max ViolationDays using dynamic key + fallbacks
    var v = 0;
    try {
      if (r && violationDaysKey && (r[violationDaysKey] !== undefined && r[violationDaysKey] !== null && r[violationDaysKey] !== "")) {
        v = Number(r[violationDaysKey]) || 0;
      } else if (r && r.ViolationDaysLast_90 !== undefined) {
        v = Number(r.ViolationDaysLast_90) || 0;
      } else if (r && r.ViolationDays !== undefined) {
        v = Number(r.ViolationDays) || 0;
      } else if (r && r.ViolationDaysLast !== undefined) {
        v = Number(r.ViolationDaysLast) || 0;
      }
    } catch (e) {
      v = 0;
    }
    if (!isNaN(v)) {
      agg.ViolationDaysLast90 = Math.max(agg.ViolationDaysLast90 || 0, v);
    }
  }); // end forEach

  var out = [];
  map.forEach(function (val, key) {
    out.push({
      EmployeeName: val.EmployeeName,
      EmployeeID: val.EmployeeID,
      CardNumber: val.CardNumber,
      ViolationCount: val.ViolationCount,
      Reasons: Array.from(val.ReasonsSet).join(";"),
      ViolationDaysLast90: val.ViolationDaysLast90,
      FirstRow: val.FirstRow,
      _rows: val._rows
    });
  });

  // sort aggregated by ViolationCount desc then name
  out.sort(function (a, b) {
    if (b.ViolationCount !== a.ViolationCount) return b.ViolationCount - a.ViolationCount;
    return (a.EmployeeName || "").localeCompare(b.EmployeeName || "");
  });

  return out;
}

var aggregatedFiltered = collapseDuplicates ? buildAggregated(filtered) : null;

var sourceForPaging = collapseDuplicates ? (aggregatedFiltered || []) : filtered;

var totalPages = Math.max(1, Math.ceil((sourceForPaging.length || 0) / pageSize));
var pageRows = (sourceForPaging || []).slice((page - 1) * pageSize, page * pageSize);
















Now fix this issue and share me updated Snippet carefully


Uncaught SyntaxError: Inline Babel script: Unexpected token, expected , (958:8)
  956 | 
  957 |         // build aggregatedFiltered only if collapseDuplicates is enabled
> 958 |         var aggregatedFiltered = collapseDuplicates ? buildAggregated(filtered) : null;
      |         ^
  959 | 
  960 |           // set up pagination source
  961 |           var sourceForPaging = collapseDuplicates ? (aggregatedFiltered || []) : filtered;
    at J.raise (babel.min.js:7:10099)
    at X.unexpected (babel.min.js:5:27476)
    at X.expect (babel.min.js:5:27253)
    at te.parseCallExpressionArguments (babel.min.js:6:27165)
    at te.parseSubscripts (babel.min.js:6:26566)
    at te.parseExprSubscripts (babel.min.js:6:25775)
    at te.parseMaybeUnary (babel.min.js:6:25267)
    at te.parseExprOps (babel.min.js:6:23839)
    at te.parseMaybeConditional (babel.min.js:6:23430)
    at te.parseMaybeAssign (babel.min.js:6:22650)Understand this error






<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Behaviour Analysis — Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- React + ReactDOM + Babel (quick prototyping) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- Flatpickr -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    (function () {
      const { useState, useEffect, useRef } = React;

      // CHANGE IF YOUR API HOST DIFFERS
      const API_BASE = "http://localhost:8002";

      function resolveApiImageUrl(imgUrl) {
        if (!imgUrl) return null;
        try {
          if (imgUrl.startsWith('http://') || imgUrl.startsWith('https://')) return imgUrl;
          // ensure API_BASE has no trailing slash
          var base = API_BASE.replace(/\/$/, '');
          if (imgUrl.startsWith('/')) return base + imgUrl;
          return base + '/' + imgUrl;
        } catch (e) {
          return imgUrl;
        }
      }


      // --- Region / Location mapping copied from backend/duration_report.REGION_CONFIG (friendly / UI names) ---
      // Keep the keys lowercase to match backend region keys.
      const REGION_OPTIONS = {
        "apac": {
          label: "APAC",
          // Friendly names used by backend normalisation (duration_report) for APAC
          partitions: ["Pune", "Quezon City", "Taguig City", "MY.Kuala Lumpur", "IN.HYD", "SG.Singapore"]
        },
        "emea": {
          label: "EMEA",
          partitions: ["LT.Vilnius", "IT.Rome", "UK.London", "IE.DUblin", "DU.Abu Dhab", "ES.Madrid"]
        },
        "laca": {
          label: "LACA",
          partitions: ["AR.Cordoba", "BR.Sao Paulo", "CR.Costa Rica Partition", "PA.Panama City", "PE.Lima", "MX.Mexico City"]
        },
        "namer": {
          label: "NAMER",
          // show friendly names to the user, but we map them to backend partition tokens before sending
          partitions: ["Denver", "Austin Texas", "Miami", "New York"]
        }
      };

      // Map from UI-friendly location label -> backend search token (used for &city=)
      // For APAC, friendly labels match backend PartitionName2 normalised values so they map to themselves.
      // For NAMER, backend normalisation sets PartitionName2 to tokens like "US.CO.OBS", "USA/Canada Default" etc.
      const LOCATION_QUERY_VALUE = {
        "apac": {
          "Pune": "Pune",
          "Quezon City": "Quezon City",
          "Taguig City": "Taguig City",
          "MY.Kuala Lumpur": "MY.Kuala Lumpur",
          "IN.HYD": "IN.HYD",
          "SG.Singapore": "SG.Singapore"
        },
        "namer": {
          // friendly->backend tokens (this matches the backend duration_report normalisation)
          "Denver": "US.CO.OBS",
          "Austin Texas": "USA/Canada Default",
          "Miami": "US.FL.Miami",
          "New York": "US.NYC"
        },
        // default passthrough for other regions (if needed)
        "emea": {},
        "laca": {}
      };

      // Map risk text/colors (same as backend map_score_to_label buckets)
      const RISK_COLORS = {
        "Low": "#10b981",
        "Low Medium": "#86efac",
        "Medium": "#facc15",
        "Medium High": "#fb923c",
        "High": "#ef4444"
      };
      const RISK_LABELS = ["Low", "Low Medium", "Medium", "Medium High", "High"];

      // (rest unchanged) Explanations...
      const SCENARIO_EXPLANATIONS = {
        "long_gap_>=4.5h": "Long gap between swipes (>=4.5 hours).",
        "short_duration_<4h": "Short total presence (<4 hours).",
        "coffee_badging": "Multiple short swipes — possible coffee badging.",
        "low_swipe_count_<=2": "Very few swipes recorded for day (<=2).",
        "single_door": "Single door used during day.",
        "only_in": "Only IN events present.",
        "only_out": "Only OUT events present.",
        "overtime_>=10h": "Overtime (>=10 hours).",
        "very_long_duration_>=16h": "Very long presence (>=16 hours).",
        "unusually_high_swipes": "Unusually high number of swipes vs history.",
        "repeated_short_breaks": "Multiple short breaks in day.",
        "multiple_location_same_day": "Multiple locations used same day.",
        "weekend_activity": "Activity on weekend.",
        "repeated_rejection_count": "Multiple rejections.",
        "badge_sharing_suspected": "Same card used by multiple persons on same day.",
        "early_arrival_before_06": "First swipe earlier than 06:00.",
        "late_exit_after_22": "Last swipe after 22:00.",
        "shift_inconsistency": "Duration inconsistent with historical shift.",
        "trending_decline": "Historical trending decline.",
        "consecutive_absent_days": "Consecutive absent days historically.",
        "high_variance_duration": "High variance in durations historically.",
        "short_duration_on_high_presence_days": "Short duration despite high typical presence.",
        "swipe_overlap": "Swipes overlapping other users (possible tailgating).",
        "shortstay_longout_repeat": "Short in -> long out -> short return pattern."
      };

      // small utilities
      function pad(n) { return n.toString().padStart(2, '0'); }
      function formatDateISO(d) {
        if (!d) return "";
        const dt = (d instanceof Date) ? d : new Date(d);
        return dt.getFullYear() + "-" + pad(dt.getMonth() + 1) + "-" + pad(dt.getDate());
      }


      function safeDateDisplay(val) {
        if (!val && val !== 0) return "";
        try {
          const d = (val instanceof Date) ? val : new Date(val);
          if (isNaN(d.getTime())) return String(val);
          return d.toLocaleString();
        } catch (e) {
          return String(val);
        }
      }

      function sanitizeName(row) {
        if (!row) return "";
        // prefer feature/duration versions if present
        return row.EmployeeName_feat || row.EmployeeName_dur || row.EmployeeName || row.ObjectName1 || row.objectname1 || row.employee_name || row.person_uid || "";
      }


      function downloadCSV(rows, filename) {
        if (!rows || !rows.length) { alert("No rows to export"); return; }
        var cols = Object.keys(rows[0]);
        var lines = [cols.join(",")];
        rows.forEach(function (r) {
          var row = cols.map(function (c) {
            var v = (r[c] === undefined || r[c] === null) ? "" : String(r[c]).replace(/\n/g, ' ');
            return JSON.stringify(v);
          }).join(",");
          lines.push(row);
        });
        var blob = new Blob([lines.join("\n")], { type: 'text/csv' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a'); a.href = url; a.download = filename || 'export.csv'; a.click(); URL.revokeObjectURL(url);
      }

      // duration formatting helper
      function formatSecondsToHmsJS(seconds) {
        if (seconds === null || seconds === undefined || seconds === '') return "-";
        const n = Number(seconds);
        if (isNaN(n) || !isFinite(n)) return "-";
        const s = Math.max(0, Math.floor(n));
        const hh = Math.floor(s / 3600);
        const mm = Math.floor((s % 3600) / 60);
        const ss = s % 60;
        return pad(hh) + ":" + pad(mm) + ":" + pad(ss);
      }



      // duration formatting helper (HH:MM) — used for Duration fields (strict HH:MM)
      function formatSecondsToHmJS(seconds) {
        if (seconds === null || seconds === undefined || seconds === '') return "-";
        const n = Number(seconds);
        if (isNaN(n) || !isFinite(n)) return "-";
        const s = Math.max(0, Math.floor(n));
        const hh = Math.floor(s / 3600);
        const mm = Math.floor((s % 3600) / 60);
        // return HH:MM (hours may be >23)
        return String(hh) + ":" + String(mm).padStart(2, '0');
      }


      // ----- Day-boundary helpers -----
      // Backend assigns Date using LocaleMessageTime.date() (no 2AM shift).
      // Keep frontend day-boundary at 0 so logical dates match backend.
      const DAY_BOUNDARY_HOUR = 0;

      function logicalDateForTs(dt, boundaryHour = DAY_BOUNDARY_HOUR) {
        if (!dt || !(dt instanceof Date) || isNaN(dt.getTime())) return null;
        const hour = dt.getHours();
        const year = dt.getFullYear();
        const month = dt.getMonth();
        const day = dt.getDate();
        const out = new Date(year, month, day, 0, 0, 0, 0);
        // with boundaryHour = 0, this never subtracts a day -> matches backend date assignment
        if (hour < boundaryHour) {
          out.setDate(out.getDate() - 1);
        }
        const y = out.getFullYear();
        const m = String(out.getMonth() + 1).padStart(2, '0');
        const d = String(out.getDate()).padStart(2, '0');
        return `${y}-${m}-${d}`;
      }

      function makeLocalDateFromRow(r) {
        try {
          if (!r) return null;

          // backend usually includes LocaleMessageTime (ISO string). Prefer that.
          if (r.LocaleMessageTime) {
            const t = new Date(r.LocaleMessageTime);
            if (!isNaN(t.getTime())) return t;
          }

          function toInt(v, fallback = 0) {
            const n = Number(v);
            return Number.isFinite(n) ? n : fallback;
          }

          // Backend also supplies DateOnly + Time for frontend convenience — use those if present.
          if (r.DateOnly && r.Time) {
            try {
              // DateOnly might be a Date object or 'YYYY-MM-DD' string.
              const dateStr = String(r.DateOnly).slice(0, 10).replace(/\//g, '-');
              const dateParts = dateStr.split('-').map(p => toInt(p, NaN));
              if (dateParts.length === 3 && !isNaN(dateParts[0])) {
                const year = dateParts[0];
                const month = dateParts[1];
                const day = dateParts[2];

                const timeRaw = String(r.Time).split(/[.+Z ]/)[0];
                const timeParts = timeRaw.split(':').map(p => toInt(p, 0));
                const hh = timeParts[0] || 0;
                const mm = timeParts[1] || 0;
                const ss = timeParts[2] || 0;

                return new Date(year, month - 1, day, hh, mm, ss, 0);
              }
            } catch (e) { /* fallthrough */ }
          }

          // fallback: if Date and Time fields exist (older API formats)
          if (r.Date && r.Time) {
            try {
              const dateStr = String(r.Date).slice(0, 10).replace(/\//g, '-');
              const dateParts = dateStr.split('-').map(p => toInt(p, NaN));
              if (dateParts.length === 3 && !isNaN(dateParts[0])) {
                const year = dateParts[0];
                const month = dateParts[1];
                const day = dateParts[2];

                const timeRaw = String(r.Time).split(/[.+Z ]/)[0];
                const timeParts = timeRaw.split(':').map(p => toInt(p, 0));
                const hh = timeParts[0] || 0;
                const mm = timeParts[1] || 0;
                const ss = timeParts[2] || 0;

                return new Date(year, month - 1, day, hh, mm, ss, 0);
              }
            } catch (e) { /* fallthrough */ }
          }

          // if only DateOnly present, return midnight of that date
          if (r.DateOnly) {
            try {
              const parts = String(r.DateOnly).slice(0, 10).replace(/\//g, '-').split('-');
              if (parts.length === 3) {
                const y = toInt(parts[0], NaN);
                const m = toInt(parts[1], NaN);
                const d = toInt(parts[2], NaN);
                if (!isNaN(y)) return new Date(y, m - 1, d, 0, 0, 0, 0);
              }
            } catch (e) { /* fallthrough */ }
          }

          // if only Date present, use that
          if (r.Date) {
            try {
              const parts = String(r.Date).slice(0, 10).replace(/\//g, '-').split('-');
              if (parts.length === 3) {
                const y = toInt(parts[0], NaN);
                const m = toInt(parts[1], NaN);
                const d = toInt(parts[2], NaN);
                if (!isNaN(y)) return new Date(y, m - 1, d, 0, 0, 0, 0);
              }
            } catch (e) { /* fallthrough */ }
          }

        } catch (e) { }
        return null;
      }

      function App() {
        var yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);

        const [dateFrom, setDateFrom] = useState(formatDateISO(yesterday));
        const [dateTo, setDateTo] = useState(formatDateISO(new Date()));
        const [loading, setLoading] = useState(false);
        const [summary, setSummary] = useState({ rows: 0, flagged_rows: 0, files: [], end_date: null });
        const [rows, setRows] = useState([]);
        const [reasonsCount, setReasonsCount] = useState({});
        const [riskCounts, setRiskCounts] = useState({ "Low": 0, "Low Medium": 0, "Medium": 0, "Medium High": 0, "High": 0 });
        const [filterText, setFilterText] = useState("");
        const [page, setPage] = useState(1);
        const [selectedReason, setSelectedReason] = useState("");
        const [reasonFilterText, setReasonFilterText] = useState("");
        const [modalRow, setModalRow] = useState(null);
        const [modalDetails, setModalDetails] = useState(null);
        const [modalLoading, setModalLoading] = useState(false);
        const [collapseDuplicates, setCollapseDuplicates] = useState(true);
        const [selectedRiskFilter, setSelectedRiskFilter] = useState("");

        // New: region & location
        const [selectedRegion, setSelectedRegion] = useState("apac");
        const [selectedLocation, setSelectedLocation] = useState("All locations");

        // NEW: Employee ID (optional) — minimal addition
        const [employeeId, setEmployeeId] = useState("");



        const [violationDaysKey, setViolationDaysKey] = useState("ViolationDaysLast90");
        const [violationDaysLabel, setViolationDaysLabel] = useState("ViolationDaysLast90");


        const pageSize = 25;
        const chartRef = useRef(null);
        const chartInst = useRef(null);

        const fromRef = useRef(null);
        const toRef = useRef(null);
        const fromFp = useRef(null);
        const toFp = useRef(null);


        // Chat state
        const [chatOpen, setChatOpen] = useState(false);
        const [chatMessages, setChatMessages] = useState([]);
        const [chatInput, setChatInput] = useState("");
        const [chatLoading, setChatLoading] = useState(false);


        /**
         * Detect the best ViolationDays key from a sample of rows.
         * Prefers column names that start with "ViolationDaysLast" and chooses
         * the one with the largest numeric suffix (e.g. ViolationDaysLast180 > ViolationDaysLast90).
         * Falls back to 'ViolationDays', 'ViolationDaysLast', or neutral key.
         */
        function detectViolationDaysKey(rows) {
          try {
            if (!rows || !rows.length) {
              setViolationDaysKey("ViolationDaysLast");
              setViolationDaysLabel("ViolationDays");
              return { key: "ViolationDaysLast", label: "ViolationDays" };
            }
            const candCols = new Set();
            rows.slice(0, 50).forEach(r => {
              if (!r) return;
              Object.keys(r).forEach(k => {
                if (typeof k === "string" && k.startsWith("ViolationDaysLast")) candCols.add(k);
              });
            });
            if (candCols.size === 0) {
              // fallback common names
              const first = rows.find(r => r);
              if (first) {
                if (first.ViolationDays !== undefined) {
                  setViolationDaysKey("ViolationDays");
                  setViolationDaysLabel("ViolationDays");
                  return { key: "ViolationDays", label: "ViolationDays" };
                }
                if (first.ViolationDaysLast !== undefined) {
                  setViolationDaysKey("ViolationDaysLast");
                  setViolationDaysLabel("ViolationDaysLast");
                  return { key: "ViolationDaysLast", label: "ViolationDaysLast" };
                }
              }
              setViolationDaysKey("ViolationDaysLast");
              setViolationDaysLabel("ViolationDays");
              return { key: "ViolationDaysLast", label: "ViolationDays" };
            }
            const cand = Array.from(candCols);
            function suffixNum(name) {
              const m = name.match(/ViolationDaysLast(\d+)/);
              if (!m) return 0;
              return parseInt(m[1], 10) || 0;
            }
            cand.sort((a, b) => suffixNum(b) - suffixNum(a));
            const chosen = cand[0];
            const m = chosen.match(/ViolationDaysLast(\d+)/);
            const label = m ? `ViolationDaysLast${m[1]}` : chosen;
            setViolationDaysKey(chosen);
            setViolationDaysLabel(label);
            return { key: chosen, label };
          } catch (e) {
            setViolationDaysKey("ViolationDaysLast");
            setViolationDaysLabel("ViolationDays");
            return { key: "ViolationDaysLast", label: "ViolationDays" };
          }
        }


        useEffect(function () {
          if (window.flatpickr && fromRef.current && toRef.current) {
            try { if (fromFp.current) fromFp.current.destroy(); } catch (e) { }
            try { if (toFp.current) toFp.current.destroy(); } catch (e) { }
            fromFp.current = window.flatpickr(fromRef.current, {
              dateFormat: "Y-m-d",
              defaultDate: dateFrom,
              allowInput: true,
              onChange: function (selectedDates, str) {
                if (selectedDates && selectedDates.length) {
                  const iso = formatDateISO(selectedDates[0]);
                  setDateFrom(iso);
                  try { if (toFp.current) toFp.current.set('minDate', iso); } catch (e) { }
                  if (dateTo && new Date(iso) > new Date(dateTo)) {
                    setDateTo(iso);
                    try { if (toFp.current) toFp.current.setDate(iso, true); } catch (e) { }
                  }
                }
              }
            });
            toFp.current = window.flatpickr(toRef.current, {
              dateFormat: "Y-m-d",
              defaultDate: dateTo,
              allowInput: true,
              onChange: function (selectedDates, str) {
                if (selectedDates && selectedDates.length) {
                  const iso = formatDateISO(selectedDates[0]);
                  setDateTo(iso);
                  try { if (fromFp.current) fromFp.current.set('maxDate', iso); } catch (e) { }
                  if (dateFrom && new Date(iso) < new Date(dateFrom)) {
                    setDateFrom(iso);
                    try { if (fromFp.current) fromFp.current.setDate(iso, true); } catch (e) { }
                  }
                }
              }
            });
            try { if (fromFp.current) fromFp.current.set('maxDate', dateTo); if (toFp.current) toFp.current.set('minDate', dateFrom); } catch (e) { }
          }
          loadLatest();
          return function () { try { if (fromFp.current) fromFp.current.destroy(); } catch (e) { } try { if (toFp.current) toFp.current.destroy(); } catch (e) { } };
          // eslint-disable-next-line
        }, []);









        useEffect(function () {
          try { if (fromFp.current && dateFrom) fromFp.current.setDate(dateFrom, false); } catch (e) { }
          try { if (toFp.current && dateTo) toFp.current.setDate(dateTo, false); } catch (e) { }
          try { if (fromFp.current) fromFp.current.set('maxDate', dateTo); } catch (e) { }
          try { if (toFp.current) toFp.current.set('minDate', dateFrom); } catch (e) { }
        }, [dateFrom, dateTo]);

        // When region changes, reset location to "All locations"
        useEffect(() => {
          setSelectedLocation("All locations");
        }, [selectedRegion]);

        async function runForRange() {
          setLoading(true);


          // --- replace existing: setRows(sample);  with this ---
          setRows(sample || []);
          // detect violation-days key from returned sample (best effort)
          try {
            detectViolationDaysKey(Array.isArray(sample) ? sample : []);
          } catch (err) {
            console.warn("Violation days detection failed:", err);
          }


          setSummary({ rows: 0, flagged_rows: 0, files: [], end_date: null });
          setReasonsCount({});
          setRiskCounts({ "Low": 0, "Low Medium": 0, "Medium": 0, "Medium High": 0, "High": 0 });
          try {
            const start = encodeURIComponent(dateFrom);
            const end = encodeURIComponent(dateTo);
            // include selected region & city if provided
            let url = API_BASE + "/run?start=" + start + "&end=" + end + "&full=true";
            if (selectedRegion) {
              url += "&region=" + encodeURIComponent(selectedRegion);
            }
            if (selectedLocation && selectedLocation !== "All locations") {
              // send backend-aware partition token (use mapping)
              const mapForRegion = LOCATION_QUERY_VALUE[selectedRegion] || {};
              const queryCity = mapForRegion[selectedLocation] || selectedLocation;
              url += "&city=" + encodeURIComponent(queryCity);
            }

            // NEW: include employee_id if provided (minimal addition)
            if (employeeId && String(employeeId).trim() !== "") {
              url += "&employee_id=" + encodeURIComponent(String(employeeId).trim());
            }

            let r = await fetch(url, { method: 'GET' });
            if (!r.ok) { const txt = await r.text(); throw new Error("API returned " + r.status + ": " + txt); }
            let js = await r.json();

            const totalRows = (typeof js.aggregated_unique_persons === 'number') ? js.aggregated_unique_persons
              : (typeof js.rows === 'number') ? js.rows : 0;
            const totalFlagged = (typeof js.flagged_rows === 'number') ? js.flagged_rows : 0;
            const files = js.files || [];

            const sample = Array.isArray(js.flagged_persons) && js.flagged_persons.length ? js.flagged_persons
              : (Array.isArray(js.sample) ? js.sample : []);
            setRows(sample);

            setSummary({ rows: totalRows, flagged_rows: totalFlagged, files: files, end_date: formatDateISO(new Date(dateTo)) });

            if (js.reasons_count && Object.keys(js.reasons_count).length > 0) {
              setReasonsCount(js.reasons_count);
            } else {
              computeReasonsAndRisks(sample);
            }
            if (js.risk_counts && Object.keys(js.risk_counts).length > 0) {
              const all = { "Low": 0, "Low Medium": 0, "Medium": 0, "Medium High": 0, "High": 0 };
              Object.keys(js.risk_counts).forEach(k => { all[k] = js.risk_counts[k]; });
              setRiskCounts(all);
            } else {
              computeReasonsAndRisks(sample);
            }
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message);
            console.error(err);
          } finally {
            setLoading(false);
          }
        }

        function pushChatMessage(msg) {
          setChatMessages(prev => [...prev, msg]);
          setTimeout(() => {
            const el = document.querySelector('.chat-body');
            if (el) el.scrollTop = el.scrollHeight;
          }, 50);
        }



        // New: group rows by person and compute unique per-person reason + highest-severity risk
        function computeReasonsAndRisks(dataRows) {
          // helper severity mapping (higher => more severe)
          function severityForLabel(label) {
            const map = { "Low": 1, "Low Medium": 2, "Medium": 3, "Medium High": 4, "High": 5 };
            if (!label) return 1;
            return map[String(label)] || 1;
          }

          var personMap = {}; // key -> { rows:[], reasonsSet:Set, maxSeverity, chosenLabel }

          (dataRows || []).forEach(function (r) {
            try {
              var key = r.EmployeeID || r.person_uid || (sanitizeName(r) + '|' + (r.CardNumber || r.Card || ''));
              if (!key) {
                // fallback: unique by row index-ish (but try to avoid counting duplicates without id)
                key = JSON.stringify(r); // rare fallback
              }
              if (!personMap[key]) {
                personMap[key] = { rows: [], reasonsSet: new Set(), maxSeverity: 0, chosenLabel: null };
              }
              var p = personMap[key];
              p.rows.push(r);

              // collect reasons (set per person)
              var reasonsField = r.Reasons || r.DetectedScenarios || r.Detected || "";
              String(reasonsField).split(";").map(function (s) { return s && s.trim(); }).filter(Boolean).forEach(function (rs) {
                p.reasonsSet.add(rs);
              });

              // pick highest severity risk label across this person's rows
              var rl = getRiskLabelForRow(r);
              var sev = severityForLabel(rl);
              if (sev > p.maxSeverity) {
                p.maxSeverity = sev;
                p.chosenLabel = rl || "Low";
              }
            } catch (err) {
              // ignore malformed rows
              console.error("computeReasonsAndRisks row error", err);
            }
          });

          // Build aggregated counts: one contribution per person
          var reasonsCounts = {};
          var rcounts = { "Low": 0, "Low Medium": 0, "Medium": 0, "Medium High": 0, "High": 0 };

          Object.keys(personMap).forEach(function (k) {
            var p = personMap[k];
            // reasons: increment each reason once per person
            p.reasonsSet.forEach(function (rn) {
              reasonsCounts[rn] = (reasonsCounts[rn] || 0) + 1;
            });
            // risk: increment chosenLabel once per person (fallback to Low)
            var label = p.chosenLabel || "Low";
            if (!rcounts[label] && rcounts[label] !== 0) rcounts[label] = 0; // ensure key exists
            rcounts[label] = (rcounts[label] || 0) + 1;
          });

          setReasonsCount(reasonsCounts);
          setRiskCounts(rcounts);
        }








        // async function loadLatest() {
        //   setLoading(true);
        //   try {
        //     // run for yesterday (to match backend's default behaviour)
        //     var d = new Date();
        //     d.setDate(d.getDate() - 1);
        //     var yesterday = formatDateISO(d);
        //     setDateFrom(yesterday);
        //     setDateTo(yesterday);

        //     const start = encodeURIComponent(yesterday);
        //     const end = encodeURIComponent(yesterday);
        //     let url = API_BASE + "/run?start=" + start + "&end=" + end + "&full=true";
        //     if (selectedRegion) {
        //       url += "&region=" + encodeURIComponent(selectedRegion);
        //     }
        //     if (selectedLocation && selectedLocation !== "All locations") {
        //       const mapForRegion = LOCATION_QUERY_VALUE[selectedRegion] || {};
        //       const queryCity = mapForRegion[selectedLocation] || selectedLocation;
        //       url += "&city=" + encodeURIComponent(queryCity);
        //     }




        //     let r = await fetch(url, { method: 'GET' });
        //     if (!r.ok) { const txt = await r.text(); throw new Error("API returned " + r.status + ": " + txt); }
        //     let js = await r.json();

        //     const totalRows = (typeof js.aggregated_unique_persons === 'number') ? js.aggregated_unique_persons
        //       : (typeof js.rows === 'number') ? js.rows : 0;
        //     const totalFlagged = (typeof js.flagged_rows === 'number') ? js.flagged_rows : 0;
        //     const files = js.files || [];

        //     const sample = Array.isArray(js.sample) ? js.sample : (Array.isArray(js.flagged_persons) ? js.flagged_persons : []);
        //     setRows(sample);
        //     setSummary({ rows: totalRows, flagged_rows: totalFlagged, files: files, end_date: yesterday });

        //     if (js.reasons_count && Object.keys(js.reasons_count).length > 0) {
        //       setReasonsCount(js.reasons_count);
        //     } else {
        //       computeReasonsAndRisks(sample);
        //     }
        //     if (js.risk_counts && Object.keys(js.risk_counts).length > 0) {
        //       const all = { "Low": 0, "Low Medium": 0, "Medium": 0, "Medium High": 0, "High": 0 };
        //       Object.keys(js.risk_counts).forEach(k => { all[k] = js.risk_counts[k]; });
        //       setRiskCounts(all);
        //     } else {
        //       computeReasonsAndRisks(sample);
        //     }
        //     setPage(1);
        //   } catch (err) {
        //     alert("Error: " + err.message);
        //     console.error(err);
        //   } finally {
        //     setLoading(false);
        //   }
        // }



        async function loadLatest() {
          setLoading(true);
          try {
            // run for yesterday (to match backend's default behaviour)
            var d = new Date();
            d.setDate(d.getDate() - 1);
            var yesterday = formatDateISO(d);
            setDateFrom(yesterday);
            setDateTo(yesterday);

            const start = encodeURIComponent(yesterday);
            const end = encodeURIComponent(yesterday);
            let url = API_BASE + "/run?start=" + start + "&end=" + end + "&full=true";
            if (selectedRegion) {
              url += "&region=" + encodeURIComponent(selectedRegion);
            }
            if (selectedLocation && selectedLocation !== "All locations") {
              const mapForRegion = LOCATION_QUERY_VALUE[selectedRegion] || {};
              const queryCity = mapForRegion[selectedLocation] || selectedLocation;
              url += "&city=" + encodeURIComponent(queryCity);
            }

            // NEW: include employee_id if provided for loadLatest as well
            if (employeeId && String(employeeId).trim() !== "") {
              url += "&employee_id=" + encodeURIComponent(String(employeeId).trim());
            }

            let r = await fetch(url, { method: 'GET' });
            if (!r.ok) { const txt = await r.text(); throw new Error("API returned " + r.status + ": " + txt); }
            let js = await r.json();

            const totalRows = (typeof js.aggregated_unique_persons === 'number') ? js.aggregated_unique_persons
              : (typeof js.rows === 'number') ? js.rows : 0;
            const totalFlagged = (typeof js.flagged_rows === 'number') ? js.flagged_rows : 0;
            const files = js.files || [];

            const sample = Array.isArray(js.sample) ? js.sample : (Array.isArray(js.flagged_persons) ? js.flagged_persons : []);
            setRows(sample);
            setSummary({ rows: totalRows, flagged_rows: totalFlagged, files: files, end_date: yesterday });

            if (js.reasons_count && Object.keys(js.reasons_count).length > 0) {
              setReasonsCount(js.reasons_count);
            } else {
              computeReasonsAndRisks(sample);
            }
            if (js.risk_counts && Object.keys(js.risk_counts).length > 0) {
              const all = { "Low": 0, "Low Medium": 0, "Medium": 0, "Medium High": 0, "High": 0 };
              Object.keys(js.risk_counts).forEach(k => { all[k] = js.risk_counts[k]; });
              setRiskCounts(all);
            } else {
              computeReasonsAndRisks(sample);
            }
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message);
            console.error(err);
          } finally {
            setLoading(false);
          }
        }




        function getRiskLabelForRow(r) {
          if (!r) return null;
          var rl = r.RiskLevel || r.Risk || null;
          if (rl) return String(rl);
          if (r.RiskScore !== undefined && r.RiskScore !== null) {
            const mapNum = { 1: "Low", 2: "Low Medium", 3: "Medium", 4: "Medium High", 5: "High" };
            return mapNum[String(r.RiskScore)] || null;
          }
          if (r.AnomalyScore !== undefined && r.AnomalyScore !== null) {
            if (r.AnomalyScore >= 5) return "High";
            if (r.AnomalyScore >= 4) return "Medium High";
            if (r.AnomalyScore >= 3) return "Medium";
            if (r.AnomalyScore >= 2) return "Low Medium";
            return "Low";
          }
          return null;
        }

        function buildChart(rcounts) {
          var labels = RISK_LABELS;
          var values = labels.map(l => rcounts && rcounts[l] ? rcounts[l] : 0);
          var colors = labels.map(l => {
            if (selectedRiskFilter) {
              return (l === selectedRiskFilter) ? RISK_COLORS[l] : '#e6edf3';
            } else {
              return RISK_COLORS[l] || '#cccccc';
            }
          });

          var ctx = chartRef.current && chartRef.current.getContext ? chartRef.current.getContext('2d') : null;
          if (!ctx) return;
          try { if (chartInst.current) chartInst.current.destroy(); } catch (e) { }

          chartInst.current = new Chart(ctx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [{
                label: 'Flagged by Risk Level',
                data: values,
                borderColor: '#2563eb',
                backgroundColor: 'rgba(37,99,235,0.2)',
                fill: true,
                tension: 0.3,
                pointBackgroundColor: colors,
                pointRadius: 5,
                pointHoverRadius: 7
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: function (context) {
                      return context.parsed.y + ' cases';
                    }
                  }
                }
              },
              onClick: function (evt, elements) {
                if (elements && elements.length > 0) {
                  var idx = elements[0].index;
                  var label = this.data.labels[idx];
                  handleRiskBarClick(label);
                }
              },
              scales: {
                y: { beginAtZero: true, ticks: { precision: 0 } }
              }
            }
          });

        }

        useEffect(function () {
          buildChart(riskCounts);
        }, [riskCounts, selectedRiskFilter]);





        // Filtering & aggregation
        // Keep old filtering behaviour to produce 'filtered' (raw rows matching filters)
        var filtered = (rows || []).filter(function (r) {
          var hay = (sanitizeName(r) + " " + (r.EmployeeID || "") + " " + (r.CardNumber || "") + " " + (r.Reasons || r.DetectedScenarios || "")).toLowerCase();
          var textOk = !filterText || hay.indexOf(filterText.toLowerCase()) !== -1;
          var reasonOk = !selectedReason || (r.Reasons && ((";" + String(r.Reasons) + ";").indexOf(selectedReason) !== -1)) || (r.DetectedScenarios && ((";" + String(r.DetectedScenarios) + ";").indexOf(selectedReason) !== -1));
          var riskOk = true;
          if (selectedRiskFilter) {
            var rl = getRiskLabelForRow(r);
            if (!rl) { riskOk = false; }
            else riskOk = (String(rl) === String(selectedRiskFilter));
          }
          return textOk && reasonOk && riskOk;
        });





        // // sort raw filtered (so aggregated picks same order for first-row)
        // filtered.sort(function (a, b) {
        //   var va = Number(a.ViolationDaysLast90 || a.ViolationDaysLast_90 || 0);
        //   var vb = Number(b.ViolationDaysLast90 || b.ViolationDaysLast_90 || 0);
        //   if (isNaN(va)) va = 0;
        //   if (isNaN(vb)) vb = 0;
        //   if (vb !== va) return vb - va;
        //   return (sanitizeName(a) || "").localeCompare(sanitizeName(b) || "");
        // });



        filtered.sort(function (a, b) {
          try {
            const getVal = (obj) => {
              if (!obj) return 0;
              // try dynamic key, then common fallbacks
              const v = obj[violationDaysKey];
              if (v !== undefined && v !== null && v !== "") return Number(v) || 0;
              if (obj.ViolationDaysLast_90 !== undefined) return Number(obj.ViolationDaysLast_90) || 0;
              if (obj.ViolationDays !== undefined) return Number(obj.ViolationDays) || 0;
              if (obj.ViolationDaysLast !== undefined) return Number(obj.ViolationDaysLast) || 0;
              return 0;
            };
            var va = getVal(a);
            var vb = getVal(b);
            if (isNaN(va)) va = 0;
            if (isNaN(vb)) vb = 0;
            if (vb !== va) return vb - va;
            return (sanitizeName(a) || "").localeCompare(sanitizeName(b) || "");
          } catch (e) {
            return 0;
          }
        });



        // AGGREGATION: group by EmployeeID / person_uid / fallback (name + card)
        function buildAggregated(rowsArr) {
          var map = new Map();
          rowsArr.forEach(function (r) {
            var id = r.EmployeeID || r.person_uid || (sanitizeName(r) + '|' + (r.CardNumber || r.Card || ''));
            var key = String(id);
            if (!map.has(key)) {
              map.set(key, {
                EmployeeName: sanitizeName(r),
                EmployeeID: r.EmployeeID || r.person_uid || "",
                CardNumber: r.CardNumber || r.Card || "",
                ViolationCount: 0,
                ReasonsSet: new Set(),
                ViolationDaysLast90: 0,
                FirstRow: r,
                _rows: []
              });
            }
            var agg = map.get(key);
            agg.ViolationCount += 1;
            agg._rows.push(r);
            // collect reasons
            var reasonsField = r.Reasons || r.DetectedScenarios || r.Detected || "";
            String(reasonsField).split(";").map(function (s) { return s.trim(); }).filter(Boolean).forEach(function (p) { agg.ReasonsSet.add(p); });
            // pick max ViolationDaysLast90 (representative)



            //   var v = Number(r.ViolationDaysLast90 || r.ViolationDaysLast_90 || r.ViolationDays || 0);
            //   if (!isNaN(v)) {
            //     agg.ViolationDaysLast90 = Math.max(agg.ViolationDaysLast90 || 0, v);
            //   }
            // });

            var v = 0;
            try {
              if (r && violationDaysKey && (r[violationDaysKey] !== undefined && r[violationDaysKey] !== null && r[violationDaysKey] !== "")) {
                v = Number(r[violationDaysKey]) || 0;
              } else if (r && r.ViolationDaysLast_90 !== undefined) {
                v = Number(r.ViolationDaysLast_90) || 0;
              } else if (r && r.ViolationDays !== undefined) {
                v = Number(r.ViolationDays) || 0;
              } else if (r && r.ViolationDaysLast !== undefined) {
                v = Number(r.ViolationDaysLast) || 0;
              }
            } catch (e) {
              v = 0;
            }
            if (!isNaN(v)) {
              agg.ViolationDaysLast90 = Math.max(agg.ViolationDaysLast90 || 0, v);
            }



            var out = [];
            map.forEach(function (val, key) {
              out.push({
                EmployeeName: val.EmployeeName,
                EmployeeID: val.EmployeeID,
                CardNumber: val.CardNumber,
                ViolationCount: val.ViolationCount,
                Reasons: Array.from(val.ReasonsSet).join(";"),
                ViolationDaysLast90: val.ViolationDaysLast90,
                FirstRow: val.FirstRow,
                _rows: val._rows
              });
            });

            // sort aggregated by ViolationCount desc then name
            out.sort(function (a, b) {
              if (b.ViolationCount !== a.ViolationCount) return b.ViolationCount - a.ViolationCount;
              return (a.EmployeeName || "").localeCompare(b.EmployeeName || "");
            });

            return out;
          }

   
      var aggregatedFiltered = collapseDuplicates ? buildAggregated(filtered) : null;
       
          var sourceForPaging = collapseDuplicates ? (aggregatedFiltered || []) : filtered;

          var totalPages = Math.max(1, Math.ceil((sourceForPaging.length || 0) / pageSize));
          var pageRows = (sourceForPaging || []).slice((page - 1) * pageSize, page * pageSize);

          var totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
          var pageRows = filtered.slice((page - 1) * pageSize, page * pageSize);


          function exportFiltered() { downloadCSV(collapseDuplicates ? (aggregatedFiltered || []) : filtered, "trend_filtered_export.csv"); }


          function onReasonClick(reason) {
            if (!reason) { setSelectedReason(""); return; }
            if (selectedReason === reason) setSelectedReason(""); else setSelectedReason(reason);
            setPage(1);
          }





          async function openEvidence(row) {
            setModalRow(row);
            setModalDetails(null);
            setModalLoading(true);
            try {
              const q = encodeURIComponent(row.EmployeeID || row.person_uid || "");
              const resp = await fetch(API_BASE + "/record?employee_id=" + q);
              if (!resp.ok) { const txt = await resp.text(); throw new Error("record failed: " + resp.status + " - " + txt); }
              const js = await resp.json();

              // QUICK: set an explicit image_url if backend provided or build one from employee id
              const quickImageUrl = js.image_url || js.imageUrl || js.ImageUrl || null;
              const candidateId = (row && (row.EmployeeID || row.person_uid)) || null;
              const builtImage = quickImageUrl || (candidateId ? `/employee/${encodeURIComponent(candidateId)}/image` : null);

              // update modalRow immediately so UI renders email/image ASAP
              setModalRow(prev => Object.assign({}, prev || {}, {
                EmployeeEmail: prev && prev.EmployeeEmail ? prev.EmployeeEmail : (js.meta && (js.meta.email || js.meta.Email) ? (js.meta.email || js.meta.Email) : null),
                Email: prev && prev.Email ? prev.Email : (js.meta && (js.meta.email || js.meta.Email) ? (js.meta.email || js.meta.Email) : null),
                ImageUrl: builtImage || (prev && prev.ImageUrl) || null
              }));

              // Normalize details (keep aggregated_rows as array, raw_swipes as array)
              const details = {
                aggregated_rows: Array.isArray(js.aggregated_rows) ? js.aggregated_rows : (Array.isArray(js.sample) ? js.sample : []),
                raw_swipe_files: Array.isArray(js.raw_swipe_files) ? js.raw_swipe_files : (Array.isArray(js.files) ? js.files : []),
                raw_swipes: Array.isArray(js.raw_swipes) ? js.raw_swipes : []
              };
              setModalDetails(details);

              // Robustly extract email (check aggregated_rows -> raw_swipes -> modalRow)
              let newEmail = null;
              try {
                if (details.aggregated_rows && details.aggregated_rows.length) {
                  const f = details.aggregated_rows[0];
                  newEmail = newEmail || f.EmployeeEmail || f.Email || f.EmailAddress || f.WorkEmail || f.EMail || null;
                }
                if (!newEmail && details.raw_swipes && details.raw_swipes.length) {
                  const r0 = details.raw_swipes[0];
                  newEmail = newEmail || r0.EmployeeEmail || r0.Email || r0.EmailAddress || r0.WorkEmail || null;
                }
                // fallback to any meta in response
                if (!newEmail && js && js.meta && (js.meta.email || js.meta.Email)) {
                  newEmail = js.meta.email || js.meta.Email;
                }
                // last fallback: original row (from table)
                if (!newEmail && row) {
                  newEmail = row.EmployeeEmail || row.Email || null;
                }
              } catch (err) {
                // swallow - we'll just not show email if unavailable
              }

              // Also capture common fields (CardNumber etc.) from the first raw_swipe if missing
              let cardNum = null;
              try {
                if (details.aggregated_rows && details.aggregated_rows.length) {
                  const f = details.aggregated_rows[0];
                  cardNum = f.CardNumber || f.Card || null;
                }
                if (!cardNum && details.raw_swipes && details.raw_swipes.length) {
                  const r0 = details.raw_swipes[0];
                  cardNum = r0.CardNumber || r0.Card || null;
                }
              } catch (err) { }

              // Merge into modalRow (ensures UI re-render shows email/card)
              setModalRow(prev => Object.assign({}, prev || {}, {
                EmployeeEmail: newEmail || (prev && prev.EmployeeEmail) || null,
                Email: newEmail || (prev && prev.Email) || null,
                CardNumber: (prev && prev.CardNumber) || cardNum || null
              }));

            } catch (e) {
              alert("Failed loading details: " + e.message);
              console.error(e);
            } finally {
              setModalLoading(false);
            }
          }


          function closeModal() { setModalRow(null); setModalDetails(null); }

          // helper to render overlap
          function renderOverlapCell(r) {
            var ov = r.OverlapWith || r.swipe_overlap || r.overlap_with || null;
            if (ov && typeof ov === 'string') {
              var parts = ov.split(";").map(function (s) { return s.trim(); }).filter(Boolean);
              if (parts.length === 0) return <span className="muted">—</span>;
              return <span className="pill" title={ov}>{parts.length} overlap</span>;
            }
            return <span className="muted">—</span>;
          }

          function renderReasonChips(reasonText) {
            if (!reasonText) return <span className="muted">—</span>;
            const parts = String(reasonText).split(";").map(s => s.trim()).filter(Boolean);
            return parts.map((p, idx) => (<span key={idx} className="pill" title={SCENARIO_EXPLANATIONS[p] || p}>{p}</span>));
          }

          function renderReasonExplanations(reasonText) {
            if (!reasonText) return <div className="muted">No flags</div>;
            const parts = String(reasonText).split(";").map(s => s.trim()).filter(Boolean);
            return (
              <div>
                {parts.map((p, idx) => (
                  <div key={idx} className="why-item" style={{ marginBottom: 8 }}>
                    <b>{p}</b>
                    <div className="small">{SCENARIO_EXPLANATIONS[p] || "No explanation available."}</div>
                  </div>
                ))}
              </div>
            );
          }

          async function sendChat(qText, opts = { top_k: 5 }) {
            if (!qText || !qText.toString().trim()) return;
            const text = qText.toString().trim();
            pushChatMessage({ who: 'user', text });
            setChatInput("");
            setChatLoading(true);
            try {
              const payload = Object.assign({ q: text }, opts);
              const resp = await fetch(API_BASE + "/chatbot/query", {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });
              if (!resp.ok) {
                const t = await resp.text().catch(() => '');
                throw new Error("Server: " + resp.status + " " + t);
              }
              const js = await resp.json();
              const answer = js.answer || js.answer_text || js.result || "No answer returned.";
              const evidence = Array.isArray(js.evidence) ? js.evidence : (js.evidence ? [js.evidence] : []);
              pushChatMessage({ who: 'bot', text: answer, evidence });
            } catch (err) {
              pushChatMessage({ who: 'bot', text: "Error: " + err.message, evidence: [] });
              console.error("chat error", err);
            } finally {
              setChatLoading(false);
              setTimeout(() => {
                const el = document.querySelector('.chat-body');
                if (el) el.scrollTop = el.scrollHeight;
              }, 80);
            }
          }

          const QUICK_PROMPTS = [
            "Who is high risk today",
            "Who is low risk today",
            "Show me 320172 last 90 days",
            "Trend details for today — top reasons",
            "Explain repeated_short_breaks"
          ];
          function useQuickPrompt(q) {
            setChatOpen(true);
            sendChat(q);
          }

          // Swipe timeline rendering uses DAY_BOUNDARY_HOUR = 0 to match backend date assignment
          function renderSwipeTimeline(details, modalRow) {
            if (!details || !details.raw_swipes || details.raw_swipes.length === 0) {
              return <div className="muted">No raw swipe evidence available (person not flagged or raw file missing).</div>;
            }

            const all = details.raw_swipes.map(r => {
              const obj = Object.assign({}, r);
              try { obj.__ts = makeLocalDateFromRow(obj); } catch (e) { obj.__ts = null; }

              let gap = null;
              if (obj.SwipeGapSeconds !== undefined && obj.SwipeGapSeconds !== null) {
                gap = Number(obj.SwipeGapSeconds);
                if (isNaN(gap)) gap = null;
              } else if (obj.SwipeGap) {
                try {
                  const parts = String(obj.SwipeGap).split(':').map(p => Number(p));
                  if (parts.length === 3 && parts.every(p => !isNaN(p))) gap = parts[0] * 3600 + parts[1] * 60 + parts[2];
                } catch (e) { gap = null; }
              }
              obj.__gap = gap;
              obj.__zone_l = String((obj.Zone || '')).toLowerCase();

              // Prefer backend-provided date fields (DateOnly) or computed timestamp
              if (obj.__ts) {
                obj.__logical_date = logicalDateForTs(obj.__ts, DAY_BOUNDARY_HOUR);
              } else if (obj.DateOnly) {
                // DateOnly may be a string or object; coerce to YYYY-MM-DD
                obj.__logical_date = String(obj.DateOnly).slice(0, 10);
              } else if (obj.Date) {
                obj.__logical_date = String(obj.Date).slice(0, 10);
              } else {
                obj.__logical_date = null;
              }
              return obj;
            }).sort((a, b) => {
              // Primary sort: parsed timestamp if present
              if (a.__ts && b.__ts) return a.__ts - b.__ts;
              if (a.__ts) return -1;
              if (b.__ts) return 1;
              // Fallback: use DateOnly + Time or Date+Time strings
              const ka = (a.DateOnly || a.Date || '') + ' ' + (a.Time || '');
              const kb = (b.DateOnly || b.Date || '') + ' ' + (b.Time || '');
              return ka.localeCompare(kb);
            });

            // flags: dayStart for first row OR when logical date changes between rows
            const flags = new Array(all.length).fill(null).map(() => ({ dayStart: false, outReturn: false }));
            for (let i = 0; i < all.length; i++) {
              const cur = all[i];
              const prev = all[i - 1];
              const curDate = cur.__logical_date || (cur.DateOnly ? String(cur.DateOnly).slice(0, 10) : (cur.Date ? String(cur.Date).slice(0, 10) : null));
              const prevDate = prev ? (prev.__logical_date || (prev.DateOnly ? String(prev.DateOnly).slice(0, 10) : (prev.Date ? String(prev.Date).slice(0, 10) : null))) : null;
              if (!prev || prevDate !== curDate) {
                flags[i].dayStart = true;
              }
            }

            const OUT_RETURN_GAP_SECONDS = 60 * 60;
            for (let i = 0; i < all.length - 1; i++) {
              const a = all[i], b = all[i + 1];
              const aZone = a.__zone_l || ''; const bZone = b.__zone_l || ''; const bGap = b.__gap || 0;
              if (aZone.includes('out of office') || aZone.includes('out_of_office') || aZone.includes('out of')) {
                if (!bZone.includes('out of office') && (bGap >= OUT_RETURN_GAP_SECONDS || (bGap === null && aZone.includes('out')))) {
                  flags[i].outReturn = true; flags[i + 1].outReturn = true;
                }
              }
            }

            for (let i = 0; i < all.length; i++) {
              if (flags[i].dayStart) {
                all[i].__gap = 0;
              }
            }

            return (
              <div className="table-scroll">
                <table className="evidence-table" role="table" aria-label="Swipe timeline">
                  <thead>
                    <tr>
                      <th>Employee Name</th>
                      <th>Employee ID</th>
                      <th>Card</th>
                      <th>Date</th>
                      <th>Time</th>
                      <th>SwipeGap</th>
                      <th>Door</th>
                      <th>Direction</th>
                      <th>Zone</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    {all.map((rObj, idx) => {
                      const r = rObj || {};
                      const g = (r.__gap !== undefined && r.__gap !== null) ? Number(r.__gap) : null;
                      const isDayStart = flags[idx].dayStart;
                      const gapFormatted = (isDayStart)
                        ? formatSecondsToHmsJS(0)
                        : (
                          (r.SwipeGap && String(r.SwipeGap).trim())
                            ? String(r.SwipeGap)
                            : (g !== null && g !== undefined)
                              ? formatSecondsToHmsJS(g)
                              : "-"
                        );

                      // display date: prefer logical (backend date), then DateOnly, then Date
                      const displayDate = r.__logical_date || (r.DateOnly ? String(r.DateOnly).slice(0, 10) : (r.Date ? String(r.Date).slice(0, 10) : '-'));
                      const displayTime = r.Time || (r.__ts ? r.__ts.toTimeString().slice(0, 8) : '-');

                      const cls = [];
                      if (isDayStart) cls.push('row-day-start');
                      if (flags[idx].outReturn) cls.push('row-out-return');
                      const rowStyle = isDayStart ? { background: '#e6ffed' } : {};
                      let extraNote = "";
                      try {
                        const originalDate = r.Date ? String(r.Date).slice(0, 10) : null;
                        const logical = r.__logical_date || null;
                        if (originalDate && logical && originalDate !== logical) {
                          extraNote = `Orig: ${originalDate}`;
                          if ((String(r.Direction || '').toLowerCase().indexOf('out') !== -1)) {
                            extraNote += " — Out";
                          }
                        }
                      } catch (e) { extraNote = ""; }

                      return (
                        <tr key={idx} className={cls.join(' ')} style={rowStyle}>
                          <td className="small">{r.EmployeeName || '-'}</td>
                          <td className="small">{r.EmployeeID || '-'}</td>
                          <td className="small">{r.CardNumber || r.Card || '-'}</td>
                          <td className="small">{displayDate}</td>
                          <td className="small">{displayTime}</td>
                          <td className="small">{gapFormatted}</td>
                          <td className="small" style={{ minWidth: 160 }}>{r.Door || '-'}</td>
                          <td className="small">{r.Direction || '-'}</td>
                          <td className="small">{r.Zone || '-'}</td>
                          <td className="small">{r.Note || '-'}{r._source ? <span className="muted"> ({r._source})</span> : null}
                            {extraNote ? <div className="muted" style={{ fontSize: 11, marginTop: 4 }}>{extraNote}</div> : null}
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            );
          }

          function handleRiskBarClick(label) {
            if (!label) return;
            if (selectedRiskFilter === label) {
              setSelectedRiskFilter("");
            } else {
              setSelectedRiskFilter(label);
            }
            setPage(1);
          }

          function clearRiskFilter() {
            setSelectedRiskFilter("");
          }


          var rowsCount = (summary && typeof summary.rows === 'number') ? summary.rows : (rows ? rows.length : 0);

          // compute unique flagged persons (dedupe by same key used above)
          var _flaggedKeys = new Set();
          (rows || []).forEach(function (r) {
            if (r && (r.Reasons || r.DetectedScenarios)) {
              var k = r.EmployeeID || r.person_uid || (sanitizeName(r) + '|' + (r.CardNumber || r.Card || ''));
              if (!k) k = JSON.stringify(r);
              _flaggedKeys.add(k);
            }
          });
          var flaggedCount = (summary && typeof summary.flagged_rows === 'number' && summary.flagged_rows > 0) ? summary.flagged_rows : _flaggedKeys.size;

          var flaggedPct = rowsCount ? Math.round((flaggedCount * 100) / (rowsCount || 1)) : 0;



          // helper to get display label for current region
          function regionDisplayLabel(key) {
            if (!key) return '';
            return (REGION_OPTIONS[key] && REGION_OPTIONS[key].label) ? REGION_OPTIONS[key].label : key.toUpperCase();
          }




          return (
            <div className="container" aria-live="polite">
              {loading && (
                <div className="spinner-overlay" role="status" aria-label="Loading">
                  <div className="spinner-box">
                    <div className="spinner" />
                    <div style={{ fontWeight: 700 }}>Loading…</div>
                  </div>
                </div>
              )}

              <div className="topbar" role="banner">
                <div className="wu-brand" aria-hidden={false}>
                  <div className="wu-logo">WU</div>
                  <div className="title-block">
                    <h1>Western Union — Trend Analysis</h1>
                    <p style={{ margin: 0, fontSize: 13 }}>
                      {regionDisplayLabel(selectedRegion)} {selectedLocation && selectedLocation !== "All locations" ? "— " + selectedLocation : ""}
                    </p>
                  </div>
                </div>

                <div className="header-actions" role="region" aria-label="controls">
                  <div className="control">
                    <label className="small" htmlFor="fromDate">From</label>
                    <input id="fromDate" ref={fromRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                  </div>

                  <div className="control">
                    <label className="small" htmlFor="toDate">To</label>
                    <input id="toDate" ref={toRef} className="date-input" type="text" placeholder="YYYY-MM-DD" />
                  </div>

                  <button className="btn-primary" onClick={runForRange} disabled={loading}>Run</button>
                  <button className="btn-ghost" onClick={loadLatest} disabled={loading}>Load latest</button>
                </div>
              </div>

              <div className="card-shell">
                <div className="cards" aria-hidden={loading}>
                  <div className="card" title="Rows analysed">
                    <div className="card-content">
                      <div className="card-text">
                        <h3>{(rowsCount !== undefined && rowsCount !== null) ? rowsCount.toLocaleString() : 0}</h3>
                        <p>Rows analysed</p>
                      </div>
                    </div>
                  </div>
                  <div className="card card-flagged" title="Flagged rows">
                    <div className="card-content">
                      <div className="card-text">
                        <h3>{(flaggedCount !== undefined && flaggedCount !== null) ? flaggedCount.toLocaleString() : 0}</h3>
                        <p>Flagged rows</p>
                      </div>
                    </div>
                  </div>
                  <div className="card card-rate" title="Flagged rate">
                    <div className="card-content">
                      <div className="card-text">
                        <h3>{flaggedPct}%</h3>
                        <p>Flagged rate</p>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="main">
                  <div className="left">
                    <div className="chart-wrap" aria-label="Risk level chart">
                      <canvas ref={chartRef}></canvas>
                    </div>




                    <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginTop: 6 }}>
                      <input placeholder="Search name, employee id, card or reason..." value={filterText} onChange={function (e) { setFilterText(e.target.value); setPage(1); }} style={{ flex: 1, padding: 10, borderRadius: 6, border: '1px solid #e6edf3' }} />

                      <label style={{ display: 'flex', alignItems: 'center', gap: 8, marginRight: 8 }}>
                        <input type="checkbox" checked={collapseDuplicates} onChange={(e) => { setCollapseDuplicates(e.target.checked); setPage(1); }} />
                        <span className="small muted">Collapse duplicates</span>
                      </label>

                      <div className="muted">
                        Showing {collapseDuplicates ? (Array.isArray(aggregatedFiltered) ? aggregatedFiltered.length : filtered.length) : filtered.length} / {rows.length} rows
                      </div>

                      <button className="small-button" onClick={exportFiltered}>Export filtered</button>
                      {selectedRiskFilter ? <button className="small-button" onClick={clearRiskFilter}>Clear risk filter</button> : null}
                    </div>



                    <div style={{ marginTop: 10 }} className="table-scroll" role="region" aria-label="results table">
                      <table>
                        <thead>
                          <tr>
                            <th>Employee</th>
                            <th className="small">ID</th>
                            <th className="small">Card</th>
                            <th className="small">Date</th>
                            <th className="small">Duration</th>
                            <th className="small">{violationDaysLabel || "ViolationDays"}</th>
                            <th className="small">Reasons</th>
                            <th className="small">Evidence</th>
                          </tr>
                        </thead>
                        <tbody>



                          {pageRows.map(function (r, idx) {
                            // if aggregated mode, r will be aggregated object (has ViolationCount and FirstRow/_rows)
                            var isAgg = collapseDuplicates && r && r.ViolationCount !== undefined;
                            var displayRow = isAgg ? r.FirstRow : r; // use FirstRow for details/evidence
                            var empName = isAgg ? (r.EmployeeName || sanitizeName(displayRow)) : sanitizeName(r);
                            var empId = isAgg ? (r.EmployeeID || displayRow.EmployeeID || "") : (r.EmployeeID || "");
                            var card = isAgg ? (r.CardNumber || displayRow.CardNumber || "") : (r.CardNumber || "");
                            var displayDate = safeDateDisplay(displayRow.DisplayDate || displayRow.Date || displayRow.DateOnly || displayRow.FirstSwipe || displayRow.LastSwipe);

                            var durText = (displayRow.Duration)
                              || (displayRow.DurationSeconds ? formatSecondsToHmJS(Number(displayRow.DurationSeconds))
                                : (displayRow.DurationMinutes ? formatSecondsToHmJS(Number(displayRow.DurationMinutes) * 60) : ""));

                            var reasonsText = isAgg ? (r.Reasons || displayRow.Reasons || displayRow.DetectedScenarios) : (r.Reasons || r.DetectedScenarios);

                            return (
                              <tr key={idx} className={(displayRow.Reasons && String(displayRow.Reasons).trim()) ? "flagged-row" : ""}>
                                <td className="row-click" onClick={function () { openEvidence(displayRow); }}>
                                  {empName || <span className="muted">—</span>}
                                  {isAgg ? <div className="small muted" style={{ marginTop: 4 }}>violation Count - {r.ViolationCount}</div> : null}
                                </td>
                                <td className="small">{empId}</td>
                                <td className="small">{card}</td>
                                <td className="small">{displayDate}</td>
                                <td className="small">{isAgg ? (displayRow.Duration || (displayRow.DurationSeconds ? formatSecondsToHmJS(Number(displayRow.DurationSeconds)) : "-")) : durText}</td>

                                <td className="small">
                                  {(() => {
                                    try {
                                      // for aggregated object, prefer aggregated value
                                      if (isAgg && r && r.ViolationDaysLast90 !== undefined && r.ViolationDaysLast90 !== null) {
                                        return String(r.ViolationDaysLast90);
                                      }
                                      const candidates = [
                                        (violationDaysKey ? displayRow[violationDaysKey] : undefined),
                                        displayRow.ViolationDaysLast_90,
                                        displayRow.ViolationDaysLast,
                                        displayRow.ViolationDays
                                      ];
                                      for (let i = 0; i < candidates.length; i++) {
                                        const val = candidates[i];
                                        if (val !== undefined && val !== null && val !== "") return String(val);
                                      }
                                      return "";
                                    } catch (e) {
                                      return "";
                                    }
                                  })()}
                                </td>





                                <td className="small">{renderReasonChips(reasonsText)}</td>
                                <td className="small">
                                  <button className="evidence-btn" onClick={function () { openEvidence(displayRow); }}>Evidence</button>
                                  {isAgg ? <span className="muted" style={{ marginLeft: 8 }}>({r.ViolationCount} rows)</span> : null}
                                </td>
                              </tr>
                            );
                          })}

                        </tbody>
                      </table>
                    </div>

                    <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginTop: 10 }}>
                      <button onClick={function () { setPage(function (p) { return Math.max(1, p - 1); }); }} disabled={page <= 1}>Prev</button>
                      <div className="muted">Page {page} / {totalPages}</div>
                      <button onClick={function () { setPage(function (p) { return Math.min(totalPages, p + 1); }); }} disabled={page >= totalPages}>Next</button>
                    </div>
                  </div>

                  <aside className="right" aria-label="side panel">

                    {/* NEW: Region & Location controls */}
                    <div className="sidebar-section" style={{ marginBottom: 12 }}>
                      <strong>Risk filters</strong>
                      <div className="small muted" style={{ marginTop: 6 }}>Select Region and Location to scope the run.</div>

                      <div style={{ display: 'flex', gap: 8, marginTop: 8, alignItems: 'center' }}>
                        <div style={{ flex: 1 }}>
                          <label className="small">Region</label>
                          <select
                            value={selectedRegion}
                            onChange={(e) => { setSelectedRegion(e.target.value); setPage(1); }}
                            style={{ width: '100%', padding: '6px 8px', borderRadius: 6, border: '1px solid #e2e8f0' }}
                          >
                            {Object.keys(REGION_OPTIONS).map(k => (
                              <option key={k} value={k}>{REGION_OPTIONS[k].label}</option>
                            ))}
                          </select>
                        </div>

                        <div style={{ flex: 1 }}>
                          <label className="small">Location</label>
                          <select
                            value={selectedLocation}
                            onChange={(e) => { setSelectedLocation(e.target.value); setPage(1); }}
                            style={{ width: '100%', padding: '6px 8px', borderRadius: 6, border: '1px solid #e2e8f0' }}
                          >
                            <option key="__all" value="All locations">All locations</option>
                            {(REGION_OPTIONS[selectedRegion] && REGION_OPTIONS[selectedRegion].partitions || []).map(loc => (
                              <option key={loc} value={loc}>{loc}</option>
                            ))}
                          </select>
                        </div>


                        {/* NEW: Employee ID input placed next to Region & Location */}

                        <div style={{ flex: 1 }}>
                          <label className="small">Employee ID </label>
                          <input
                            value={employeeId}
                            onChange={(e) => { setEmployeeId(e.target.value); setPage(1); }}
                            placeholder="Enter Employee ID e.g. 326131"
                            style={{ width: '100%', padding: '6px 8px', borderRadius: 6, border: '1px solid #e2e8f0' }}
                          />
                        </div>
                      </div>
                    </div>



                    {/* existing risk chips */}
                    <div className="sidebar-section">
                      <div className="risk-filter-list" style={{ marginTop: 8 }}>
                        {RISK_LABELS.map((lab) => {
                          const cnt = (riskCounts && riskCounts[lab]) ? riskCounts[lab] : 0;
                          const active = selectedRiskFilter === lab;
                          return (
                            <div key={lab} role="button" tabIndex={0} aria-pressed={active} className={"risk-chip " + (active ? "active" : "")} onClick={function () { handleRiskBarClick(lab); }} onKeyDown={function (e) { if (e.key === 'Enter' || e.key === ' ') { handleRiskBarClick(lab); } }}>
                              <div style={{ width: 10, height: 10, borderRadius: 999, background: RISK_COLORS[lab], boxShadow: '0 2px 6px rgba(0,0,0,0.08)' }}></div>
                              <div style={{ fontSize: 13 }}>{lab} <span className="muted" style={{ marginLeft: 6 }}>({cnt})</span></div>
                            </div>
                          );
                        })}
                      </div>

                      <div style={{ marginTop: 8 }}>
                        <button className="small-button" onClick={clearRiskFilter}>Clear risk filter</button>
                      </div>
                    </div>


                    <div className="sidebar-section" style={{ marginTop: 12 }}>
                      <strong>Top reasons summary</strong>
                      <div className="small muted" style={{ marginTop: 6 }}>Click a reason to filter the table by that reason. Click again to clear.</div>

                      <div style={{ marginTop: 8, display: 'flex', gap: 8 }}>
                        <input placeholder="Filter reason list..." value={reasonFilterText} onChange={function (e) { setReasonFilterText(e.target.value); }} style={{ flex: 1, padding: '6px 8px', borderRadius: 6, border: '1px solid #e2e8f0' }} />
                        <button className="small-button" onClick={function () { setSelectedReason(''); setReasonFilterText(''); }}>Clear</button>
                      </div>

                      <div style={{ marginTop: 8, maxHeight: 320, overflow: 'auto' }}>
                        {Object.keys(reasonsCount).length === 0 && <div className="muted">No flags found</div>}
                        {Object.entries(reasonsCount).sort(function (a, b) { return b[1] - a[1]; }).filter(function (kv) {
                          var name = kv[0];
                          if (!reasonFilterText) return true;
                          return name.toLowerCase().indexOf(reasonFilterText.toLowerCase()) !== -1;
                        }).slice(0, 50).map(function (kv) {
                          var name = kv[0], count = kv[1];
                          var active = selectedReason === name;
                          return (
                            <div key={name} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 8, marginBottom: 6 }}>
                              <button className={"chip " + (active ? "active" : "")} style={{ textAlign: 'left', flex: 1 }} onClick={function () { onReasonClick(name); }}>
                                {name}
                              </button>
                              <div style={{ minWidth: 48, textAlign: 'right' }} className="small"><b>{count}</b></div>
                            </div>
                          );
                        })}

                      </div>
                    </div>
                  </aside>
                </div>
              </div>




              {modalRow &&
                <div className="modal" onClick={closeModal}>
                  <div className="modal-inner" onClick={function (e) { e.stopPropagation(); }}>
                    <div className="modal-header">
                      <div className="header-content">
                        <div className="header-icon">
                          <i className="bi bi-clipboard2-data-fill"></i>
                        </div>
                        <div className="header-text">
                          <h3>Details — Evidence</h3>
                          <div className="header-subtitle small">Evidence & explanation for selected row</div>
                        </div>
                      </div>
                      <button className="close-btn" onClick={closeModal}>
                        <i className="bi bi-x-lg"></i>
                        Close
                      </button>
                    </div>
                    <div className="modal-body">
                      {modalLoading && (
                        <div className="loading-state">
                          <div className="loading-spinner"></div>
                          <span>Loading evidence…</span>
                        </div>
                      )}
                      <div className="modal-top" role="region" aria-label="evidence summary">
                        <div className="image-section">
                          <div className="image-container">
                            <div className="multi-color-border">
                              <div className="color-ring color-1"></div>
                              <div className="color-ring color-2"></div>
                              <div className="color-ring color-3"></div>
                              <div className="color-ring color-4"></div>
                              <div className="image-content">







                                {/* Improved modal image block — prefer ObjectID/GUID and try more fallbacks */}

                                {(modalDetails && ((modalDetails.aggregated_rows && modalDetails.aggregated_rows.length > 0) || (modalDetails.raw_swipes && modalDetails.raw_swipes.length > 0))) ? (

                                  (() => {
                                    // helper: candidate image key names (same as before)
                                    const candidateImageKeys = ['imageUrl', 'image_url', 'ImageUrl', 'image', 'Image', 'img', 'imgUrl', 'ImagePath', 'Photo', 'PhotoUrl', 'EmployeePhoto', 'photo', 'photoUrl'];

                                    // pick first md (aggregated/raw) row if exists
                                    const md = (modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0])
                                      || (modalDetails && modalDetails.raw_swipes && modalDetails.raw_swipes[0])
                                      || {};

                                    // try to obtain an explicit image path from md first
                                    let imgPath = candidateImageKeys.map(k => (md && md[k]) ? md[k] : null).find(Boolean) || null;

                                    // if not present yet, use any image_url included in full record response (js.image_url -> set below in openEvidence)
                                    if (!imgPath && modalRow && modalRow.ImageUrl) {
                                      imgPath = modalRow.ImageUrl;
                                    }

                                    // Build ordered id candidates preferring modalRow
                                    const idCandidates = [];
                                    if (modalRow && modalRow.EmployeeID) idCandidates.push(String(modalRow.EmployeeID));
                                    if (modalRow && modalRow.person_uid) idCandidates.push(String(modalRow.person_uid));
                                    if (md && md.EmployeeID) idCandidates.push(String(md.EmployeeID));
                                    if (md && md.person_uid) idCandidates.push(String(md.person_uid));
                                    if (md && md.ObjectID) idCandidates.push(String(md.ObjectID));
                                    if (md && md.GUID) idCandidates.push(String(md.GUID));

                                    const uniqIds = idCandidates.filter((v, i) => v && idCandidates.indexOf(v) === i);

                                    // If still no explicit path, build a likely image endpoint from the top id candidate
                                    if (!imgPath && uniqIds.length) {
                                      imgPath = `/employee/${encodeURIComponent(uniqIds[0])}/image`;
                                    }

                                    if (imgPath) {
                                      const imgSrc = resolveApiImageUrl(imgPath) || imgPath;
                                      return (
                                        <img
                                          className="modal-image"
                                          src={imgSrc}
                                          alt={sanitizeName(modalRow) || "Employee image"}
                                          onLoad={(e) => { try { console.info("employee image loaded:", e.target.src); } catch (e) { } }}
                                          onError={async (e) => {
                                            try {
                                              e.target.onerror = null;
                                              console.warn("image load failed for:", e.target.src);

                                              // cache-busted retry + API variants for all uniqIds
                                              const tryUrls = [];
                                              const original = e.target.src;
                                              tryUrls.push(original + (original.indexOf('?') === -1 ? '?cb=' + Date.now() : '&cb=' + Date.now()));
                                              uniqIds.forEach(id => {
                                                if (!id) return;
                                                const a = resolveApiImageUrl(`/api/employees/${encodeURIComponent(id)}/image`);
                                                const b = resolveApiImageUrl(`/employee/${encodeURIComponent(id)}/image`);
                                                if (a && tryUrls.indexOf(a) === -1) tryUrls.push(a);
                                                if (b && tryUrls.indexOf(b) === -1) tryUrls.push(b);
                                              });

                                              let found = null;
                                              for (const url of tryUrls) {
                                                try {
                                                  const getr = await fetch(url, { method: 'GET', cache: 'no-store' });
                                                  if (getr && getr.ok) {
                                                    const ct = (getr.headers.get('content-type') || '').toLowerCase();
                                                    if (ct.startsWith('image')) { found = url; break; }
                                                  }
                                                } catch (err) { /* ignore */ }
                                              }

                                              if (found) {
                                                e.target.src = found + (found.indexOf('?') === -1 ? ('?cb=' + Date.now()) : ('&cb=' + Date.now()));
                                                return;
                                              }

                                              // final fallback SVG
                                              const svg = '<svg xmlns="http://www.w3.org/2000/svg" width="160" height="160"><rect fill="#eef2f7" width="100%" height="100%"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#64748b" font-size="18">No image</text></svg>';
                                              e.target.src = 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
                                            } catch (err) {
                                              try { e.target.style.display = 'none'; } catch (err2) { }
                                              console.error("image fallback error", err);
                                            }
                                          }}
                                        />
                                      );
                                    } else {
                                      // no id/path available -> simple placeholder (unchanged)
                                      return (
                                        <div className="modal-image-placeholder">
                                          <i className="bi bi-person-square"></i>
                                          <span>No image</span>
                                        </div>
                                      );
                                    }
                                  })()

                                ) : (
                                  <div className="modal-image-placeholder">
                                    <i className="bi bi-person-square"></i>
                                    <span>No image</span>
                                  </div>

                                )}

                              </div>
                            </div>
                          </div>
                        </div>

                        <div className="modal-details">
                          <div className="details-header">
                            <div className="emp-info">
                              <div className="emp-name">
                                {sanitizeName(modalRow) || "—"}
                                <span
                                  className="risk-badge"
                                  style={{
                                    marginLeft: "12px",
                                    background:
                                      RISK_COLORS[modalRow.RiskLevel] ||
                                      RISK_COLORS[getRiskLabelForRow(modalRow)] ||
                                      RISK_COLORS["Low"],
                                  }}
                                >
                                  {modalRow.RiskLevel ||
                                    (modalRow.RiskScore ? "Score " + modalRow.RiskScore : "Low")}
                                </span>
                              </div>
                              <div className="emp-badge">
                                <i className="bi bi-person-badge"></i>
                                ID: {modalRow.EmployeeID || "—"}
                              </div>
                            </div>
                          </div>
                          <div className="details-grid">
                            <div className="detail-item">
                              <div className="detail-icon">
                                <i className="bi bi-credit-card"></i>
                              </div>
                              <div className="detail-content">
                                <label>Card Number</label>
                                <span>{modalRow.CardNumber || "—"}</span>
                              </div>
                            </div>
                            <div className="detail-item">
                              <div className="detail-icon">
                                <i className="bi bi-envelope"></i>
                              </div>
                              <div className="detail-content">
                                <label>EmployeeEmail</label>

                                <span>
                                  {(
                                    // prefer aggregated_rows[0], then raw_swipes[0], then modalRow
                                    (modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0] && (modalDetails.aggregated_rows[0].EmployeeEmail || modalDetails.aggregated_rows[0].Email))
                                    || (modalDetails && modalDetails.raw_swipes && modalDetails.raw_swipes[0] && (modalDetails.raw_swipes[0].EmployeeEmail || modalDetails.raw_swipes[0].Email))
                                    || modalRow.EmployeeEmail
                                    || modalRow.Email
                                    || (modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0] && (modalDetails.aggregated_rows[0].WorkEmail || modalDetails.aggregated_rows[0].EMail))
                                  ) ? (
                                    (modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0] && (modalDetails.aggregated_rows[0].EmployeeEmail || modalDetails.aggregated_rows[0].Email))
                                    || (modalDetails && modalDetails.raw_swipes && modalDetails.raw_swipes[0] && (modalDetails.raw_swipes[0].EmployeeEmail || modalDetails.raw_swipes[0].Email))
                                    || modalRow.EmployeeEmail
                                    || modalRow.Email
                                    || (modalDetails && modalDetails.aggregated_rows && modalDetails.aggregated_rows[0] && (modalDetails.aggregated_rows[0].WorkEmail || modalDetails.aggregated_rows[0].EMail))
                                  ) : <span className="muted">—</span>}
                                </span>





                              </div>
                            </div>
                            <div className="detail-item">
                              <div className="detail-icon">
                                <i className="bi bi-calendar-date"></i>
                              </div>
                              <div className="detail-content">
                                <label>Date</label>
                                <span>{safeDateDisplay(modalRow.DisplayDate || modalRow.Date || modalRow.DateOnly || modalRow.FirstSwipe)}</span>
                              </div>
                            </div>
                            <div className="detail-item">
                              <div className="detail-icon">
                                <i className="bi bi-clock"></i>
                              </div>
                              <div className="detail-content">
                                <label>Duration</label>

                                <span className="duration-badge">
                                  {modalRow.Duration
                                    || (modalRow.DurationSeconds ? formatSecondsToHmJS(Number(modalRow.DurationSeconds))
                                      : (modalRow.DurationMinutes ? formatSecondsToHmJS(Number(modalRow.DurationMinutes) * 60) : "—"))}
                                </span>


                              </div>
                              <div style={{ marginTop: 8, textAlign: 'right' }}>
                                <div className="muted">Violation days</div>
                                <div style={{ fontWeight: 700 }}>




                                  {(() => {
                                    try {
                                      const candidates = [
                                        (violationDaysKey ? modalRow && modalRow[violationDaysKey] : undefined),
                                        modalRow && modalRow.ViolationDaysLast_90,
                                        modalRow && modalRow.ViolationDaysLast,
                                        modalRow && modalRow.ViolationDays
                                      ];
                                      for (let i = 0; i < candidates.length; i++) {
                                        const v = candidates[i];
                                        if (v !== undefined && v !== null && v !== "") return v;
                                      }
                                      return 0;
                                    } catch (e) { return 0; }
                                  })()}



                                </div>
                              </div>
                            </div>
                          </div>
                        </div>

                        <div className="modal-reasons">
                          <div className="explanation-section" style={{ marginTop: 12 }}>
                            <div style={{ fontWeight: 700 }}>Explanation</div>
                            <div style={{
                              marginTop: 8,
                              maxHeight: 160,
                              overflow: 'auto',
                              background: '#fff',
                              border: '1px solid #eef2f7',
                              padding: 8,
                              borderRadius: 6
                            }}>
                              {(modalRow.Explanation || modalRow.ViolationExplanation)
                                ? <div style={{ whiteSpace: 'pre-wrap' }}>{modalRow.Explanation || modalRow.ViolationExplanation}</div>
                                : <div className="muted">No explanation provided.</div>}

                            </div>
                          </div>
                          <div className="reasons-section">
                            <div className="section-title">
                              <i className="bi bi-list-check"></i>
                              Reasons Flagged
                            </div>
                            <div className="reasons-list">
                              {renderReasonChips(modalRow.Reasons || modalRow.DetectedScenarios)}
                            </div>
                          </div>
                        </div>
                      </div>

                      <div className="evidence-section">
                        <div className="section-header">
                          <i className="bi bi-folder2-open"></i>
                          <h4>Available Evidence Files</h4>
                        </div>
                        <div className="files-container">
                          {modalDetails && modalDetails.raw_swipe_files && modalDetails.raw_swipe_files.length > 0 ? (
                            <div className="files-list">
                              {modalDetails.raw_swipe_files.map((f, i) => (
                                <div key={i} className="file-item">
                                  <i className="bi bi-file-earmark-text"></i>
                                  <span className="file-name">{f}</span>
                                  <button
                                    className="download-btn"
                                    onClick={function () { window.location = API_BASE + "/swipes/" + encodeURIComponent(f); }}
                                  >
                                    <i className="bi bi-download"></i>
                                    Download
                                  </button>
                                </div>
                              ))}
                            </div>
                          ) : (
                            <div className="no-files">
                              <i className="bi bi-folder-x"></i>
                              <span>No raw swipe files found for this person/date.</span>
                            </div>
                          )}
                        </div>
                      </div>

                      <div className="timeline-section">
                        <div className="section-header">
                          <i className="bi bi-clock-history"></i>
                          <h4>Swipe Timeline</h4>
                          <span className="subtitle">Filtered for this person/date</span>
                        </div>
                        <div className="timeline-content">
                          {modalDetails ? renderSwipeTimeline(modalDetails, modalRow) : (
                            <div className="loading-timeline">
                              <i className="bi bi-hourglass-split"></i>
                              <span>Evidence not loaded yet.</span>
                            </div>
                          )}
                        </div>
                      </div>

                      <div className="raw-json-section">
                        <label className="toggle-label">
                          <input
                            type="checkbox"
                            id="showraw"
                            onChange={function (e) {
                              const el = document.getElementById('rawpayload');
                              if (el) el.style.display = e.target.checked ? 'block' : 'none';
                            }}
                          />
                          <span className="toggle-slider"></span>
                          <span className="toggle-text">
                            <i className="bi bi-code-slash"></i>
                            Show raw aggregated JSON
                          </span>
                        </label>
                        <div id="rawpayload" className="raw-json" style={{ display: 'none' }}>
                          <pre>{JSON.stringify(modalRow, null, 2)}</pre>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              }

              <button className="chat-fab" title="Ask Trend Details (Ask Me )" onClick={() => setChatOpen(true)} aria-label="Open chat">
                <span className="meta-icon"><img src="chat-bot.png" alt="" /></span>
              </button>


              {chatOpen && (
                <div className="chat-modal" role="dialog" aria-modal="true" aria-label="Trend Chatbot">
                  <div className="chat-header">
                    <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                      <div style={{ width: 36, height: 36, borderRadius: 8, background: '#', display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#2563eb', fontWeight: 800 }}><img src="chat-bot.png" alt="" style={{ width: 36, height: 36, }} /></div>
                      <div>
                        <div className="title">Ask me — Trend Details</div>
                        <div style={{ fontSize: 12, opacity: 0.85 }}>Ask trend & risk questions</div>
                      </div>
                    </div>
                    <div style={{ marginLeft: 'auto' }}>
                      <button className="small-button bot-close" onClick={() => { setChatOpen(false); }}>Close</button>
                    </div>
                  </div>

                  <div className="chat-body">
                    {chatMessages.length === 0 && (
                      <div style={{ color: '#64748b', fontSize: 13 }}>
                        Hi — ask about trends (e.g. "Who is high risk today"). Use the quick prompts below.
                      </div>
                    )}
                    {chatMessages.map((m, i) => (
                      <div key={i} style={{ display: 'block' }}>
                        <div className={"chat-bubble " + (m.who === 'user' ? 'user' : 'bot')}>
                          {m.text}
                          {m.who === 'bot' && m.evidence && m.evidence.length > 0 && (
                            <div className="chat-evidence">
                              <strong>Evidence</strong>
                              <div style={{ marginTop: 6 }}>{m.evidence.slice(0, 5).map((e, j) => (<div key={j}>{typeof e === 'string' ? e : JSON.stringify(e)}</div>))}</div>
                            </div>
                          )}
                        </div>
                      </div>
                    ))}

                    {chatLoading && <div className="chat-loading" style={{ marginTop: 6 }}>Thinking…</div>}
                    <div style={{ marginTop: 8 }} className="quick-prompts" aria-hidden={chatLoading}>
                      {QUICK_PROMPTS.map((q, idx) => (
                        <button key={idx} onClick={() => useQuickPrompt(q)} disabled={chatLoading}>{q}</button>
                      ))}
                    </div>
                  </div>

                  <div className="chat-input-row">
                    <input
                      className="chat-input"
                      placeholder="Type a question, e.g. 'Who is high risk today'…"
                      value={chatInput}
                      onChange={(e) => setChatInput(e.target.value)}
                      onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChat(chatInput); } }}
                    />
                    <button className="chat-send-btn" onClick={() => sendChat(chatInput)} disabled={chatLoading}>Send</button>
                  </div>
                </div>
              )}

            </div>
          );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
      }) ();
  </script>
</body>

</html>
