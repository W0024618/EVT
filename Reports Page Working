Now Check below Both file line by line nd update Report service .js file carefully ..update database name 
i want dont mentioned Database name in Query when database is update i can easily update from single file whichb is db Config .js so remove database name from 
Query carefully
and share me fully ipdated file so i can easily swap file each othed 



// backend/config/dbConfig.js
import sql from 'mssql';

// shared options
const commonOpts = {
  options: {
    encrypt: true,
    trustServerCertificate: true
  },
  requestTimeout: 300000,
  connectionTimeout: 30000,
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  }
};

// NOTE:
// - All regions now point to the requested current DB (ACVSUJournal_00010022),
//   server SRVWUDEN0890V and password Westernuniongsoc@2025.
// - The existing parseDbWithNumericSuffix/getRegionDbNames logic remains and will
//   derive prior numeric-suffixed DB names automatically (last-n) based on the
//   numeric suffix of the configured database name.

const regions = {
  apac: {
    user: 'GSOC_Test',
    password: 'Westernuniongsoc@2025',
    server: 'SRVWUDEN0890V',
    database: 'ACVSUJournal_00010022',
    ...commonOpts
  },
  emea: {
    user: 'GSOC_Test',
    password: 'Westernuniongsoc@2025',
    server: 'SRVWUDEN0890V',
    database: 'ACVSUJournal_00010022',
    ...commonOpts
  },
  laca: {
    user: 'GSOC_Test',
    password: 'Westernuniongsoc@2025',
    server: 'SRVWUDEN0890V',
    database: 'ACVSUJournal_00010022',
    ...commonOpts
  },
  namer: {
    user: 'GSOC_Test',
    password: 'Westernuniongsoc@2025',
    server: 'SRVWUDEN0890V',
    database: 'ACVSUJournal_00010022',
    ...commonOpts
  }
};

// cache of connected pools by key: `${regionKey}_${database}`
const pools = {};

/**
 * Parse DB name for trailing numeric suffix: "<base>_<digits>"
 */
function parseDbWithNumericSuffix(dbName) {
  if (!dbName || typeof dbName !== 'string') return null;
  const m = dbName.match(/^(.*?_)(\d+)$/);
  if (!m) return null;
  const base = m[1];
  const numStr = m[2];
  const num = parseInt(numStr, 10);
  return { base, num, width: numStr.length };
}

function buildDbName(parsed, targetNum) {
  const padded = String(targetNum).padStart(parsed.width, '0');
  return `${parsed.base}${padded}`;
}

/**
 * Create/return (cached) a connected pool for the supplied region config object,
 * overriding the database name if overrideDatabase is provided.
 */
async function ensurePoolForDatabase(regionKey, cfg, overrideDatabase) {
  const dbName = overrideDatabase || cfg.database;
  const cacheKey = `${regionKey}_${dbName}`;
  if (pools[cacheKey]) {
    try {
      // if pool exists but marked disconnected, attempt reconnect
      if (pools[cacheKey]._connected === false) {
        pools[cacheKey] = await new sql.ConnectionPool({ ...cfg, database: dbName }).connect();
      }
      return pools[cacheKey];
    } catch (e) {
      delete pools[cacheKey];
    }
  }

  const poolCfg = { ...cfg, database: dbName };
  const pool = await new sql.ConnectionPool(poolCfg).connect();
  pools[cacheKey] = pool;
  return pool;
}

/**
 * Backwards-compatible: return pool for configured (primary) DB for regionKey.
 */
export async function getPool(regionKey) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) throw new Error(`Unknown region: ${regionKey}`);
  return ensurePoolForDatabase(key, cfg, cfg.database);
}

/**
 * Return list of candidate DB NAMES for a region (primary, primary-1, ..., up to maxBackups)
 * This function does NOT create connections; it's cheap and deterministic.
 *
 * @param {string} regionKey
 * @param {number} maxBackups  how many previous DBs to include (default 4)
 * @returns {string[]} array of database names (primary first)
 */
export function getRegionDbNames(regionKey, maxBackups = 4) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) throw new Error(`Unknown region: ${regionKey}`);

  const parsed = parseDbWithNumericSuffix(cfg.database);
  if (!parsed) {
    return [cfg.database];
  }

  const nums = [];
  for (let i = 0; i <= maxBackups; i++) {
    const n = parsed.num - i;
    if (n > 0) nums.push(n);
  }
  const dbNames = nums.map(n => buildDbName(parsed, n));
  return dbNames;
}

/**
 * Connect (sequentially) to the given dbNames for the region and return the pools.
 * This connects only to the requested dbNames and caches them.
 *
 * @param {string} regionKey
 * @param {string[]} dbNames
 * @returns {Promise<sql.ConnectionPool[]>}
 */
export async function getPoolsForDbNames(regionKey, dbNames = []) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) throw new Error(`Unknown region: ${regionKey}`);

  const createdPools = [];
  for (const db of dbNames) {
    try {
      const p = await ensurePoolForDatabase(key, cfg, db);
      createdPools.push(p);
    } catch (err) {
      // compact log only
      // eslint-disable-next-line no-console
      console.warn(`Failed to connect to ${db} for region ${key}:`, err && err.message ? err.message : String(err));
    }
  }

  // If nothing connected, fallback to primary configured DB (ensured)
  if (createdPools.length === 0) {
    const primary = await ensurePoolForDatabase(key, cfg, cfg.database);
    return [primary];
  }
  return createdPools;
}

/**
 * Old function signature: returns pools for primary + previous 4 (but does NOT eagerly connect them).
 * For backwards compatibility - we connect only to primary and return [primary] (to avoid accidental heavy connects).
 * If caller actually needs multiple pools they should call getRegionDbNames + getPoolsForDbNames to control which DBs to open.
 */
export async function getRegionPools(regionKey) {
  // For safety and backwards compatibility we only return primary pool here.
  // New code should use getRegionDbNames + getPoolsForDbNames to control which DBs to open.
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) throw new Error(`Unknown region: ${regionKey}`);
  const primary = await ensurePoolForDatabase(key, cfg, cfg.database);
  return [primary];
}

/**
 * Convenience: returns the first available pool among primary db (backwards-compatible).
 */
export async function getAnyPool(regionKey) {
  const arr = await getRegionPools(regionKey);
  if (arr && arr.length) return arr[0];
  return getPool(regionKey);
}

export { sql, regions };







// backend/services/reportService.js
import { getPool, getRegionDbNames, getPoolsForDbNames, sql, regions } from '../config/dbConfig.js';

/**
 * Small helper to retrieve a human DB name for a pool
 */
function safePoolDbName(pool) {
  try {
    if (!pool) return 'unknown';
    return (pool.config && pool.config.database) ? pool.config.database : 'unknown';
  } catch (e) {
    return 'unknown';
  }
}

/**
 * Query strategy:
 * - For small ranges (<= 31 days) we try primary DB first; if it returns any rows we use that (fast path).
 *   If primary returns nothing we check previous DBs one-by-one until we find rows.
 * - For larger ranges (> 31 days) we query up to `maxBackups+1` DBs sequentially, collecting rows from each.
 *
 * buildReq(req) => returns query string and is expected to bind inputs to req before returning the SQL.
 *
 * This function deliberately queries pools sequentially (not Promise.all) to avoid connection explosion.
 */
async function queryAcrossRegionPoolsSmart(region, buildReq, { startDate = null, endDate = null, maxBackups = 4 } = {}) {
  if (!region) throw new Error('region required');

  // compute candidate DB names (primary, primary-1, ...)
  const dbNames = getRegionDbNames(region, maxBackups);

  // decide mode based on date range length
  let mode = 'small'; // default fast-path mode
  if (startDate && endDate) {
    const s = new Date(startDate);
    const e = new Date(endDate);
    const days = Math.ceil((e - s) / (1000 * 60 * 60 * 24));
    if (days > 31) mode = 'large';
  }

  const allRows = [];

  // For small ranges: try primary first and accept fast if it returns any rows.
  if (mode === 'small') {
    // Try primary DB only first (fast)
    const primaryName = dbNames[0];
    try {
      const pools = await getPoolsForDbNames(region, [primaryName]);
      const pool = pools && pools[0];
      if (pool) {
        try {
          const req = pool.request();
          req.timeout = 300000;
          const q = buildReq(req);
          const res = await req.query(q);
          const rows = (res && res.recordset) ? res.recordset : [];
          if (rows && rows.length) {
            // got results from primary -> fast return
            allRows.push(...rows);
            return allRows;
          }
          // else fall through to check previous DBs sequentially
        } catch (err) {
          // log compactly and continue to previous DBs
          // eslint-disable-next-line no-console
          console.warn(`Query failed on pool (db=${primaryName}) for region ${region}:`, err && err.message ? err.message : String(err));
        }
      }
    } catch (err) {
      // eslint-disable-next-line no-console
      console.warn('primary pool connection failed:', err && err.message ? err.message : String(err));
    }

    // Primary had no rows or failed -> check previous DBs one-by-one until first successful set
    for (let i = 1; i < dbNames.length; i++) {
      const dbn = dbNames[i];
      try {
        const pools = await getPoolsForDbNames(region, [dbn]);
        const pool = pools && pools[0];
        if (!pool) continue;
        const req = pool.request();
        req.timeout = 300000;
        const q = buildReq(req);
        const res = await req.query(q);
        const rows = (res && res.recordset) ? res.recordset : [];
        if (rows && rows.length) {
          allRows.push(...rows);
          // stop at first DB with rows (fast)
          break;
        }
      } catch (err) {
        // eslint-disable-next-line no-console
        console.warn(`Query failed on pool (db=${dbn}) for region ${region}:`, err && err.message ? err.message : String(err));
      }
    }

    return allRows;
  }

  // For large ranges: query up to maxBackups+1 DBs sequentially and aggregate results
  for (let i = 0; i < dbNames.length; i++) {
    const dbn = dbNames[i];
    try {
      const pools = await getPoolsForDbNames(region, [dbn]);
      const pool = pools && pools[0];
      if (!pool) continue;
      const req = pool.request();
      req.timeout = 300000;
      const q = buildReq(req);
      const res = await req.query(q);
      const rows = (res && res.recordset) ? res.recordset : [];
      if (rows && rows.length) {
        allRows.push(...rows);
      }
    } catch (err) {
      // eslint-disable-next-line no-console
      console.warn(`Query failed on pool (db=${dbn}) for region ${region}:`, err && err.message ? err.message : String(err));
    }
  }

  return allRows;
}

// ------------------------- light-weight functions -------------------------

export async function listLocations(region) {
  if (!region) throw new Error('region required');
  const pool = await getPool(region);
  const req = pool.request();
  const q = `SELECT DISTINCT PartitionName2 FROM ACVSUJournalLog WHERE PartitionName2 IS NOT NULL ORDER BY PartitionName2`;
  const { recordset } = await req.query(q);
  return (recordset || []).map(r => r.PartitionName2).filter(Boolean);
}

export async function searchEmployees(region = 'emea', q = '') {
  const pool = await getPool(region);
  const req = pool.request();
  const like = `%${q}%`;
  req.input('q', sql.NVarChar(200), like);

  const query = `
    SELECT TOP (200)
      CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR(50)) END AS EmployeeID,
      ISNULL(t2.Text1, '') AS Name
    FROM ACVSCore.Access.Personnel AS t2
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId = t3.ObjectID
    WHERE (t2.Text1 LIKE @q) OR (CAST(t2.Int1 AS NVARCHAR(50)) LIKE @q) OR (t2.Text12 LIKE @q)
    ORDER BY t2.Text1;
  `;
  const { recordset } = await req.query(query);
  return (recordset || []).map(r => ({ EmployeeID: r.EmployeeID, Name: r.Name }));
}

// ------------------------- rawReport (smart) -------------------------

export async function rawReport(region, { startDate, endDate, location, admitFilter = 'all' }) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;
  const admitFilterParam = String(admitFilter || 'all');

  const buildReq = (req) => {
    req.input('location', sql.NVarChar(200), locationParam);
    req.input('startDate', sql.Date, startDate);
    req.input('endDate', sql.Date, endDate);
    req.input('admitFilter', sql.NVarChar(20), admitFilterParam);

    const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    AND (
      UPPER(ISNULL(@admitFilter,'all')) = 'ALL'
      OR (UPPER(@admitFilter) = 'ADMIT'  AND t1.MessageType = 'CardAdmitted')
      OR (UPPER(@admitFilter) = 'REJECT' AND t1.MessageType = 'CardRejected')
    )
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM CombinedQuery
ORDER BY LocaleMessageTime ASC;
`;
    return query;
  };

  // smart query: if small range prefer fast path
  const rows = await queryAcrossRegionPoolsSmart(region, buildReq, { startDate, endDate, maxBackups: 4 });
  // ensure global ordering
  rows.sort((a, b) => {
    const ta = new Date(a.LocaleMessageTime || a.DateOnly || 0).getTime();
    const tb = new Date(b.LocaleMessageTime || b.DateOnly || 0).getTime();
    return ta - tb;
  });
  return rows;
}

// ------------------------- rejectionReport (smart) -------------------------

export async function rejectionReport(region, { startDate, endDate, location } = {}) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;

  const buildReq = (req) => {
    req.input('location', sql.NVarChar(200), locationParam);
    req.input('startDate', sql.Date, startDate);
    req.input('endDate', sql.Date, endDate);

    const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType = 'CardRejected'
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
),
Unified AS (
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Lost'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Clearance'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type IN ('CardDisabled','Disabled')
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Stolen'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Expired'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'PIN'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'UnknownCard'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'SiteCode'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'NotActivated'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'FacilityCode'
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM Unified
ORDER BY LocaleMessageTime DESC;
`;
    return query;
  };

  const rows = await queryAcrossRegionPoolsSmart(region, buildReq, { startDate, endDate, maxBackups: 4 });
  rows.sort((a, b) => {
    const ta = new Date(a.LocaleMessageTime || a.DateOnly || 0).getTime();
    const tb = new Date(b.LocaleMessageTime || b.DateOnly || 0).getTime();
    return tb - ta;
  });
  return rows;
}

// ------------------------- dailyAccessReportEMEA (smart per-DB) -------------------------

export async function dailyAccessReportEMEA({ from, to, employees = '' }) {
  const region = 'emea';
  const employeesParam = (employees && String(employees).trim()) ? String(employees).trim() : null;
  const startDate = from;
  const endDate = to;

  const buildReq = (req) => {
    req.input('fromDate', sql.Date, startDate);
    req.input('toDate', sql.Date, endDate);
    req.input('employees', sql.NVarChar(sql.MAX), employeesParam);

    const query = `

  -- expects parameters: @fromDate (DATE), @toDate (DATE), @employees (NVARCHAR(MAX) | NULL)
DECLARE @empCSV NVARCHAR(MAX) = @employees;

;WITH EmpList AS (
  SELECT LTRIM(RTRIM(value)) AS emp
  FROM STRING_SPLIT(ISNULL(@empCSV,''), ',')
  WHERE LTRIM(RTRIM(value)) <> ''
)

-- Raw rows: compute LocaleMessageTime once and use OUTER APPLY to avoid duplicate shreddes
, RawSwipes AS (
  SELECT
    t1.ObjectName1,
    t1.ObjectName2,
    t1.MessageType,
    t2.Text12       AS EmployeeID,
    CAST(t2.Int1 AS NVARCHAR(50)) AS NumericEmployeeID,
    t3.Name         AS PersonnelType,
    t1.PartitionName2 AS PartitionName2,

    -- compute local wall-clock once (DO NOT change sign here; using your -1 * MessageLocaleOffset)
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,

    -- direction/value picked by OUTER APPLY (single row)
    CASE
      WHEN dir.Value = 'InDirection'  THEN 'IN'
      WHEN dir.Value = 'OutDirection' THEN 'OUT'
      ELSE 'Unknown'
    END AS Swipe,

    card.Value AS CardNumber
  FROM ACVSUJournal_00010022.dbo.ACVSUJournalLog AS t1
  INNER JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  INNER JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID

  -- pick at most one direction shred row (InDirection/OutDirection)
  OUTER APPLY (
    SELECT TOP (1) s.Value
    FROM ACVSUJournal_00010022.dbo.ACVSUJournalLogxmlShred AS s
    WHERE s.GUID = t1.XmlGUID
      AND s.Value IN ('InDirection','OutDirection')
  ) AS dir

  -- pick at most one numeric card value (exclude direction values, ensure numeric)
  OUTER APPLY (
    SELECT TOP (1) s.Value
    FROM ACVSUJournal_00010022.dbo.ACVSUJournalLogxmlShred AS s
    WHERE s.GUID = t1.XmlGUID
      AND s.Value NOT IN ('InDirection','OutDirection')
      AND s.Value NOT LIKE '%[^0-9]%'
      AND s.Value IS NOT NULL
      AND LTRIM(RTRIM(s.Value)) <> ''
  ) AS card
)

-- Strict time window: >= 08:00 on @fromDate, and < 08:00 on @toDate
, Windowed AS (
  SELECT *
  FROM RawSwipes
  WHERE
    LocaleMessageTime >= DATEADD(HOUR, 8, CAST(@fromDate AS DATETIME))
    -- NOTE: removed extra DATEADD(DAY,1,...) — upper bound should be < toDate 08:00
    AND LocaleMessageTime <  DATEADD(HOUR, 8, CAST(@toDate AS DATETIME))
    AND Swipe IN ('IN','OUT') -- only real swipes
)

-- final projection + optional employee filter (supports CSV of names or IDs)
SELECT
  ObjectName1,
  ObjectName2,
  PersonnelType,
  EmployeeID,
  NumericEmployeeID,
  -- alias PartitionName2 -> location so frontend sees r.location
  PartitionName2 AS location,
  -- alias MessageType -> Messagetype so frontend sees r.Messagetype
  MessageType AS Messagetype,
  Swipe,
  CardNumber,
  LocaleMessageTime
FROM Windowed w
WHERE
  (
    @empCSV IS NULL
    OR LTRIM(RTRIM(@empCSV)) = ''
    OR EXISTS (
      SELECT 1
      FROM EmpList e
      WHERE
        e.emp = LTRIM(RTRIM(w.ObjectName1))
        OR e.emp = w.EmployeeID
        OR e.emp = w.NumericEmployeeID
    )
  )
ORDER BY LocaleMessageTime;

`;
    return query;
  };

  // small-range strategy applies (daily ranges typically small)
  const rows = await queryAcrossRegionPoolsSmart(region, buildReq, { startDate, endDate, maxBackups: 4 });
  rows.sort((a, b) => {
    const ta = new Date(a.LocaleMessageTime || 0).getTime();
    const tb = new Date(b.LocaleMessageTime || 0).getTime();
    return ta - tb;
  });
  return rows;
}

// ------------------------- other reports (kept single-pool or smart as appropriate) -------------------------

export async function inOutReport(region, { year, month, doors }) {
  const pool = await getPool(region);
  const req = pool.request();
  req.timeout = 300000;

  req.input('TargetYear', sql.Int, year);
  req.input('TargetMonth', sql.Int, month);
  doors.forEach((d, i) => req.input(`door${i}`, sql.NVarChar, d));
  const doorList = doors.map((_, i) => `@door${i}`).join(',');

  const query = `
WITH CombinedQuery AS (
  SELECT
    DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
    t1.ObjectName1,
    t1.PartitionName2    AS location,
    t5_card.CardNumber,
    t5_dir.value         AS Direction,
    CASE
      WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
      ELSE CAST(t2.Int1 AS NVARCHAR)
    END                    AS EmployeeID,
    t3.Name               AS PersonnelType
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID
    AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml AS t_xml
    ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard
    ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  WHERE
    YEAR(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetYear
    AND MONTH(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetMonth
    AND t1.ObjectName2 IN (${doorList})
)
SELECT
  FORMAT(LocaleMessageTime,'yyyy-MM')    AS Month,
  ObjectName1                           AS EmployeeName,
  EmployeeID,
  PersonnelType,
  location,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)  AS In_Count,
  SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS Out_Count,
  COUNT(*)                                                 AS TotalSwipes,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)
  - SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS InOut_Difference
FROM CombinedQuery
GROUP BY FORMAT(LocaleMessageTime,'yyyy-MM'),
         ObjectName1, EmployeeID, PersonnelType, location
ORDER BY Month DESC, EmployeeName;
`;

  const { recordset } = await req.query(query);
  return recordset;
}

export async function timeDurationReport(region, { partition = 'Default', startDate }) {
  // timeDurationReport often queries a partition and multiple days; we treat as large-range
  const pool = await getPool(region);
  const req = pool.request();
  req.timeout = 300000;

  // bind inputs
  const fullPartition = `${region.toUpperCase()}.${partition}`;
  req.input('partition', sql.NVarChar, fullPartition);
  req.input('startDate', sql.Date, startDate);

  const query = `

SELECT 
    t1.[ObjectName1],
    t1.[ObjectName2],
    t1.[PartitionName2],
    CASE
        WHEN t2.[Int1] = 0 THEN t2.[Text12]
        ELSE CAST(t2.[Int1] AS NVARCHAR)
    END AS EmployeeID,
    t3.[Name] AS PersonnelType,
    t2.text5,
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    DATEADD(HOUR, -2, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) AS AdjustedMessageTime
INTO 
    #CombinedEmployeeData
FROM 
    [ACVSUJournal_00010022].[dbo].[ACVSUJournalLog] AS t1
INNER JOIN 
    [ACVSCore].[Access].[Personnel] AS t2
    ON t1.ObjectIdentity1 = t2.GUID
INNER JOIN 
    [ACVSCore].[Access].[PersonnelType] AS t3
    ON t2.[PersonnelTypeId] = t3.[ObjectID];

WITH DailyDurations AS (
    SELECT 
        [ObjectName1],
        PersonnelType,
        EmployeeID,
        [PartitionName2],
        text5,
        CONVERT(DATE, AdjustedMessageTime) AS ShiftedDate,
        DATEPART(WEEK, AdjustedMessageTime) AS WeekNumber,
        DATEPART(YEAR, AdjustedMessageTime) AS YearNumber,
        MIN(LocaleMessageTime) AS FirstSwipeTime,
        MAX(LocaleMessageTime) AS LastSwipeTime,
        DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) AS DurationMinutes,
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) / 60 AS NVARCHAR), 2)
        + ':' +
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) % 60 AS NVARCHAR), 2) AS DurationHHMM,
        CASE 
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 5 THEN '<5mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 10 THEN '<10mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 20 THEN '<20mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 30 THEN '<30mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 60 THEN '<1hr'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 120 THEN 'Less than <2hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 180 THEN 'Less than <3hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 240 THEN 'Less than <4hrs'
            ELSE '4+ hrs'
        END AS TimeDiffCategory
    FROM 
        #CombinedEmployeeData
  WHERE CONVERT(DATE, AdjustedMessageTime) >= @startDate
   AND [PartitionName2] = 'APAC.Default'
        AND PersonnelType IN ('Employee', 'Terminated Personnel')
    GROUP BY 
        [ObjectName1], EmployeeID, PersonnelType, text5, [PartitionName2],
        CONVERT(DATE, AdjustedMessageTime),
        DATEPART(WEEK, AdjustedMessageTime),
        DATEPART(YEAR, AdjustedMessageTime)
),

WeeklySummary AS (
    SELECT 
        EmployeeID,
        [ObjectName1],
        PersonnelType,
        text5,
        [PartitionName2],
        YearNumber,
        WeekNumber,
        COUNT(DISTINCT ShiftedDate) AS DaysPresentInWeek,
        SUM(CASE WHEN DurationMinutes < 240 THEN 1 ELSE 0 END) AS ViolationDaysInWeek
    FROM 
        DailyDurations
    GROUP BY 
        EmployeeID, [ObjectName1], PersonnelType, text5, [PartitionName2], YearNumber, WeekNumber
)

SELECT 
    dd.EmployeeID,
    dd.ObjectName1,
    dd.PersonnelType,
    dd.text5,
    dd.PartitionName2,
    dd.YearNumber,
    dd.WeekNumber,
    dd.ShiftedDate,
    dd.FirstSwipeTime,
    dd.LastSwipeTime,
    dd.DurationHHMM,
    dd.TimeDiffCategory,
    ws.DaysPresentInWeek,
    ws.ViolationDaysInWeek,
    (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) AS CleanDaysInWeek,
    CASE
        WHEN (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) < 3 THEN 'Yes'
        ELSE 'No'
    END AS Defaulter
FROM 
    DailyDurations dd
JOIN 
    WeeklySummary ws
    ON dd.EmployeeID = ws.EmployeeID
    AND dd.WeekNumber = ws.WeekNumber
    AND dd.YearNumber = ws.YearNumber
ORDER BY 
    dd.YearNumber DESC, dd.WeekNumber DESC, dd.EmployeeID, dd.ShiftedDate;
`;

  const { recordset } = await req.query(query);
  return recordset;
}

export async function eurocAdmitRejectionReport(region, { reportDate }) {
  if (!region) throw new Error('region required');
  if (!reportDate) throw new Error('reportDate required');

  // for this report we want data for a single date (small), so smart logic will try primary first
  const dbNames = getRegionDbNames(region, 4);
  const admitRows = [];
  const rejectRows = [];
  const summaryMap = {};

  // try sequentially until at least one DB yields non-empty admit OR reject
  for (let i = 0; i < dbNames.length; i++) {
    const dbn = dbNames[i];
    try {
      const pools = await getPoolsForDbNames(region, [dbn]);
      const pool = pools && pools[0];
      if (!pool) continue;
      const req = pool.request();
      req.timeout = 300000;
      // enforce location LT.Vilnius (as requested)
      req.input('location', sql.NVarChar, 'LT.Vilnius');
      // reportDate should be YYYY-MM-DD or Date — bind as sql.Date
      req.input('reportDate', sql.Date, reportDate);

      const q = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    AND t1.PartitionName2 = @location
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @reportDate
)

-- materialize CombinedQuery into a temp table
SELECT
  LocaleMessageTime,
  CONVERT(date, LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  MessageType
INTO #Combined
FROM CombinedQuery;

-- create admits with row number (first admit per employee)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  ROW_NUMBER() OVER (PARTITION BY ISNULL(EmployeeID, CardNumber) ORDER BY LocaleMessageTime ASC) AS rn
INTO #Admits
FROM #Combined
WHERE MessageType = 'CardAdmitted'
  AND PersonnelType IN('Employee', 'Terminated Personnel');

-- create rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
INTO #Rejections
FROM #Combined
WHERE MessageType = 'CardRejected';

-- resultset 1: admits (only rn = 1)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Admits
WHERE rn = 1
ORDER BY LocaleMessageTime ASC;

-- resultset 2: rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Rejections
ORDER BY LocaleMessageTime ASC;

-- resultset 3: summary counts by Rejection_Type
SELECT
  ISNULL(Rejection_Type, 'Unknown') AS Rejection_Type,
  COUNT(*) AS CountVal
FROM #Rejections
GROUP BY ISNULL(Rejection_Type, 'Unknown')
ORDER BY CountVal DESC;

-- cleanup temp tables (optional — they scope to the session and will go away automatically,
-- but good practice to drop)
DROP TABLE IF EXISTS #Admits;
DROP TABLE IF EXISTS #Rejections;
DROP TABLE IF EXISTS #Combined;
`;
      const result = await req.query(q);
      const recordsets = result.recordsets || [];

      const admits = (recordsets[0] || []).map(r => ({
        LocaleMessageTime: r.LocaleMessageTime,
        DateOnly: r.DateOnly,
        Swipe_Time: r.Swipe_Time,
        ObjectName1: r.ObjectName1,
        EmployeeID: r.EmployeeID,
        PersonnelType: r.PersonnelType,
        CardNumber: r.CardNumber,
        Door: r.Door,
        location: r.location,
        Direction: r.Direction
      }));

      const rejects = (recordsets[1] || []).map(r => ({
        LocaleMessageTime: r.LocaleMessageTime,
        DateOnly: r.DateOnly,
        Swipe_Time: r.Swipe_Time,
        ObjectName1: r.ObjectName1,
        EmployeeID: r.EmployeeID,
        PersonnelType: r.PersonnelType,
        CardNumber: r.CardNumber,
        Rejection_Type: r.Rejection_Type,
        Door: r.Door,
        location: r.location,
        Direction: r.Direction
      }));

      const summary = (recordsets[2] || []).map(r => ({ Rejection_Type: r.Rejection_Type, Count: r.CountVal }));

      if (admits.length) admitRows.push(...admits);
      if (rejects.length) rejectRows.push(...rejects);
      summary.forEach(s => {
        summaryMap[s.Rejection_Type] = (summaryMap[s.Rejection_Type] || 0) + (s.Count || 0);
      });

      // if we got any rows (admit or reject), stop here to be fast
      if (admits.length || rejects.length) break;
    } catch (err) {
      // eslint-disable-next-line no-console
      console.warn(`euroc query failed on db=${dbn}:`, err && err.message ? err.message : String(err));
    }
  }

  admitRows.sort((a, b) => new Date(a.LocaleMessageTime || 0) - new Date(b.LocaleMessageTime || 0));
  rejectRows.sort((a, b) => new Date(a.LocaleMessageTime || 0) - new Date(b.LocaleMessageTime || 0));
  const summaryRows = Object.entries(summaryMap).map(([k, v]) => ({ Rejection_Type: k, Count: v }));

  return { admit: admitRows, rejection: rejectRows, summary: summaryRows };
}

