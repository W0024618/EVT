import sql from 'mssql';

// shared options
const commonOpts = {
  options: {
    encrypt: true,
    trustServerCertificate: true
  },
  // increase timeouts (milliseconds)
  requestTimeout: 300000,      // 5 minutes
  connectionTimeout: 30000,    // 30 seconds
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  }
};

// lowercase keys only
const regions = {
  apac: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUPNQ0986V',
    database: 'ACVSUJournal_00010029',
    journalPrefix: 'ACVSUJournal_', // optional hint
    ...commonOpts
  },
  emea: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUFRA0986V',
    database: 'ACVSUJournal_00011028',
    journalPrefix: 'ACVSUJournal_',
    ...commonOpts
  },
  laca: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUSJO0986V',
    database: 'ACVSUJournal_00010029',
    journalPrefix: 'ACVSUJournal_',
    ...commonOpts
  },
  namer: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUDEN0891V',
    database: 'ACVSUJournal_00010029',
    journalPrefix: 'ACVSUJournal_',
    ...commonOpts
  }
};

const pools = {};

/**
 * @param {string} regionKey  one of the keys in `regions`, case-insensitive
 * @param {string} [dbName] optionally specify a database name override for the connection pool
 */
export async function getPool(regionKey, dbName) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) {
    throw new Error(`Unknown region: ${regionKey}`);
  }

  // Build a cache key (region::dbName) so different DB pools can be cached per region
  const cacheKey = dbName ? `${key}::${dbName}` : `${key}::${cfg.database}`;

  if (pools[cacheKey]) {
    return pools[cacheKey];
  }

  // clone cfg and apply dbName override (if any)
  const cfgForPool = { ...cfg, database: dbName || cfg.database };

  // create and connect pool
  const pool = new sql.ConnectionPool(cfgForPool);
  pools[cacheKey] = await pool.connect();
  return pools[cacheKey];
}

/**
 * Returns up to `max` recent ACVSUJournal_* database names on the region server, newest-first.
 * Requires that the configured user for the region can query sys.databases.
 *
 * @param {string} regionKey
 * @param {number} max
 * @returns {Promise<string[]>}
 */
export async function getRecentDatabases(regionKey, max = 10) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) throw new Error(`Unknown region: ${regionKey}`);

  // connect to master (or the configured database) to query sys.databases
  // use cacheKey region::master
  const cacheKey = `${key}::master`;
  if (!pools[cacheKey]) {
    const cfgMaster = { ...cfg, database: 'master' };
    pools[cacheKey] = await new sql.ConnectionPool(cfgMaster).connect();
  }
  const pool = pools[cacheKey];
  const request = pool.request();

  // safe filter: prefix from config if available, otherwise ACVSUJournal_
  const prefix = cfg.journalPrefix || 'ACVSUJournal_';
  // we'll select name where name like 'prefix%' and name contains digits; order by name desc (newest suffix assumed to be lexicographically larger)
  const q = `
    SELECT TOP (@max) name
    FROM sys.databases
    WHERE name LIKE @prefix + '%'
      AND ISNUMERIC(REPLACE(name, @prefix, '')) = 1
    ORDER BY name DESC
  `;
  request.input('max', sql.Int, max);
  request.input('prefix', sql.NVarChar, prefix);

  const { recordset } = await request.query(q);
  const names = (recordset || []).map(r => r.name).filter(Boolean);
  // fallback: if none found, return the configured database as a single item
  if (names.length === 0 && cfg.database) return [cfg.database];
  return names;
}

/**
 * Select a working (accessible) journal database for the region.
 * Behavior:
 *  - tries the latest DB first
 *  - if latest not accessible, tries up to `fallbackCount` previous DBs (so default fallbackCount=1 tries one previous)
 *  - if none accessible, returns the configured default database in regions[regionKey].database
 *
 * Returns the DB name (string).
 */
export async function selectWorkingDb(regionKey, fallbackCount = 1) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) throw new Error(`Unknown region: ${regionKey}`);

  const candidates = await getRecentDatabases(regionKey, fallbackCount + 1);
  if (!Array.isArray(candidates) || candidates.length === 0) {
    return cfg.database;
  }

  for (const dbName of candidates) {
    try {
      // attempt to get a pool to that db and perform a tiny harmless query
      const pool = await getPool(regionKey, dbName);
      // quick test query in the current DB context
      await pool.request().query('SELECT 1 AS ok');
      // success ‚Äî return this db
      return dbName;
    } catch (err) {
      // If access denied or any error, try next candidate
      // Keep iterating ‚Äî do not throw yet
      // Optionally you can inspect err.message to check for access errors specifically
      // console.warn(`db access test failed for ${dbName}: ${err.message}`);
      continue;
    }
  }

  // nothing worked ‚Äî return configured default database as last resort
  return cfg.database;
}

export { sql };









import { getPool, selectWorkingDb, getRecentDatabases, sql } from '../config/dbConfig.js';

/**
 * Helper: safe identifier quoting for SQL Server
 */
function quoteIdent(s) {
  return `[${String(s).replace(/]/g, ']]')}]`;
}

/**
 * NOTE:
 * All report queries below now resolve a single working DB using selectWorkingDb(region, 1)
 * That means:
 *  - Try latest DB
 *  - If latest inaccessible, automatically try one previous DB and use it
 *  - Avoids running UNION across multiple DBs which fails when any DB is inaccessible
 */

/**
 * List Locations (PartitionName2) ‚Äî uses a single working DB (latest accessible)
 */
export async function listLocations(region) {
  if (!region) throw new Error('region required');

  const workingDb = await selectWorkingDb(region, 1); // latest or one previous
  const pool = await getPool(region, workingDb);

  const q = `
    SELECT DISTINCT PartitionName2
    FROM ${quoteIdent(workingDb)}.dbo.ACVSUJournalLog
    WHERE PartitionName2 IS NOT NULL
    ORDER BY PartitionName2;
  `;

  const { recordset } = await pool.request().query(q);
  return (recordset || []).map(r => r.PartitionName2).filter(Boolean);
}

/**
 * Search employees by name or employee id fragment (unchanged)
 */
export async function searchEmployees(region = 'emea', q = '') {
  const pool = await getPool(region);
  const req = pool.request();
  const like = `%${q}%`;
  req.input('q', sql.NVarChar(200), like);

  const query = `
    SELECT TOP (200)
      CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR(50)) END AS EmployeeID,
      ISNULL(t2.Text1, '') AS Name
    FROM ACVSCore.Access.Personnel AS t2
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId = t3.ObjectID
    WHERE (t2.Text1 LIKE @q) OR (CAST(t2.Int1 AS NVARCHAR(50)) LIKE @q) OR (t2.Text12 LIKE @q)
    ORDER BY t2.Text1;
  `;
  const { recordset } = await req.query(query);
  return (recordset || []).map(r => ({ EmployeeID: r.EmployeeID, Name: r.Name }));
}


/**
 * rawReport: uses a single working DB (latest accessible, else previous)
 */
export async function rawReport(region, { startDate, endDate, location, admitFilter = 'all' }) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const workingDb = await selectWorkingDb(region, 1);
  const pool = await getPool(region, workingDb);
  const req = pool.request();
  req.timeout = 300000;

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;
  req.input('location', sql.NVarChar(200), locationParam);
  req.input('startDate', sql.Date, startDate);
  req.input('endDate', sql.Date, endDate);
  req.input('admitFilter', sql.NVarChar(20), String(admitFilter || 'all'));

  const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ${quoteIdent(workingDb)}.dbo.ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM CombinedQuery
WHERE
  (
    UPPER(ISNULL(@admitFilter,'all')) = 'ALL'
    OR (UPPER(@admitFilter) = 'ADMIT'  AND MessageType = 'CardAdmitted')
    OR (UPPER(@admitFilter) = 'REJECT' AND MessageType = 'CardRejected')
  )
ORDER BY LocaleMessageTime ASC;
`;

  const { recordset } = await req.query(query);
  return recordset;
}


/**
 * rejectionReport: single working DB
 */
export async function rejectionReport(region, { startDate, endDate, location } = {}) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const workingDb = await selectWorkingDb(region, 1);
  const pool = await getPool(region, workingDb);
  const req = pool.request();
  req.timeout = 300000;

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;
  req.input('location', sql.NVarChar(200), locationParam);
  req.input('startDate', sql.Date, startDate);
  req.input('endDate', sql.Date, endDate);

  const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ${quoteIdent(workingDb)}.dbo.ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType = 'CardRejected'
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
),
Unified AS (
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Lost'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Clearance'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type IN ('CardDisabled','Disabled')
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Stolen'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Expired'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'PIN'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'UnknownCard'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'SiteCode'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'NotActivated'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'FacilityCode'
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM Unified
ORDER BY LocaleMessageTime DESC;
`;

  const { recordset } = await req.query(query);
  return recordset;
}


/**
 * dailyAccessReportEMEA ‚Äî uses selected working DB
 */
export async function dailyAccessReportEMEA({ region = 'emea', from, to, employees = '' }) {
  if (!region) throw new Error('region required');

  const workingDb = await selectWorkingDb(region, 1);
  const pool = await getPool(region, workingDb);
  const req  = pool.request();
  req.timeout = 300000;

  req.input('fromDate', sql.Date, from);
  req.input('toDate',   sql.Date, to);
  const employeesParam = (employees && String(employees).trim()) ? String(employees).trim() : null;
  req.input('employees', sql.NVarChar(sql.MAX), employeesParam);

  const query = `
  ;WITH EmpList AS (
    SELECT LTRIM(RTRIM(value)) AS emp
    FROM STRING_SPLIT(ISNULL(@employees,''), ',')
    WHERE LTRIM(RTRIM(value)) <> ''
  )

  -- Raw rows: compute LocaleMessageTime once and use OUTER APPLY to avoid duplicate shreddes
  , RawSwipes AS (
    SELECT
      t1.ObjectName1,
      t1.ObjectName2,
      t1.MessageType,
      t2.Text12       AS EmployeeID,
      CAST(t2.Int1 AS NVARCHAR(50)) AS NumericEmployeeID,
      t3.Name         AS PersonnelType,
      t1.PartitionName2 AS PartitionName2,
      DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
      CASE
        WHEN dir.Value = 'InDirection'  THEN 'IN'
        WHEN dir.Value = 'OutDirection' THEN 'OUT'
        ELSE 'Unknown'
      END AS Swipe,
      card.Value AS CardNumber
    FROM ${quoteIdent(workingDb)}.dbo.ACVSUJournalLog AS t1
    INNER JOIN ACVSCore.Access.Personnel     AS t2
      ON t1.ObjectIdentity1 = t2.GUID
    INNER JOIN ACVSCore.Access.PersonnelType AS t3
      ON t2.PersonnelTypeId = t3.ObjectID
    OUTER APPLY (
      SELECT TOP (1) s.Value
      FROM ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred AS s
      WHERE s.GUID = t1.XmlGUID
        AND s.Value IN ('InDirection','OutDirection')
    ) AS dir
    OUTER APPLY (
      SELECT TOP (1) s.Value
      FROM ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred AS s
      WHERE s.GUID = t1.XmlGUID
        AND s.Value NOT IN ('InDirection','OutDirection')
        AND s.Value NOT LIKE '%[^0-9]%'
        AND s.Value IS NOT NULL
        AND LTRIM(RTRIM(s.Value)) <> ''
    ) AS card
  )

  -- Strict time window: >= 08:00 on @fromDate, and < 08:00 on @toDate
  , Windowed AS (
    SELECT *
    FROM RawSwipes
    WHERE
      LocaleMessageTime >= DATEADD(HOUR, 8, CAST(@fromDate AS DATETIME))
      AND LocaleMessageTime <  DATEADD(HOUR, 8, CAST(@toDate AS DATETIME))
      AND Swipe IN ('IN','OUT') -- only real swipes
  )

  SELECT
    ObjectName1,
    ObjectName2,
    PersonnelType,
    EmployeeID,
    NumericEmployeeID,
    PartitionName2 AS location,
    MessageType AS Messagetype,
    Swipe,
    CardNumber,
    LocaleMessageTime
  FROM Windowed w
  WHERE
    (
      @employees IS NULL
      OR LTRIM(RTRIM(@employees)) = ''
      OR EXISTS (
        SELECT 1
        FROM EmpList e
        WHERE
          e.emp = LTRIM(RTRIM(w.ObjectName1))
          OR e.emp = w.EmployeeID
          OR e.emp = w.NumericEmployeeID
      )
    )
  ORDER BY LocaleMessageTime;
  `;

  const { recordset } = await req.query(query);
  return recordset;
}


/**
 * inOutReport - single working DB
 */
export async function inOutReport(region, { year, month, doors }) {
  if (!region) throw new Error('region required');

  const workingDb = await selectWorkingDb(region, 1);
  const pool = await getPool(region, workingDb);
  const req = pool.request();
  req.timeout = 300000;

  req.input('TargetYear',  sql.Int, year);
  req.input('TargetMonth', sql.Int, month);
  doors.forEach((d, i) => req.input(`door${i}`, sql.NVarChar, d));
  const doorList = doors.map((_, i) => `@door${i}`).join(',');

  const query = `
WITH CombinedQuery AS (
  SELECT
    DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
    t1.ObjectName1,
    t1.PartitionName2    AS location,
    t5_card.CardNumber,
    t5_dir.value         AS Direction,
    CASE
      WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
      ELSE CAST(t2.Int1 AS NVARCHAR)
    END                    AS EmployeeID,
    t3.Name               AS PersonnelType
  FROM ${quoteIdent(workingDb)}.dbo.ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID
  LEFT JOIN ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID
    AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxml AS t_xml
    ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard
    ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  WHERE
    YEAR(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetYear
    AND MONTH(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetMonth
    AND t1.ObjectName2 IN (${doorList})
)
SELECT
  FORMAT(LocaleMessageTime,'yyyy-MM')    AS Month,
  ObjectName1                           AS EmployeeName,
  EmployeeID,
  PersonnelType,
  location,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)  AS In_Count,
  SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS Out_Count,
  COUNT(*)                                                 AS TotalSwipes,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)
  - SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS InOut_Difference
FROM CombinedQuery
GROUP BY FORMAT(LocaleMessageTime,'yyyy-MM'),
         ObjectName1, EmployeeID, PersonnelType, location
ORDER BY Month DESC, EmployeeName;
`;

  const { recordset } = await req.query(query);
  return recordset;
}


/**
 * timeDurationReport ‚Äî picks the latest accessible DB (or previous if latest inaccessible)
 */
export async function timeDurationReport(region, { partition = 'Default', startDate }) {
  if (!region) throw new Error('region required');

  const workingDb = await selectWorkingDb(region, 1); // latest or previous
  const pool = await getPool(region, workingDb);
  const req = pool.request();
  req.timeout = 300000;

  const fullPartition = `${region.toUpperCase()}.${partition}`;
  req.input('partition', sql.NVarChar, fullPartition);
  req.input('startDate', sql.Date, startDate);

  const query = `
SELECT 
    t1.[ObjectName1],
    t1.[ObjectName2],
    t1.[PartitionName2],
    CASE
        WHEN t2.[Int1] = 0 THEN t2.[Text12]
        ELSE CAST(t2.[Int1] AS NVARCHAR)
    END AS EmployeeID,
    t3.[Name] AS PersonnelType,
    t2.text5,
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    DATEADD(HOUR, -2, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) AS AdjustedMessageTime
INTO 
    #CombinedEmployeeData
FROM ${quoteIdent(workingDb)}.dbo.ACVSUJournalLog AS t1
INNER JOIN 
    ACVSCore.Access.Personnel AS t2
    ON t1.ObjectIdentity1 = t2.GUID
INNER JOIN 
    ACVSCore.Access.PersonnelType AS t3
    ON t2.[PersonnelTypeId] = t3.[ObjectID];

-- (rest of the original query remains unchanged from your previous implementation)
-- Step 2: Daily duration per employee
WITH DailyDurations AS (
    SELECT 
        [ObjectName1],
        PersonnelType,
        EmployeeID,
        [PartitionName2],
        text5,
        CONVERT(DATE, AdjustedMessageTime) AS ShiftedDate,
        DATEPART(WEEK, AdjustedMessageTime) AS WeekNumber,
        DATEPART(YEAR, AdjustedMessageTime) AS YearNumber,
        MIN(LocaleMessageTime) AS FirstSwipeTime,
        MAX(LocaleMessageTime) AS LastSwipeTime,
        DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) AS DurationMinutes,
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) / 60 AS NVARCHAR), 2)
        + ':' +
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) % 60 AS NVARCHAR), 2) AS DurationHHMM,
        CASE 
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 5 THEN '<5mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 10 THEN '<10mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 20 THEN '<20mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 30 THEN '<30mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 60 THEN '<1hr'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 120 THEN 'Less than <2hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 180 THEN 'Less than <3hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 240 THEN 'Less than <4hrs'
            ELSE '4+ hrs'
        END AS TimeDiffCategory
    FROM 
        #CombinedEmployeeData

  WHERE CONVERT(DATE, AdjustedMessageTime) >= @startDate

   AND [PartitionName2] = 'APAC.Default'
        AND PersonnelType IN ('Employee', 'Terminated Personnel')
    GROUP BY 
        [ObjectName1], EmployeeID, PersonnelType, text5, [PartitionName2],
        CONVERT(DATE, AdjustedMessageTime),
        DATEPART(WEEK, AdjustedMessageTime),
        DATEPART(YEAR, AdjustedMessageTime)
),

-- Step 3: Weekly summary
WeeklySummary AS (
    SELECT 
        EmployeeID,
        [ObjectName1],
        PersonnelType,
        text5,
        [PartitionName2],
        YearNumber,
        WeekNumber,
        COUNT(DISTINCT ShiftedDate) AS DaysPresentInWeek,
        SUM(CASE WHEN DurationMinutes < 240 THEN 1 ELSE 0 END) AS ViolationDaysInWeek
    FROM 
        DailyDurations
    GROUP BY 
        EmployeeID, [ObjectName1], PersonnelType, text5, [PartitionName2], YearNumber, WeekNumber
)

-- Step 4: Final output with daily duration, category, and defaulter flag
SELECT 
    dd.EmployeeID,
    dd.ObjectName1,
    dd.PersonnelType,
    dd.text5,
    dd.PartitionName2,
    dd.YearNumber,
    dd.WeekNumber,
    dd.ShiftedDate,
    dd.FirstSwipeTime,
    dd.LastSwipeTime,
    dd.DurationHHMM,
    dd.TimeDiffCategory,
    ws.DaysPresentInWeek,
    ws.ViolationDaysInWeek,
    (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) AS CleanDaysInWeek,
    CASE
        WHEN (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) < 3 THEN 'Yes'
        ELSE 'No'
    END AS Defaulter
FROM 
    DailyDurations dd
JOIN 
    WeeklySummary ws
    ON dd.EmployeeID = ws.EmployeeID
    AND dd.WeekNumber = ws.WeekNumber
    AND dd.YearNumber = ws.YearNumber
ORDER BY 
    dd.YearNumber DESC, dd.WeekNumber DESC, dd.EmployeeID, dd.ShiftedDate;
  `;

  const { recordset } = await req.query(query);
  return recordset;
}


/**
 * eurocAdmitRejectionReport - single working DB
 */
export async function eurocAdmitRejectionReport(region, { reportDate }) {
  if (!region) throw new Error('region required');

  const workingDb = await selectWorkingDb(region, 1);
  const pool = await getPool(region, workingDb);
  const req = pool.request();
  req.timeout = 300000;

  req.input('location', sql.NVarChar, 'LT.Vilnius');
  req.input('reportDate', sql.Date, reportDate);

  const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ${quoteIdent(workingDb)}.dbo.ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ${quoteIdent(workingDb)}.dbo.ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    AND t1.PartitionName2 = @location
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @reportDate
)

-- (rest of your euroc flow unchanged, using the single workingDb)
SELECT
  LocaleMessageTime,
  CONVERT(date, LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  MessageType
INTO #Combined
FROM CombinedQuery;

-- create admits with row number (first admit per employee)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  ROW_NUMBER() OVER (PARTITION BY ISNULL(EmployeeID, CardNumber) ORDER BY LocaleMessageTime ASC) AS rn
INTO #Admits
FROM #Combined
WHERE MessageType = 'CardAdmitted'
  AND PersonnelType IN('Employee', 'Terminated Personnel');

-- create rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
INTO #Rejections
FROM #Combined
WHERE MessageType = 'CardRejected';

-- resultset 1: admits (only rn = 1)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Admits
WHERE rn = 1
ORDER BY LocaleMessageTime ASC;

-- resultset 2: rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Rejections
ORDER BY LocaleMessageTime ASC;

-- resultset 3: summary counts by Rejection_Type
SELECT
  ISNULL(Rejection_Type, 'Unknown') AS Rejection_Type,
  COUNT(*) AS CountVal
FROM #Rejections
GROUP BY ISNULL(Rejection_Type, 'Unknown')
ORDER BY CountVal DESC;

-- cleanup temp tables
DROP TABLE IF EXISTS #Admits;
DROP TABLE IF EXISTS #Rejections;
DROP TABLE IF EXISTS #Combined;
`;

  const result = await req.query(query);
  const recordsets = result.recordsets || [];
  const admitRows = (recordsets[0] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const rejectRows = (recordsets[1] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Rejection_Type: r.Rejection_Type,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const summaryRows = (recordsets[2] || []).map(r => ({ Rejection_Type: r.Rejection_Type, Count: r.CountVal }));

  return { admit: admitRows, rejection: rejectRows, summary: summaryRows };
}






















Failed to generate report: The server principal "GSOC_Test" is not able to access the database "ACVSUJournal_00010030" under the current security context.

üåç Global-backend listening on http://localhost:3008
RequestError: The server principal "GSOC_Test" is not able to access the database "ACVSUJournal_00010030" under the current security context.
    at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:384:15)
    at Connection.emit (node:events:518:28)
    at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18)
    at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
    at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
    at Readable.emit (node:events:518:28)
    at addChunk (node:internal/streams/readable:561:12)
    at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
    at Readable.push (node:internal/streams/readable:393:5)
    at nextAsync (node:internal/streams/from:194:22)
RequestError: The server principal "GSOC_Test" is not able to access the database "ACVSUJournal_00010030" under the current security context.
    at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:384:15)
    at Connection.emit (node:events:518:28)
    at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18)
    at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
    at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
    at Readable.emit (node:events:518:28)
    at addChunk (node:internal/streams/readable:561:12)
    at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
    at Readable.push (node:internal/streams/readable:393:5)
    at nextAsync (node:internal/streams/from:194:22)





If database is Not accesiable then use previous database 
When latest database is accesaible then use Latest databse ....





//C:\Users\W0024618\Desktop\global-page\backend\config\dbConfig.js


import sql from 'mssql';

// shared options
const commonOpts = {
  options: {
    encrypt: true,
    trustServerCertificate: true
  },
  // increase timeouts (milliseconds)
  requestTimeout: 300000,      // 5 minutes
  connectionTimeout: 30000,    // 30 seconds
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  }
};

// lowercase keys only
const regions = {
  apac: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUPNQ0986V',
    database: 'ACVSUJournal_00010029',
    journalPrefix: 'ACVSUJournal_', // optional hint
    ...commonOpts
  },
  emea: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUFRA0986V',
    database: 'ACVSUJournal_00011028',
    journalPrefix: 'ACVSUJournal_',
    ...commonOpts
  },
  laca: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUSJO0986V',
    database: 'ACVSUJournal_00010029',
    journalPrefix: 'ACVSUJournal_',
    ...commonOpts
  },
  namer: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUDEN0891V',
    database: 'ACVSUJournal_00010029',
    journalPrefix: 'ACVSUJournal_',
    ...commonOpts
  }
};

const pools = {};

/**
 * @param {string} regionKey  one of the keys in `regions`, case-insensitive
 * @param {string} [dbName] optionally specify a database name override for the connection pool
 */
export async function getPool(regionKey, dbName) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) {
    throw new Error(`Unknown region: ${regionKey}`);
  }

  // Build a cache key (region::dbName) so different DB pools can be cached per region
  const cacheKey = dbName ? `${key}::${dbName}` : `${key}::${cfg.database}`;

  if (pools[cacheKey]) {
    return pools[cacheKey];
  }

  // clone cfg and apply dbName override (if any)
  const cfgForPool = { ...cfg, database: dbName || cfg.database };

  // create and connect pool
  const pool = new sql.ConnectionPool(cfgForPool);
  pools[cacheKey] = await pool.connect();
  return pools[cacheKey];
}

/**
 * Returns up to `max` recent ACVSUJournal_* database names on the region server, newest-first.
 * Requires that the configured user for the region can query sys.databases.
 *
 * @param {string} regionKey
 * @param {number} max
 * @returns {Promise<string[]>}
 */
export async function getRecentDatabases(regionKey, max = 10) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) throw new Error(`Unknown region: ${regionKey}`);

  // connect to master (or the configured database) to query sys.databases
  // use cacheKey region::master
  const cacheKey = `${key}::master`;
  if (!pools[cacheKey]) {
    const cfgMaster = { ...cfg, database: 'master' };
    pools[cacheKey] = await new sql.ConnectionPool(cfgMaster).connect();
  }
  const pool = pools[cacheKey];
  const request = pool.request();

  // safe filter: prefix from config if available, otherwise ACVSUJournal_
  const prefix = cfg.journalPrefix || 'ACVSUJournal_';
  // we'll select name where name like 'prefix%' and name contains digits; order by name desc (newest suffix assumed to be lexicographically larger)
  const q = `
    SELECT TOP (@max) name
    FROM sys.databases
    WHERE name LIKE @prefix + '%'
      AND ISNUMERIC(REPLACE(name, @prefix, '')) = 1
    ORDER BY name DESC
  `;
  request.input('max', sql.Int, max);
  request.input('prefix', sql.NVarChar, prefix);

  const { recordset } = await request.query(q);
  const names = (recordset || []).map(r => r.name).filter(Boolean);
  // fallback: if none found, return the configured database as a single item
  if (names.length === 0 && cfg.database) return [cfg.database];
  return names;
}

export { sql };
















//C:\Users\W0024618\Desktop\global-page\backend\services\reportService.js


import { getPool, getRecentDatabases, sql } from '../config/dbConfig.js';

/**
 * Helper: safe identifier quoting for SQL Server
 */
function quoteIdent(s) {
  return `[${String(s).replace(/]/g, ']]')}]`;
}

/**
 * Helper: build union-of-journal-selects for a CTE or large query.
 *
 * @param {string[]} dbList  array of database names (already validated)
 * @param {function} perDbSelectFn  function(dbName) returning the SELECT ... FROM ... (without trailing semicolon)
 * @returns {string} combined SQL (a union of per-db selects)
 */
function buildUnionAcrossDbs(dbList, perDbSelectFn) {
  if (!Array.isArray(dbList) || dbList.length === 0) {
    throw new Error('No journal databases provided');
  }
  return dbList.map(db => `(${perDbSelectFn(db)})`).join('\nUNION ALL\n');
}

/**
 * List Locations (PartitionName2) across latest journal DBs for region
 */
export async function listLocations(region) {
  if (!region) throw new Error('region required');

  // get up to 10 recent journal DBs
  const dbList = await getRecentDatabases(region, 10);

  // build unioned query: SELECT DISTINCT PartitionName2 FROM [db].dbo.ACVSUJournalLog
  const unionSql = buildUnionAcrossDbs(dbList, (db) => {
    return `SELECT PartitionName2 FROM ${quoteIdent(db)}.dbo.ACVSUJournalLog WHERE PartitionName2 IS NOT NULL`;
  });

  const finalSql = `
    SELECT DISTINCT PartitionName2
    FROM (
      ${unionSql}
    ) AS u
    WHERE PartitionName2 IS NOT NULL
    ORDER BY PartitionName2;
  `;

  // execute on pool (any pool on the region server; use the region's default pool)
  const pool = await getPool(region);
  const { recordset } = await pool.request().query(finalSql);
  return (recordset || []).map(r => r.PartitionName2).filter(Boolean);
}

/**
 * Search employees by name or employee id fragment
 * q: search string (partial), region: region key for getPool
 *
 * NOTE: this uses ACVSCore objects (unchanged). If ACVSCore is on another DB and needs qualification,
 * we can qualify it similarly.
 */
export async function searchEmployees(region = 'emea', q = '') {
  const pool = await getPool(region);
  const req = pool.request();
  const like = `%${q}%`;
  req.input('q', sql.NVarChar(200), like);

  const query = `
    SELECT TOP (200)
      CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR(50)) END AS EmployeeID,
      ISNULL(t2.Text1, '') AS Name
    FROM ACVSCore.Access.Personnel AS t2
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId = t3.ObjectID
    WHERE (t2.Text1 LIKE @q) OR (CAST(t2.Int1 AS NVARCHAR(50)) LIKE @q) OR (t2.Text12 LIKE @q)
    ORDER BY t2.Text1;
  `;
  const { recordset } = await req.query(query);
  return (recordset || []).map(r => ({ EmployeeID: r.EmployeeID, Name: r.Name }));
}


/**
 * Raw Report (searches CardAdmitted / CardRejected) across up to last 10 journal DBs
 */
export async function rawReport(region, { startDate, endDate, location, admitFilter = 'all' }) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const pool = await getPool(region);
  const req = pool.request();
  req.timeout = 300000;

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;
  req.input('location', sql.NVarChar(200), locationParam);
  req.input('startDate', sql.Date, startDate);
  req.input('endDate', sql.Date, endDate);
  req.input('admitFilter', sql.NVarChar(20), String(admitFilter || 'all'));

  const dbList = await getRecentDatabases(region, 10);

  // Per-db SELECT chunk (same columns used previously). ACVSCore.* joins left unqualified.
  const perDbSelect = (db) => `
    SELECT 
       DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
       t1.ObjectName1,
       t1.PartitionName2       AS location,
       t5_card.CardNumber,
       t5_admit.value          AS AdmitCode,
       t5_dir.value            AS Direction,
       t1.ObjectName2          AS Door,
       t5_rej.value            AS Rejection_Type,
       CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
            THEN t2.Text12
            ELSE CAST(t2.Int1 AS NVARCHAR)
       END                       AS EmployeeID,
       t3.Name                  AS PersonnelType,
       t1.MessageType,
       t1.XmlGUID
    FROM ${quoteIdent(db)}.dbo.ACVSUJournalLog AS t1
    LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
    LEFT JOIN ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred       AS t5_admit
      ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
    LEFT JOIN ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred       AS t5_dir
      ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
    LEFT JOIN ${quoteIdent(db)}.dbo.ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
    LEFT JOIN (
      SELECT GUID, [value]
      FROM ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred
      WHERE [Name] IN ('Card','CHUID')
    ) AS SCard ON t1.XmlGUID = SCard.GUID
    OUTER APPLY (
      SELECT COALESCE(
        TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
        TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
        SCard.[value]
      ) AS CardNumber
    ) AS t5_card
    LEFT JOIN ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred AS t5_rej
      ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
    WHERE
      t1.MessageType IN ('CardAdmitted' , 'CardRejected')
      AND (@location IS NULL OR t1.PartitionName2 = @location)
      AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
  `;

  const combined = buildUnionAcrossDbs(dbList, perDbSelect);

  const finalQuery = `
WITH CombinedQuery AS (
  ${combined}
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM CombinedQuery
-- admitFilter logic handled in JS params (same as earlier)
WHERE
  (
    UPPER(ISNULL(@admitFilter,'all')) = 'ALL'
    OR (UPPER(@admitFilter) = 'ADMIT'  AND MessageType = 'CardAdmitted')
    OR (UPPER(@admitFilter) = 'REJECT' AND MessageType = 'CardRejected')
  )
ORDER BY LocaleMessageTime ASC;
`;

  const { recordset } = await req.query(finalQuery);
  return recordset;
}


/**
 * Rejection report (CardRejected) across journal DBs
 */
export async function rejectionReport(region, { startDate, endDate, location } = {}) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const pool = await getPool(region);
  const req = pool.request();
  req.timeout = 300000;

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;
  req.input('location', sql.NVarChar(200), locationParam);
  req.input('startDate', sql.Date, startDate);
  req.input('endDate', sql.Date, endDate);

  const dbList = await getRecentDatabases(region, 10);

  const perDbSelect = (db) => `
    SELECT 
       DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
       t1.ObjectName1,
       t1.PartitionName2       AS location,
       t5_card.CardNumber,
       t5_admit.value          AS AdmitCode,
       t5_dir.value            AS Direction,
       t1.ObjectName2          AS Door,
       t5_rej.value            AS Rejection_Type,
       CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
            THEN t2.Text12
            ELSE CAST(t2.Int1 AS NVARCHAR)
       END                       AS EmployeeID,
       t3.Name                  AS PersonnelType,
       t1.MessageType,
       t1.XmlGUID
    FROM ${quoteIdent(db)}.dbo.ACVSUJournalLog AS t1
    LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
    LEFT JOIN ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred       AS t5_admit
      ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
    LEFT JOIN ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred       AS t5_dir
      ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
    LEFT JOIN ${quoteIdent(db)}.dbo.ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
    LEFT JOIN (
      SELECT GUID, [value]
      FROM ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred
      WHERE [Name] IN ('Card','CHUID')
    ) AS SCard ON t1.XmlGUID = SCard.GUID
    OUTER APPLY (
      SELECT COALESCE(
        TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
        TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
        SCard.[value]
      ) AS CardNumber
    ) AS t5_card
    LEFT JOIN ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred AS t5_rej
      ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
    WHERE
      t1.MessageType = 'CardRejected'
      AND (@location IS NULL OR t1.PartitionName2 = @location)
      AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
  `;

  const combined = buildUnionAcrossDbs(dbList, perDbSelect);

  const finalQuery = `
WITH CombinedQuery AS (
  ${combined}
),
Unified AS (
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Lost'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Clearance'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type IN ('CardDisabled','Disabled')
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Stolen'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Expired'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'PIN'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'UnknownCard'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'SiteCode'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'NotActivated'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'FacilityCode'
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM Unified
ORDER BY LocaleMessageTime DESC;
`;

  const { recordset } = await req.query(finalQuery);
  return recordset;
}


/**
 * dailyAccessReportEMEA ‚Äî adjusted to use latest journal DB by default (and union across recent DBs)
 *
 * Note: original query referenced ACVSUJournal_00011028 directly. We now union across recent databases.
 */
export async function dailyAccessReportEMEA({ region = 'emea', from, to, employees = '' }) {
  if (!region) throw new Error('region required');
  const pool = await getPool(region);
  const req  = pool.request();
  req.timeout = 300000;

  req.input('fromDate', sql.Date, from);
  req.input('toDate',   sql.Date, to);
  const employeesParam = (employees && String(employees).trim()) ? String(employees).trim() : null;
  req.input('employees', sql.NVarChar(sql.MAX), employeesParam);

  const dbList = await getRecentDatabases(region, 10);

  // raw per-db chunk for RawSwipes (adapted from original)
  const perDbRawSwipes = (db) => `
    SELECT
      t1.ObjectName1,
      t1.ObjectName2,
      t1.MessageType,
      t2.Text12       AS EmployeeID,
      CAST(t2.Int1 AS NVARCHAR(50)) AS NumericEmployeeID,
      t3.Name         AS PersonnelType,
      t1.PartitionName2 AS PartitionName2,
      DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
      CASE
        WHEN dir.Value = 'InDirection'  THEN 'IN'
        WHEN dir.Value = 'OutDirection' THEN 'OUT'
        ELSE 'Unknown'
      END AS Swipe,
      card.Value AS CardNumber
    FROM ${quoteIdent(db)}.dbo.ACVSUJournalLog AS t1
    INNER JOIN ACVSCore.Access.Personnel     AS t2
      ON t1.ObjectIdentity1 = t2.GUID
    INNER JOIN ACVSCore.Access.PersonnelType AS t3
      ON t2.PersonnelTypeId = t3.ObjectID
    OUTER APPLY (
      SELECT TOP (1) s.Value
      FROM ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred AS s
      WHERE s.GUID = t1.XmlGUID
        AND s.Value IN ('InDirection','OutDirection')
    ) AS dir
    OUTER APPLY (
      SELECT TOP (1) s.Value
      FROM ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred AS s
      WHERE s.GUID = t1.XmlGUID
        AND s.Value NOT IN ('InDirection','OutDirection')
        AND s.Value NOT LIKE '%[^0-9]%'
        AND s.Value IS NOT NULL
        AND LTRIM(RTRIM(s.Value)) <> ''
    ) AS card
  `;

  const rawUnion = buildUnionAcrossDbs(dbList, perDbRawSwipes);

  const query = `
  ;WITH EmpList AS (
    SELECT LTRIM(RTRIM(value)) AS emp
    FROM STRING_SPLIT(ISNULL(@employees,''), ',')
    WHERE LTRIM(RTRIM(value)) <> ''
  ),
  RawSwipes AS (
    ${rawUnion}
  ),
  Windowed AS (
    SELECT *
    FROM RawSwipes
    WHERE
      LocaleMessageTime >= DATEADD(HOUR, 8, CAST(@fromDate AS DATETIME))
      AND LocaleMessageTime <  DATEADD(HOUR, 8, CAST(@toDate AS DATETIME))
      AND Swipe IN ('IN','OUT')
  )
  SELECT
    ObjectName1,
    ObjectName2,
    PersonnelType,
    EmployeeID,
    NumericEmployeeID,
    PartitionName2 AS location,
    MessageType AS Messagetype,
    Swipe,
    CardNumber,
    LocaleMessageTime
  FROM Windowed w
  WHERE
    (
      @employees IS NULL
      OR LTRIM(RTRIM(@employees)) = ''
      OR EXISTS (
        SELECT 1
        FROM EmpList e
        WHERE
          e.emp = LTRIM(RTRIM(w.ObjectName1))
          OR e.emp = w.EmployeeID
          OR e.emp = w.NumericEmployeeID
      )
    )
  ORDER BY LocaleMessageTime;
  `;

  const { recordset } = await req.query(query);
  return recordset;
}


/**
 * inOutReport - uses ACVSUJournalLog references unqualified previously; now union across recent DBs
 */
export async function inOutReport(region, { year, month, doors }) {
  if (!region) throw new Error('region required');
  const pool = await getPool(region);
  const req = pool.request();
  req.timeout = 300000;

  req.input('TargetYear',  sql.Int, year);
  req.input('TargetMonth', sql.Int, month);
  doors.forEach((d, i) => req.input(`door${i}`, sql.NVarChar, d));
  const doorList = doors.map((_, i) => `@door${i}`).join(',');

  const dbList = await getRecentDatabases(region, 10);

  const perDbCombinedQuery = (db) => `
    SELECT
      DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
      t1.ObjectName1,
      t1.PartitionName2    AS location,
      t5_card.CardNumber,
      t5_dir.value         AS Direction,
      CASE
        WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
        ELSE CAST(t2.Int1 AS NVARCHAR)
      END                    AS EmployeeID,
      t3.Name               AS PersonnelType
    FROM ${quoteIdent(db)}.dbo.ACVSUJournalLog AS t1
    LEFT JOIN ACVSCore.Access.Personnel     AS t2
      ON t1.ObjectIdentity1 = t2.GUID
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3
      ON t2.PersonnelTypeId = t3.ObjectID
    LEFT JOIN ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred AS t5_dir
      ON t1.XmlGUID = t5_dir.GUID
      AND t5_dir.Value IN ('InDirection','OutDirection')
    LEFT JOIN ${quoteIdent(db)}.dbo.ACVSUJournalLogxml AS t_xml
      ON t1.XmlGUID = t_xml.GUID
    LEFT JOIN (
      SELECT GUID, [value]
      FROM ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred
      WHERE [Name] IN ('Card','CHUID')
    ) AS SCard
      ON t1.XmlGUID = SCard.GUID
    OUTER APPLY (
      SELECT COALESCE(
        TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
        TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
        SCard.[value]
      ) AS CardNumber
    ) AS t5_card
    WHERE
      YEAR(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetYear
      AND MONTH(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetMonth
      AND t1.ObjectName2 IN (${doorList})
  `;

  const combined = buildUnionAcrossDbs(dbList, perDbCombinedQuery);

  const query = `
WITH CombinedQuery AS (
  ${combined}
)
SELECT
  FORMAT(LocaleMessageTime,'yyyy-MM')    AS Month,
  ObjectName1                           AS EmployeeName,
  EmployeeID,
  PersonnelType,
  location,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)  AS In_Count,
  SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS Out_Count,
  COUNT(*)                                                 AS TotalSwipes,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)
  - SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS InOut_Difference
FROM CombinedQuery
GROUP BY FORMAT(LocaleMessageTime,'yyyy-MM'),
         ObjectName1, EmployeeID, PersonnelType, location
ORDER BY Month DESC, EmployeeName;
`;

  const { recordset } = await req.query(query);
  return recordset;
}


/**
 * timeDurationReport ‚Äî updated to run against the latest journal DB (single DB usage)
 * This query originally used an INTO #CombinedEmployeeData from a specific DB. We'll pick the latest DB and run there.
 */
export async function timeDurationReport(region, { partition = 'Default', startDate }) {
  if (!region) throw new Error('region required');

  // get the latest DB for region (first in list)
  const dbList = await getRecentDatabases(region, 1);
  const latestDb = dbList[0];

  // request using pool for that latest DB (so unqualified references can work if needed)
  const pool = await getPool(region, latestDb);
  const req = pool.request();
  req.timeout = 300000;

  const fullPartition = `${region.toUpperCase()}.${partition}`;
  req.input('partition', sql.NVarChar, fullPartition);
  req.input('startDate', sql.Date, startDate);

  // We replace the hard-coded [ACVSUJournal_00010029] in your previous query with the latestDb
  const query = `
SELECT 
    t1.[ObjectName1],
    t1.[ObjectName2],
    t1.[PartitionName2],
    CASE
        WHEN t2.[Int1] = 0 THEN t2.[Text12]
        ELSE CAST(t2.[Int1] AS NVARCHAR)
    END AS EmployeeID,
    t3.[Name] AS PersonnelType,
    t2.text5,
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    DATEADD(HOUR, -2, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) AS AdjustedMessageTime
INTO 
    #CombinedEmployeeData
FROM ${quoteIdent(latestDb)}.dbo.ACVSUJournalLog AS t1
INNER JOIN 
    ACVSCore.Access.Personnel AS t2
    ON t1.ObjectIdentity1 = t2.GUID
INNER JOIN 
    ACVSCore.Access.PersonnelType AS t3
    ON t2.[PersonnelTypeId] = t3.[ObjectID];

-- Step 2: Daily duration per employee
WITH DailyDurations AS (
    SELECT 
        [ObjectName1],
        PersonnelType,
        EmployeeID,
        [PartitionName2],
        text5,
        CONVERT(DATE, AdjustedMessageTime) AS ShiftedDate,
        DATEPART(WEEK, AdjustedMessageTime) AS WeekNumber,
        DATEPART(YEAR, AdjustedMessageTime) AS YearNumber,
        MIN(LocaleMessageTime) AS FirstSwipeTime,
        MAX(LocaleMessageTime) AS LastSwipeTime,
        DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) AS DurationMinutes,
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) / 60 AS NVARCHAR), 2)
        + ':' +
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) % 60 AS NVARCHAR), 2) AS DurationHHMM,
        CASE 
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 5 THEN '<5mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 10 THEN '<10mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 20 THEN '<20mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 30 THEN '<30mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 60 THEN '<1hr'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 120 THEN 'Less than <2hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 180 THEN 'Less than <3hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 240 THEN 'Less than <4hrs'
            ELSE '4+ hrs'
        END AS TimeDiffCategory
    FROM 
        #CombinedEmployeeData

  WHERE CONVERT(DATE, AdjustedMessageTime) >= @startDate

   AND [PartitionName2] = 'APAC.Default'
        AND PersonnelType IN ('Employee', 'Terminated Personnel')
    GROUP BY 
        [ObjectName1], EmployeeID, PersonnelType, text5, [PartitionName2],
        CONVERT(DATE, AdjustedMessageTime),
        DATEPART(WEEK, AdjustedMessageTime),
        DATEPART(YEAR, AdjustedMessageTime)
),

-- Step 3: Weekly summary
WeeklySummary AS (
    SELECT 
        EmployeeID,
        [ObjectName1],
        PersonnelType,
        text5,
        [PartitionName2],
        YearNumber,
        WeekNumber,
        COUNT(DISTINCT ShiftedDate) AS DaysPresentInWeek,
        SUM(CASE WHEN DurationMinutes < 240 THEN 1 ELSE 0 END) AS ViolationDaysInWeek
    FROM 
        DailyDurations
    GROUP BY 
        EmployeeID, [ObjectName1], PersonnelType, text5, [PartitionName2], YearNumber, WeekNumber
)

-- Step 4: Final output with daily duration, category, and defaulter flag
SELECT 
    dd.EmployeeID,
    dd.ObjectName1,
    dd.PersonnelType,
    dd.text5,
    dd.PartitionName2,
    dd.YearNumber,
    dd.WeekNumber,
    dd.ShiftedDate,
    dd.FirstSwipeTime,
    dd.LastSwipeTime,
    dd.DurationHHMM,
    dd.TimeDiffCategory,
    ws.DaysPresentInWeek,
    ws.ViolationDaysInWeek,
    (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) AS CleanDaysInWeek,
    CASE
        WHEN (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) < 3 THEN 'Yes'
        ELSE 'No'
    END AS Defaulter
FROM 
    DailyDurations dd
JOIN 
    WeeklySummary ws
    ON dd.EmployeeID = ws.EmployeeID
    AND dd.WeekNumber = ws.WeekNumber
    AND dd.YearNumber = ws.YearNumber
ORDER BY 
    dd.YearNumber DESC, dd.WeekNumber DESC, dd.EmployeeID, dd.ShiftedDate;
  `;

  const { recordset } = await req.query(query);
  return recordset;
}

/**
 * eurocAdmitRejectionReport - uses union across recent DBs similar to rejectionReport
 */
export async function eurocAdmitRejectionReport(region, { reportDate }) {
  if (!region) throw new Error('region required');
  const dbList = await getRecentDatabases(region, 10);
  const pool = await getPool(region);
  const req = pool.request();
  req.timeout = 300000;

  req.input('location', sql.NVarChar, 'LT.Vilnius');
  req.input('reportDate', sql.Date, reportDate);

  const perDbSelect = (db) => `
    SELECT 
       DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
       t1.ObjectName1,
       t1.PartitionName2       AS location,
       t5_card.CardNumber,
       t5_admit.value          AS AdmitCode,
       t5_dir.value            AS Direction,
       t1.ObjectName2          AS Door,
       t5_rej.value            AS Rejection_Type,
       CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
            THEN t2.Text12
            ELSE CAST(t2.Int1 AS NVARCHAR)
       END                       AS EmployeeID,
       t3.Name                  AS PersonnelType,
       t1.MessageType,
       t1.XmlGUID
    FROM ${quoteIdent(db)}.dbo.ACVSUJournalLog AS t1
    LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
    LEFT JOIN ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred       AS t5_admit
      ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
    LEFT JOIN ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred       AS t5_dir
      ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
    LEFT JOIN ${quoteIdent(db)}.dbo.ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
    LEFT JOIN (
      SELECT GUID, [value]
      FROM ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred
      WHERE [Name] IN ('Card','CHUID')
    ) AS SCard ON t1.XmlGUID = SCard.GUID
    OUTER APPLY (
      SELECT COALESCE(
        TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
        TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
        SCard.[value]
      ) AS CardNumber
    ) AS t5_card
    LEFT JOIN ${quoteIdent(db)}.dbo.ACVSUJournalLogxmlShred AS t5_rej
      ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
    WHERE
      t1.MessageType IN ('CardAdmitted' , 'CardRejected')
      AND t1.PartitionName2 = @location
      AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @reportDate
  `;

  const combined = buildUnionAcrossDbs(dbList, perDbSelect);

  const finalQuery = `
WITH CombinedQuery AS(
  ${combined}
)

-- materialize CombinedQuery into a temp table
SELECT
  LocaleMessageTime,
  CONVERT(date, LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  MessageType
INTO #Combined
FROM CombinedQuery;

-- create admits with row number (first admit per employee)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  ROW_NUMBER() OVER (PARTITION BY ISNULL(EmployeeID, CardNumber) ORDER BY LocaleMessageTime ASC) AS rn
INTO #Admits
FROM #Combined
WHERE MessageType = 'CardAdmitted'
  AND PersonnelType IN('Employee', 'Terminated Personnel');

-- create rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
INTO #Rejections
FROM #Combined
WHERE MessageType = 'CardRejected';

-- resultset 1: admits (only rn = 1)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Admits
WHERE rn = 1
ORDER BY LocaleMessageTime ASC;

-- resultset 2: rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Rejections
ORDER BY LocaleMessageTime ASC;

-- resultset 3: summary counts by Rejection_Type
SELECT
  ISNULL(Rejection_Type, 'Unknown') AS Rejection_Type,
  COUNT(*) AS CountVal
FROM #Rejections
GROUP BY ISNULL(Rejection_Type, 'Unknown')
ORDER BY CountVal DESC;

-- cleanup temp tables
DROP TABLE IF EXISTS #Admits;
DROP TABLE IF EXISTS #Rejections;
DROP TABLE IF EXISTS #Combined;
`;

  const result = await req.query(finalQuery);
  const recordsets = result.recordsets || [];
  const admitRows = (recordsets[0] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const rejectRows = (recordsets[1] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Rejection_Type: r.Rejection_Type,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const summaryRows = (recordsets[2] || []).map(r => ({ Rejection_Type: r.Rejection_Type, Count: r.CountVal }));

  return { admit: admitRows, rejection: rejectRows, summary: summaryRows };
}















