Read Below File carefully keep all Logic same just remove Q1/Q2/Q3/Q4 Avg columns 
We dont need this keep All report as same Previous and share me Updated file 

# denverAttendance_updated_quarters.py
# Adds Q1/Q2/Q3/Q4 Avg columns after each quarter end and applies full borders with thick outer border.
# Minimal changes from previous working file: only adds quarter avg columns and border handling.

import os
from datetime import date, datetime, timedelta
from pathlib import Path
import pandas as pd
import re

ODBC_DRIVER = os.getenv("ODBC_DRIVER", "ODBC Driver 17 for SQL Server")
DB_SERVER = os.getenv("DB_SERVER", "SRVWUDEN0890V")
DB_USER = os.getenv("DB_USER", "GSOC_Test")
DB_PASSWORD = os.getenv("DB_PASSWORD", "Westernuniongsoc@2025")

DB_LIST = [
    "ACVSUJournal_00010021",
    "ACVSUJournal_00010020",
    "ACVSUJournal_00010019",
]

SQL_TEMPLATE = r"""
SELECT
    t1.[ObjectName1] AS EmployeeName,
    t1.[ObjectName2] AS Door,
    CASE WHEN t2.[Int1] = 0 THEN t2.[Text12] ELSE CAST(t2.[Int1] AS NVARCHAR(200)) END AS EmployeeID,
    t3.[Name] AS PersonnelTypeName,
    CAST(t1.ObjectIdentity1 AS NVARCHAR(200)) AS EmployeeIdentity,
    t1.PartitionName2,
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    t2.Text5 AS PrimaryLocation,
    CASE
        WHEN t1.[ObjectName2] LIKE '%HQ%' THEN 'Denver'
        WHEN t1.[ObjectName2] LIKE '%Austin%' THEN 'Austin'
        WHEN t1.[ObjectName2] LIKE '%Miami%' THEN 'Miami'
        WHEN t1.[ObjectName2] LIKE '%NYC%' THEN 'New York'
        WHEN t1.[ObjectName2] LIKE 'APAC_PI%' THEN 'Taguig City'
        WHEN t1.[ObjectName2] LIKE 'APAC_PH%' THEN 'Quezon City'
        WHEN t1.[ObjectName2] LIKE '%PUN%' THEN 'Pune'
        WHEN t1.[ObjectName2] LIKE '%HYD%' THEN 'Hyderabad'
        ELSE t1.[PartitionName2]
    END AS LogicalLocation
FROM [{db}].dbo.ACVSUJournalLog AS t1
INNER JOIN ACVSCore.Access.Personnel AS t2 ON t1.ObjectIdentity1 = t2.GUID
INNER JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeID = t3.ObjectID
WHERE
    t1.MessageType = 'CardAdmitted'
    AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) BETWEEN '{start}' AND '{end}'
    AND (
        t1.[ObjectName2] LIKE '%HQ%'
        OR (t2.Text5 IS NOT NULL AND LOWER(t2.Text5) LIKE '%denver%' AND LOWER(t2.Text5) LIKE '%hq%')
        OR t1.[PartitionName2] = 'Denver'
    )
    AND LOWER(LTRIM(RTRIM(t3.[Name]))) IN ('employee','terminated personnel')
"""

def _get_engine(database: str) -> 'sqlalchemy.engine.Engine':
    from sqlalchemy import create_engine
    from urllib.parse import quote_plus
    odbc_str = (
        f"DRIVER={{{ODBC_DRIVER}}};"
        f"SERVER={DB_SERVER};"
        f"DATABASE={database};"
        f"UID={DB_USER};"
        f"PWD={DB_PASSWORD};"
        "TrustServerCertificate=Yes;Connection Timeout=30;"
    )
    quoted = quote_plus(odbc_str)
    url = f"mssql+pyodbc:///?odbc_connect={quoted}"
    return create_engine(url, pool_pre_ping=True, fast_executemany=True)

def _fetch_swipes_between(start_date: date, end_date: date) -> pd.DataFrame:
    start_s = start_date.strftime("%Y-%m-%d")
    end_s = end_date.strftime("%Y-%m-%d")
    frames = []
    for db in DB_LIST:
        sql = SQL_TEMPLATE.format(db=db, start=start_s, end=end_s)
        try:
            engine = _get_engine(db)
            with engine.connect() as conn:
                df = pd.read_sql(sql, conn)
            if not df.empty:
                df["SourceDB"] = db
                frames.append(df)
        except Exception:
            continue
    if not frames:
        return pd.DataFrame()
    out = pd.concat(frames, ignore_index=True)
    out.columns = [c.strip() for c in out.columns]
    out["LocaleMessageTime"] = pd.to_datetime(out.get("LocaleMessageTime"), errors="coerce")
    return out

def generate_monthly_denver_report(start_date: date = None, end_date: date = None, outdir: str = None) -> str:
    if start_date is None:
        start_date = date(2025, 1, 1)
    if end_date is None:
        end_date = datetime.now().date()
    swipes = _fetch_swipes_between(start_date, end_date)

    # Deduplicate and filter (keep original logic intent)
    swipes["DateOnly"] = swipes["LocaleMessageTime"].dt.date.fillna(pd.NaT)
    def _dedupe_key(row):
        for col in ("EmployeeIdentity", "EmployeeID", "EmployeeName"):
            val = str(row.get(col)).strip() if row.get(col) else None
            if val and val.lower() not in ('', 'nan', 'none', 'null'):
                return val
        return None
    if swipes.empty:
        ordered_days = []
        cur = start_date
        while cur <= end_date:
            ordered_days.append(cur)
            cur += timedelta(days=1)
        return _write_excel([], ordered_days, {}, outdir, start_date, end_date)

    swipes["dedupe_key"] = swipes.apply(_dedupe_key, axis=1)
    swipes = swipes[swipes["dedupe_key"].notna()]
    swipes = swipes[swipes["PersonnelTypeName"].str.strip().str.lower().isin(["employee", "terminated personnel"])]
    swipes = swipes[swipes["LogicalLocation"].str.strip().str.lower() == "denver"]
    swipes = swipes.sort_values(["dedupe_key", "DateOnly", "LocaleMessageTime"], ascending=[True, True, False])
    swipes = swipes.drop_duplicates(subset=["dedupe_key", "DateOnly"], keep="first")

    # ordered days list
    ordered_days = []
    cur = start_date
    while cur <= end_date:
        ordered_days.append(cur)
        cur += timedelta(days=1)

    # presence matrix (index = dedupe_key, columns = date objects)
    presence = pd.DataFrame(0, index=sorted(swipes["dedupe_key"].unique()), columns=ordered_days)
    for _, r in swipes.iterrows():
        uid = r["dedupe_key"]
        d = r["DateOnly"]
        if pd.isna(d):
            continue
        try:
            presence.at[uid, d] = 1
        except Exception:
            continue

    meta = swipes.groupby("dedupe_key", as_index=True).agg({
        "EmployeeName": "first",
        "EmployeeID": "first",
        "PersonnelTypeName": "first"
    })

    # Build rows (list of dicts)
    rows = []
    for uid in sorted(meta.index):
        empid = meta.loc[uid, "EmployeeID"]
        empname = meta.loc[uid, "EmployeeName"]
        row = {"Emp ID": empid, "Emp Name": empname}
        for d in ordered_days:
            key = d.strftime("%Y-%m-%d")
            value = int(presence.at[uid, d]) if (uid in presence.index and d in presence.columns) else 0
            row[key] = value
        rows.append(row)
    df = pd.DataFrame(rows)

    # Create months mapping maintaining chronological order
    months = {}
    for d in ordered_days:
        mon_key = d.strftime("%b")  # e.g., Jan, Feb
        months.setdefault(mon_key, []).append(d.strftime("%Y-%m-%d"))

    return _write_excel(df, ordered_days, months, outdir, start_date, end_date)

def _write_excel(df, ordered_days, months, outdir, start_date, end_date):
    outdir = Path(outdir or Path.cwd() / "output")
    outdir.mkdir(parents=True, exist_ok=True)
    fname = outdir / f"denver_attendance_{start_date.strftime('%Y%m%d')}_{end_date.strftime('%Y%m%d')}.xlsx"

    import xlsxwriter
    workbook = xlsxwriter.Workbook(str(fname))
    worksheet = workbook.add_worksheet("Attendance")
    worksheet.hide_gridlines(2)

    # Base style dicts (so we can reuse and add thick borders later)
    center_style = {"border": 1, "align": "center", "valign": "vcenter"}
    header_style = {"bold": True, **center_style, "bg_color": "#87CEEB"}
    present_style = {**center_style, "bg_color": "#C6EFCE"}     # light green
    absent_style = {**center_style, "bg_color": "#FFC7CE"}      # light red for absent
    weekend_header_style = {**center_style, "bg_color": "#FFDADA", "bold": True}
    weekend_cell_style = {**center_style, "bg_color": "#FFDADA"}
    month_total_header_style = {**center_style, "bg_color": "#FFEB9C", "bold": True}
    month_total_cell_style = {**center_style, "bg_color": "#FFEB9C"}
    grand_total_style = {**center_style, "bg_color": "#FFEB9C", "bold": True}
    empname_style = {**center_style}

    # Create formats from styles
    header_fmt = workbook.add_format(header_style)
    present_fmt = workbook.add_format(present_style)
    absent_fmt = workbook.add_format(absent_style)
    weekend_header_fmt = workbook.add_format(weekend_header_style)
    weekend_cell_fmt = workbook.add_format(weekend_cell_style)
    month_total_header_fmt = workbook.add_format(month_total_header_style)
    month_total_cell_fmt = workbook.add_format(month_total_cell_style)
    grand_total_fmt = workbook.add_format(grand_total_style)
    empname_fmt = workbook.add_format(empname_style)

    # Build final columns in desired order and capture quarter day mappings
    final_columns = ["Emp ID", "Emp Name"]
    # ensure months chronological
    seen = []
    for d in ordered_days:
        m = d.strftime("%b")
        if m not in seen:
            seen.append(m)
    month_order = seen
    month_day_lists = [months.get(m, []) for m in month_order]

    # Quarter mapping: q -> list of day strings
    quarter_map = {}
    for idx, (m, day_list) in enumerate(zip(month_order, month_day_lists), start=1):
        final_columns.extend(day_list)
        final_columns.append(f"{m} Total")
        # Determine if end of quarter
        m_num = datetime.strptime(f"{m} 1 2000", "%b %d %Y").month
        if m_num % 3 == 0:
            q = (m_num - 1) // 3 + 1
            # collect quarter days: last 3 months in month_order
            q_months = month_order[idx-3:idx] if idx-3 >= 0 else month_order[0:idx]
            q_days = []
            for qm in q_months:
                q_days.extend(months.get(qm, []))
            quarter_map[q] = q_days
            final_columns.append(f"Q{q} Avg")

    final_columns.append("Grand Total")

    # Write header row with formatted date strings and capture header labels
    header_labels = []
    for col_idx, col_name in enumerate(final_columns):
        if re.match(r"\d{4}-\d{2}-\d{2}", str(col_name)):
            d = datetime.strptime(col_name, "%Y-%m-%d").date()
            header_label = f"{d.strftime('%a')}, {d.day} {d.strftime('%B')}, {d.year}"
            header_labels.append(header_label)
            if d.weekday() >= 5:
                worksheet.write(0, col_idx, header_label, weekend_header_fmt)
            else:
                worksheet.write(0, col_idx, header_label, header_fmt)
        elif str(col_name).endswith("Total") or str(col_name).endswith("Avg") or str(col_name) == "Grand Total":
            header_labels.append(col_name)
            worksheet.write(0, col_idx, col_name, month_total_header_fmt)
        else:
            header_labels.append(col_name)
            worksheet.write(0, col_idx, col_name, header_fmt)

    # Set column widths
    worksheet.set_column(0, 0, 15)  # Emp ID
    worksheet.set_column(1, 1, 30)  # Emp Name
    worksheet.set_column(2, len(final_columns)-1, 12)

    # Write employee rows
    df_rows = [] if isinstance(df, (list, tuple)) else (df.to_dict(orient="records") if not df.empty else [])
    start_row = 1
    for r_idx, row in enumerate(df_rows):
        excel_row = start_row + r_idx
        worksheet.write(excel_row, 0, row.get("Emp ID"), empname_fmt)
        worksheet.write(excel_row, 1, row.get("Emp Name"), empname_fmt)
        col_ptr = 2
        # iterate months and insert month totals and Q avgs when needed
        for idx, (m, day_list) in enumerate(zip(month_order, month_day_lists), start=1):
            for day in day_list:
                val = int(row.get(day, 0) or 0)
                d = datetime.strptime(day, "%Y-%m-%d").date()
                if val == 1:
                    worksheet.write(excel_row, col_ptr, val, present_fmt)
                else:
                    if d.weekday() >= 5:
                        worksheet.write(excel_row, col_ptr, val, weekend_cell_fmt)
                    else:
                        worksheet.write(excel_row, col_ptr, val, absent_fmt)
                col_ptr += 1
            # month total
            month_total = sum(int(row.get(day, 0) or 0) for day in day_list)
            worksheet.write(excel_row, col_ptr, month_total, month_total_cell_fmt)
            col_ptr += 1
            # if end of quarter, write Q avg
            m_num = datetime.strptime(f"{m} 1 2000", "%b %d %Y").month
            if m_num % 3 == 0:
                q = (m_num - 1) // 3 + 1
                q_days = quarter_map.get(q, [])
                q_total = sum(int(row.get(day, 0) or 0) for day in q_days)
                q_avg = round(q_total / len(q_days), 2) if q_days else 0
                worksheet.write(excel_row, col_ptr, q_avg, month_total_cell_fmt)
                col_ptr += 1

        # grand total
        all_date_cols = [c for c in row.keys() if re.match(r"\d{4}-\d{2}-\d{2}", str(c))]
        grand = sum(int(row.get(day, 0) or 0) for day in all_date_cols)
        worksheet.write(excel_row, col_ptr, grand, grand_total_fmt)

    # After all employees, write summary row (Total) with day sums, month sums, and Q averages (mean of employee Q avgs)
    summary_row = start_row + len(df_rows)
    worksheet.write(summary_row, 0, "Total", month_total_header_fmt)
    worksheet.write(summary_row, 1, "", month_total_header_fmt)
    col_ptr = 2
    for idx, (m, day_list) in enumerate(zip(month_order, month_day_lists), start=1):
        for day in day_list:
            if isinstance(df, (list, tuple)) or df.empty:
                day_sum = 0
            else:
                day_sum = int(df.get(day, pd.Series(dtype=int)).sum())
            worksheet.write(summary_row, col_ptr, day_sum, month_total_cell_fmt)
            col_ptr += 1
        # month total (sum of day sums)
        if isinstance(df, (list, tuple)) or df.empty:
            msum = 0
        else:
            msum = int(df[[d for d in day_list]].sum(axis=1).sum())
        worksheet.write(summary_row, col_ptr, msum, month_total_cell_fmt)
        col_ptr += 1
        # quarter avg for summary: average of per-employee q_avg
        m_num = datetime.strptime(f"{m} 1 2000", "%b %d %Y").month
        if m_num % 3 == 0:
            q = (m_num - 1) // 3 + 1
            q_days = quarter_map.get(q, [])
            if isinstance(df, (list, tuple)) or df.empty or not q_days:
                summary_q_avg = 0
            else:
                per_emp_q_avgs = (df[[d for d in q_days]].sum(axis=1) / len(q_days)).round(2)
                summary_q_avg = round(float(per_emp_q_avgs.mean()), 2) if not per_emp_q_avgs.empty else 0
            worksheet.write(summary_row, col_ptr, summary_q_avg, month_total_cell_fmt)
            col_ptr += 1

    # Grand total cell
    grand_col_idx = len(final_columns) - 1
    if isinstance(df, (list, tuple)) or df.empty:
        grand_total_val = 0
    else:
        day_cols = [c for c in df.columns if re.match(r"\d{4}-\d{2}-\d{2}", c)]
        grand_total_val = int(df[day_cols].sum(axis=1).sum()) if day_cols else 0
    worksheet.write(summary_row, grand_col_idx, grand_total_val, grand_total_fmt)

    # Freeze header
    worksheet.freeze_panes(1, 2)

    # Apply thick outer border: top row (header), bottom row (summary), leftmost col, rightmost col
    last_row = summary_row
    last_col = len(final_columns) - 1

    # helper to create format dicts preserving bg and borders
    def make_fmt(base_style, extra=None):
        s = dict(base_style)
        s["border"] = s.get("border", 1)
        if extra:
            s.update(extra)
        return workbook.add_format(s)

    # Top border: rewrite header row with top border thick
    for c_idx, col_name in enumerate(final_columns):
        base_style = header_style if not (str(col_name).endswith("Total") or str(col_name).endswith("Avg") or str(col_name)=="Grand Total") else month_total_header_style
        if re.match(r"\d{4}-\d{2}-\d{2}", str(col_name)):
            d = datetime.strptime(col_name, "%Y-%m-%d").date()
            if d.weekday() >= 5:
                base_style = weekend_header_style
        extra = {"top": 2}
        fmt = make_fmt(base_style, extra)
        worksheet.write(0, c_idx, header_labels[c_idx], fmt)

    # Bottom border: rewrite summary row with bottom thick
    for c_idx, col_name in enumerate(final_columns):
        base_style = month_total_cell_style
        extra = {"bottom": 2}
        fmt = make_fmt(base_style, extra)
        # compute value similar to earlier
        if c_idx == 0:
            value = "Total"
        elif c_idx == 1:
            value = ""
        else:
            name = col_name
            if re.match(r"\d{4}-\d{2}-\d{2}", str(name)):
                if isinstance(df, (list, tuple)) or df.empty:
                    value = 0
                else:
                    value = int(df.get(name, pd.Series(dtype=int)).sum())
            elif str(name).endswith("Total") and str(name) != "Grand Total":
                mon = str(name).replace(" Total", "")
                day_list = months.get(mon, [])
                if isinstance(df, (list, tuple)) or df.empty:
                    value = 0
                else:
                    value = int(df[[d for d in day_list]].sum(axis=1).sum()) if day_list else 0
            elif str(name).startswith("Q") and "Avg" in str(name):
                q = int(str(name).replace("Q", "").replace(" Avg", ""))
                q_days = quarter_map.get(q, [])
                if isinstance(df, (list, tuple)) or df.empty or not q_days:
                    value = 0
                else:
                    per_emp_q_avgs = (df[[d for d in q_days]].sum(axis=1) / len(q_days)).round(2)
                    value = round(float(per_emp_q_avgs.mean()), 2) if not per_emp_q_avgs.empty else 0
            elif str(name) == "Grand Total":
                if isinstance(df, (list, tuple)) or df.empty:
                    value = 0
                else:
                    day_cols = [c for c in df.columns if re.match(r"\d{4}-\d{2}-\d{2}", c)]
                    value = int(df[day_cols].sum(axis=1).sum()) if day_cols else 0
            else:
                value = ""
        worksheet.write(summary_row, c_idx, value, fmt)

    # Left border: add thick left border to first column for all rows from 0..last_row
    for r in range(0, last_row + 1):
        if r == 0:
            base = header_style
        elif r == summary_row:
            base = month_total_cell_style
        else:
            base = empname_style
        fmt = make_fmt(base, {"left": 2})
        if r == 0:
            val = header_labels[0]
        elif r == summary_row:
            val = "Total"
        else:
            idx = r - start_row
            if 0 <= idx < len(df_rows):
                val = df_rows[idx].get("Emp ID")
            else:
                val = ""
        worksheet.write(r, 0, val, fmt)

    # Right border: add thick right border to last column for all rows 0..last_row
    for r in range(0, last_row + 1):
        if r == 0:
            base = header_style
        elif r == summary_row:
            base = month_total_cell_style
        else:
            base = grand_total_style
        fmt = make_fmt(base, {"right": 2})
        c = last_col
        if r == 0:
            val = header_labels[c]
        elif r == summary_row:
            if isinstance(df, (list, tuple)) or df.empty:
                val = 0
            else:
                day_cols = [c for c in df.columns if re.match(r"\d{4}-\d{2}-\d{2}", c)]
                val = int(df[day_cols].sum(axis=1).sum()) if day_cols else 0
        else:
            idx = r - start_row
            if 0 <= idx < len(df_rows):
                row = df_rows[idx]
                all_date_cols = [c for c in row.keys() if re.match(r"\d{4}-\d{2}-\d{2}", str(c))]
                val = sum(int(row.get(day, 0) or 0) for day in all_date_cols)
            else:
                val = ""
        worksheet.write(r, c, val, fmt)

    workbook.close()
    return str(fname)

if __name__ == "__main__":
    path = generate_monthly_denver_report()
    print("Wrote:", path)



