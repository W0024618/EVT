Now 
i have update each file as per above suggestion now we got below error fix this error and share me fully updated file carefully

üåç Global-backend listening on http://localhost:3008
PS C:\Users\W0024618\Desktop\global-page\backend> npm run start:backend

> global-page@1.0.0 start:backend
> cd backend && node index.js

üåç Global-backend listening on http://localhost:3008
PS C:\Users\W0024618\Desktop\global-page\backend> npm run start:backend

> global-page@1.0.0 start:backend
> cd backend && node index.js

üåç Global-backend listening on http://localhost:3008
PS C:\Users\W0024618\Desktop\global-page\backend> npm run start:backend

> global-page@1.0.0 start:backend
> cd backend && node index.js

üåç Global-backend listening on http://localhost:3008
PS C:\Users\W0024618\Desktop\global-page\backend> ^C
PS C:\Users\W0024618\Desktop\global-page\backend> npm run start:backend

> global-page@1.0.0 start:backend
> cd backend && node index.js

üåç Global-backend listening on http://localhost:3008
SQL stream error RequestError: Incorrect syntax near the keyword 'AS'.
    at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:384:15)    
    at Connection.emit (node:events:518:28)
    at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18)   
    at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
    at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
    at Readable.emit (node:events:518:28)
    at addChunk (node:internal/streams/readable:561:12)
    at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
    at Readable.push (node:internal/streams/readable:393:5)
    at nextAsync (node:internal/streams/from:194:22)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
  code: 'EREQUEST',
  originalError: Error: Incorrect syntax near the keyword 'AS'.
      at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:382:19)  
      at Connection.emit (node:events:518:28)
      at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18) 
      at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
      at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
      at Readable.emit (node:events:518:28)
      at addChunk (node:internal/streams/readable:561:12)
      at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
      at Readable.push (node:internal/streams/readable:393:5)
      at nextAsync (node:internal/streams/from:194:22)
      at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
    info: ErrorMessageToken {
      name: 'ERROR',
      handlerName: 'onErrorMessage',
      number: 156,
      state: 1,
      class: 15,
      message: "Incorrect syntax near the keyword 'AS'.",
      serverName: 'SRVWUDEN0891V',
      procName: '',
      lineNumber: 36
    }
  },
  number: 156,
  lineNumber: 36,
  state: 1,
  class: 15,
  serverName: 'SRVWUDEN0891V',
  procName: ''
}
SQL stream error RequestError: Incorrect syntax near the keyword 'AS'.
    at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:384:15)    
    at Connection.emit (node:events:518:28)
    at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18)   
    at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
    at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
    at Readable.emit (node:events:518:28)
    at addChunk (node:internal/streams/readable:561:12)
    at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
    at Readable.push (node:internal/streams/readable:393:5)
    at nextAsync (node:internal/streams/from:194:22)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
  code: 'EREQUEST',
  originalError: Error: Incorrect syntax near the keyword 'AS'.
      at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:382:19)  
      at Connection.emit (node:events:518:28)
      at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18) 
      at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
      at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
      at Readable.emit (node:events:518:28)
      at addChunk (node:internal/streams/readable:561:12)
      at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
      at Readable.push (node:internal/streams/readable:393:5)
      at nextAsync (node:internal/streams/from:194:22)
      at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
    info: ErrorMessageToken {
      name: 'ERROR',
      handlerName: 'onErrorMessage',
      number: 156,
      state: 1,
      class: 15,
      message: "Incorrect syntax near the keyword 'AS'.",
      serverName: 'SRVWUDEN0891V',
      procName: '',
      lineNumber: 36
    }
  },
  number: 156,
  lineNumber: 36,
  state: 1,
  class: 15,
  serverName: 'SRVWUDEN0891V',
  procName: ''
}
SQL stream error RequestError: Incorrect syntax near the keyword 'AS'.
    at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:384:15)    
    at Connection.emit (node:events:518:28)
    at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18)   
    at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
    at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
    at Readable.emit (node:events:518:28)
    at addChunk (node:internal/streams/readable:561:12)
    at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
    at Readable.push (node:internal/streams/readable:393:5)
    at nextAsync (node:internal/streams/from:194:22)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
  code: 'EREQUEST',
  originalError: Error: Incorrect syntax near the keyword 'AS'.
      at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:382:19)  
      at Connection.emit (node:events:518:28)
      at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18) 
      at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
      at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
      at Readable.emit (node:events:518:28)
      at addChunk (node:internal/streams/readable:561:12)
      at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
      at Readable.push (node:internal/streams/readable:393:5)
      at nextAsync (node:internal/streams/from:194:22)
      at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
    info: ErrorMessageToken {
      name: 'ERROR',
      handlerName: 'onErrorMessage',
      number: 156,
      state: 1,
      class: 15,
      message: "Incorrect syntax near the keyword 'AS'.",
      serverName: 'SRVWUDEN0891V',
      procName: '',
      lineNumber: 51
    }
  },
  number: 156,
  lineNumber: 51,
  state: 1,
  class: 15,
  serverName: 'SRVWUDEN0891V',
  procName: ''
}
SQL stream error RequestError: Incorrect syntax near the keyword 'AS'.
    at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:384:15)    
    at Connection.emit (node:events:518:28)
    at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18)   
    at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
    at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
    at Readable.emit (node:events:518:28)
    at addChunk (node:internal/streams/readable:561:12)
    at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
    at Readable.push (node:internal/streams/readable:393:5)
    at nextAsync (node:internal/streams/from:194:22)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
  code: 'EREQUEST',
  originalError: Error: Incorrect syntax near the keyword 'AS'.
      at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:382:19)  
      at Connection.emit (node:events:518:28)
      at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18) 
      at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
      at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
      at Readable.emit (node:events:518:28)
      at addChunk (node:internal/streams/readable:561:12)
      at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
      at Readable.push (node:internal/streams/readable:393:5)
      at nextAsync (node:internal/streams/from:194:22)
      at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
    info: ErrorMessageToken {
      name: 'ERROR',
      handlerName: 'onErrorMessage',
      number: 156,
      state: 1,
      class: 15,
      message: "Incorrect syntax near the keyword 'AS'.",
      serverName: 'SRVWUDEN0891V',
      procName: '',
      lineNumber: 51
    }
  },
  number: 156,
  lineNumber: 51,
  state: 1,
  class: 15,
  serverName: 'SRVWUDEN0891V',
  procName: ''
}
SQL stream error RequestError: Incorrect syntax near the keyword 'AS'.
    at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:384:15)    
    at Connection.emit (node:events:518:28)
    at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18)   
    at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
    at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
    at Readable.emit (node:events:518:28)
    at addChunk (node:internal/streams/readable:561:12)
    at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
    at Readable.push (node:internal/streams/readable:393:5)
    at nextAsync (node:internal/streams/from:194:22)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
  code: 'EREQUEST',
  originalError: Error: Incorrect syntax near the keyword 'AS'.
      at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:382:19)  
      at Connection.emit (node:events:518:28)
      at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18) 
      at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
      at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
      at Readable.emit (node:events:518:28)
      at addChunk (node:internal/streams/readable:561:12)
      at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
      at Readable.push (node:internal/streams/readable:393:5)
      at nextAsync (node:internal/streams/from:194:22)
      at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
    info: ErrorMessageToken {
      name: 'ERROR',
      handlerName: 'onErrorMessage',
      number: 156,
      state: 1,
      class: 15,
      message: "Incorrect syntax near the keyword 'AS'.",
      serverName: 'SRVWUDEN0891V',
      procName: '',
      lineNumber: 58
    }
  },
  number: 156,
  lineNumber: 58,
  state: 1,
  class: 15,
  serverName: 'SRVWUDEN0891V',
  procName: ''
}
SQL stream error RequestError: Incorrect syntax near the keyword 'AS'.
    at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:384:15)    
    at Connection.emit (node:events:518:28)
    at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18)   
    at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
    at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
    at Readable.emit (node:events:518:28)
    at addChunk (node:internal/streams/readable:561:12)
    at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
    at Readable.push (node:internal/streams/readable:393:5)
    at nextAsync (node:internal/streams/from:194:22)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
  code: 'EREQUEST',
  originalError: Error: Incorrect syntax near the keyword 'AS'.
      at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:382:19)  
      at Connection.emit (node:events:518:28)
      at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18) 
      at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
      at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
      at Readable.emit (node:events:518:28)
      at addChunk (node:internal/streams/readable:561:12)
      at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
      at Readable.push (node:internal/streams/readable:393:5)
      at nextAsync (node:internal/streams/from:194:22)
      at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
    info: ErrorMessageToken {
      name: 'ERROR',
      handlerName: 'onErrorMessage',
      number: 156,
      state: 1,
      class: 15,
      message: "Incorrect syntax near the keyword 'AS'.",
      serverName: 'SRVWUDEN0891V',
      procName: '',
      lineNumber: 58
    }
  },
  number: 156,
  lineNumber: 58,
  state: 1,
  class: 15,
  serverName: 'SRVWUDEN0891V',
  procName: ''
}
safeCommit: workbook.commit failed ArchiverError: archive already finalizing
    at Archiver.finalize (C:\Users\W0024618\Desktop\global-page\node_modules\archiver\lib\core.js:778:27)      
    at C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:342:16    
    at new Promise (<anonymous>)
    at WorkbookWriter._finalize (C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:335:12)
    at WorkbookWriter.commit (C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:111:17)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async Request.<anonymous> (file:///C:/Users/W0024618/Desktop/global-page/backend/services/reportService.js:2381:11) {
  code: 'FINALIZING',
  data: undefined
}

node:internal/process/promises:394
    triggerUncaughtException(err, true /* fromPromise */);
    ^
ArchiverError: archive already finalizing
    at Archiver.finalize (C:\Users\W0024618\Desktop\global-page\node_modules\archiver\lib\core.js:778:27)      
    at C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:342:16    
    at new Promise (<anonymous>)
    at WorkbookWriter._finalize (C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:335:12)
    at WorkbookWriter.commit (C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:111:17)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async Request.<anonymous> (file:///C:/Users/W0024618/Desktop/global-page/backend/services/reportService.js:2381:11) {
  code: 'FINALIZING',
  data: undefined
}

Node.js v22.17.0
PS C:\Users\W0024618\Desktop\global-page\backend> 



//C:\Users\W0024618\Desktop\global-page\backend\services\reportService.js

 import { getPool, sql } from '../config/dbConfig.js';
 
import ExcelJS from 'exceljs';




// export async function listLocations(region) {
//   if (!region) throw new Error('region required');
//   const pool = await getPool(region);
//   const req = pool.request();
//   // get distinct PartitionName2 values
//   const q = `SELECT DISTINCT PartitionName2 FROM ACVSUJournalLog WHERE PartitionName2 IS NOT NULL ORDER BY PartitionName2`;
//   const { recordset } = await req.query(q);
//   return (recordset || []).map(r => r.PartitionName2).filter(Boolean);
// }



export async function listLocations(region) {
  if (!region) throw new Error('region required');
  const pool = await getPool(region);
  const req = pool.request();



  if ((region || '').toLowerCase() === 'namer') {
    const q = `
      SELECT DISTINCT LogicalLocation
      FROM (
        SELECT
          CASE
            WHEN ObjectName2 LIKE '%HQ%' THEN 'Denver-HQ'
            WHEN ObjectName2 LIKE '%Austin%' THEN 'Austin Texas'
            WHEN ObjectName2 LIKE '%Miami%' THEN 'Miami'
            WHEN ObjectName2 LIKE '%NYC%' THEN 'New York'
            ELSE NULL
          END AS LogicalLocation
        FROM ACVSUJournalLog
        WHERE PartitionName2 IS NOT NULL
      ) AS X
      WHERE LogicalLocation IS NOT NULL
      ORDER BY LogicalLocation;
    `;
    const { recordset } = await req.query(q);
    return (recordset || []).map(r => r.LogicalLocation).filter(Boolean);
  
    
  } else {
    const q = `SELECT DISTINCT PartitionName2 FROM ACVSUJournalLog WHERE PartitionName2 IS NOT NULL ORDER BY PartitionName2`;
    const { recordset } = await req.query(q);
    return (recordset || []).map(r => r.PartitionName2).filter(Boolean);
  }
}




/**
 * Search employees by name or employee id fragment
 * q: search string (partial), region: region key for getPool
 */
export async function searchEmployees(region = 'emea', q = '') {
  const pool = await getPool(region);
  const req = pool.request();
  const like = `%${q}%`;
  req.input('q', sql.NVarChar(200), like);

  // search common personnel name field (Text1) and numeric EmployeeID (Int1) and Text12 (contractor id)
  const query = `
    SELECT TOP (200)
      CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR(50)) END AS EmployeeID,
      ISNULL(t2.Text1, '') AS Name
    FROM ACVSCore.Access.Personnel AS t2
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId = t3.ObjectID
    WHERE (t2.Text1 LIKE @q) OR (CAST(t2.Int1 AS NVARCHAR(50)) LIKE @q) OR (t2.Text12 LIKE @q)
    ORDER BY t2.Text1;
  `;
  const { recordset } = await req.query(query);
  return (recordset || []).map(r => ({ EmployeeID: r.EmployeeID, Name: r.Name }));
}



/**
 * rawReportStreamToResponse
 * - Inputs: region (JS param), startDate, endDate, location (friendly name or partition), admitFilter
 * - Minimal changes: add @regionKey and LogicalLocation mapping, accept friendly NAMER location names
 */
export async function rawReportStreamToResponse(res, region, { startDate, endDate, location, admitFilter = 'all' }) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const pool = await getPool(region);
  const request = pool.request();
  request.timeout = 10 * 60 * 1000; // 10 minutes

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;
  request.input('location', sql.NVarChar(200), locationParam);
  request.input('startDate', sql.Date, startDate);
  request.input('endDate', sql.Date, endDate);
  request.input('admitFilter', sql.NVarChar(20), String(admitFilter || 'all'));
  // pass region key so SQL knows to apply NAMER mapping when appropriate
  request.input('regionKey', sql.NVarChar(50), String(region || ''));

  const query = `
  WITH CombinedQuery AS(
    SELECT 
       DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
       t1.ObjectName1,
       t1.PartitionName2       AS location,
       t5_card.CardNumber,
       t5_admit.value          AS AdmitCode,
       t5_dir.value            AS Direction,
       t1.ObjectName2          AS Door,
       t5_rej.value            AS Rejection_Type,
       CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
            THEN t2.Text12
            ELSE CAST(t2.Int1 AS NVARCHAR)
       END                       AS EmployeeID,
       t3.Name                  AS PersonnelType,
       t1.MessageType,
       t1.XmlGUID,
       -- LogicalLocation: only populated for NAMER-like partitions (door name -> friendly)
       CASE
         WHEN (UPPER(ISNULL(@regionKey,'')) = 'NAMER' OR t1.PartitionName2 LIKE 'US.%' OR t1.PartitionName2 LIKE 'USA%')
         THEN


        CASE
  WHEN (UPPER(ISNULL(@regionKey,'')) = 'NAMER' OR t1.PartitionName2 LIKE 'US.%' OR t1.PartitionName2 LIKE 'USA%')
  THEN
    CASE
      WHEN t1.ObjectName2 LIKE '%HQ%' THEN 'Denver-HQ'
      WHEN t1.ObjectName2 LIKE '%Austin%' THEN 'Austin Texas'
      WHEN t1.ObjectName2 LIKE '%Miami%' THEN 'Miami'
      WHEN t1.ObjectName2 LIKE '%NYC%' THEN 'New York'
      ELSE NULL
    END
  ELSE NULL
END AS LogicalLocation


    FROM ACVSUJournalLog AS t1
    LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
    LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
      ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
    LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
      ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
    LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
    LEFT JOIN (
      SELECT GUID, [value]
      FROM ACVSUJournalLogxmlShred
      WHERE [Name] IN ('Card','CHUID')
    ) AS SCard ON t1.XmlGUID = SCard.GUID
    OUTER APPLY (
      SELECT COALESCE(
        TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
        TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
        SCard.[value]
      ) AS CardNumber
    ) AS t5_card
    LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
      ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
    WHERE
      t1.MessageType IN ('CardAdmitted' , 'CardRejected')
      AND (
        @location IS NULL
        OR t1.PartitionName2 = @location
        OR (
          -- allow matching friendly logical names for NAMER (frontend can send 'Denver' etc)
          (CASE
            WHEN (UPPER(ISNULL(@regionKey,'')) = 'NAMER' OR t1.PartitionName2 LIKE 'US.%' OR t1.PartitionName2 LIKE 'USA%')
            THEN
              CASE
                WHEN t1.ObjectName2 LIKE '%HQ%' THEN 'Denver'
                WHEN t1.ObjectName2 LIKE '%Austin%' THEN 'Austin'
                WHEN t1.ObjectName2 LIKE '%Miami%' THEN 'Miami'
                WHEN t1.ObjectName2 LIKE '%NYC%' THEN 'New York'
                ELSE NULL
              END
            ELSE NULL
          END) = @location
        )
      )
      AND (
        UPPER(ISNULL(@admitFilter,'all')) = 'ALL'
        OR (UPPER(@admitFilter) = 'ADMIT'  AND t1.MessageType = 'CardAdmitted')
        OR (UPPER(@admitFilter) = 'REJECT' AND t1.MessageType = 'CardRejected')
      )
      AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
  )
  SELECT
    LocaleMessageTime,
    CONVERT(date,    LocaleMessageTime) AS DateOnly,
    CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
    EmployeeID,
    ObjectName1,
    PersonnelType,
    location,
    LogicalLocation, -- new friendly logical column (nullable)
    CardNumber,
    AdmitCode,
    Direction,
    Door,
    Rejection_Type
  FROM CombinedQuery
  ORDER BY LocaleMessageTime ASC;
  `;


   const filename = `Raw_${region}_${startDate.replace(/-/g,'')}_to_${endDate.replace(/-/g,'')}.xlsx`;
  res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
  res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
  res.setHeader('Cache-Control', 'no-cache');

  // create streaming workbook with styles enabled
  const workbook = new ExcelJS.stream.xlsx.WorkbookWriter({ stream: res, useSharedStrings: true, useStyles: true });

  // configuration
  const MAX_ROWS_PER_SHEET = 700000;

  // Build headers depending on admitFilter (server will still filter data by admitFilter)
  // let headers = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber'];
  
   let headers = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','LogicalLocation','CardNumber'];

  
  const admit = 'AdmitCode';
  const rej = 'Rejection_Type';
  const tail = ['Direction','Door'];

  const af = (String(admitFilter || 'all')).toLowerCase();
  if (af === 'admit') {
    headers = headers.concat([admit, ...tail]);
  } else if (af === 'reject') {
    headers = headers.concat([...tail, rej]);
  } else {
    headers = headers.concat([admit, ...tail, rej]);
  }

  // column widths map aligned to headers above (fallback widths)
   const defaultWidths = {
    LocaleMessageTime: 22, DateOnly: 12, Swipe_Time: 12, EmployeeID: 15,
    ObjectName1: 30, PersonnelType: 18, location: 18, LogicalLocation: 20, CardNumber: 20,
    AdmitCode: 14, Direction: 10, Door: 22, Rejection_Type: 22
  };


  // helpers
  const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  function humanMonthNameFromKey(key) {
    if (!key || key === 'unknown') return 'Unknown';
    const [y,m] = key.split('-');
    const mm = parseInt(m,10);
    const mon = MONTH_ABBR[mm - 1] || m;
    return `${mon}-${y}`;
  }

  let currentMonthKey = null;
  let worksheet = null;
  let sheetIndexForMonth = {};

  // create footer row to provide thick bottom border for streaming sheets
  function addFooterRowForOutsideBorder(ws, headersLen) {
    // create an empty footer row; top border on footer -> acts as bottom border of table
    const footerValues = new Array(headersLen).fill('');
    const footer = ws.addRow(footerValues);
    const lastColIndex = headersLen;
    footer.eachCell((cell, colNumber) => {
      // top border thick to form bottom outside border
      const border = {
        top: { style: 'thick' },
        left: colNumber === 1 ? { style: 'thick' } : (cell.border && cell.border.left ? cell.border.left : { style: 'thin' }),
        right: colNumber === lastColIndex ? { style: 'thick' } : (cell.border && cell.border.right ? cell.border.right : { style: 'thin' }),
        bottom: { style: 'thin' }
      };
      cell.border = border;
      // fill/align blank footer consistently
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
    });
    footer.commit();
  }

  function createWorksheetFor(monthKey) {
    sheetIndexForMonth[monthKey] = (sheetIndexForMonth[monthKey] || 0) + 1;
    const part = sheetIndexForMonth[monthKey];
    const human = humanMonthNameFromKey(monthKey);
    const name = part === 1 ? `${human} Sheet 1` : `${human} Sheet ${part}`;

    const ws = workbook.addWorksheet(name);

    // Set reasonable column widths up-front (do NOT use `header:` in columns ‚Äî that can create an auto-header)
    ws.columns = headers.map(h => ({ key: h, width: defaultWidths[h] || 18 }));

    // write header row explicitly and style it (only one header row)
    const headerRow = ws.addRow(headers);

    // style header: bold, center alignment for all except Door (left)
    const doorIndex = headers.indexOf('Door') + 1; // 1-based
    headerRow.eachCell((cell, colNumber) => {
      cell.font = { bold: true };
      cell.alignment = { horizontal: (colNumber === doorIndex ? 'left' : 'center'), vertical: 'middle' };
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFCCE8FF' } };
      // thick border on the full header row (top + left/right)
      cell.border = {
        top: { style: 'thick' },
        left: (colNumber === 1) ? { style: 'thick' } : { style: 'thin' },
        bottom: { style: 'thin' },
        right: (colNumber === headers.length) ? { style: 'thick' } : { style: 'thin' }
      };
    });
    headerRow.commit();

    ws.__written = 1;
    return ws;
  }

  function monthKeyForRow(row) {
    try {
      const iso = row.LocaleMessageTime || row.DateOnly;
      if (iso) {
        const d = new Date(iso);
        if (!isNaN(d.getTime())) {
          const y = d.getUTCFullYear();
          const m = String(d.getUTCMonth() + 1).padStart(2, '0');
          return `${y}-${m}`;
        }
      }
    } catch (e) { /* ignore */ }
    return 'unknown';
  }

  // safe commit helper
  let committed = false;
  async function safeCommit() {
    if (committed) return;
    committed = true;
    try {
      await workbook.commit();
    } catch (e) {
      console.error('safeCommit: workbook.commit failed', e);
    }
  }

  request.stream = true;

  request.on('error', async (err) => {
    console.error('SQL stream error', err);
    try { await safeCommit(); } catch (e) {}
    try { res.end(); } catch (e) {}
  });

  request.on('row', (row) => {
    const monthKey = monthKeyForRow(row);
    // rotate/create sheet if needed
    if (!worksheet || monthKey !== currentMonthKey || (worksheet.__written >= MAX_ROWS_PER_SHEET)) {
      // if we already have a worksheet, add a footer row to create thick bottom border, then commit it
      if (worksheet) {
        try {
          addFooterRowForOutsideBorder(worksheet, headers.length);
        } catch (e) { /* ignore footer errors */ }
        try { worksheet.commit(); } catch (e) { /* ignore commit error */ }
      }
      currentMonthKey = monthKey;
      worksheet = createWorksheetFor(monthKey);
    }

    // Build row values; prefer Date objects for date/time columns where possible
    let localeDate = null;
    if (row.LocaleMessageTime) {
      localeDate = (row.LocaleMessageTime instanceof Date) ? row.LocaleMessageTime : new Date(row.LocaleMessageTime);
      if (isNaN(localeDate.getTime())) localeDate = null;
    }
    let dateOnlyDate = null;
    if (row.DateOnly) {
      const d = new Date(row.DateOnly);
      if (!isNaN(d.getTime())) dateOnlyDate = d;
    }
    let swipeDate = null;
    if (row.Swipe_Time) {
      if (row.Swipe_Time instanceof Date && !isNaN(row.Swipe_Time.getTime())) swipeDate = row.Swipe_Time;
      else {
        const t = String(row.Swipe_Time || '').trim();
        if (t) {
          const parts = t.split(':').map(p => parseInt(p || '0', 10));
          if (parts.length >= 2) swipeDate = new Date(Date.UTC(1970,0,1, parts[0], parts[1], parts[2]||0));
        }
      }
    }



    // // Compose row values in same order as headers array (dynamically)
    // const fullObj = {
    //   LocaleMessageTime: localeDate || (row.LocaleMessageTime || ''),
    //   DateOnly: dateOnlyDate || (row.DateOnly || ''),
    //   Swipe_Time: swipeDate || (row.Swipe_Time || ''),
    //   EmployeeID: row.EmployeeID || '',
    //   ObjectName1: row.ObjectName1 || '',
    //   PersonnelType: row.PersonnelType || '',
    //   location: row.location || '',
    //   CardNumber: row.CardNumber || '',
    //   AdmitCode: row.AdmitCode || '',
    //   Direction: row.Direction || '',
    //   Door: row.Door || '',
    //   Rejection_Type: row.Rejection_Type || ''
    // };


    const fullObj = {
      LocaleMessageTime: localeDate || (row.LocaleMessageTime || ''),
      DateOnly: dateOnlyDate || (row.DateOnly || ''),
      Swipe_Time: swipeDate || (row.Swipe_Time || ''),
      EmployeeID: row.EmployeeID || '',
      ObjectName1: row.ObjectName1 || '',
      PersonnelType: row.PersonnelType || '',
      location: row.location || '',
      // <-- prefer logical/friendly location provided by the SQL
      LogicalLocation: row.LogicalLocation || null,
      CardNumber: row.CardNumber || '',
      AdmitCode: row.AdmitCode || '',
      Direction: row.Direction || '',
      Door: row.Door || '',
      Rejection_Type: row.Rejection_Type || ''
    };

    const rowVals = headers.map(h => (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '');

    // Add row and style cells
    const wrow = worksheet.addRow(rowVals);

    try {
      // column-based formatting: header & data alignment rules (Door left, rest center)
      const doorIndex = headers.indexOf('Door') + 1; // 1-based index for Door if present
      for (let ci = 1; ci <= headers.length; ci++) {
        const cell = wrow.getCell(ci);
        // date/time number formats
        const headerName = headers[ci - 1];
        if (headerName === 'LocaleMessageTime' && localeDate) {
          cell.numFmt = 'dd-mmm-yyyy h:mm:ss AM/PM';
        } else if (headerName === 'DateOnly' && dateOnlyDate) {
          cell.numFmt = 'dd-mmm-yy';
        } else if (headerName === 'Swipe_Time' && swipeDate) {
          cell.numFmt = 'h:mm:ss AM/PM';
        }
        // alignment: Door left, others center
        const horizontal = (ci === doorIndex) ? 'left' : 'center';
        cell.alignment = { vertical: 'middle', horizontal };

        // border: top/bottom thin by default, left thick for first col, right thick for last col
        const border = {
          top: { style: 'thin' },
          bottom: { style: 'thin' },
          left: (ci === 1) ? { style: 'thick' } : { style: 'thin' },
          right: (ci === headers.length) ? { style: 'thick' } : { style: 'thin' }
        };
        cell.border = border;
      }
    } catch (e) {
      console.warn('row styling warning', e && e.message ? e.message : e);
    }

    wrow.commit();
    worksheet.__written++;
  });

  request.on('done', async () => {
    try {
      if (worksheet) {
        // add footer row with top thick to act as bottom border
        try { addFooterRowForOutsideBorder(worksheet, headers.length); } catch (e) { /* ignore */ }
        try { worksheet.commit(); } catch (e) { /* ignore */ }
      }
      await safeCommit();
    } catch (err) {
      console.error('Workbook commit error', err);
    } finally {
      try { res.end(); } catch (e) {}
    }
  });



//   // trigger the streaming query
//   request.query(query).catch(async (err) => {
//     console.error('request.query failed', err);
//     try { await safeCommit(); } catch (e) {}
//     try { res.end(); } catch (e) {}
//   });
// }



 // trigger the streaming query
  request.stream = true;
  request.on('error', async (err) => {
    console.error('SQL stream error', err);
    try { await workbook.commit(); } catch (e) {}
    try { res.end(); } catch (e) {}
  });

  // Re-use your existing request.on('row') / on('done') blocks here exactly as in your original
  // file, but when mapping row values include LogicalLocation where appropriate.
  // (Because the streaming block is long and unchanged, keep it from your original file.)
  try {
    request.query(query).catch(async (err) => {
      console.error('request.query failed', err);
      try { await workbook.commit(); } catch (e) {}
      try { res.end(); } catch (e) {}
    });
  } catch (err) {
    console.error('rawReport stream start failed', err);
    try { await workbook.commit(); } catch (e) {}
    try { res.end(); } catch (e) {}
  }
}




// export async function rejectionReport(region, { startDate, endDate, location } = {}) {
//   if (!region) throw new Error('region required');
//   if (!startDate || !endDate) throw new Error('startDate and endDate required');

//   // const pool = await getPool(region);
//   // const req = pool.request();

//    const pool = await getPool(region);
//   const req = pool.request();
//   // increase timeout for this request (ms) ‚Äî set to 5 minutes
//   req.timeout = 300000;


//   const locationParam = (location && String(location).trim()) ? String(location).trim() : null;

//   req.input('location', sql.NVarChar(200), locationParam);
//   req.input('startDate', sql.Date, startDate);
//   req.input('endDate', sql.Date, endDate);

//   const query = `
// WITH CombinedQuery AS(
//   SELECT 
//      DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
//      t1.ObjectName1,
//      t1.PartitionName2       AS location,
//      t5_card.CardNumber,
//      t5_admit.value          AS AdmitCode,
//      t5_dir.value            AS Direction,
//      t1.ObjectName2          AS Door,
//      t5_rej.value            AS Rejection_Type,
//      CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
//           THEN t2.Text12
//           ELSE CAST(t2.Int1 AS NVARCHAR)
//      END                       AS EmployeeID,
//      t3.Name                  AS PersonnelType,
//      t1.MessageType,
//      t1.XmlGUID
//   FROM ACVSUJournalLog AS t1
//   LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
//   LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
//   LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
//     ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
//   LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
//     ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
//   LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
//   LEFT JOIN (
//     SELECT GUID, [value]
//     FROM ACVSUJournalLogxmlShred
//     WHERE [Name] IN ('Card','CHUID')
//   ) AS SCard ON t1.XmlGUID = SCard.GUID
//   OUTER APPLY (
//     SELECT COALESCE(
//       TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
//       TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
//       SCard.[value]
//     ) AS CardNumber
//   ) AS t5_card
//   LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
//     ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
//   WHERE
//     t1.MessageType = 'CardRejected'
//     AND (@location IS NULL OR t1.PartitionName2 = @location)
//     AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
// ),
// Unified AS (
//   SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Lost'
//   UNION ALL
//   SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Clearance'
//   UNION ALL
//   SELECT * FROM CombinedQuery WHERE Rejection_Type IN ('CardDisabled','Disabled')
//   UNION ALL
//   SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Stolen'
//   UNION ALL
//   SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Expired'
//   UNION ALL
//   SELECT * FROM CombinedQuery WHERE Rejection_Type = 'PIN'
//   UNION ALL
//   SELECT * FROM CombinedQuery WHERE Rejection_Type = 'UnknownCard'
//   UNION ALL
//   SELECT * FROM CombinedQuery WHERE Rejection_Type = 'SiteCode'
//   UNION ALL
//   SELECT * FROM CombinedQuery WHERE Rejection_Type = 'NotActivated'
//   UNION ALL
//   SELECT * FROM CombinedQuery WHERE Rejection_Type = 'FacilityCode'
// )
// SELECT
//   LocaleMessageTime,
//   CONVERT(date,    LocaleMessageTime) AS DateOnly,
//   CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
//   EmployeeID,
//   ObjectName1,
//   PersonnelType,
//   location,
//   CardNumber,
//   AdmitCode,
//   Direction,
//   Door,
//   Rejection_Type
// FROM Unified
// ORDER BY LocaleMessageTime DESC;
// `;


/**
 * rejectionReport(region, { startDate, endDate, location })
 * Minimal update: add regionKey parameter, compute LogicalLocation same as raw,
 * allow friendly location names in WHERE comparison.
 */
export async function rejectionReport(region, { startDate, endDate, location } = {}) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const pool = await getPool(region);
  const req = pool.request();
  req.timeout = 300000;

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;
  req.input('location', sql.NVarChar(200), locationParam);
  req.input('startDate', sql.Date, startDate);
  req.input('endDate', sql.Date, endDate);
  req.input('regionKey', sql.NVarChar(50), String(region || ''));

  const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID,
 CASE
  WHEN (UPPER(ISNULL(@regionKey,'')) = 'NAMER' OR t1.PartitionName2 LIKE 'US.%' OR t1.PartitionName2 LIKE 'USA%')
  THEN
    CASE
      WHEN t1.ObjectName2 LIKE '%HQ%' THEN 'Denver-HQ'
      WHEN t1.ObjectName2 LIKE '%Austin%' THEN 'Austin Texas'
      WHEN t1.ObjectName2 LIKE '%Miami%' THEN 'Miami'
      WHEN t1.ObjectName2 LIKE '%NYC%' THEN 'New York'
      ELSE NULL
    END
  ELSE NULL
END AS LogicalLocation

  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType = 'CardRejected'
    AND (
      @location IS NULL
      OR t1.PartitionName2 = @location
      OR (
        (CASE
          WHEN (UPPER(ISNULL(@regionKey,'')) = 'NAMER' OR t1.PartitionName2 LIKE 'US.%' OR t1.PartitionName2 LIKE 'USA%')
          THEN
            CASE
              WHEN t1.ObjectName2 LIKE '%HQ%' THEN 'Denver'
              WHEN t1.ObjectName2 LIKE '%Austin%' THEN 'Austin'
              WHEN t1.ObjectName2 LIKE '%Miami%' THEN 'Miami'
              WHEN t1.ObjectName2 LIKE '%NYC%' THEN 'New York'
              ELSE NULL
            END
          ELSE NULL
        END) = @location
      )
    )
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
)
-- keep the same selection output but include LogicalLocation as extra column for consumers
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  LogicalLocation,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM CombinedQuery
ORDER BY LocaleMessageTime DESC;
`;

  const { recordset } = await req.query(query);
  return recordset;
}




// // backend/services/reportService.js
export async function dailyAccessReportEMEA({ from, to, employees = '' }) {
  const pool = await getPool('emea');
  const req  = pool.request();

  req.input('fromDate', sql.Date, from);
  req.input('toDate',   sql.Date, to);
  const employeesParam = (employees && String(employees).trim()) ? String(employees).trim() : null;
  req.input('employees', sql.NVarChar(sql.MAX), employeesParam);

  const query = `

  -- expects parameters: @fromDate (DATE), @toDate (DATE), @employees (NVARCHAR(MAX) | NULL)
DECLARE @empCSV NVARCHAR(MAX) = @employees;

;WITH EmpList AS (
  SELECT LTRIM(RTRIM(value)) AS emp
  FROM STRING_SPLIT(ISNULL(@empCSV,''), ',')
  WHERE LTRIM(RTRIM(value)) <> ''
)

-- Raw rows: compute LocaleMessageTime once and use OUTER APPLY to avoid duplicate shreddes
, RawSwipes AS (
  SELECT
    t1.ObjectName1,
    t1.ObjectName2,
    t1.MessageType,
    t2.Text12       AS EmployeeID,
    CAST(t2.Int1 AS NVARCHAR(50)) AS NumericEmployeeID,
    t3.Name         AS PersonnelType,
    t1.PartitionName2 AS PartitionName2,

    -- compute local wall-clock once (DO NOT change sign here; using your -1 * MessageLocaleOffset)
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,

    -- direction/value picked by OUTER APPLY (single row)
    CASE
      WHEN dir.Value = 'InDirection'  THEN 'IN'
      WHEN dir.Value = 'OutDirection' THEN 'OUT'
      ELSE 'Unknown'
    END AS Swipe,

    card.Value AS CardNumber
  FROM ACVSUJournal_00011029.dbo.ACVSUJournalLog AS t1
  INNER JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  INNER JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID

  -- pick at most one direction shred row (InDirection/OutDirection)
  OUTER APPLY (
    SELECT TOP (1) s.Value
    FROM ACVSUJournal_00011029.dbo.ACVSUJournalLogxmlShred AS s
    WHERE s.GUID = t1.XmlGUID
      AND s.Value IN ('InDirection','OutDirection')
  ) AS dir

  -- pick at most one numeric card value (exclude direction values, ensure numeric)
  OUTER APPLY (
    SELECT TOP (1) s.Value
    FROM ACVSUJournal_00011029.dbo.ACVSUJournalLogxmlShred AS s
    WHERE s.GUID = t1.XmlGUID
      AND s.Value NOT IN ('InDirection','OutDirection')
      AND s.Value NOT LIKE '%[^0-9]%'
      AND s.Value IS NOT NULL
      AND LTRIM(RTRIM(s.Value)) <> ''
  ) AS card
)

-- Strict time window: >= 08:00 on @fromDate, and < 08:00 on @toDate
, Windowed AS (
  SELECT *
  FROM RawSwipes
  WHERE
    LocaleMessageTime >= DATEADD(HOUR, 8, CAST(@fromDate AS DATETIME))
    -- NOTE: removed extra DATEADD(DAY,1,...) ‚Äî upper bound should be < toDate 08:00
    AND LocaleMessageTime <  DATEADD(HOUR, 8, CAST(@toDate AS DATETIME))
    AND Swipe IN ('IN','OUT') -- only real swipes
)

-- final projection + optional employee filter (supports CSV of names or IDs)
SELECT
  ObjectName1,
  ObjectName2,
  PersonnelType,
  EmployeeID,
  NumericEmployeeID,
  -- alias PartitionName2 -> location so frontend sees r.location
  PartitionName2 AS location,
  -- alias MessageType -> Messagetype so frontend sees r.Messagetype
  MessageType AS Messagetype,
  Swipe,
  CardNumber,
  LocaleMessageTime
FROM Windowed w
WHERE
  (
    @empCSV IS NULL
    OR LTRIM(RTRIM(@empCSV)) = ''
    OR EXISTS (
      SELECT 1
      FROM EmpList e
      WHERE
        e.emp = LTRIM(RTRIM(w.ObjectName1))
        OR e.emp = w.EmployeeID
        OR e.emp = w.NumericEmployeeID
    )
  )
ORDER BY LocaleMessageTime;

`;

  const { recordset } = await req.query(query);
  return recordset;
}






/**
 * In-vs-Out Report (parameterized) ‚Äî groups by employee & month
 */
export async function inOutReport(region, { year, month, doors }) {
 // const pool = await getPool(region);
  // const req  = pool.request();

    const pool = await getPool(region);
  const req = pool.request();
  // increase timeout for this request (ms) ‚Äî set to 5 minutes
  req.timeout = 300000;


  req.input('TargetYear',  sql.Int, year);
  req.input('TargetMonth', sql.Int, month);
  doors.forEach((d, i) => req.input(`door${i}`, sql.NVarChar, d));
  const doorList = doors.map((_, i) => `@door${i}`).join(',');

  const query = `
WITH CombinedQuery AS (
  SELECT
    DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
    t1.ObjectName1,
    t1.PartitionName2    AS location,
    t5_card.CardNumber,
    t5_dir.value         AS Direction,
    CASE
      WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
      ELSE CAST(t2.Int1 AS NVARCHAR)
    END                    AS EmployeeID,
    t3.Name               AS PersonnelType
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID
    AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml AS t_xml
    ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard
    ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  WHERE
    YEAR(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetYear
    AND MONTH(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetMonth
    AND t1.ObjectName2 IN (${doorList})
)
SELECT
  FORMAT(LocaleMessageTime,'yyyy-MM')    AS Month,
  ObjectName1                           AS EmployeeName,
  EmployeeID,
  PersonnelType,
  location,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)  AS In_Count,
  SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS Out_Count,
  COUNT(*)                                                 AS TotalSwipes,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)
  - SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS InOut_Difference
FROM CombinedQuery
GROUP BY FORMAT(LocaleMessageTime,'yyyy-MM'),
         ObjectName1, EmployeeID, PersonnelType, location
ORDER BY Month DESC, EmployeeName;
`;

  const { recordset } = await req.query(query);
  return recordset;
}



/**
 * Time Duration Report (parameterized by region, partition, startDate)
 */
export async function timeDurationReport(region, { partition = 'Default', startDate }) {
  // const pool = await getPool(region);
  // const req  = pool.request();

    const pool = await getPool(region);
 const req = pool.request();
 // increase timeout for this request (ms) ‚Äî set to 5 minutes
  req.timeout = 300000;


  // bind inputs
  const fullPartition = `${region.toUpperCase()}.${partition}`;
  req.input('partition', sql.NVarChar, fullPartition);
  req.input('startDate', sql.Date, startDate);

  const query = `

SELECT 
    t1.[ObjectName1],
    t1.[ObjectName2],
    t1.[PartitionName2],
    CASE
        WHEN t2.[Int1] = 0 THEN t2.[Text12]
        ELSE CAST(t2.[Int1] AS NVARCHAR)
    END AS EmployeeID,
    t3.[Name] AS PersonnelType,
    t2.text5,
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    DATEADD(HOUR, -2, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) AS AdjustedMessageTime
INTO 
    #CombinedEmployeeData
FROM 
    [ACVSUJournal_00010030].[dbo].[ACVSUJournalLog] AS t1
INNER JOIN 
    [ACVSCore].[Access].[Personnel] AS t2
    ON t1.ObjectIdentity1 = t2.GUID
INNER JOIN 
    [ACVSCore].[Access].[PersonnelType] AS t3
    ON t2.[PersonnelTypeId] = t3.[ObjectID];

-- Step 2: Daily duration per employee
WITH DailyDurations AS (
    SELECT 
        [ObjectName1],
        PersonnelType,
        EmployeeID,
        [PartitionName2],
        text5,
        CONVERT(DATE, AdjustedMessageTime) AS ShiftedDate,
        DATEPART(WEEK, AdjustedMessageTime) AS WeekNumber,
        DATEPART(YEAR, AdjustedMessageTime) AS YearNumber,
        MIN(LocaleMessageTime) AS FirstSwipeTime,
        MAX(LocaleMessageTime) AS LastSwipeTime,
        DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) AS DurationMinutes,
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) / 60 AS NVARCHAR), 2)
        + ':' +
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) % 60 AS NVARCHAR), 2) AS DurationHHMM,
        CASE 
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 5 THEN '<5mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 10 THEN '<10mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 20 THEN '<20mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 30 THEN '<30mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 60 THEN '<1hr'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 120 THEN 'Less than <2hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 180 THEN 'Less than <3hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 240 THEN 'Less than <4hrs'
            ELSE '4+ hrs'
        END AS TimeDiffCategory
    FROM 
        #CombinedEmployeeData



  WHERE CONVERT(DATE, AdjustedMessageTime) >= @startDate

   AND [PartitionName2] = 'APAC.Default'
        AND PersonnelType IN ('Employee', 'Terminated Personnel')
    GROUP BY 
        [ObjectName1], EmployeeID, PersonnelType, text5, [PartitionName2],
        CONVERT(DATE, AdjustedMessageTime),
        DATEPART(WEEK, AdjustedMessageTime),
        DATEPART(YEAR, AdjustedMessageTime)
),

-- Step 3: Weekly summary
WeeklySummary AS (
    SELECT 
        EmployeeID,
        [ObjectName1],
        PersonnelType,
        text5,
        [PartitionName2],
        YearNumber,
        WeekNumber,
        COUNT(DISTINCT ShiftedDate) AS DaysPresentInWeek,
        SUM(CASE WHEN DurationMinutes < 240 THEN 1 ELSE 0 END) AS ViolationDaysInWeek
    FROM 
        DailyDurations
    GROUP BY 
        EmployeeID, [ObjectName1], PersonnelType, text5, [PartitionName2], YearNumber, WeekNumber
)

-- Step 4: Final output with daily duration, category, and defaulter flag
SELECT 
    dd.EmployeeID,
    dd.ObjectName1,
    dd.PersonnelType,
    dd.text5,
    dd.PartitionName2,
    dd.YearNumber,
    dd.WeekNumber,
    dd.ShiftedDate,
    dd.FirstSwipeTime,
    dd.LastSwipeTime,
    dd.DurationHHMM,
    dd.TimeDiffCategory,
    ws.DaysPresentInWeek,
    ws.ViolationDaysInWeek,
    (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) AS CleanDaysInWeek,
    CASE
        WHEN (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) < 3 THEN 'Yes'
        ELSE 'No'
    END AS Defaulter
FROM 
    DailyDurations dd
JOIN 
    WeeklySummary ws
    ON dd.EmployeeID = ws.EmployeeID
    AND dd.WeekNumber = ws.WeekNumber
    AND dd.YearNumber = ws.YearNumber
ORDER BY 
    dd.YearNumber DESC, dd.WeekNumber DESC, dd.EmployeeID, dd.ShiftedDate;
  `;

  const { recordset } = await req.query(query);
  return recordset;
}


//EUROC 




export async function eurocAdmitRejectionReport(region, { reportDate }) {
  // const pool = await getPool(region);
  // const req  = pool.request();

    const pool = await getPool(region);
  const req = pool.request();
  // increase timeout for this request (ms) ‚Äî set to 5 minutes
  req.timeout = 300000;


  // enforce location LT.Vilnius (as requested)
  req.input('location', sql.NVarChar, 'LT.Vilnius');
  // reportDate should be YYYY-MM-DD or Date ‚Äî bind as sql.Date
  req.input('reportDate', sql.Date, reportDate);

  const query = `
/*
  Approach:
  1) Build CombinedQuery as a CTE and SELECT INTO #Combined (materialize)
  2) Build #Admits (with ROW_NUMBER) and #Rejections from #Combined
  3) Return three resultsets: admits (rn=1), rejections (all), summary (counts)
*/

WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    AND t1.PartitionName2 = @location
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @reportDate
)

-- materialize CombinedQuery into a temp table
SELECT
  LocaleMessageTime,
  CONVERT(date, LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  MessageType
INTO #Combined
FROM CombinedQuery;

-- create admits with row number (first admit per employee)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  ROW_NUMBER() OVER (PARTITION BY ISNULL(EmployeeID, CardNumber) ORDER BY LocaleMessageTime ASC) AS rn
INTO #Admits
FROM #Combined
WHERE MessageType = 'CardAdmitted'
  AND PersonnelType IN('Employee', 'Terminated Personnel');

-- create rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
INTO #Rejections
FROM #Combined
WHERE MessageType = 'CardRejected';

-- resultset 1: admits (only rn = 1)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Admits
WHERE rn = 1
ORDER BY LocaleMessageTime ASC;

-- resultset 2: rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Rejections
ORDER BY LocaleMessageTime ASC;

-- resultset 3: summary counts by Rejection_Type
SELECT
  ISNULL(Rejection_Type, 'Unknown') AS Rejection_Type,
  COUNT(*) AS CountVal
FROM #Rejections
GROUP BY ISNULL(Rejection_Type, 'Unknown')
ORDER BY CountVal DESC;

-- cleanup temp tables (optional ‚Äî they scope to the session and will go away automatically,
-- but good practice to drop)
DROP TABLE IF EXISTS #Admits;
DROP TABLE IF EXISTS #Rejections;
DROP TABLE IF EXISTS #Combined;
`;

  const result = await req.query(query);
  // result.recordsets is an array of resultsets
  const recordsets = result.recordsets || [];
  const admitRows = (recordsets[0] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const rejectRows = (recordsets[1] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Rejection_Type: r.Rejection_Type,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const summaryRows = (recordsets[2] || []).map(r => ({ Rejection_Type: r.Rejection_Type, Count: r.CountVal }));

  return { admit: admitRows, rejection: rejectRows, summary: summaryRows };
}
