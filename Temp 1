
//C:\Users\W0024618\Desktop\global-page\backend\config\dbConfig.js
import sql from 'mssql';

// shared options
const commonOpts = {
  options: {
    encrypt: true,
    trustServerCertificate: true
  },
  // increase timeouts (milliseconds)
  requestTimeout: 300000,      // 5 minutes
  connectionTimeout: 30000,    // 30 seconds
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  }
};

// lowercase keys only
// NOTE: moved to `databases` array so we can reference previous/other ACVSUJournal DBs easily.
const regions = {
  apac: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUPNQ0986V',
    // primary DB first; add previous/other ACVSUJournal DB names to this array as needed
    databases: ['ACVSUJournal_00010030','ACVSUJournal_00010029','ACVSUJournal_00010028','ACVSUJournal_00010027','ACVSUJournal_00010026','ACVSUJournal_00010025'],
    ...commonOpts
  },
  emea: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUFRA0986V',
    databases: ['ACVSUJournal_00011029','ACVSUJournal_00011028','ACVSUJournal_00011027','ACVSUJournal_00011026','ACVSUJournal_00011025','ACVSUJournal_00011024','ACVSUJournal_00011023'],
    ...commonOpts
  },
  laca: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUSJO0986V',
    databases: ['ACVSUJournal_00010030','ACVSUJournal_00010029','ACVSUJournal_00010028','ACVSUJournal_00010027','ACVSUJournal_00010026','ACVSUJournal_00010025'],
    ...commonOpts
  },
  namer: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUDEN0891V',
    databases: ['ACVSUJournal_00010030','ACVSUJournal_00010029','ACVSUJournal_00010028','ACVSUJournal_00010027','ACVSUJournal_00010026','ACVSUJournal_00010025'],
    ...commonOpts
  }
};

const pools = {};

/**
 * @param {string} regionKey  one of the keys in `regions`, case-insensitive
 */
export async function getPool(regionKey) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) {
    throw new Error(`Unknown region: ${regionKey}`);
  }

  // Use the first database in the array as the connection default (so queries without explicit db still work).
  if (Array.isArray(cfg.databases) && cfg.databases.length) {
    cfg.database = cfg.databases[0];
  } else if (!cfg.database) {
    // If no database specified, leave it alone (the server's default DB will be used).
    cfg.database = undefined;
  }

  if (!pools[key]) {
    pools[key] = await new sql.ConnectionPool(cfg).connect();
  }
  return pools[key];
}

/**
 * Return array of database names configured for a region (always returns array).
 * This is intentionally exported for other modules to dynamically build fully-qualified table references.
 */
export function getRegionDatabases(regionKey) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) return [];
  if (Array.isArray(cfg.databases) && cfg.databases.length) return cfg.databases.slice();
  if (cfg.database) return [cfg.database];
  return [];
}

/**
 * Safe bracketed DB name for embedding into SQL identifiers.
 */
export function bracketDb(dbName) {
  if (!dbName) return '';
  // protect against accidental injection: remove closing bracket then bracket it
  const safe = String(dbName).replace(/]/g, '');
  return `[${safe}]`;
}

export { sql };










// C:\Users\W0024618\Desktop\global-page\backend\routes\reports.js


 import express from 'express';
import {
 // rawReport,
  rejectionReport,
  dailyAccessReportEMEA,
   inOutReport,
  timeDurationReport,
  eurocAdmitRejectionReport,
  rawReportStreamToResponse 

} from '../services/reportService.js';
import { listLocations, searchEmployees } from '../services/reportService.js';

const router = express.Router();

// router.get('/raw', rawReportHandler);





router.get('/locations', async (req, res) => {
  try {
    const region = (req.query.region || 'emea').toString().toLowerCase();
    // for 'global' you could optionally return combined results by calling each region's pool,
    // but frontend already calls fetchLocationsForRegion per region when region==='global'.
    const locations = await listLocations(region);
    res.json({ data: locations });
  } catch (err) {
    console.error('GET /api/locations err', err);
    res.status(500).json({ error: err.message || 'failed' });
  }
});

router.get('/employees', async (req, res) => {
  try {
    const q = (req.query.q || '').toString();
    const region = (req.query.region || 'emea').toString().toLowerCase();
    if (!q || q.length < 2) return res.json({ data: [] });
    const rows = await searchEmployees(region, q);
    // return as array of objects
    res.json({ data: rows });
  } catch (err) {
    console.error('GET /api/employees err', err);
    res.status(500).json({ error: err.message || 'failed' });
  }
});






// Helper to unify GET/POST inputs
function getParam(req, name, defaultValue = undefined) {
  if (req.method === 'GET') {
    return req.query[name] ?? defaultValue;
  } else {
    return req.body[name] ?? defaultValue;
  }
}

// Middleware to ensure `region` is defined
function requireRegion(req, res, next) {
  const region = getParam(req, 'region');
  if (!region) {
    return res
      .status(400)
      .json({ error: "Missing required parameter: 'region'" });
  }
  next();
}



async function handleRaw(req, res, next) {
  try {
    const region = getParam(req, 'region');
    const startDateParam = getParam(req, 'startDate');
    const endDateParam = getParam(req, 'endDate');
    const location = getParam(req, 'location', undefined);
    const admitFilter = getParam(req, 'admitFilter', 'all');

    if (!startDateParam || !endDateParam) {
      return res
        .status(400)
        .json({ error: "Missing required parameters: 'startDate' and/or 'endDate'" });
    }

    const startDate = new Date(startDateParam);
    const endDate = new Date(endDateParam);
    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      return res.status(400).json({ error: "Invalid date format for startDate/endDate" });
    }

    // call service with validated params (service expects startDate & endDate + optional location & admitFilter)
    const data = await rawReport(region, { startDate, endDate, location, admitFilter });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}



router.get ('/raw',  requireRegion, handleRaw);
router.post('/raw',  requireRegion, handleRaw);


// Rejection Report handler (supports region=global)
async function handleRejection(req, res, next) {
  try {
    const regionRaw = getParam(req, 'region');
    const region = (regionRaw || '').toString().toLowerCase();
    const startDateParam = getParam(req, 'startDate');
    const endDateParam = getParam(req, 'endDate');
    const location = getParam(req, 'location', undefined);

    if (!startDateParam || !endDateParam) {
      return res
        .status(400)
        .json({ error: "Missing required parameters: 'startDate' and/or 'endDate'" });
    }

    const startDate = new Date(startDateParam);
    const endDate = new Date(endDateParam);
    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      return res.status(400).json({ error: "Invalid date format for startDate/endDate" });
    }

    const ALL_REGIONS = ['apac', 'emea', 'laca', 'namer'];

    if (region === 'global') {
      const promises = ALL_REGIONS.map(r => rejectionReport(r, { startDate, endDate, location }));
      const results = await Promise.all(promises);
      const merged = results.flat();
      // sort by LocaleMessageTime desc (most recent first)
      merged.sort((a, b) => {
        const ta = a.LocaleMessageTime ? new Date(a.LocaleMessageTime).getTime() : 0;
        const tb = b.LocaleMessageTime ? new Date(b.LocaleMessageTime).getTime() : 0;
        return tb - ta;
      });
      return res.json({ data: merged });
    }

    // single-region
    const data = await rejectionReport(region, { startDate, endDate, location });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}

router.get('/rejection', requireRegion, handleRejection);
router.post('/rejection', requireRegion, handleRejection);





// Daily Access Report handler
async function handleDailyAccess(req, res, next) {
  try {
    const region    = getParam(req, 'region');
    const from      = getParam(req, 'from');
    const to        = getParam(req, 'to');
    if (!from || !to) {
      return res
        .status(400)
        .json({ error: "Missing required parameters: 'from' and/or 'to'" });
    }
    // employees: POST expects array, GET expects comma-separated string
    let employees = getParam(req, 'employees', []);
    if (typeof employees === 'string') {
      employees = employees.split(',').map(s => s.trim()).filter(Boolean);
    }
    if (!Array.isArray(employees) || employees.length === 0) {
      return res
        .status(400)
        .json({ error: "Missing or empty required parameter: 'employees'" });
    }
    const data = await dailyAccessReportEMEA({ from, to });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}
router.get ('/daily-access',  requireRegion, handleDailyAccess);
router.post('/daily-access',  requireRegion, handleDailyAccess);

// In vs Out Report handler
async function handleInOut(req, res, next) {
  try {
    const region = getParam(req, 'region');
    const year   = parseInt(getParam(req, 'year'),  10);
    const month  = parseInt(getParam(req, 'month'), 10);
    if (Number.isNaN(year) || Number.isNaN(month)) {
      return res
        .status(400)
        .json({ error: "Missing or invalid parameters: 'year' and/or 'month'" });
    }
    // doors: POST expects array, GET expects comma-separated string
    let doors = getParam(req, 'doors', []);
    if (typeof doors === 'string') {
      doors = doors.split(',').map(s => s.trim()).filter(Boolean);
    }
    if (!Array.isArray(doors) || doors.length === 0) {
      return res
        .status(400)
        .json({ error: "Missing or empty required parameter: 'doors'" });
    }
    const data = await inOutReport(region, { year, month, doors });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}
router.get ('/in-out',  requireRegion, handleInOut);
router.post('/in-out',  requireRegion, handleInOut);


// Time Duration Report handler
async function handleTimeDuration(req, res, next) {
  try {
    const region    = getParam(req, 'region');
    const startDate = getParam(req, 'startDate');
    const partition = getParam(req, 'partition', 'Default');

    if (!startDate) {
      return res
        .status(400)
        .json({ error: "Missing required parameter: 'startDate'" });
    }

    const data = await timeDurationReport(region, { partition, startDate });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}
router.get('/time-duration',  requireRegion, handleTimeDuration);
router.post('/time-duration', requireRegion, handleTimeDuration);





// EUROC Admit-Rejection handler
async function handleEuroc(req, res, next) {
  try {
    const region = getParam(req, 'region');
    const dateParam = getParam(req, 'date'); // expected YYYY-MM-DD or JS date string
    if (!region || region.toLowerCase() !== 'emea') {
      return res.status(400).json({ error: "EUROC report only supported for region 'emea'" });
    }
    if (!dateParam) {
      return res.status(400).json({ error: "Missing required parameter: 'date' (YYYY-MM-DD)" });
    }
    // normalize date (send only date part)
    const dt = new Date(dateParam);
    if (Number.isNaN(dt.getTime())) {
      return res.status(400).json({ error: "Invalid date parameter" });
    }
    const isoDate = dt.toISOString().slice(0, 10); // YYYY-MM-DD
    const data = await eurocAdmitRejectionReport(region, { reportDate: isoDate });
    res.json({ data });
  } catch (err) {
    next(err);
  }
}
router.get('/euroc-admit-rejection', requireRegion, handleEuroc);
router.post('/euroc-admit-rejection', requireRegion, handleEuroc);






// new - robust raw-download handler
router.get('/raw-download', async (req, res) => {
  try {
    const region = req.query.region;
    const startDate = req.query.startDate; // expect 'YYYY-MM-DD' or ISO
    const endDate = req.query.endDate;
    const location = req.query.location || null;
    const admitFilter = req.query.admitFilter || 'all';

    // Basic validation
    if (!region || !startDate || !endDate) {
      return res.status(400).json({ error: 'region, startDate and endDate required' });
    }

    // Normalize employees param: support CSV string OR array (employees[]=a&employees[]=b) OR frontend rawSearch/q
    let employeesRaw = null;

    const decodeAndTrim = s => {
      if (!s && s !== 0) return null;
      try { s = decodeURIComponent(String(s)); } catch (e) { s = String(s); }
      s = String(s).trim();
      return s.length ? s : null;
    };

    if (typeof req.query.employees === 'string' && req.query.employees.trim() !== '') {
      employeesRaw = decodeAndTrim(req.query.employees);
    } else if (Array.isArray(req.query.employees) && req.query.employees.length) {
      employeesRaw = req.query.employees.map(s => decodeAndTrim(s)).filter(Boolean).join(',');
    } else if (Array.isArray(req.query['employees[]']) && req.query['employees[]'].length) {
      employeesRaw = req.query['employees[]'].map(s => decodeAndTrim(s)).filter(Boolean).join(',');
    } else if (req.query.q && String(req.query.q).trim() !== '') {
      // support '?q=...' if frontend sends the search token under q
      employeesRaw = decodeAndTrim(req.query.q);
    } else if (req.query.rawSearch && String(req.query.rawSearch).trim() !== '') {
      employeesRaw = decodeAndTrim(req.query.rawSearch);
    } else if (req.body && req.body.employees) {
      // POST fallback
      if (typeof req.body.employees === 'string' && req.body.employees.trim() !== '') {
        employeesRaw = decodeAndTrim(req.body.employees);
      } else if (Array.isArray(req.body.employees) && req.body.employees.length) {
        employeesRaw = req.body.employees.map(s => decodeAndTrim(s)).filter(Boolean).join(',');
      }
    }

    // Defensive: if it's a single token with spaces but no commas, keep it intact (string_split will treat it as one token)
    // Log first 200 chars for debugging
    console.log('raw-download params:', {
      region, startDate, endDate, location, admitFilter,
      employees: employeesRaw ? employeesRaw.slice(0, 200) : null
    });

    // call streaming service — it writes directly to res and ends it
    await rawReportStreamToResponse(res, region, { startDate, endDate, location, admitFilter, employees: employeesRaw });
  } catch (err) {
    console.error('raw-download error', err);
    if (!res.headersSent) res.status(500).json({ error: 'Failed to generate download' });
    try { res.end(); } catch (e) {}
  }
});






export default router;
















