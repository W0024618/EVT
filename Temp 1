// (keep your existing require()s and helper functions above unchanged)

const service       = require('../services/occupancy.service');
const doorMap       = require('../utils/doorMap');
const normalizeDoor = doorMap.normalizeDoor;
const roles         = require('../utils/roles');
const tzMap         = require('../utils/timezones'); // partition→IANA tz

/* ... keep helper functions (isEmployeeType, lookupFloor, formatInZone, etc.) unchanged ... */

/**
 * GET /api/occupancy/live-summary
 * Optional query param: ts=ISO timestamp (UTC)
 */
exports.getLiveSummary = async (req, res) => {
  try {
    const { ts } = req.query;

    // 1) Time-travel branch (pure UTC)
    if (ts) {
      const timestamp = new Date(ts);
      if (isNaN(timestamp)) {
        return res.status(400).json({ success:false, message:'invalid ts query param' });
      }

      // UTC date string of ts
      const dayStr = timestamp.toISOString().slice(0,10); // e.g. "2025-07-15"

      // a) fetch last 24h, narrow to that UTC date
      const fetched = await service.fetchHistoricalData({ days:1, location:null });

      // fetched might be array (old shape) or object { details, summaryByDate }
      const raw = Array.isArray(fetched) ? fetched : (fetched && Array.isArray(fetched.details) ? fetched.details : []);

      const sameDay = raw.filter(r =>
        new Date(r.LocaleMessageTime).toISOString().slice(0,10) === dayStr
      );

      // b) keep only swipes ≤ ts
      const upTo = sameDay.filter(r => new Date(r.LocaleMessageTime) <= timestamp);

      // c) last swipe per person ≤ ts
      const lastByPerson = {};
      upTo.forEach(r => {
        const key = r.PersonGUID;
        const t   = new Date(r.LocaleMessageTime).getTime();
        if (!lastByPerson[key] ||
            t > new Date(lastByPerson[key].LocaleMessageTime).getTime()) {
          lastByPerson[key] = r;
        }
      });

      // d) build “today” & realtime snapshot
      const today    = { total:0, Employee:0, Contractor:0 };
      const realtime = {};
      const details  = [];
      const unmapped = new Set();

      Object.values(lastByPerson).forEach(r => {
        // count
        const isEmp = isEmployeeType(r.PersonnelType);
        today.total++;
        if (isEmp) today.Employee++; else today.Contractor++;

        // floor mapping
        const floorName = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmapped) || 'Unknown';
        if (floorName === 'Out of office') return;

        // tally realtime
        const p = r.PartitionName2;
        realtime[p] = realtime[p] || { total:0, Employee:0, Contractor:0, floors:{} };
        realtime[p].total++;
        if (isEmp) realtime[p].Employee++; else realtime[p].Contractor++;
        realtime[p].floors[floorName] = (realtime[p].floors[floorName]||0) + 1;

        // detail row (UTC)
        details.push({
          ...r,
          snapshotTime:      r.LocaleMessageTime,
          LocaleMessageTime: new Date(r.LocaleMessageTime).toISOString(),
          floor:             floorName
        });
      });

      return res.json({
        success:      true,
        timestampUtc: timestamp.toISOString(),
        today,
        realtime,
        details
      });
    }

    // 2) Default live branch
    const swipes = await service.fetchLiveOccupancy();

    // 2a) “today” = first swipe per person (UTC date = today)
    const first = {};
    swipes.forEach(r => {
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!first[r.PersonGUID] ||
          t < new Date(first[r.PersonGUID].LocaleMessageTime).getTime()) {
        first[r.PersonGUID] = r;
      }
    });
    const today = { total:0, Employee:0, Contractor:0 };
    Object.values(first).forEach(r => {
      today.total++;
      isEmployeeType(r.PersonnelType)
        ? today.Employee++
        : today.Contractor++;
    });

    // 2b) “realtime” = last swipe per person
    const last     = {};
    const realtime = {};
    const details  = [];
    const unmapped = new Set();

    swipes.forEach(r => {
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!last[r.PersonGUID] ||
          t > new Date(last[r.PersonGUID].LocaleMessageTime).getTime()) {
        last[r.PersonGUID] = r;
      }
    });

    Object.values(last).forEach(r => {
      // skip OUT→“Out of office”
      if (r.Direction === 'OutDirection') {
        const fl = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmapped);
        if (fl === 'Out of office') return;
      }

      // floor
      const floorName = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmapped) || 'Unknown';
      if (floorName === 'Out of office') return;

      // tally
      const p = r.PartitionName2;
      realtime[p] = realtime[p] || { total:0, Employee:0, Contractor:0, floors:{} };
      realtime[p].total++;
      isEmployeeType(r.PersonnelType)
        ? realtime[p].Employee++
        : realtime[p].Contractor++;
      realtime[p].floors[floorName] = (realtime[p].floors[floorName]||0) + 1;

      // detail
      details.push({
        ...r,
        snapshotTime:      r.LocaleMessageTime,
        LocaleMessageTime: new Date(r.LocaleMessageTime).toISOString(),
        floor:             floorName
      });
    });

    return res.json({ success:true, today, realtime, details });
  }
  catch (err) {
    console.error('live-summary error:', err);
    return res.status(500).json({ success:false, message:'Live summary failed' });
  }
};


/**
 * GET /api/occupancy/history
 * Optional query params: start=YYYY-MM-DD, end=YYYY-MM-DD
 * Optional URL param: :location
 */
exports.getHistoricalOccupancy = async (req, res) => {
  try {
    const { start, end } = req.query;
    const location       = req.params.location || null;

    if (start && end) {
      // --- average-over-range logic ---
      const startD = new Date(start);
      const endD   = new Date(end);
      if (isNaN(startD) || isNaN(endD) || endD < startD) {
        return res
          .status(400)
          .json({ success:false, message:'invalid start/end date range' });
      }

      // inclusive days count
      const days = Math.ceil((endD - startD)/(1000*60*60*24)) + 1;
      const fetched = await service.fetchHistoricalData({ days, location });

      // accommodate both service shapes: array OR { details, summaryByDate }
      const raw = Array.isArray(fetched) ? fetched : (fetched && Array.isArray(fetched.details) ? fetched.details : []);

      // bucket unique PersonGUID per date
      const byDate = {};
      raw.forEach(r => {
        const t    = new Date(r.LocaleMessageTime);
        if (isNaN(t)) return;
        const date = t.toISOString().slice(0,10);
        if (date < start || date > end) return;
        byDate[date] = byDate[date] || new Set();
        byDate[date].add(r.PersonGUID);
      });

      // build breakdown & average
      const dates     = Object.keys(byDate).sort();
      const breakdown = dates.map(d => ({ date: d, count: byDate[d].size }));
      const sum       = breakdown.reduce((s,x) => s + x.count, 0);
      const average   = breakdown.length ? sum/breakdown.length : 0;

      return res.json({
        success:   true,
        start,
        end,
        average,
        breakdown
      });
    }

    // --- default history logic ---
    const fetched = await service.fetchHistoricalOccupancy(location);
    const raw = Array.isArray(fetched) ? fetched : (fetched && Array.isArray(fetched.details) ? fetched.details : []);
    const byDate = {};
    const details = [];

    raw.forEach(r => {
      const iso = (r.LocaleMessageTime instanceof Date)
        ? r.LocaleMessageTime.toISOString()
        : r.LocaleMessageTime;
      if (!iso) return;
      const date = iso.slice(0,10);
      byDate[date] = byDate[date] || {};
      const prev = byDate[date][r.PersonGUID];
      if (!prev || new Date(iso) < new Date(prev.LocaleMessageTime)) {
        byDate[date][r.PersonGUID] = { ...r, LocaleMessageTime: iso };
      }
    });

    const summaryByDate = Object.keys(byDate).sort().map(date => {
      const recs = Object.values(byDate[date]);
      details.push(...recs);
      const region = { total:0, Employee:0, Contractor:0 };
      const partitions = {};

      recs.forEach(r => {
        region.total++;
        isEmployeeType(r.PersonnelType) ? region.Employee++ : region.Contractor++;
        if (!location) {
          partitions[r.PartitionName2] = partitions[r.PartitionName2] || { total:0, Employee:0, Contractor:0 };
          partitions[r.PartitionName2].total++;
          isEmployeeType(r.PersonnelType)
            ? partitions[r.PartitionName2].Employee++
            : partitions[r.PartitionName2].Contractor++;
        }
      });

      return {
        date,
        day: new Date(date).toLocaleDateString('en-US',{ weekday:'long' }),
        region: location ? { name: location, ...region } : { name: 'NAMER', ...region },
        partitions: location ? undefined : partitions
      };
    });

    res.json({ success:true, summaryByDate, details });

  } catch (e) {
    console.error('history error:', e);
    res.status(500).json({ success:false, message:'Historical fetch failed' });
  }
};









  





// src/controllers/occupancy.controller.js

  const service       = require('../services/occupancy.service');
  const doorMap       = require('../utils/doorMap');
  const normalizeDoor = doorMap.normalizeDoor;
  const roles         = require('../utils/roles');
  const tzMap         = require('../utils/timezones'); // partition→IANA tz
 

  /**
   * Determine if the given PersonnelType is considered an employee.
   */
  function isEmployeeType(pt) {
    return ['Employee','Terminated Employee','Terminated Personnel'].includes(pt);
  }


  /**
   * Map (partition, door, direction) → logical floor name.
   * Tracks any unmapped doors in the provided Set.
   */

function lookupFloor(partition, door, direction, unmapped) {
  const normPart = String(partition || '').trim().toUpperCase();
  const normDoor = normalizeDoor(door);

  // Special-case: when Default bucket receives an HQ door for the 15th floor,
  // treat it as the Denver HQ (US.CO.OBS Floor 15).
  if (normPart === 'USA/CANADA DEFAULT' && /USCOHQ.*\b15\b/.test(normDoor)) {
    return direction === 'InDirection' ? 'Floor 15' : 'Out of office';
  }

  // existing logic continues unchanged...
  // 1) exact partition+door match
  let entry = doorMap.find(d =>
    d.partition.trim().toUpperCase() === normPart &&
    d.door === normDoor
  );



    // 1b) fallback for OBS doors mapped under Default
    if (!entry && normPart === 'US.CO.OBS') {
      entry = doorMap.find(d =>
        d.partition.trim().toUpperCase() === 'USA/CANADA DEFAULT' &&
        d.door === normDoor
      );
    }

    // 2) general OBS wildcard (‘*’) under Default
    if (!entry && normPart === 'US.CO.OBS') {
      entry = doorMap.find(d =>
        d.partition.trim().toUpperCase() === 'USA/CANADA DEFAULT' &&
        d.door === '*'
      );
    }

    // 2b) heuristic: catch any “15” or “1” in the door name for OBS
    if (!entry && normPart === 'US.CO.OBS') {
      if (/\b15\b/.test(normDoor)) {
        return direction === 'InDirection' ? 'Floor 15' : 'Out of office';
      }
      if (/\b1\b/.test(normDoor)) {
        return direction === 'InDirection' ? 'Floor 01' : 'Out of office';
      }
    }

    // 3) still no mapping? record and bail
    if (!entry) {
      unmapped.add(`${partition}|${door}`);
      return null;
    }

    return direction === 'InDirection'
      ? entry.inDirectionFloor
      : entry.outDirectionFloor;
  }






/**
 * Format an ISO timestamp into the given partition’s timezone, with AM/PM.
 */
function formatInZone(isoString, partition) {
  const tz = tzMap[partition] || 'UTC';
  return new Intl.DateTimeFormat('en-US', {
    timeZone: tz,
    hour12:  true,
    year:    'numeric',
    month:   '2-digit',
    day:     '2-digit',
    hour:    'numeric',
    minute:  '2-digit',
    second:  '2-digit'
  }).format(new Date(isoString));
}


  /**
   * GET /api/occupancy/live
   */
  exports.getLiveOccupancy = async (req, res) => {
    try {
      const data = await service.fetchLiveOccupancy();
      res.json({ success:true, count:data.length, data });
    } catch (e) {
      console.error(e);
      res.status(500).json({ success:false, message:'Live occupancy fetch failed' });
    }
  };


  

/**
 * GET /api/occupancy/live
 */
exports.getLiveOccupancy = async (req, res) => {
  try {
    const data = await service.fetchLiveOccupancy();
    res.json({ success:true, count:data.length, data });
  } catch (e) {
    console.error(e);
    res.status(500).json({ success:false, message:'Live occupancy fetch failed' });
  }
};


/**
 * GET /api/occupancy/live-summary
 * Optional query param: ts=ISO timestamp (UTC, e.g. "...?ts=2025-07-15T10:30:00Z")
 */
exports.getLiveSummary = async (req, res) => {
  try {
    const { ts } = req.query;

    // ────────────────────────────
    // 1) Time-travel branch (pure UTC)
    // ────────────────────────────
    if (ts) {
      const timestamp = new Date(ts);
      if (isNaN(timestamp)) {
        return res
          .status(400)
          .json({ success:false, message:'invalid ts query param' });
      }

      // UTC date string of ts
      const dayStr = timestamp.toISOString().slice(0,10); // e.g. "2025-07-15"

      // a) fetch last 24h, narrow to that UTC date
      const raw     = await service.fetchHistoricalData({ days:1, location:null });
      const sameDay = raw.filter(r => 
        new Date(r.LocaleMessageTime).toISOString().slice(0,10) === dayStr
      );

      // b) keep only swipes ≤ ts
      const upTo = sameDay.filter(r => new Date(r.LocaleMessageTime) <= timestamp);

      // c) last swipe per person ≤ ts
      const lastByPerson = {};
      upTo.forEach(r => {
        const key = r.PersonGUID;
        const t   = new Date(r.LocaleMessageTime).getTime();
        if (!lastByPerson[key] ||
            t > new Date(lastByPerson[key].LocaleMessageTime).getTime()) {
          lastByPerson[key] = r;
        }
      });

      // d) build “today” & realtime snapshot
      const today    = { total:0, Employee:0, Contractor:0 };
      const realtime = {};
      const details  = [];
      const unmapped = new Set();

      Object.values(lastByPerson).forEach(r => {
        // count
        const isEmp = isEmployeeType(r.PersonnelType);
        today.total++;
        if (isEmp) today.Employee++; else today.Contractor++;

        // floor mapping
        const floorName = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmapped) || 'Unknown';
        if (floorName === 'Out of office') return;

        // tally realtime
        const p = r.PartitionName2;
        realtime[p] = realtime[p] || { total:0, Employee:0, Contractor:0, floors:{} };
        realtime[p].total++;
        if (isEmp) realtime[p].Employee++; else realtime[p].Contractor++;
        realtime[p].floors[floorName] = (realtime[p].floors[floorName]||0) + 1;

        // detail row (UTC)
        details.push({
          ...r,
          snapshotTime:      r.LocaleMessageTime,
          LocaleMessageTime: new Date(r.LocaleMessageTime).toISOString(),
          floor:             floorName
        });
      });

      return res.json({
        success:      true,
        timestampUtc: timestamp.toISOString(),
        today,
        realtime,
        details
      });
    }

    // ────────────────────────────
    // 2) Default live branch
    // ────────────────────────────
    const swipes = await service.fetchLiveOccupancy();

    // 2a) “today” = first swipe per person (UTC date = today)
    const first = {};
    swipes.forEach(r => {
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!first[r.PersonGUID] ||
          t < new Date(first[r.PersonGUID].LocaleMessageTime).getTime()) {
        first[r.PersonGUID] = r;
      }
    });
    const today = { total:0, Employee:0, Contractor:0 };
    Object.values(first).forEach(r => {
      today.total++;
      isEmployeeType(r.PersonnelType)
        ? today.Employee++
        : today.Contractor++;
    });

    // 2b) “realtime” = last swipe per person
    const last     = {};
    const realtime = {};
    const details  = [];
    const unmapped = new Set();

    swipes.forEach(r => {
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!last[r.PersonGUID] ||
          t > new Date(last[r.PersonGUID].LocaleMessageTime).getTime()) {
        last[r.PersonGUID] = r;
      }
    });

    Object.values(last).forEach(r => {
      // skip OUT→“Out of office”
      if (r.Direction === 'OutDirection') {
        const fl = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmapped);
        if (fl === 'Out of office') return;
      }

      // floor
      const floorName = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmapped) || 'Unknown';
      if (floorName === 'Out of office') return;

      // tally
      const p = r.PartitionName2;
      realtime[p] = realtime[p] || { total:0, Employee:0, Contractor:0, floors:{} };
      realtime[p].total++;
      isEmployeeType(r.PersonnelType)
        ? realtime[p].Employee++
        : realtime[p].Contractor++;
      realtime[p].floors[floorName] = (realtime[p].floors[floorName]||0) + 1;

      // detail
      details.push({
        ...r,
        snapshotTime:      r.LocaleMessageTime,
        LocaleMessageTime: new Date(r.LocaleMessageTime).toISOString(),
        floor:             floorName
      });
    });

    return res.json({ success:true, today, realtime, details });
  }
  catch (err) {
    console.error('live-summary error:', err);
    return res.status(500).json({ success:false, message:'Live summary failed' });
  }
};




  /**
   * GET /api/occupancy/history
   * Optional query params: start=YYYY-MM-DD, end=YYYY-MM-DD
   * Optional URL param: :location
   */
  exports.getHistoricalOccupancy = async (req, res) => {
    try {
      const { start, end } = req.query;
      const location       = req.params.location || null;

      if (start && end) {
        // --- average-over-range logic ---
        const startD = new Date(start);
        const endD   = new Date(end);
        if (isNaN(startD) || isNaN(endD) || endD < startD) {
          return res
            .status(400)
            .json({ success:false, message:'invalid start/end date range' });
        }

        // inclusive days count
        const days = Math.ceil((endD - startD)/(1000*60*60*24)) + 1;
        const raw  = await service.fetchHistoricalData({ days, location });

        // bucket unique PersonGUID per date
        const byDate = {};
        raw.forEach(r => {
          const t    = new Date(r.LocaleMessageTime);
          const date = t.toISOString().slice(0,10);
          if (date < start || date > end) return;
          byDate[date] = byDate[date] || new Set();
          byDate[date].add(r.PersonGUID);
        });

        // build breakdown & average
        const dates     = Object.keys(byDate).sort();
        const breakdown = dates.map(d => ({ date: d, count: byDate[d].size }));
        const sum       = breakdown.reduce((s,x) => s + x.count, 0);
        const average   = breakdown.length ? sum/breakdown.length : 0;

        return res.json({
          success:   true,
          start,
          end,
          average,
          breakdown
        });
      }

      // --- default history logic ---
      const raw = await service.fetchHistoricalOccupancy(location);
      const byDate = {};
      const details = [];

      raw.forEach(r => {
        const iso = (r.LocaleMessageTime instanceof Date)
          ? r.LocaleMessageTime.toISOString()
          : r.LocaleMessageTime;
        const date = iso.slice(0,10);
        byDate[date] = byDate[date] || {};
        const prev = byDate[date][r.PersonGUID];
        if (!prev || new Date(iso) < new Date(prev.LocaleMessageTime)) {
          byDate[date][r.PersonGUID] = { ...r, LocaleMessageTime: iso };
        }
      });

      const summaryByDate = Object.keys(byDate).sort().map(date => {
        const recs = Object.values(byDate[date]);
        details.push(...recs);
        const region = { total:0, Employee:0, Contractor:0 };
        const partitions = {};

        recs.forEach(r => {
          region.total++;
          isEmployeeType(r.PersonnelType) ? region.Employee++ : region.Contractor++;
          if (!location) {
            partitions[r.PartitionName2] = partitions[r.PartitionName2] || { total:0, Employee:0, Contractor:0 };
            partitions[r.PartitionName2].total++;
            isEmployeeType(r.PersonnelType)
              ? partitions[r.PartitionName2].Employee++
              : partitions[r.PartitionName2].Contractor++;
          }
        });

        return {
          date,
          day: new Date(date).toLocaleDateString('en-US',{ weekday:'long' }),
          region: location ? { name: location, ...region } : { name: 'NAMER', ...region },
          partitions: location ? undefined : partitions
        };
      });

      res.json({ success:true, summaryByDate, details });

    } catch (e) {
      console.error('history error:', e);
      res.status(500).json({ success:false, message:'Historical fetch failed' });
    }
  };

  /**
   * GET /api/occupancy/security-officers
   */
  exports.getSecurityOfficersInBuilding = async (req, res) => {
    try {
      const swipes = await service.fetchSecuritySwipes();
      const lastByOfficer = {};

      swipes.forEach(s => {
        const key = s.EmployeeID;
        if (!lastByOfficer[key] ||
            new Date(s.LocaleMessageTime) > new Date(lastByOfficer[key].LocaleMessageTime)) {
          lastByOfficer[key] = s;
        }
      });

      const present = Object.values(lastByOfficer)
        .filter(s => s.Direction === 'InDirection')
        .map(s => {
          const floor = lookupFloor(s.PartitionName2, s.Door, s.Direction, new Set()) || 'Unknown';
          return { badge: s.EmployeeID, time: s.LocaleMessageTime, floor };
        });

      res.json({ success:true, present });
    } catch (e) {
      console.error(e);
      res.status(500).json({ success:false, message:'Security officers fetch failed' });
    }
  };

  /**
   * GET /api/occupancy/visitors-by-floor
   */
  exports.getVisitorCountsByFloor = async (req, res) => {
    try {
      const raw = await service.fetchVisitorCountsByFloor();
      const unmapped = new Set();
      const floorCounts = raw.reduce((acc, { PartitionName2, Floor, visitorCount }) => {
        const floor = lookupFloor(PartitionName2, Floor, 'InDirection', unmapped) || 'Unknown';
        acc[floor] = (acc[floor]||0) + visitorCount;
        return acc;
      }, {});
      const counts = Object.entries(floorCounts)
                          .map(([floor, visitorCount]) => ({ floor, visitorCount }));
      res.json({ success:true, counts });
    } catch (e) {
      console.error(e);
      res.status(500).json({ success:false, message:'Visitor counts fetch failed' });
    }
  };

  /**
   * GET /api/occupancy/badge-rejections
   */
  exports.getBadgeRejections = async (req, res) => {
    try {
      const { liveCount, history } = await service.fetchBadgeRejectionDetails();

      // normalize history rows
      const normHistory = history.map(r => {
        const dateOnlyStr = (r.DateOnly instanceof Date)
          ? r.DateOnly.toISOString().slice(0,10)
          : String(r.DateOnly).slice(0,10);
        let swipeTimeStr;
        if (r.SwipeTime instanceof Date) {
          swipeTimeStr = r.SwipeTime.toISOString().slice(11,19);
        } else {
          const m = String(r.SwipeTime).match(/(\d{2}:\d{2}:\d{2})/);
          swipeTimeStr = m ? m[1] : String(r.SwipeTime);
        }
        return { ...r, DateOnly: dateOnlyStr, SwipeTime: swipeTimeStr, Door: r.Door };
      });

      const todayDate = new Date().toISOString().slice(0,10);
      const todayRows = normHistory.filter(r => r.DateOnly === todayDate);

      const today = {
        total:      liveCount,
        Employee:   todayRows.filter(r => r.PersonnelType === 'Employee').length,
        Contractor: todayRows.filter(r => r.PersonnelType !== 'Employee').length
      };

      const realtime = {};
      todayRows.forEach(r => {
        const loc = r.Location || 'Unknown';
        if (!realtime[loc]) realtime[loc] = { total:0, Employee:0, Contractor:0 };
        realtime[loc].total++;
        if (r.PersonnelType === 'Employee') realtime[loc].Employee++;
        else realtime[loc].Contractor++;
      });

      res.json({ success:true, today, realtime, details: normHistory });
    } catch (e) {
      console.error('Badge‐rejection fetch failed:', e);
      res.status(500).json({ success:false, message:'Badge rejections fetch failed' });
    }
  };

  /**
   * GET /api/occupancy/vendor-time/:badgeId
   */
  exports.getVendorTimeCalc = async (req, res) => {
    try {
      const { badgeId } = req.params;
      const swipes       = await service.fetchVendorSwipes({ vendorBadgeId: badgeId });
      const durations    = [];
      let inTime         = null;

      swipes.forEach(s => {
        const t = new Date(s.LocaleMessageTime);
        if (s.Direction === 'InDirection') {
          inTime = t;
        } else if (s.Direction === 'OutDirection' && inTime) {
          durations.push((t - inTime) / 3600000);
          inTime = null;
        }
      });

      res.json({ success:true, badgeId, durations });
    } catch (e) {
      console.error(e);
      res.status(500).json({ success:false, message:'Vendor time calc failed' });
    }
  };


