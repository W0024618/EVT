const generateRawExcel = async (rows, opts = {}) => {
  // local helper to format Swipe times (kept from original)
  const formatTimeFromSwipe = (swipeIso) => {
    if (!swipeIso) return '';
    const dt = new Date(swipeIso);
    if (!isNaN(dt.getTime())) {
      return formatTimeFromServerISO(swipeIso);
    }
    const parts = ('' + swipeIso).split(':').map(p => parseInt(p || 0, 10));
    const hh = parts[0] || 0;
    const mm = parts[1] || 0;
    const ss = parts[2] || 0;
    const ampm = hh >= 12 ? 'PM' : 'AM';
    const hh12 = ((hh + 11) % 12) + 1;
    return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
  };

  const admitFilter = (opts.rawAdmitFilter || 'all').toString().toLowerCase();

  const baseHeaders = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber'];
  const admitCol = 'AdmitCode';
  const rejCol = 'Rejection_Type';
  const tailCols = ['Direction','Door'];

  let headers = [...baseHeaders];
  if (admitFilter === 'all') {
    headers.push(admitCol, ...tailCols, rejCol);
  } else if (admitFilter === 'admit') {
    headers.push(admitCol, ...tailCols);
  } else if (admitFilter === 'reject') {
    headers.push(...tailCols, rejCol);
  } else {
    headers.push(admitCol, ...tailCols, rejCol);
  }

  // If no rows, still create a single workbook with header row
  const wb = new ExcelJS.Workbook();

  // Safety/config
  const MAX_ROWS_PER_SHEET = 100000; // adjust to taste; keeps sheets reasonable in browser
  const AUTOSIZE_LIMIT = 20000; // only autosize columns if total rows < this (keeps memory down)

  // Helper: obtain year-month key for a row (e.g. "2025-01") or 'unknown'
  const monthKeyForRow = (r) => {
    try {
      const iso = getServerISO(r);
      if (iso) {
        const d = new Date(iso);
        if (!isNaN(d.getTime())) {
          const y = d.getUTCFullYear();
          const m = pad2(d.getUTCMonth() + 1);
          return `${y}-${m}`;
        }
      }
      if (r.DateOnly) {
        const dt = isoDateOnlyToLocalDate(r.DateOnly);
        if (dt) {
          const y = dt.getFullYear();
          const m = pad2(dt.getMonth() + 1);
          return `${y}-${m}`;
        }
      }
    } catch (e) { /* ignore */ }
    return 'unknown';
  };

  // Build map monthKey -> rows
  let rowsByMonth = {};
  if (Array.isArray(rows) && rows.length) {
    rows.forEach(r => {
      const key = monthKeyForRow(r);
      rowsByMonth[key] = rowsByMonth[key] || [];
      rowsByMonth[key].push(r);
    });
  } else {
    rowsByMonth['empty'] = [];
  }

  // If opts.from / opts.to indicate a single-month selection we might still have mixed month values from data;
  // but user requested splitting by month when range > 1 month â€” detect that:
  let shouldSplitByMonth = false;
  try {
    if (opts.from && opts.to) {
      const f = new Date(opts.from);
      const t = new Date(opts.to);
      if (!isNaN(f.getTime()) && !isNaN(t.getTime())) {
        // If more than 31 days or different month/year -> split by month
        const monthSpan = (t.getFullYear() - f.getFullYear()) * 12 + (t.getMonth() - f.getMonth());
        if (monthSpan >= 1) shouldSplitByMonth = true;
      }
    }
  } catch (e) { /* ignore */ }

  // Also force split if data huge
  if ((Array.isArray(rows) && rows.length > MAX_ROWS_PER_SHEET)) shouldSplitByMonth = true;

  // If not splitting by month, put everything into a single "Raw" sheet but still chunk by MAX_ROWS_PER_SHEET
  if (!shouldSplitByMonth) {
    // We'll create a single 'Raw' sheet and chunk into multiple "Raw Sheet 1/2/..." only if large.
    const allRows = Array.isArray(rows) ? rows : [];
    if (!allRows.length) {
      const ws = wb.addWorksheet('Raw');
      hideGridLines(ws);
      const hdr = ws.addRow(headers);
      applyHeaderStyles(hdr);
    } else {
      // chunk
      for (let i = 0; i < allRows.length; i += MAX_ROWS_PER_SHEET) {
        const chunk = allRows.slice(i, i + MAX_ROWS_PER_SHEET);
        const part = Math.floor(i / MAX_ROWS_PER_SHEET) + 1;
        const sheetName = (part === 1) ? 'Raw' : `Raw Sheet ${part}`;
        const ws = wb.addWorksheet(sheetName);
        hideGridLines(ws);
        const hdr = ws.addRow(headers);
        applyHeaderStyles(hdr);

        chunk.forEach(r => {
          const iso = getServerISO(r);
          const dateStr = iso ? formatDateFromServerISO(iso) : (r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '');
          const timeStr = iso ? formatTimeFromServerISO(iso) : (r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '');
          const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');
          const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';
          const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

          const fullObj = {
            LocaleMessageTime: localeMsgFormatted,
            DateOnly: dateOnlyFormatted,
            Swipe_Time: swipeTimeFormatted,
            EmployeeID: r.EmployeeID || '',
            ObjectName1: r.ObjectName1 || '',
            PersonnelType: r.PersonnelType || '',
            location: r.location || '',
            CardNumber: r.CardNumber || '',
            AdmitCode: r.AdmitCode || r.Messagetype || '',
            Direction: r.Direction || r.Swipe || '',
            Door: r.Door || r.ObjectName2 || '',
            Rejection_Type: r.Rejection_Type || ''
          };

          const rowVals = headers.map(h => (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '');
          const added = ws.addRow(rowVals);
          added.eachCell(c => {
            c.border = THIN_BORDER;
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        // autosize only when small overall to avoid heavy memory use
        if (allRows.length < AUTOSIZE_LIMIT) autosizeColumns(ws);
      }
    }
  } else {
    // Split by monthKey (and chunk each month)
    const monthKeys = Object.keys(rowsByMonth).sort(); // e.g. ["2025-01","2025-02",...]
    monthKeys.forEach(monthKey => {
      const monthRows = rowsByMonth[monthKey] || [];
      if (!monthRows.length) {
        // still create an empty month sheet for completeness
        const human = monthKey === 'unknown' ? 'Unknown' : (() => {
          const [y,m] = monthKey.split('-');
          const mm = parseInt(m,10);
          const monName = MONTH_ABBR[mm-1] || m;
          return `${monName}-${y}`;
        })();
        const ws = wb.addWorksheet(`${human} Sheet 1`);
        hideGridLines(ws);
        const hdr = ws.addRow(headers);
        applyHeaderStyles(hdr);
        return;
      }

      // convert monthKey into a human name
      const humanMonth = (monthKey === 'unknown') ? 'Unknown' : (() => {
        const [y,m] = monthKey.split('-');
        const mm = parseInt(m,10);
        const monName = MONTH_ABBR[mm-1] || m;
        return `${monName}-${y}`;
      })();

      for (let i = 0; i < monthRows.length; i += MAX_ROWS_PER_SHEET) {
        const chunk = monthRows.slice(i, i + MAX_ROWS_PER_SHEET);
        const part = Math.floor(i / MAX_ROWS_PER_SHEET) + 1;
        const sheetName = (part === 1) ? `${humanMonth} Sheet 1` : `${humanMonth} Sheet ${part}`;
        const ws = wb.addWorksheet(sheetName);
        hideGridLines(ws);
        const hdr = ws.addRow(headers);
        applyHeaderStyles(hdr);

        chunk.forEach(r => {
          const iso = getServerISO(r);
          const dateStr = iso ? formatDateFromServerISO(iso) : (r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '');
          const timeStr = iso ? formatTimeFromServerISO(iso) : (r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '');
          const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');
          const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';
          const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

          const fullObj = {
            LocaleMessageTime: localeMsgFormatted,
            DateOnly: dateOnlyFormatted,
            Swipe_Time: swipeTimeFormatted,
            EmployeeID: r.EmployeeID || '',
            ObjectName1: r.ObjectName1 || '',
            PersonnelType: r.PersonnelType || '',
            location: r.location || '',
            CardNumber: r.CardNumber || '',
            AdmitCode: r.AdmitCode || r.Messagetype || '',
            Direction: r.Direction || r.Swipe || '',
            Door: r.Door || r.ObjectName2 || '',
            Rejection_Type: r.Rejection_Type || ''
          };

          const rowVals = headers.map(h => (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '');
          const added = ws.addRow(rowVals);
          added.eachCell(c => {
            c.border = THIN_BORDER;
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        // autosize only when this month chunk is reasonably small
        if (monthRows.length < AUTOSIZE_LIMIT) autosizeColumns(ws);
      }
    });
  }

  // finalize filename & download
  const filename = buildRawFileName(opts);
  try {
    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  } catch (err) {
    // If writeBuffer fails (memory/timeout), try a fallback: create a minimal "Too large" workbook message sheet
    console.error('generateRawExcel writeBuffer error', err);
    try {
      const fallbackWb = new ExcelJS.Workbook();
      const ws = fallbackWb.addWorksheet('Export_Failed');
      ws.getCell('A1').value = 'Export failed because the result set is too large for browser export.';
      ws.getCell('A2').value = 'Please reduce the date range (choose 1 month or less) or filter by location/employee and try again.';
      const buf2 = await fallbackWb.xlsx.writeBuffer();
      const blob2 = new Blob([buf2], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const link2 = document.createElement('a');
      link2.href = URL.createObjectURL(blob2);
      link2.download = filename.replace('.xlsx', '_FAILED.xlsx');
      link2.click();
    } catch (e) {
      alert('Failed to generate raw export: ' + (e && e.message ? e.message : String(e)));
    }
  }
};

















Good Morning , Happy Diwali 
Today i want to start from Report page..
I just want to Update logic for Raw report when i run Query or when i try to pull report for APAC and month select jan to march ..
any month ..Data is too long so Ui get stuck and we got message like page is unresponsive , please wait . and finally we got memory error 

If data is too long then then When export function for raw report we can u able to make like 
Data is too big or selected month is greate than 1 month then make data Sheet Wise in same file like 
for Jan Sheet 1 , Feb Sheet 2 ... Like 

SO we can prevent this error ...
so check below file and update only for Raw report ....

// C:\Users\W0024618\Desktop\global-page\frontend\src\pages\ReportsPage.jsx
import React, { useState, useEffect, useRef } from 'react';
import {
  Box, FormControl, InputLabel, Select, OutlinedInput,
  Checkbox, ListItemText, MenuItem, Button,
  CircularProgress, Typography, TextField, Tabs, Tab, Grid, Paper, IconButton, Divider, Autocomplete
} from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import axios from 'axios';
import ExcelJS from 'exceljs';
import * as XLSX from 'xlsx';
import { useAuth } from '../context/AuthContext';

import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import PlaceIcon from '@mui/icons-material/Place';
import PeopleIcon from '@mui/icons-material/People';
import DownloadIcon from '@mui/icons-material/CloudDownload';
import FilterListIcon from '@mui/icons-material/FilterList';
import Avatar from '@mui/material/Avatar';
import { generateDailyAccessExcelFromRows } from './DailyAccessReport';

// Static lists
const EMPLOYEE_OPTIONS = [
  'Vainilaitis, Valdas',
  'Tomasevic, Kazimez',
  'Sesickis, Janas',
  'Valiunas, Sigitas',
  'JANCUKOVIC, VACLAVA',
  'Kalpokiene, Alina',
  'Korkus, Vanda',
  'Kvaraciejiene, Maryte',
  'ZNAMEROVSKIS, DARIUS',
  'Dovgialo, Liucija'
];

const REGION_OPTIONS = ['global', 'apac', 'emea', 'laca', 'namer'];
const LOCATION_MAP = {
  apac: ['APAC.Default', 'JP.Tokyo', 'PH.Manila', 'MY.Kuala Lumpur','IN.HYD'],
  emea: ['AUT.Vienna', 'DU.Abu Dhab', 'IE.Dublin', 'IT.Rome', 'LT.Vilnius', 'MA.Casablanca', 'RU.Moscow', 'UK.London', 'ES.Madrid'],
  laca: ['AR.Cordoba', 'CR.Costa Rica Partition', 'MX.Mexico City', 'PE.Lima', 'BR.Sao Paulo', 'PA.Panama City'],
  namer: ['US.NYC', 'US.FL.Miami', 'USA/Canada Default', 'US.CO.OBS','US.Denver'],
  global: []
};

function formatDisplayDate(date) {
  if (!date) return '';
  const d = new Date(date);
  const day = d.getDate();
  const suf = day % 10 === 1 && day !== 11 ? 'st'
    : day % 10 === 2 && day !== 12 ? 'nd'
      : day % 10 === 3 && day !== 13 ? 'rd' : 'th';
  const mon = d.toLocaleString('default', { month: 'long' });
  return `${day}${suf} ${mon} ${d.getFullYear()}`;
}

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');



 // ---------- helpers for Excel formatting ----------
  const HEADER_FILL = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFCCE8FF' } }; // light blue
  const THIN_BORDER = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
  const THICK_BORDER = { top: { style: 'thick' }, left: { style: 'thick' }, bottom: { style: 'thick' }, right: { style: 'thick' } };

  function hideGridLines(ws) {
    try {
      ws.views = [{ showGridLines: false }];
    } catch (e) { /* ignore */ }
  }

  function applyHeaderStyles(row) {
    row.eachCell(cell => {
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.fill = HEADER_FILL;
      cell.border = THICK_BORDER;
    });
  }

  function applyThinBordersToWorksheet(ws, headerRowIndex = 1) {
    ws.eachRow((row, rIdx) => {
      row.eachCell(cell => {
        // skip header row (we already applied thick border)
        if (rIdx === headerRowIndex) return;
        // ensure border exists
        cell.border = THIN_BORDER;
        if (!cell.alignment) cell.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });
  }

  function autosizeColumns(ws) {
    // simple heuristic: compute max text length per column
    const colCount = ws.columnCount || (ws._columns && ws._columns.length) || 0;
    for (let c = 1; c <= colCount; c++) {
      let maxLen = 10; // minimal
      ws.eachRow((row) => {
        const cell = row.getCell(c);
        const v = cell && cell.value !== undefined && cell.value !== null ? String(cell.value) : '';
        if (v.length > maxLen) maxLen = v.length;
      });
      // width heuristic: a little padding, cap to reasonable value
      const width = Math.min(60, Math.max(10, Math.ceil(maxLen * 1.2)));
      try {
        ws.getColumn(c).width = width;
      } catch (e) { /* ignore if impossible */ }
    }
  }
  // ---------- end helpers ----------




// --- Helper functions (unchanged from your original) ---
function _extractServerDateTimeParts(iso) {
  if (!iso) return null;
  const s = String(iso);
  let datePart = '', timePart = '';
  if (s.includes('T')) {
    [datePart, timePart] = s.split('T');
  } else if (s.includes(' ')) {
    [datePart, timePart] = s.split(' ');
  } else {
    return null;
  }
  datePart = datePart.slice(0, 10);
  timePart = (timePart || '').replace(/Z|[+-]\d{2}:\d{2}$/, '').replace(/\.\d+$/, '');
  const dParts = datePart.split('-').map(p => parseInt(p, 10));
  const tParts = timePart.split(':').map(p => parseInt(p || '0', 10));
  return {
    year: dParts[0] || 0,
    month: dParts[1] || 0,
    day: dParts[2] || 0,
    hour: tParts[0] || 0,
    minute: tParts[1] || 0,
    second: tParts[2] || 0
  };
}

function formatDateFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  const y = dt.getUTCFullYear();
  const m = dt.getUTCMonth(); // 0..11
  const d = dt.getUTCDate();
  const yrShort = String(y).slice(-2);
  return `${pad2(d)}-${MONTH_ABBR[m]}-${yrShort}`;         // e.g. "12-Aug-25"
}

function formatTimeFromServerISO(iso) {
  if (!iso) return '';
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const hh = p.hour;
  const mm = p.minute || 0;
  const ss = p.second || 0;
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1;
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
}

function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10);
  if (!swipeIso) {
    return `${datePart}T00:00:00.000`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000`;
  }
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000`;
}

const getServerISO = (r) => {
  if (!r) return '';
  if (r.LocaleMessageTime) return r.LocaleMessageTime;
  if (r.DateOnly) return buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  return '';
};

const getServerYMD = (r) => {
  const iso = getServerISO(r);
  if (!iso) return '';
  return iso.slice(0, 10);
};

const isoDateOnlyToLocalDate = (iso) => {
  if (!iso) return null;
  const s = iso.toString().slice(0, 10);
  const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
  return new Date(y, m - 1, d);
};

const buildLocalDateFromDateOnlyAndSwipe = (dateOnly, swipeTime) => {
  if (!dateOnly) return null;
  const dateStr = dateOnly.toString().slice(0, 10);
  const [yy, mm, dd] = dateStr.split('-').map(n => parseInt(n, 10));

  let hh = 0, min = 0, ss = 0;
  if (swipeTime) {
    const parsed = new Date(swipeTime);
    if (!isNaN(parsed.getTime())) {
      hh = parsed.getUTCHours();
      min = parsed.getUTCMinutes();
      ss = parsed.getUTCSeconds();
    } else {
      const parts = swipeTime.split(':').map(p => parseInt(p, 10));
      if (parts.length >= 2) {
        hh = parts[0] || 0;
        min = parts[1] || 0;
        ss = parts[2] || 0;
      }
    }
  }
  return new Date(yy, mm - 1, dd, hh, min, ss);
};

export default function ReportsPage() {
  const auth = useAuth();

  // --- state ---
  const [tab, setTab] = useState(0);

  // default region now set to 'emea' for initial tab 0 behavior
  const [region, setRegion] = useState('emea');
  const [location, setLocation] = useState('LT.Vilnius');
  const [from, setFrom] = useState(null);
  const [to, setTo] = useState(null);
  const [showFromCal, setShowFromCal] = useState(false);
  const [showToCal, setShowToCal] = useState(false);
  const [selectedEmps, setSelectedEmps] = useState([]);
  const [loading, setLoading] = useState(false);
  const [generatingMessage, setGeneratingMessage] = useState('');

  const [rawSearch, setRawSearch] = useState('');
  const [rawAdmitFilter, setRawAdmitFilter] = useState('all');
  const [newEmployee, setNewEmployee] = useState('');

  const [availableLocations, setAvailableLocations] = useState([]);
  const [selectedLocations, setSelectedLocations] = useState([]);
  const [rawEmpOptions, setRawEmpOptions] = useState([]);
  const [selectedRawEmps, setSelectedRawEmps] = useState([]);
  const empQueryRef = useRef(null);

  // Provide region options depending on tab
  const regionOptionsForTab = () => {
    if (tab === 0) return ['emea'];            // Daily Access -> only EMEA
    if (tab === 3) return ['emea'];            // EUROC -> only EMEA
    if (tab === 4) return ['apac'];            // Time Duration -> only APAC
    if (tab === 6) return ['namer'];           // Denver -> NAMER
    return REGION_OPTIONS;                     // default (Raw, Rejection, HeadCount, etc.)
  };

  // Provide location options depending on tab & region
  const locationOptionsForTab = (r) => {
    const rr = r || region;
    if (tab === 0) return ['LT.Vilnius']; // Daily Access -> only Vilnius
    if (tab === 6) return ['US.Denver']; // Denver -> Denver only
    if (tab === 3) {
      // EUROC -> show full EMEA location list (allow multi-selection)
      return availableLocations.length ? availableLocations : (LOCATION_MAP['emea'] || []);
    }
    if (tab === 4) {
      // Time Duration -> show APAC location list strictly
      return availableLocations.length ? availableLocations : (LOCATION_MAP['apac'] || []);
    }
    if (tab === 1) {
      return availableLocations.length ? availableLocations : (LOCATION_MAP[rr] || []);
    }
    // default
    return availableLocations.length ? availableLocations : (LOCATION_MAP[rr] || []);
  };

  // fetch availableLocations for the currently selected region (runs on region change)
  useEffect(() => {
    let mounted = true;
    const load = async () => {
      setAvailableLocations([]);
      if (!region) return;
      const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];

      try {
        if (region === 'global') {
          const promises = MULTI_REGIONS.map(r => fetchLocationsForRegion(r));
          const results = await Promise.all(promises);
          const merged = results.flat();
          if (!mounted) return;
          setAvailableLocations(Array.from(new Set(merged)).sort());
        } else {
          const list = await fetchLocationsForRegion(region);
          if (!mounted) return;
          setAvailableLocations(Array.from(new Set(list)).sort());
        }
      } catch (err) {
        console.error('load locations error', err);
        // fallback to static map
        const key = (region || '').toLowerCase();
        setAvailableLocations((LOCATION_MAP[key] || []).slice());
      }
    };

    // always attempt to fetch when region is set (EUROC & Time Duration need real lists)
    if (region) {
      load();
    } else {
      setAvailableLocations([]);
    }

    return () => { mounted = false; };
  }, [region, tab]);

  // Helper: fetch locations for a single region key (backend endpoint: GET /api/locations?region=apac)
  const fetchLocationsForRegion = async (r) => {
    try {
      if (!r) return [];
      const resp = await axios.get('/api/locations', { params: { region: r } });
      const listRaw = (resp.data && (resp.data.data || resp.data)) || [];
      const list = Array.isArray(listRaw)
        ? listRaw.map(item => {
            if (typeof item === 'string') return item;
            return item.PartitionName2 || item.partition || item.location || item.name || (item.label ? item.label : null);
          }).filter(Boolean)
        : [];
      if (!list.length) {
        const key = (r || '').toLowerCase();
        return (LOCATION_MAP[key] || []).slice();
      }
      return Array.from(new Set(list)).sort();
    } catch (e) {
      console.warn('fetchLocationsForRegion error', r, e);
      const key = (r || '').toLowerCase();
      return (LOCATION_MAP[key] || []).slice();
    }
  };

  // Handle tab switch (Daily / Raw / Rejection / etc.)
  const handleTabChange = (_, v) => {
    setTab(v);

    // Reset shared filters
    setFrom(null);
    setTo(null);
    setSelectedEmps([]);
    setRawSearch('');
    setRawAdmitFilter('all');
    setSelectedLocations([]);
    setSelectedRawEmps([]);
    setNewEmployee('');
    setRawEmpOptions([]);
    setGeneratingMessage('');

    // Default region/location per tab (as requested)
    if (v === 0) {         // Daily Access -> EMEA + Vilnius
      setRegion('emea');
      setLocation('LT.Vilnius');
    } else if (v === 1) {  // Raw -> keep default region (emea) but let user change
      setRegion('emea');
      setLocation('');
    } else if (v === 2) {  // Rejection -> default emea
      setRegion('emea');
      setLocation('');
    } else if (v === 3) {  // EUROC -> EMEA only, allow multi locations
      setRegion('emea');
      setLocation(''); // user chooses 0..n locations (none => all)
    } else if (v === 4) {  // Time Duration -> APAC only
      setRegion('apac');
      setLocation('');
    } else if (v === 5) {  // HeadCount -> default emea
      setRegion('emea');
      setLocation('');
    } else if (v === 6) {  // Denver -> NAMER + Denver
      setRegion('namer');
      setLocation('US.Denver');
    }
  };



  const generateTimeDurationExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Time Duration');

    hideGridLines(ws);

    ws.mergeCells('A1:M1');
    ws.getCell('A1').value =
      `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center', vertical: 'middle' };
    ws.getRow(1).height = 22;

    const headers = [
      'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
      'Partition', 'Text5', 'Year', 'Week', 'Date',
      'First Swipe', 'Last Swipe', 'Duration', 'Category',
      'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
    ];
    const headerRow = ws.addRow(headers);
    applyHeaderStyles(headerRow);

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'ptype', width: 18 },
      { key: 'part', width: 15 },
      { key: 'txt5', width: 20 },
      { key: 'year', width: 8 },
      { key: 'week', width: 6 },
      { key: 'date', width: 12 },
      { key: 'first', width: 16 },
      { key: 'last', width: 16 },
      { key: 'dur', width: 10 },
      { key: 'cat', width: 12 },
      { key: 'dpw', width: 12 },
      { key: 'vdw', width: 14 },
      { key: 'cdw', width: 12 },
      { key: 'def', width: 10 }
    ];

    data.forEach((r, idx) => {
      const first = r.FirstSwipeTime ? new Date(r.FirstSwipeTime) : null;
      const last = r.LastSwipeTime ? new Date(r.LastSwipeTime) : null;
      const date = r.ShiftedDate ? new Date(r.ShiftedDate) : null;
      const row = ws.addRow([
        idx + 1,
        r.ObjectName1,
        r.EmployeeID,
        r.PersonnelType,
        r.PartitionName2,
        r.text5,
        r.YearNumber,
        r.WeekNumber,
        date,
        first,
        last,
        r.DurationHHMM,
        r.TimeDiffCategory,
        r.DaysPresentInWeek,
        r.ViolationDaysInWeek,
        r.CleanDaysInWeek,
        r.Defaulter
      ]);

      if (date) row.getCell(9).numFmt = 'dd-mmm-yy';
      if (first) row.getCell(10).numFmt = 'h:mm:ss AM/PM';
      if (last) row.getCell(11).numFmt = 'h:mm:ss AM/PM';

      row.eachCell(c => {
        c.border = THIN_BORDER;
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    // apply autosize
    autosizeColumns(ws);

    ws.autoFilter = 'A2:Q2';

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    const filename =
      `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;

    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };






  
const generateRejectionExcel = async data => {
  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Rejection');

  const GRAY_FILL = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };

  // hide gridlines
  hideGridLines(ws);

  // --- Prepare layout: skip first row and first column (A) ---
  ws.addRow([]); // row 1 (blank)

  // Title in row 2, columns B..K (10 headers -> B..K)
  const title = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}`;
  ws.addRow([null]); // ensure row 2 exists
  ws.mergeCells('B2:K2');
  ws.getCell('B2').value = title;
  ws.getCell('B2').font = { bold: true, size: 14 };
  ws.getCell('B2').alignment = { horizontal: 'center', vertical: 'middle' };
  ws.getRow(2).height = 22;
  // style merged title cells (B2..K2)
  for (let c = 2; c <= 11; c++) {
    const cell = ws.getCell(2, c);
    cell.fill = GRAY_FILL;
    cell.font = { bold: true, size: 14 };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.border = THICK_BORDER;
  }

  // Headers in row 3 (we add a row where first element null keeps column A blank)
  const headers = [
    'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
    'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
  ];
  const headerRow = ws.addRow([null, ...headers]); // this will be row 3
  headerRow.height = 20;
  headerRow.eachCell((cell, colNumber) => {
    // colNumber counts across the entire row including the null at col A; header cells are cols 2..11
    if (colNumber >= 2 && colNumber <= 11) {
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.fill = GRAY_FILL;
      cell.border = THICK_BORDER;
    }
  });

  // setup columns widths (A blank column + 10 content columns B..K)
  ws.columns = [
    { key: 'blankA', width: 3 }, // column A (skipped)
    { key: 'sr', width: 8 },     // B
    { key: 'date', width: 12 },  // C
    { key: 'time', width: 12 },  // D
    { key: 'name', width: 30 },  // E
    { key: 'id', width: 15 },    // F
    { key: 'card', width: 18 },  // G
    { key: 'type', width: 18 },  // H
    { key: 'door', width: 40 },  // I
    { key: 'loc', width: 18 },   // J
    { key: 'swipe', width: 12 }  // K
  ];

  // Column alignment sets (absolute column indices)
  // With blank A, the content cols shift by +1: Sr -> 2, Date -> 3, ..., Swipe -> 11
  const centerCols = new Set([2,3,4,5,6,7,8,10,11]); // Sr,Date,Time,Name,ID,Card,Type,Location,Swipe
  const leftCols = new Set([9]); // Door Name only (I)

  // Add data rows (starting from row 4)
  data.forEach((r, idx) => {
    const iso = getServerISO(r);
    const dateStr = iso ? formatDateFromServerISO(iso) : (r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '');
    const timeStr = iso ? formatTimeFromServerISO(iso) : (r.Swipe_Time ? formatTimeFromServerISO(r.Swipe_Time) : '');

    const rowVals = [
      null, // column A blank
      idx + 1,
      dateStr,
      timeStr,
      r.ObjectName1 || '',
      r.EmployeeID || '',
      r.CardNumber || '',
      r.Rejection_Type || '',
      r.Door || r.ObjectName2 || '',
      r.location || '',
      r.Direction || r.Swipe || ''
    ];
    const row = ws.addRow(rowVals);

    row.eachCell((cell, colNumber) => {
      // only style cells inside B..K
      if (colNumber >= 2 && colNumber <= 11) {
        cell.border = THIN_BORDER;
        const horiz = leftCols.has(colNumber) ? 'left' : (centerCols.has(colNumber) ? 'center' : 'left');
        cell.alignment = { vertical: 'middle', horizontal: horiz };
      }
    });
  });

  // Apply thick outside border around header + data (columns B..K)
  const headerRowIndex = 3;
  const firstDataRow = headerRowIndex; // include header when constructing outer border
  const lastDataRow = ws.lastRow ? ws.lastRow.number : headerRowIndex;
  const firstCol = 2; // column B
  const lastCol = 11; // column K

  for (let r = firstDataRow; r <= lastDataRow; r++) {
    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(r, c);
      if (!cell.border) cell.border = THIN_BORDER;
      const border = {
        top: (r === firstDataRow) ? { style: 'thick' } : (cell.border.top || { style: 'thin' }),
        bottom: (r === lastDataRow) ? { style: 'thick' } : (cell.border.bottom || { style: 'thin' }),
        left: (c === firstCol) ? { style: 'thick' } : (cell.border.left || { style: 'thin' }),
        right: (c === lastCol) ? { style: 'thick' } : (cell.border.right || { style: 'thin' })
      };
      cell.border = border;
    }
  }

  // ---------- Summary block placed to the RIGHT of the table ----------
  // We'll leave one blank column after the last data column, then place summary (2 columns wide)
  const summaryStartCol = lastCol + 2; // skip one column after Swipe
  const summaryTitleRow = headerRowIndex + 1; // place summary title starting near header (row 4)
  const summaryHdrRow = summaryTitleRow + 1;

  // Build counts by Rejection_Type
  const countsMap = {};
  data.forEach(r => {
    const key = (r.Rejection_Type || 'Unknown').toString();
    countsMap[key] = (countsMap[key] || 0) + 1;
  });
  const countEntries = Object.entries(countsMap);

  // Summary title (merged across two summary columns)
  const colLetter = (c => {
    // helper to convert 1-indexed col number to letter(s)
    let n = c, s = '';
    while (n > 0) {
      const m = (n - 1) % 26;
      s = String.fromCharCode(65 + m) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  });
  const sA = colLetter(summaryStartCol);
  const sB = colLetter(summaryStartCol + 1);
  ws.mergeCells(`${sA}${summaryTitleRow}:${sB}${summaryTitleRow}`);
  ws.getCell(`${sA}${summaryTitleRow}`).value = 'Summary';
  ws.getCell(`${sA}${summaryTitleRow}`).font = { bold: true };
  ws.getCell(`${sA}${summaryTitleRow}`).alignment = { horizontal: 'center', vertical: 'middle' };
  ws.getCell(`${sA}${summaryTitleRow}`).fill = GRAY_FILL;
  ws.getCell(`${sA}${summaryTitleRow}`).border = THICK_BORDER;
  ws.getCell(`${sB}${summaryTitleRow}`).fill = GRAY_FILL;
  ws.getCell(`${sB}${summaryTitleRow}`).border = THICK_BORDER;

  // Header row for summary - NOW using THICK_BORDER for header columns
  ws.getCell(summaryHdrRow, summaryStartCol).value = 'Rejection';
  ws.getCell(summaryHdrRow, summaryStartCol + 1).value = 'Count';
  [summaryStartCol, summaryStartCol + 1].forEach(c => {
    const cell = ws.getCell(summaryHdrRow, c);
    cell.font = { bold: true };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.fill = GRAY_FILL;
    // <<== make header cells have thick outside border as requested
    cell.border = THICK_BORDER;
  });

  // Summary detail rows (start below summaryHdrRow)
  let cur = summaryHdrRow + 1;
  countEntries.forEach(([type, cnt]) => {
    ws.getCell(cur, summaryStartCol).value = type;
    ws.getCell(cur, summaryStartCol + 1).value = cnt;
    ws.getCell(cur, summaryStartCol).alignment = { horizontal: 'left', vertical: 'middle' };
    ws.getCell(cur, summaryStartCol + 1).alignment = { horizontal: 'center', vertical: 'middle' };
    ws.getCell(cur, summaryStartCol).border = THIN_BORDER;
    ws.getCell(cur, summaryStartCol + 1).border = THIN_BORDER;
    cur++;
  });

  // Grand Total row - make Grand Total cells bold + thick border
  const grandTotal = data.length || 0;
  ws.getCell(cur, summaryStartCol).value = 'Grand Total';
  ws.getCell(cur, summaryStartCol + 1).value = grandTotal;
  [summaryStartCol, summaryStartCol + 1].forEach(c => {
    const cell = ws.getCell(cur, c);
    cell.font = { bold: true };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.fill = GRAY_FILL;
    // <<== make grand total cells have thick outside border as requested
    cell.border = THICK_BORDER;
  });

  // Apply thick outside border for summary block (this will preserve header/grandTotal thick borders)
  for (let r = summaryTitleRow; r <= cur; r++) {
    for (let c = summaryStartCol; c <= summaryStartCol + 1; c++) {
      const cell = ws.getCell(r, c);
      if (!cell.border) cell.border = THIN_BORDER;
      const border = {
        top: (r === summaryTitleRow) ? { style: 'thick' } : (cell.border.top || { style: 'thin' }),
        bottom: (r === cur) ? { style: 'thick' } : (cell.border.bottom || { style: 'thin' }),
        left: (c === summaryStartCol) ? { style: 'thick' } : (cell.border.left || { style: 'thin' }),
        right: (c === (summaryStartCol + 1)) ? { style: 'thick' } : (cell.border.right || { style: 'thin' })
      };
      cell.border = border;
    }
  }

  // Final workbook buffer & download (filename)
  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const filename = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}.xlsx`;
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
};




  function buildRawFileName(opts = {}) {
    const safe = s => (s === undefined || s === null) ? '' : String(s).replace(/[\/\\:?<>|"]/g, '_').trim();
    const regionPart = opts.region ? safe(opts.region).toUpperCase() : 'RAW';
    const locationPart = opts.location ? `_${safe(opts.location).replace('.', '_')}` : '';
    const admitPart = opts.rawAdmitFilter ? `_${safe(opts.rawAdmitFilter)}` : '';
    const searchPart = opts.rawSearch ? `_${safe(opts.rawSearch).replace(/\s+/g, '_')}` : '';
    const formatDateForName = d => {
      if (!d) return '';
      try {
        if (d instanceof Date) return `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}`;
        const dt = new Date(d);
        if (!isNaN(dt.getTime())) return `${dt.getFullYear()}${pad2(dt.getMonth()+1)}${pad2(dt.getDate())}`;
      } catch (e) { /* ignore */ }
      return safe(d).slice(0,10).replace(/[-\s:]/g,'');
    };

    const fromPart = opts.from ? `_from_${formatDateForName(opts.from)}` : '';
    const toPart   = opts.to   ? `_to_${formatDateForName(opts.to)}` : '';
    const filename = `Raw_${regionPart}${locationPart}${fromPart}${toPart}${admitPart}${searchPart}.xlsx`;
    return filename;
  }



 const generateRawExcel = async (rows, opts = {}) => {
    const formatTimeFromSwipe = (swipeIso) => {
      if (!swipeIso) return '';
      const dt = new Date(swipeIso);
      if (!isNaN(dt.getTime())) {
        return formatTimeFromServerISO(swipeIso);
      }
      const parts = ('' + swipeIso).split(':').map(p => parseInt(p || 0, 10));
      const hh = parts[0] || 0;
      const mm = parts[1] || 0;
      const ss = parts[2] || 0;
      const ampm = hh >= 12 ? 'PM' : 'AM';
      const hh12 = ((hh + 11) % 12) + 1;
      return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
    };

    const admitFilter = (opts.rawAdmitFilter || 'all').toString().toLowerCase();

    const baseHeaders = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber'];
    const admitCol = 'AdmitCode';
    const rejCol = 'Rejection_Type';
    const tailCols = ['Direction','Door'];

    let headers = [...baseHeaders];
    if (admitFilter === 'all') {
      headers.push(admitCol, ...tailCols, rejCol);
    } else if (admitFilter === 'admit') {
      headers.push(admitCol, ...tailCols);
    } else if (admitFilter === 'reject') {
      headers.push(...tailCols, rejCol);
    } else {
      headers.push(admitCol, ...tailCols, rejCol);
    }

    // If no rows, still create workbook with header row
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Raw');
    hideGridLines(ws);

    // header
    const hdr = ws.addRow(headers);
    applyHeaderStyles(hdr);

    if (rows && rows.length) {
      rows.forEach(r => {
        const iso = getServerISO(r);
        const dateStr = iso ? formatDateFromServerISO(iso) : '';
        const timeStr = iso ? formatTimeFromServerISO(iso) : '';
        const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');
        const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';
        const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

        const fullObj = {
          LocaleMessageTime: localeMsgFormatted,
          DateOnly: dateOnlyFormatted,
          Swipe_Time: swipeTimeFormatted,
          EmployeeID: r.EmployeeID || '',
          ObjectName1: r.ObjectName1 || '',
          PersonnelType: r.PersonnelType || '',
          location: r.location || '',
          CardNumber: r.CardNumber || '',
          AdmitCode: r.AdmitCode || r.Messagetype || '',
          Direction: r.Direction || r.Swipe || '',
          Door: r.Door || r.ObjectName2 || '',
          Rejection_Type: r.Rejection_Type || ''
        };

        const rowVals = headers.map(h => (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '');
        const added = ws.addRow(rowVals);
        added.eachCell(c => {
          c.border = THIN_BORDER;
          c.alignment = { vertical: 'middle', horizontal: 'left' };
        });
      });
    }

    // autosize
    autosizeColumns(ws);

    const filename = buildRawFileName(opts);
    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };




  const exportPermsForTab = () => {
    if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
    if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
    if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
    if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
    if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
    if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
    if (tab === 6) return ['gsoc_reports.denver_monthly', 'gsoc_reports'];
    return ['gsoc_reports'];
  };

  const disabled = loading
    || (tab !== 6 && !region)
    || (tab === 0 && (!from || !to || selectedEmps.length === 0))
    || (tab === 1 && (!from || !to))
    || (tab === 2 && (!from || !to))
    || (tab === 3 && !from)
    || (tab === 4 && (!from || !to));

  const navDisabled = (tab !== 6 && !region) || loading;
  const exportAllowed = auth.hasPermission(exportPermsForTab());

  // Format helpers used in handleGenerate (copied from your file)
  const formatLocalDate = (date, endOfDay = false) => {
    const d = new Date(date);
    if (endOfDay) d.setHours(23, 59, 59, 999);
    else d.setHours(0, 0, 0, 0);
    const pad = n => n.toString().padStart(2, '0');
    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}` +
           `T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  };

  const toLocalYMD = date => `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`;

  const handleGenerate = async () => {
    const requirePermissionForTab = () => {
      if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
      if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
      if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
      if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
      if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
      if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
      if (tab === 6) return ['gsoc_reports.denver_monthly', 'gsoc_reports'];
      return ['gsoc_reports'];
    };

    if (!auth.hasPermission(requirePermissionForTab())) {
      alert('You do not have permission to generate this report.');
      return;
    }

    // set user-visible generating message (different per tab)
    const messages = {
      0: 'Generating Daily Access report...',
      1: 'Generating Raw report...',
      2: 'Generating Rejection report...',
      3: 'Generating EUROC Admit-Reject report...',
      4: 'Generating Time Duration report...',
      5: 'Opening HeadCount...',
      6: 'Generating Denver Attendance report...'
    };
    setGeneratingMessage(messages[tab] || 'Generating report...');
    setLoading(true);

    try {
      const baseParams = { region, location: location || undefined };

      // ----- 0: Daily Access -----
      if (tab === 0) {
        const fromDateOnly = `${from.getFullYear()}-${pad2(from.getMonth() + 1)}-${pad2(from.getDate())}`;
        const toDateOnly = `${to.getFullYear()}-${pad2(to.getMonth() + 1)}-${pad2(to.getDate())}`;

        const params = {
          ...baseParams,
          from: fromDateOnly,
          to: toDateOnly,
          employees: selectedEmps.join(',')
        };
        const resp = await axios.get('/api/reports/daily-access', { params });
        const rows = (resp.data && resp.data.data) || [];
        await generateDailyAccessExcelFromRows(rows, { from: fromDateOnly, to: toDateOnly, selectedEmps, region });
        return;
      }

      // ----- 1: Raw -----
      if (tab === 1) {
        const startISO = formatLocalDate(from);
        const endISO = formatLocalDate(to, true);
        const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];
        const requests = [];
        const pushReq = (r, locationParam = undefined) => {
          const params = { startDate: startISO, endDate: endISO, admitFilter: rawAdmitFilter };
          if (r) params.region = r;
          if (locationParam) params.location = locationParam;
          requests.push(axios.get('/api/reports/raw', { params }));
        };

        if (region === 'global') {
          if (selectedLocations && selectedLocations.length) {
            const regionMap = {};
            selectedLocations.forEach(loc => {
              const parts = String(loc).split('.');
              const rKey = (parts[0] || '').toString().toLowerCase();
              regionMap[rKey] = regionMap[rKey] || [];
              regionMap[rKey].push(loc);
            });
            Object.entries(regionMap).forEach(([rKey, locs]) => {
              const isKnown = MULTI_REGIONS.includes(rKey);
              if (isKnown) {
                locs.forEach(loc => pushReq(rKey, loc));
              } else {
                locs.forEach(loc => pushReq(undefined, loc));
              }
            });
          } else {
            MULTI_REGIONS.forEach(r => pushReq(r));
          }
        } else {
          if (selectedLocations && selectedLocations.length) {
            selectedLocations.forEach(loc => pushReq(region, loc));
          } else {
            pushReq(region);
          }
        }

        let rowsSrcCombined = [];
        try {
          if (!requests.length) {
            pushReq(region === 'global' ? MULTI_REGIONS[0] : region);
          }
          const responses = await Promise.all(requests);
          rowsSrcCombined = responses.flatMap(r => (r.data && (r.data.data || r.data)) || []);
        } catch (err) {
          console.error('raw fetch error', err);
          throw err;
        }

        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

        const rows = rowsSrcCombined.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          if (!date) return false;
          return (date >= startDate && date <= endDate);
        });

        let filtered = rows;
        if (rawSearch && rawSearch.trim() !== '') {
          const s = rawSearch.trim().toLowerCase();
          filtered = filtered.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            return id.includes(s) || name.includes(s);
          });
        }

        if (selectedRawEmps && selectedRawEmps.length) {
          const setSel = new Set(selectedRawEmps.map(x => String(x).toLowerCase()));
          filtered = filtered.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            return setSel.has(id) || setSel.has(name) || selectedRawEmps.some(sel => id.includes(String(sel).toLowerCase()) || name.includes(String(sel).toLowerCase()));
          });
        }

        const keySet = new Set();
        const deduped = [];
        filtered.forEach(r => {
          const key = `${getServerISO(r)}|${r.EmployeeID}|${r.Door}|${r.CardNumber}`;
          if (!keySet.has(key)) {
            keySet.add(key);
            deduped.push(r);
          }
        });

        await generateRawExcel(deduped, { region, location: selectedLocations && selectedLocations.join(',') || location, rawSearch, from, to, rawAdmitFilter });
        return;
      }

      // ----- 2: Rejection -----
      if (tab === 2) {
        const params = { ...baseParams, startDate: formatLocalDate(from), endDate: formatLocalDate(to, true) };
        const resp = await axios.get('/api/reports/rejection', { params });
        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);
        const rowsSrc = (resp.data && resp.data.data) || [];
        const rows = rowsSrc.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          return date >= startDate && date <= endDate;
        });
        await generateRejectionExcel(rows);
        return;
      }

      // ----- 3: EUROC Admit-Reject (single day) -----
      if (tab === 3) {
        if (region.toLowerCase() !== 'emea') {
          alert('EUROC report is only available for region EMEA. Please select EMEA.');
          return;
        }
        if (!from) {
          alert('Please select a date (From) for EUROC report.');
          return;
        }

        // If user selected specific locations (selectedLocations) then pass them to backend as comma separated
        const dateParam = toLocalYMD(new Date(from));
        const params = { region: 'emea', date: dateParam };
        if (selectedLocations && selectedLocations.length) params.locations = selectedLocations.join(',');
        const resp = await axios.get('/api/reports/euroc-admit-rejection', { params });
        const { data } = resp.data || {};

        // ---------- EUROC Admit-Reject generation (updated formatting) ----------
        {
          const wb = new ExcelJS.Workbook();

          // common constants
          const GRAY_FILL_LOCAL = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };

          // helper: convert 1-index col num to letter
          const colLetterLocal = (c => {
            let n = c, s = '';
            while (n > 0) {
              const m = (n - 1) % 26;
              s = String.fromCharCode(65 + m) + s;
              n = Math.floor((n - 1) / 26);
            }
            return s;
          });

          // --- helper to build a formatted sheet ---
          function createFormattedSheet(sheetName, titleText, headers, rowsData) {
            const ws = wb.addWorksheet(sheetName);
            hideGridLines(ws);

            // Skip first row
            ws.addRow([]);

            // Title (row 2) merged across content columns (content will start at col B)
            const contentCols = headers.length; // number of content columns
            const startCol = 2; // B
            const endCol = startCol + contentCols - 1;
            const startLetter = colLetterLocal(startCol);
            const endLetter = colLetterLocal(endCol);

            // ensure row 2 exists
            ws.addRow([null]);
            ws.mergeCells(`${startLetter}2:${endLetter}2`);
            ws.getCell(`${startLetter}2`).value = titleText;
            ws.getCell(`${startLetter}2`).font = { bold: true, size: 14 };
            ws.getCell(`${startLetter}2`).alignment = { horizontal: 'center', vertical: 'middle' };
            ws.getRow(2).height = 22;

            // style merged title cells (thick border + gray fill)
            for (let c = startCol; c <= endCol; c++) {
              const cell = ws.getCell(2, c);
              cell.fill = GRAY_FILL_LOCAL;
              cell.font = { bold: true, size: 14 };
              cell.alignment = { horizontal: 'center', vertical: 'middle' };
              cell.border = THICK_BORDER;
            }

            // Header row (row 3) - insert with a null at col A so column A remains blank
            const headerRow = ws.addRow([null, ...headers]);
            headerRow.height = 20;
            headerRow.eachCell((cell, colNumber) => {
              if (colNumber >= startCol && colNumber <= endCol) {
                cell.font = { bold: true };
                cell.alignment = { horizontal: 'center', vertical: 'middle' };
                cell.fill = GRAY_FILL_LOCAL;
                cell.border = THICK_BORDER;
              }
            });

            // set columns (include blank A)
            const cols = [{ key: 'blankA', width: 3 }];
            headers.forEach(h => cols.push({ key: h.replace(/\s+/g, '').toLowerCase(), width: 18 }));
            ws.columns = cols;

            // All data columns center aligned (including "Door Name")
            const centerCols = new Set();
            for (let c = startCol; c <= endCol; c++) centerCols.add(c);

            // Data rows start at row 4
            (rowsData || []).forEach((r, idx) => {
              // map row values in same order as headers
              const vals = headers.map(h => {
                // pick common fields or fallback to empty
                const key = h.toString();
                if (/Sr\.?\s*No/i.test(key)) return idx + 1;
                if (/Date/i.test(key)) {
                  // prefer formatted date if available
                  const iso = getServerISO(r);
                  return iso ? formatDateFromServerISO(iso) : (r.DateOnly || '');
                }
                if (/Time/i.test(key)) {
                  const iso = getServerISO(r);
                  return iso ? formatTimeFromServerISO(iso) : (r.Swipe_Time || r.Direction || '');
                }
                if (/Employee Name/i.test(key)) return r.ObjectName1 || r.EmployeeName || '';
                if (/Employee ID/i.test(key)) return r.EmployeeID || '';
                if (/Access Card/i.test(key)) return r.CardNumber || r.Card || r.CardNo || '';
                if (/Rejection Type/i.test(key)) return r.Rejection_Type || r.RejectType || '';
                if (/Personnel Type/i.test(key)) return r.PersonnelType || '';
                if (/Door Name/i.test(key)) return r.Door || r.ObjectName2 || '';
                if (/Location/i.test(key)) return r.location || '';
                if (/Swipe/i.test(key)) return r.Direction || r.Swipe || '';
                return (r[key] !== undefined && r[key] !== null) ? r[key] : '';
              });

              // prepend null for column A
              const row = ws.addRow([null, ...vals]);

              row.eachCell((cell, colNumber) => {
                if (colNumber >= startCol && colNumber <= endCol) {
                  cell.border = THIN_BORDER;
                  cell.alignment = { vertical: 'middle', horizontal: (centerCols.has(colNumber) ? 'center' : 'left') };
                }
              });
            });

            // apply thick outside border around header + data (B..end)
            const headerRowIndex = 3;
            const firstDataRow = headerRowIndex;
            const lastDataRow = ws.lastRow ? ws.lastRow.number : headerRowIndex;
            for (let r = firstDataRow; r <= lastDataRow; r++) {
              for (let c = startCol; c <= endCol; c++) {
                const cell = ws.getCell(r, c);
                if (!cell.border) cell.border = THIN_BORDER;
                const border = {
                  top: (r === firstDataRow) ? { style: 'thick' } : (cell.border.top || { style: 'thin' }),
                  bottom: (r === lastDataRow) ? { style: 'thick' } : (cell.border.bottom || { style: 'thin' }),
                  left: (c === startCol) ? { style: 'thick' } : (cell.border.left || { style: 'thin' }),
                  right: (c === endCol) ? { style: 'thick' } : (cell.border.right || { style: 'thin' })
                };
                cell.border = border;
              }
            }

            // return metadata so caller can add a summary block to the right
            return { ws, startCol, endCol, headerRowIndex, lastDataRow };
          }

          // Build admit sheet
          const admitHeaders = [
            'Sr. No.', 'Date', 'Time', 'Employee Name',
            'Access Card No.', 'Personnel Type', 'Door Name', 'Location', 'Swipe'
          ];
          const admitRows = (data && data.admit) ? (data.admit.map(r => r)) : [];
          const admitMeta = createFormattedSheet('EUROC Admit', `EUROC Admit Report - ${formatDisplayDate(from)}`, admitHeaders, admitRows);

          // Build rejection sheet
          const rejHeaders = [
            'Sr. No.', 'Date', 'Time', 'Employee Name', 'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
          ];
          const rejRows = (data && data.rejection) ? (data.rejection.map(r => r)) : [];
          const rejMeta = createFormattedSheet('EUROC Rejection', `EUROC Rejection Report - ${formatDisplayDate(from)}`, rejHeaders, rejRows);

          // ---------- Summary placement & formatting (same style as Rejection) ----------
          // We'll add a summary block on the REJECTION sheet (rejMeta) to the right of the table
          (function addSummaryToRejectionSheet() {
            const ws2 = rejMeta.ws;
            const lastCol = rejMeta.endCol;
            const summaryStartCol = lastCol + 2; // skip one blank column after Swipe
            const summaryTitleRow = rejMeta.headerRowIndex + 1; // one row below header (row 4)
            const summaryHdrRow = summaryTitleRow + 1;

            // Build counts map
            const countsMap = {};
            if (data && Array.isArray(data.summary) && data.summary.length) {
              (data.summary || []).forEach(c => {
                const key = c.Rejection_Type || c.rejectionType || 'Unknown';
                const cnt = (typeof c.Count === 'number') ? c.Count : c.count || 0;
                countsMap[key] = (countsMap[key] || 0) + cnt;
              });
            }
            // fallback: if summary empty, compute from rejection rows
            if (Object.keys(countsMap).length === 0) {
              (rejRows || []).forEach(r => {
                const k = (r.Rejection_Type || 'Unknown').toString();
                countsMap[k] = (countsMap[k] || 0) + 1;
              });
            }
            const entries = Object.entries(countsMap);

            const sA = colLetterLocal(summaryStartCol);
            const sB = colLetterLocal(summaryStartCol + 1);
            ws2.mergeCells(`${sA}${summaryTitleRow}:${sB}${summaryTitleRow}`);
            ws2.getCell(`${sA}${summaryTitleRow}`).value = 'Summary';
            ws2.getCell(`${sA}${summaryTitleRow}`).font = { bold: true };
            ws2.getCell(`${sA}${summaryTitleRow}`).alignment = { horizontal: 'center', vertical: 'middle' };
            ws2.getCell(`${sA}${summaryTitleRow}`).fill = GRAY_FILL_LOCAL;
            ws2.getCell(`${sA}${summaryTitleRow}`).border = THICK_BORDER;
            ws2.getCell(`${sB}${summaryTitleRow}`).fill = GRAY_FILL_LOCAL;
            ws2.getCell(`${sB}${summaryTitleRow}`).border = THICK_BORDER;

            // header row for summary (use THICK_BORDER on header cells)
            ws2.getCell(summaryHdrRow, summaryStartCol).value = 'Rejection';
            ws2.getCell(summaryHdrRow, summaryStartCol + 1).value = 'Count';
            [summaryStartCol, summaryStartCol + 1].forEach(c => {
              const cell = ws2.getCell(summaryHdrRow, c);
              cell.font = { bold: true };
              cell.alignment = { horizontal: 'center', vertical: 'middle' };
              cell.fill = GRAY_FILL_LOCAL;
              cell.border = THICK_BORDER;
            });

            // detail rows
            let cur = summaryHdrRow + 1;
            entries.forEach(([type, cnt]) => {
              ws2.getCell(cur, summaryStartCol).value = type;
              ws2.getCell(cur, summaryStartCol + 1).value = cnt;
              ws2.getCell(cur, summaryStartCol).alignment = { horizontal: 'left', vertical: 'middle' };
              ws2.getCell(cur, summaryStartCol + 1).alignment = { horizontal: 'center', vertical: 'middle' };
              ws2.getCell(cur, summaryStartCol).border = THIN_BORDER;
              ws2.getCell(cur, summaryStartCol + 1).border = THIN_BORDER;
              cur++;
            });

            // grand total (make thick border & gray fill)
            const total = (rejRows || []).length;
            ws2.getCell(cur, summaryStartCol).value = 'Grand Total';
            ws2.getCell(cur, summaryStartCol + 1).value = total;
            [summaryStartCol, summaryStartCol + 1].forEach(c => {
              const cell = ws2.getCell(cur, c);
              cell.font = { bold: true };
              cell.alignment = { horizontal: 'center', vertical: 'middle' };
              cell.fill = GRAY_FILL_LOCAL;
              cell.border = THICK_BORDER;
            });

            // enforce thick outside border for the entire summary block
            for (let r = summaryTitleRow; r <= cur; r++) {
              for (let c = summaryStartCol; c <= summaryStartCol + 1; c++) {
                const cell = ws2.getCell(r, c);
                if (!cell.border) cell.border = THIN_BORDER;
                const border = {
                  top: (r === summaryTitleRow) ? { style: 'thick' } : (cell.border.top || { style: 'thin' }),
                  bottom: (r === cur) ? { style: 'thick' } : (cell.border.bottom || { style: 'thin' }),
                  left: (c === summaryStartCol) ? { style: 'thick' } : (cell.border.left || { style: 'thin' }),
                  right: (c === (summaryStartCol + 1)) ? { style: 'thick' } : (cell.border.right || { style: 'thin' })
                };
                cell.border = border;
              }
            }
          })();

          // write file
          const buf = await wb.xlsx.writeBuffer();
          const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
          const filename = `EUROC_Admit_Rejection_${dateParam}.xlsx`;
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = filename;
          link.click();
        }

        return;
      }

      // ----- 4: Time Duration -----
      if (tab === 4) {
        if (!from || !to) {
          alert('Please select both Start Date and End Date for Time Duration report.');
          return;
        }
        const startParam = toLocalYMD(new Date(from));
        const endParam = toLocalYMD(new Date(to));
        const params = {
          region,
          startDate: startParam,
          endDate: endParam,
          partition: location ? location.split('.').pop() : 'Default'
        };
        const resp = await axios.get('/api/reports/time-duration', { params });
        await generateTimeDurationExcel(resp.data.data || []);
        return;
      }

     //       // ----- 5: HeadCount / External navigation -----
      if (tab === 5) {
        // final permission check (region specific)
        const permCandidates = [`headcount.${region}`, 'headcount', 'global_access'];
        if (!auth.hasPermission(permCandidates)) {
          alert(`You do not have permission to view HeadCount for ${region.toUpperCase()}.`);
          setLoading(false);
          return;
        }

        let url = '';

        if (region === 'laca') {
          if (!location) url = 'http://10.199.22.57:3003/history';
          else {
            const LACA_URLS = {
              'CR.Costa Rica Partition': 'http://10.199.22.57:3003/partition/CR.Costa%20Rica%20Partition/history',
              'MX.Mexico City': 'http://10.199.22.57:3003/partition/MX.Mexico%20City/history',
              'AR.Cordoba': 'http://10.199.22.57:3003/partition/AR.Cordoba/history',
              'PA.Panama City': 'http://10.199.22.57:3003/partition/PA.Panama%20City/history',
              'PE.Lima': 'http://10.199.22.57:3003/partition/PE.Lima/history',
              'BR.Sao Paulo': 'http://10.199.22.57:3003/partition/BR.Sao%20Paulo/history'
            };
            url = LACA_URLS[location] || 'http://10.199.22.57:3003/history';
          }
        } else if (region === 'namer') {
          if (!location) url = 'http://10.199.22.57:3002/history';
          else {
            const NAMER_URLS = {
              'US.Denver': 'http://10.199.22.57:3002/partition/US.CO.OBS/history',
              'US.Miami': 'http://10.199.22.57:3002/partition/US.FL.Miami/history',
              'US.NYC': 'http://10.199.22.57:3002/partition/US.NYC/history',
              'US.Austin': 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default/history'
            };
            url = NAMER_URLS[location] || 'http://10.199.22.57:3002/history';
          }
        } else if (region === 'apac') {
          if (!location) url = 'http://10.199.22.57:3000/history';
          else {
            const APAC_URLS = {
              'APAC.Default': 'http://10.199.22.57:3000/partition/Pune/history',
              'IN.HYD':'http://10.199.22.57:3000/partition/IN.HYD/history',
              'MY.Kuala Lumpur': 'http://10.199.22.57:3000/partition/MY.Kuala Lumpur/history',
              'PH.Manila': 'http://10.199.22.57:3000/partition/PH.Manila/history',
              'JP.Tokyo': 'http://10.199.22.57:3000/history',
              'CN.Beijing': 'http://10.199.22.57:3000/history'
            };
            url = APAC_URLS[location] || 'http://10.199.22.57:3000/history';
          }
        } else if (region === 'emea') {
          if (!location) url = 'http://10.199.22.57:3001/history';
          else {
            const EMEA_URLS = {
              'AUT.Vienna': 'http://10.199.22.57:3001/history',
              'DU.Abu Dhabi': 'http://10.199.22.57:3001/history',
              'IE.Dublin': 'http://10.199.22.57:3001/history',
              'IT.Rome': 'http://10.199.22.57:3001/history',
              'LT.Vilnius': 'http://10.199.22.57:3001/history',
              'MA.Casablanca': 'http://10.199.22.57:3001/history',
              'RU.Moscow': 'http://10.199.22.57:3001/history',
              'UK.London': 'http://10.199.22.57:3001/history',
              'ES.Madrid': 'http://10.199.22.57:3001/history'
            };
            url = EMEA_URLS[location] || 'http://10.199.22.57:3001/history';
          }
        }

        if (url) window.location.href = url;
        else alert('Invalid region or location selected.');
        return;
      }


      // // ----- Denver Monthly (tab 6) -----
      // if (tab === 6) {
      //   let useYear = null;
      //   let useMonth = null;
      //   if (from) {
      //     const d = new Date(from);
      //     useYear = d.getFullYear();
      //     useMonth = d.getMonth() + 1;
      //   } else {
      //     const dt = new Date();
      //     dt.setDate(1); dt.setHours(0,0,0,0);
      //     dt.setMonth(dt.getMonth() - 1);
      //     useYear = dt.getFullYear();
      //     useMonth = dt.getMonth() + 1;
      //   }

      //   try {
      //     const resp = await axios.get('/api/reports/denver-attendance', {
      //       params: { year: useYear, month: useMonth },
      //       responseType: 'blob'
      //     });

      //     let filename = `denver_attendance_${useYear}${String(useMonth).padStart(2,'0')}.xlsx`;
      //     const cd = resp.headers['content-disposition'];
      //     if (cd) {
      //       const m = cd.match(/filename\*?=(?:UTF-8'')?["']?([^;"']+)/);
      //       if (m && m[1]) filename = decodeURIComponent(m[1]);
      //     }

      //     const blob = new Blob([resp.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      //     const link = document.createElement('a');
      //     link.href = window.URL.createObjectURL(blob);
      //     link.download = filename;
      //     link.click();
      //   } catch (err) {
      //     console.error('Denver attendance download error', err);
      //     let msg = 'Failed to download Denver attendance report';
      //     if (err?.response?.data) {
      //       msg += `: ${err.response?.data?.detail || err.message || JSON.stringify(err.response.data)}`;
      //     } else if (err?.message) {
      //       msg += `: ${err.message}`;
      //     }
      //     alert(msg);
      //   }
      //   return;
      // }



// ----- Denver Monthly (tab 6) -----
if (tab === 6) {
  try {
    // If user selected both From and To, send full date range to backend.
    // Otherwise fall back to single-month behaviour (existing behavior).
    let params = {};
    if (from && to) {
      params = {
        from_date: toLocalYMD(new Date(from)),
        to_date: toLocalYMD(new Date(to))
      };
    } else if (from) {
      const d = new Date(from);
      params = { year: d.getFullYear(), month: d.getMonth() + 1 };
    } else {
      // fallback: previous month (preserve existing UX)
      const dt = new Date();
      dt.setDate(1); dt.setHours(0,0,0,0);
      dt.setMonth(dt.getMonth() - 1);
      params = { year: dt.getFullYear(), month: dt.getMonth() + 1 };
    }

    // const resp = await axios.get('/api/reports/denver-attendance', {
    //   params,
    //   responseType: 'blob'
    // });


const resp = await axios.get('/api/reports/denver-attendance', {
  params,
  responseType: 'blob',
  timeout: 20 * 60 * 1000, // 20 minutes (ms) â€” adjust if you expect even longer runs
  headers: {
    Accept: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/octet-stream'
  }
});



    // Construct a friendly filename:
    let filename = 'denver_attendance.xlsx';
    // if range provided, prefer from-to name
    if (params.from_date && params.to_date) {
      filename = `denver_attendance_${params.from_date.replace(/-/g,'')}_to_${params.to_date.replace(/-/g,'')}.xlsx`;
    } else if (params.year && params.month) {
      filename = `denver_attendance_${params.year}${String(params.month).padStart(2,'0')}.xlsx`;
    }

    // Respect backend Content-Disposition if present
    const cd = resp.headers['content-disposition'];
    if (cd) {
      const m = cd.match(/filename\*?=(?:UTF-8'')?["']?([^;"']+)/);
      if (m && m[1]) filename = decodeURIComponent(m[1]);
    }

    const blob = new Blob([resp.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const link = document.createElement('a');
    link.href = window.URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  } catch (err) {
    console.error('Denver attendance download error', err);
    let msg = 'Failed to download Denver attendance report';
    if (err?.response?.data) {
      msg += `: ${err.response?.data?.detail || err.message || JSON.stringify(err.response.data)}`;
    } else if (err?.message) {
      msg += `: ${err.message}`;
    }
    alert(msg);
  }
  return;
}





    } catch (err) {
      console.error('handleGenerate error:', err);
      let msg = 'Failed to generate report';
      if (err?.response?.data) {
        const d = err.response.data;
        const serverMsg = (typeof d === 'string') ? d
                          : (d.error || d.message || JSON.stringify(d));
        msg += `: ${serverMsg}`;
      } else if (err?.message) {
        msg += `: ${err.message}`;
      }
      alert(msg);
    } finally {
      setLoading(false);
      setGeneratingMessage('');
    }
  };

  // --- UI render ---
  const regionOptions = regionOptionsForTab();
  const locationOptions = locationOptionsForTab();

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
        {/* Topbar / Header */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            px: 3,
            py: 2,
            borderBottom: '1px solid rgba(255,204,0,0.08)',
            background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
          }}
        >
          <Avatar sx={{ bgcolor: '#000', border: '3px solid #FFCC00', width: 56, height: 56 }}>
            <Typography sx={{ color: '#FFCC00', fontWeight: 900 }}>WU</Typography>
          </Avatar>

          <Box sx={{ flex: 1 }}>
            <Typography variant="h5" sx={{ fontWeight: 900, letterSpacing: 0.6 }}>
              Global Security Operation Center
            </Typography>
            <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
              Reports & Exports â€” Secure access, fast insights
            </Typography>
          </Box>

          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
            <Button
              startIcon={<DownloadIcon />}
              onClick={handleGenerate}
              disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
              sx={{
                bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                color: '#000',
                fontWeight: 800,
                px: 3,
                py: 1,
                borderRadius: 3,
                boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
                transformOrigin: 'center',
                '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-2px)' : 'none' }
              }}
            >
              {loading ? 'Loadingâ€¦' : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
            </Button>
          </Box>
        </Box>

        {/* Generating banner */}
        {generatingMessage && (
          <Box sx={{ px: 3, py: 1, bgcolor: 'rgba(255,255,255,0.02)', borderBottom: '1px solid rgba(255,204,0,0.04)', display: 'flex', alignItems: 'center', gap: 2 }}>
            <CircularProgress size={20} />
            <Typography variant="body2" sx={{ color: '#FFCC00', fontWeight: 700 }}>{generatingMessage}</Typography>
          </Box>
        )}

        {/* Main content */}
        <Grid container sx={{ px: 3, py: 4 }} spacing={3}>
          <Grid item xs={12} md={3}>
            <Paper elevation={8} sx={{ p: 2.5, borderRadius: 3, height: { xs: 'auto', md: 'calc(100vh - 150px)' }, overflow: 'auto', background: 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015))', border: '1px solid rgba(255,204,0,0.06)' }}>
              <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
                <Box>
                  <Typography variant="subtitle1" sx={{ fontWeight: 800, color: '#FFCC00' }}>Filters</Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Narrow down by region, date and employees
                  </Typography>
                </Box>
                <IconButton size="small" sx={{ color: '#FFCC00' }}>
                  <FilterListIcon />
                </IconButton>
              </Box>

              <Divider sx={{ my: 1, borderColor: 'rgba(255,204,0,0.06)' }} />

              {/* Region - show per-tab region options */}
              {regionOptions.length > 0 && (
                <Box sx={{ mt: 1 }}>
                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Region</InputLabel>
                    <Select
                      value={region}
                      onChange={e => { setRegion(e.target.value); setLocation(''); }}
                      input={<OutlinedInput label="Region" />}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.24)' }
                      }}
                    >
                      {regionOptions.map(r => <MenuItem key={r} value={r}>{r.toUpperCase()}</MenuItem>)}
                    </Select>
                  </FormControl>
                </Box>
              )}

              {/* Location */}
              <Box sx={{ mt: 2 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Location</InputLabel>

                  {/* RAW (tab 1) keeps multi Autocomplete */}
                  {tab === 1 ? (
                    <Autocomplete
                      multiple
                      freeSolo={false}
                      options={availableLocations}
                      value={selectedLocations}
                      onChange={(e, v) => setSelectedLocations(v)}
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          placeholder="Choose 0..n locations (leave empty = all)"
                          InputLabelProps={{ style: { color: '#FFCC00' } }}
                          sx={{
                            '& .MuiInputBase-input': { color: '#fff' },
                            '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                          }}
                        />
                      )}
                      getOptionLabel={(opt) => String(opt)}
                      isOptionEqualToValue={(opt, val) => opt === val}
                      disabled={!region}
                    />
                  ) : null}

                  {/* EUROC (tab 3) -> multi-select Autocomplete of EMEA locations */}
                  {tab === 3 ? (
                    <Autocomplete
                      multiple
                      freeSolo={false}
                      options={availableLocations.length ? availableLocations : (LOCATION_MAP['emea'] || [])}
                      value={selectedLocations}
                      onChange={(e, v) => setSelectedLocations(v)}
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          placeholder="Select 0..n locations (leave empty = all EMEA)"
                          InputLabelProps={{ style: { color: '#FFCC00' } }}
                          sx={{
                            '& .MuiInputBase-input': { color: '#fff' },
                            '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                          }}
                        />
                      )}
                      getOptionLabel={(opt) => String(opt)}
                      isOptionEqualToValue={(opt, val) => opt === val}
                      disabled={!region}
                    />
                  ) : null}

                  {/* For Time Duration (tab 4) and others (including Denver tab 6), single-select */}
                  {tab !== 1 && tab !== 3 && tab !== 6 && (
                    <Select
                      value={location}
                      onChange={e => setLocation(e.target.value)}
                      input={<OutlinedInput label="Location" />}
                      disabled={(regionOptions.length === 0)}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                      }}
                    >
                      { (locationOptions && locationOptions.length) ? locationOptions.map(loc => (
                          <MenuItem key={loc} value={loc}>
                            {String(loc).split('.').pop()}
                          </MenuItem>
                        ))
                        : ((LOCATION_MAP[region] || []).map(loc => (
                          <MenuItem key={loc} value={loc}>{String(loc).split('.').pop()}</MenuItem>
                        )))
                      }
                    </Select>
                  )}

                  {/* Denver (tab 6) - single select but only Denver */}
                  {tab === 6 && (
                    <Select
                      value={location}
                      onChange={e => setLocation(e.target.value)}
                      input={<OutlinedInput label="Location" />}
                      disabled={false}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                      }}
                    >
                      <MenuItem value="US.Denver">Denver</MenuItem>
                    </Select>
                  )}
                </FormControl>
              </Box>

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />

              {/* Employee input area (Daily and Raw) */}
              {tab === 1 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employee (name or ID) â€” multiple
                  </Typography>

                  <Autocomplete
                    multiple
                    freeSolo
                    filterSelectedOptions
                    options={rawEmpOptions}
                    value={selectedRawEmps}
                    onChange={(e, v) => setSelectedRawEmps(v)}
                    onInputChange={async (e, value, reason) => {
                      if (empQueryRef.current) clearTimeout(empQueryRef.current);
                      if (!value || value.length < 2) {
                        empQueryRef.current = setTimeout(() => setRawEmpOptions([]), 150);
                        return;
                      }
                      empQueryRef.current = setTimeout(async () => {
                        try {
                          const params = { q: value };
                          if (region && region !== 'global') params.region = region;
                          const resp = await axios.get('/api/employees', { params });
                          const raw = (resp.data && (resp.data.data || resp.data)) || [];
                          const normalized = Array.isArray(raw) ? raw.map(item => {
                            if (typeof item === 'string') return item;
                            const id = item.EmployeeID || item.id || item.NumericEmployeeID || item.Employee || '';
                            const name = item.Name || item.name || item.ObjectName1 || '';
                            if (name && id) return `${name} (${id})`;
                            if (id) return String(id);
                            if (name) return String(name);
                            return JSON.stringify(item);
                          }) : [];
                          setRawEmpOptions(Array.from(new Set(normalized)));
                        } catch (err) {
                          console.warn('employee suggestions error', err);
                          setRawEmpOptions([]);
                        }
                      }, 300);
                    }}
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        placeholder="Type name or ID (2+ chars) â€” select multiple"
                        InputLabelProps={{ style: { color: '#FFCC00' } }}
                        sx={{
                          '& .MuiInputBase-input': { color: '#fff' },
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                        }}
                      />
                    )}
                    getOptionLabel={(opt) => (typeof opt === 'string' ? opt : (opt.label || opt.name || String(opt)))}
                    renderOption={(props, option) => <li {...props}>{typeof option === 'string' ? option : (option.label || option.name || String(option))}</li>}
                    ListboxProps={{ style: { maxHeight: 240 } }}
                  />

                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                    Leave empty to export all raw rows for the date range. Type 2+ chars to get suggestions for employee names or IDs.
                  </Typography>

                  <Box sx={{ mt: 2 }}>
                    <FormControl fullWidth>
                      <InputLabel sx={{ color: '#FFCC00' }}>Admit / Reject</InputLabel>
                      <Select
                        value={rawAdmitFilter}
                        onChange={(e) => setRawAdmitFilter(e.target.value)}
                        input={<OutlinedInput label="Admit / Reject" />}
                        sx={{
                          color: '#fff',
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                        }}
                      >
                        <MenuItem value="all">All (Admitted + Rejected)</MenuItem>
                        <MenuItem value="admit">Admitted only</MenuItem>
                        <MenuItem value="reject">Rejected only</MenuItem>
                      </Select>
                    </FormControl>
                    <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                      Default = All.
                    </Typography>
                  </Box>
                </Box>
              )}

              {/* Dates (shown for all tabs except external navigation tab 5) */}
              {tab !== 5 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Date Range
                  </Typography>
                  <Box sx={{ display: 'grid', gap: 1.25 }}>
                    <TextField
                      label={tab === 0 ? 'From Date' : 'Start Date'}
                      value={from ? from.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowFromCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                    <TextField
                      label={tab === 0 ? 'To Date' : 'End Date'}
                      value={to ? to.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowToCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                  </Box>

                  {showFromCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={from}
                        onChange={(newValue) => setFrom(newValue)}
                        onAccept={() => setShowFromCal(false)}
                        onClose={() => setShowFromCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                  {showToCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={to}
                        onChange={(newValue) => setTo(newValue)}
                        onAccept={() => setShowToCal(false)}
                        onClose={() => setShowToCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                </Box>
              )}

              {/* Daily employees block */}
              {tab === 0 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employees
                  </Typography>

                  <Box sx={{ display: 'flex', gap: 1, mb: 1 }}>
                    <TextField
                      fullWidth
                      placeholder="Add name or ID (e.g. 'Vainilaitis, Valdas' or '323471')"
                      value={newEmployee}
                      onChange={(e) => setNewEmployee(e.target.value)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                      InputLabelProps={{ style: { color: '#FFCC00' } }}
                    />
                    <Button
                      variant="contained"
                      onClick={() => {
                        const v = (newEmployee || '').toString().trim();
                        if (!v) return;
                        if (!selectedEmps.includes(v)) {
                          setSelectedEmps(prev => [...prev, v]);
                        }
                        setNewEmployee('');
                      }}
                      sx={{
                        bgcolor: '#FFCC00',
                        color: '#000',
                        fontWeight: 800,
                        px: 2,
                        '&:hover': { bgcolor: '#ffd84d' }
                      }}
                    >
                      Add
                    </Button>
                  </Box>

                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Employees</InputLabel>

                    <Select
                      multiple
                      value={selectedEmps}
                      onChange={e => setSelectedEmps(e.target.value)}
                      input={<OutlinedInput label="Employees" />}
                      renderValue={vals => vals.join(', ')}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                      }}
                    >
                      {[
                        ...EMPLOYEE_OPTIONS,
                        ...selectedEmps.filter(s => !EMPLOYEE_OPTIONS.includes(s))
                      ].map(n => (
                        <MenuItem key={n} value={n}>
                          <Checkbox checked={selectedEmps.includes(n)} />
                          <ListItemText primary={n} />
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              )}

              <Box sx={{ mt: 3, p: 2, borderRadius: 2, background: 'rgba(255,255,255,0.02)' }}>
                <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                  Tip: For daily exports pick employees & a single day range. For Time Duration choose the required partition via Location.
                </Typography>
              </Box>
            </Paper>
          </Grid>

          {/* Main panel */}
          <Grid item xs={12} md={9}>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              <Paper elevation={3} sx={{ px: 2, py: 1, borderRadius: 2, display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 2, border: '1px solid rgba(255,204,0,0.04)' }}>
                <Tabs value={tab} onChange={handleTabChange} sx={{ '& .MuiTab-root': { textTransform: 'none', minWidth: 120, fontWeight: 700, color: 'rgba(255,255,255,0.8)' }, '& .Mui-selected': { color: '#FFCC00' } }}>
                  <Tab icon={<CalendarTodayIcon />} label="Daily Access" />
                  <Tab icon={<PeopleIcon />} label="Raw" />
                  <Tab icon={<PlaceIcon />} label="Rejection" />
                  <Tab icon={<PeopleIcon />} label="EUROC Admit-Reject" />
                  <Tab icon={<CalendarTodayIcon />} label="Time Duration" />
                  <Tab icon={<PeopleIcon />} label="HeadCount" />
                  <Tab icon={<PeopleIcon />} label="Denver Monthly" />
                </Tabs>

                <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                  <Button variant="text" startIcon={<FilterListIcon />} sx={{ color: 'rgba(255,255,255,0.65)', textTransform: 'none' }} onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}>
                    Reset View
                  </Button>
                </Box>
              </Paper>

              <Paper elevation={6} sx={{ p: 3, borderRadius: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 2 }}>
                <Box>
                  <Typography variant="h6" sx={{ fontWeight: 900 }}>Export Center</Typography>
                  <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                    Selected Region: <strong style={{ color: '#FFCC00' }}>{region ? region.toUpperCase() : 'â€”'}</strong> {location ? `â€¢ ${location.split('.').pop() === 'Denver' ? 'Denver' : location.split('.').pop()}` : ''}
                  </Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Choose tab, select filters and export reports in Excel.
                  </Typography>
                </Box>

                <Box>
                  <Button
                    startIcon={loading ? <CircularProgress size={20} /> : <DownloadIcon />}
                    disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
                    onClick={handleGenerate}
                    sx={{
                      bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                      color: '#000',
                      fontWeight: 900,
                      px: 4,
                      py: 1,
                      borderRadius: 3,
                      boxShadow: '0 8px 30px rgba(255,204,0,0.22)',
                      '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-3px)' : 'none' }
                    }}
                  >
                    {loading
                      ? 'Loadingâ€¦'
                      : (tab === 5
                          ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`)
                          : 'Export to Excel')}
                  </Button>
                </Box>
              </Paper>
            </Box>
          </Grid>
        </Grid>
      </Box>
    </LocalizationProvider>
  );
}


