// -------------------- rawReportStreamToResponse --------------------
export async function rawReportStreamToResponse(res, region, { startDate, endDate, location, admitFilter = 'all', employees = null }) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  // small helper: normalize incoming date to YYYY-MM-DD (string) or throw
  function toISODateOnly(input) {
    if (!input) return null;
    const d = (input instanceof Date) ? input : new Date(input);
    if (isNaN(d.getTime())) throw new Error(`Invalid date input: ${input}`);
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2, '0');
    const dd = String(d.getDate()).padStart(2, '0');
    return `${yyyy}-${mm}-${dd}`; // SQL Date-friendly
  }

  console.log(`rawReportStreamToResponse called: region=${region} startDate=${startDate} endDate=${endDate} location=${location} admitFilter=${admitFilter} employees=${employees}`);

  // normalize dates (this ensures SQL receives unambiguous dates)
  let startDateIso, endDateIso;
  try {
    startDateIso = toISODateOnly(startDate);
    endDateIso = toISODateOnly(endDate);
  } catch (err) {
    console.error('Date normalization error', err);
    throw err;
  }

  const pool = await getPool(region);

  // Best-effort: bump pool-level request timeout if possible (avoids the 300000ms default)
  try {
    if (pool && pool.config && pool.config.options) {
      pool.config.options.requestTimeout = 10 * 60 * 1000; // 10 minutes
      console.log('Adjusted pool.config.options.requestTimeout to 10 minutes');
    }
  } catch (e) {
    console.warn('Could not adjust pool.config.options.requestTimeout', e && e.message ? e.message : e);
  }

  const request = pool.request();

  // Per-request timeout: disable/extend (streaming queries often run long)
  request.timeout = 0; // 0 = no timeout on request object

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;
  const employeesParam = (employees && String(employees).trim()) ? String(employees).trim() : null;

  // Pass normalized ISO dates to SQL — pass as JS Date objects to sql.Date to avoid driver/string conversion issues
  // create Date objects at UTC midnight for clarity
  const startDateObj = new Date(`${startDateIso}T00:00:00.000Z`);
  const endDateObj   = new Date(`${endDateIso}T00:00:00.000Z`);

  request.input('location', sql.NVarChar(200), locationParam);
  request.input('startDate', sql.Date, startDateObj);
  request.input('endDate', sql.Date, endDateObj);
  request.input('admitFilter', sql.NVarChar(20), String(admitFilter || 'all'));
  request.input('regionKey', sql.NVarChar(50), String(region || ''));
  request.input('employees', sql.NVarChar(sql.MAX), employeesParam);

  // Build the CTEs for region so we use AllLogs / AllShred / AllXml which UNION across configured DBs
  const regionCTEs = buildRegionCTEs(region);

  const query = ` ... same SQL as before ... `; // keep the long SQL exactly the same (no change)

  const filename = `Raw_${region}_${startDateIso.replace(/-/g,'')}_to_${endDateIso.replace(/-/g,'')}.xlsx`;
  res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
  res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
  res.setHeader('Cache-Control', 'no-cache');

  // flush headers so client knows response has started (helps browsers/axios avoid early network errors)
  if (typeof res.flushHeaders === 'function') {
    try { res.flushHeaders(); } catch (e) { /* ignore */ }
  }

  // create streaming workbook with styles enabled
  const workbook = new ExcelJS.stream.xlsx.WorkbookWriter({ stream: res, useSharedStrings: true, useStyles: true });

  // configuration
  const MAX_ROWS_PER_SHEET = 700000;

  // ... rest of function unchanged (the streaming listeners, row handling, commit, error handling remain exactly the same) ...

  request.stream = true;

  request.on('error', async (err) => {
    console.error('SQL stream error', err);
    try { await safeCommit(); } catch (e) {}
    try { res.end(); } catch (e) {}
  });

  request.on('row', (row) => {
    // same row handling logic as before (no changes)
  });

  request.on('done', async () => {
    try {
      if (worksheet) {
        try { addFooterRowForOutsideBorder(worksheet, headers.length); } catch (e) {}
        try { worksheet.commit(); } catch (e) {}
      }
      await safeCommit();
    } catch (err) {
      console.error('Workbook commit error', err);
    } finally {
      try { res.end(); } catch (e) {}
    }
  });

  // start streaming query (single invocation)
  try {
    await request.query(query);
  } catch (err) {
    console.error('request.query failed', err);
    try { await safeCommit(); } catch (e) {}
    try { res.end(); } catch (e) {}
  }
}












Check Below 3 File line by line Only i want to update for Raw Report ..
For raw reportv i have review Some issue which i need to fix....

For raw report when Long data select like 1 jan to 25 Oct (Pune ) Backend dont display any error but frontend early display Network error ..
Basically i suggest like For Raw report dont Produce API respponce direct Export in excel report ....

if there is any another better way then implement thus 

For Raw report when i want filter Pull Data only for Specific Employee like Using Employee ID , NAme or Card Number so this filter is not Working 

DOnt touch another logic obly update Nencessary part check all 3 line file carefullly and fix the issue ....




//C:\Users\W0024618\Desktop\global-page\backend\config\dbConfig.js
import sql from 'mssql';

// shared options
const commonOpts = {
  options: {
    encrypt: true,
    trustServerCertificate: true
  },
  // increase timeouts (milliseconds)
  requestTimeout: 300000,      // 5 minutes
  connectionTimeout: 30000,    // 30 seconds
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  }
};

// lowercase keys only
// NOTE: moved to `databases` array so we can reference previous/other ACVSUJournal DBs easily.
const regions = {
  apac: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUPNQ0986V',
    // primary DB first; add previous/other ACVSUJournal DB names to this array as needed
    databases: ['ACVSUJournal_00010030','ACVSUJournal_00010029','ACVSUJournal_00010028','ACVSUJournal_00010027','ACVSUJournal_00010026','ACVSUJournal_00010025'],
    ...commonOpts
  },
  emea: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUFRA0986V',
    databases: ['ACVSUJournal_00011029','ACVSUJournal_00011028','ACVSUJournal_00011027','ACVSUJournal_00011026','ACVSUJournal_00011025','ACVSUJournal_00011024','ACVSUJournal_00011023'],
    ...commonOpts
  },
  laca: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUSJO0986V',
    databases: ['ACVSUJournal_00010030','ACVSUJournal_00010029','ACVSUJournal_00010028','ACVSUJournal_00010027','ACVSUJournal_00010026','ACVSUJournal_00010025'],
    ...commonOpts
  },
  namer: {
    user: 'GSOC_Test',
    password: 'Westernccure@2025',
    server: 'SRVWUDEN0891V',
    databases: ['ACVSUJournal_00010030','ACVSUJournal_00010029','ACVSUJournal_00010028','ACVSUJournal_00010027','ACVSUJournal_00010026','ACVSUJournal_00010025'],
    ...commonOpts
  }
};

const pools = {};

/**
 * @param {string} regionKey  one of the keys in `regions`, case-insensitive
 */
export async function getPool(regionKey) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) {
    throw new Error(`Unknown region: ${regionKey}`);
  }

  // Use the first database in the array as the connection default (so queries without explicit db still work).
  if (Array.isArray(cfg.databases) && cfg.databases.length) {
    cfg.database = cfg.databases[0];
  } else if (!cfg.database) {
    // If no database specified, leave it alone (the server's default DB will be used).
    cfg.database = undefined;
  }

  if (!pools[key]) {
    pools[key] = await new sql.ConnectionPool(cfg).connect();
  }
  return pools[key];
}

/**
 * Return array of database names configured for a region (always returns array).
 * This is intentionally exported for other modules to dynamically build fully-qualified table references.
 */
export function getRegionDatabases(regionKey) {
  const key = (regionKey || '').toLowerCase();
  const cfg = regions[key];
  if (!cfg) return [];
  if (Array.isArray(cfg.databases) && cfg.databases.length) return cfg.databases.slice();
  if (cfg.database) return [cfg.database];
  return [];
}

/**
 * Safe bracketed DB name for embedding into SQL identifiers.
 */
export function bracketDb(dbName) {
  if (!dbName) return '';
  // protect against accidental injection: remove closing bracket then bracket it
  const safe = String(dbName).replace(/]/g, '');
  return `[${safe}]`;
}

export { sql };








//C:\Users\W0024618\Desktop\global-page\backend\services\reportService.js



import { getPool, sql, getRegionDatabases, bracketDb } from '../config/dbConfig.js';
import ExcelJS from 'exceljs';

// helper: build SQL snippets (UNION ALL) for region for given table name
function buildUnionForRegionTables(region, tableName) {
  const dbs = getRegionDatabases(region);
  if (!dbs || !dbs.length) {
    // fallback to referencing the current DB default (no prefix)
    return `SELECT * FROM ${tableName}`;
  }
  return dbs.map(db => `SELECT * FROM ${bracketDb(db)}.dbo.${tableName}`).join('\nUNION ALL\n');
}

// helper: produce initial CTE header for logs/shred/xml for given region
function buildRegionCTEs(region) {
  const logsUnion = buildUnionForRegionTables(region, 'ACVSUJournalLog');
  const shredUnion = buildUnionForRegionTables(region, 'ACVSUJournalLogxmlShred');
  const xmlUnion = buildUnionForRegionTables(region, 'ACVSUJournalLogxml');

  // Return the CTEs (without the leading "WITH" — caller should attach as required).
  const cte = [
    `AllLogs AS (\n${logsUnion}\n)`,
    `AllShred AS (\n${shredUnion}\n)`,
    `AllXml AS (\n${xmlUnion}\n)`
  ].join(',\n');
  return cte;
}


// -------------------- listLocations --------------------
export async function listLocations(region) {
  if (!region) throw new Error('region required');
  const pool = await getPool(region);
  const req = pool.request();

  if ((region || '').toLowerCase() === 'namer') {
    const q = `
      SELECT DISTINCT LogicalLocation
      FROM (
        SELECT
          CASE
            WHEN ObjectName2 LIKE '%HQ%' THEN 'Denver-HQ'
            WHEN ObjectName2 LIKE '%Austin%' THEN 'Austin Texas'
            WHEN ObjectName2 LIKE '%Miami%' THEN 'Miami'
            WHEN ObjectName2 LIKE '%NYC%' THEN 'New York'
            ELSE NULL
          END AS LogicalLocation
        FROM AllLogs
        WHERE PartitionName2 IS NOT NULL
      ) AS X
      WHERE LogicalLocation IS NOT NULL
      ORDER BY LogicalLocation;
    `;

    // Use dynamic CTEs so we select from all configured region DBs
    const ctes = buildRegionCTEs(region);
    const fullQuery = `WITH ${ctes}\n${q}`;
    const { recordset } = await req.query(fullQuery);
    return (recordset || []).map(r => r.LogicalLocation).filter(Boolean);
  } else {
    const q = `SELECT DISTINCT PartitionName2 FROM AllLogs WHERE PartitionName2 IS NOT NULL ORDER BY PartitionName2`;
    const ctes = buildRegionCTEs(region);
    const fullQuery = `WITH ${ctes}\n${q}`;
    const { recordset } = await req.query(fullQuery);
    return (recordset || []).map(r => r.PartitionName2).filter(Boolean);
  }
}



// -------------------- searchEmployees --------------------
export async function searchEmployees(region = 'emea', q = '') {
  const pool = await getPool(region);
  const req = pool.request();
  const like = `%${q}%`;
  req.input('q', sql.NVarChar(200), like);

  const query = `
    SELECT TOP (200)
      CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR(50)) END AS EmployeeID,
      ISNULL(t2.Text1, '') AS Name
    FROM ACVSCore.Access.Personnel AS t2
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId = t3.ObjectID
    WHERE (t2.Text1 LIKE @q) OR (CAST(t2.Int1 AS NVARCHAR(50)) LIKE @q) OR (t2.Text12 LIKE @q)
    ORDER BY t2.Text1;
  `;
  const { recordset } = await req.query(query);
  return (recordset || []).map(r => ({ EmployeeID: r.EmployeeID, Name: r.Name }));
}




// -------------------- rawReportStreamToResponse --------------------
/**
 * rawReportStreamToResponse
 * - Inputs: region (JS param), startDate, endDate, location (friendly name or partition), admitFilter
 * - NEW: accepts `employees` (CSV) param which filters rows by EmployeeID, Name or CardNumber
 */
export async function rawReportStreamToResponse(res, region, { startDate, endDate, location, admitFilter = 'all', employees = null }) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  // small helper: normalize incoming date to YYYY-MM-DD (string) or throw
  function toISODateOnly(input) {
    if (!input) return null;
    const d = (input instanceof Date) ? input : new Date(input);
    if (isNaN(d.getTime())) throw new Error(`Invalid date input: ${input}`);
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2, '0');
    const dd = String(d.getDate()).padStart(2, '0');
    return `${yyyy}-${mm}-${dd}`; // SQL Date-friendly
  }

  // log incoming params (helps track frontend vs backend param mismatches)
  console.log(`rawReportStreamToResponse called: region=${region} startDate=${startDate} endDate=${endDate} location=${location} admitFilter=${admitFilter} employees=${employees}`);

  // normalize dates (this ensures SQL receives unambiguous dates)
  let startDateIso, endDateIso;
  try {
    startDateIso = toISODateOnly(startDate);
    endDateIso = toISODateOnly(endDate);
  } catch (err) {
    console.error('Date normalization error', err);
    throw err;
  }

  const pool = await getPool(region);

  // Best-effort: bump pool-level request timeout if possible (avoids the 300000ms default)
  try {
    if (pool && pool.config && pool.config.options) {
      pool.config.options.requestTimeout = 10 * 60 * 1000; // 10 minutes
      console.log('Adjusted pool.config.options.requestTimeout to 10 minutes');
    }
  } catch (e) {
    console.warn('Could not adjust pool.config.options.requestTimeout', e && e.message ? e.message : e);
  }

  const request = pool.request();

  // Per-request timeout: disable/extend (streaming queries often run long)
  // Note: some drivers still enforce the connection-level requestTimeout; that's why we adjusted the pool above.
  request.timeout = 0; // 0 = no timeout on request object

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;
  const employeesParam = (employees && String(employees).trim()) ? String(employees).trim() : null;

  // Pass normalized ISO dates to SQL
  request.input('location', sql.NVarChar(200), locationParam);
  request.input('startDate', sql.Date, startDateIso);
  request.input('endDate', sql.Date, endDateIso);
  request.input('admitFilter', sql.NVarChar(20), String(admitFilter || 'all'));
  request.input('regionKey', sql.NVarChar(50), String(region || ''));
  request.input('employees', sql.NVarChar(sql.MAX), employeesParam);

  // Build the CTEs for region so we use AllLogs / AllShred / AllXml which UNION across configured DBs
  const regionCTEs = buildRegionCTEs(region);

  const query = `
  WITH ${regionCTEs},
  CombinedQuery AS(
    SELECT 
       DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
       t1.ObjectName1,
       t1.PartitionName2       AS PartitionName2,
       t5_card.CardNumber,
       t5_admit.value          AS AdmitCode,
       t5_dir.value            AS Direction,
       t1.ObjectName2          AS Door,
       t5_rej.value            AS Rejection_Type,
       CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
            THEN t2.Text12
            ELSE CAST(t2.Int1 AS NVARCHAR)
       END                       AS EmployeeID,
       t3.Name                  AS PersonnelType,
       t1.MessageType,
       t1.XmlGUID,
       CASE
         WHEN (UPPER(ISNULL(@regionKey,'')) = 'NAMER' OR t1.PartitionName2 LIKE 'US.%' OR t1.PartitionName2 LIKE 'USA%')
         THEN
           CASE
             WHEN t1.ObjectName2 LIKE '%HQ%' THEN 'Denver-HQ'
             WHEN t1.ObjectName2 LIKE '%Austin%' THEN 'Austin Texas'
             WHEN t1.ObjectName2 LIKE '%Miami%' THEN 'Miami'
             WHEN t1.ObjectName2 LIKE '%NYC%' THEN 'New York'
             ELSE t1.PartitionName2
           END
         WHEN (UPPER(ISNULL(@regionKey,'')) = 'APAC' OR t1.PartitionName2 LIKE 'APAC.%' OR t1.PartitionName2 LIKE 'APAC%')
         THEN
           CASE
             WHEN t1.ObjectName2 LIKE 'APAC_PI%' THEN 'Taguig City'
             WHEN t1.ObjectName2 LIKE 'APAC_PH%' THEN 'Quezon City'
             WHEN t1.ObjectName2 LIKE '%PUN%' THEN 'Pune'
             WHEN t1.ObjectName2 LIKE '%HYD%' THEN 'Hyderabad'
             ELSE t1.PartitionName2
           END
         ELSE t1.PartitionName2
       END AS Location
    FROM AllLogs AS t1
    LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
    LEFT JOIN AllShred       AS t5_admit
      ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
    LEFT JOIN AllShred       AS t5_dir
      ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
    LEFT JOIN AllXml         AS t_xml ON t1.XmlGUID = t_xml.GUID
    LEFT JOIN (
      SELECT GUID, [value]
      FROM AllShred
      WHERE [Name] IN ('Card','CHUID')
    ) AS SCard ON t1.XmlGUID = SCard.GUID
    OUTER APPLY (
      SELECT COALESCE(
        TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
        TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
        SCard.[value]
      ) AS CardNumber
    ) AS t5_card
    LEFT JOIN AllShred AS t5_rej
      ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
    WHERE
      t1.MessageType IN ('CardAdmitted' , 'CardRejected')
      AND (
        @location IS NULL
        OR t1.PartitionName2 = @location
        OR (
          (CASE
            WHEN (UPPER(ISNULL(@regionKey,'')) = 'NAMER' OR t1.PartitionName2 LIKE 'US.%' OR t1.PartitionName2 LIKE 'USA%')
            THEN
              CASE
                WHEN t1.ObjectName2 LIKE '%HQ%' THEN 'Denver-HQ'
                WHEN t1.ObjectName2 LIKE '%Austin%' THEN 'Austin Texas'
                WHEN t1.ObjectName2 LIKE '%Miami%' THEN 'Miami'
                WHEN t1.ObjectName2 LIKE '%NYC%' THEN 'New York'
                ELSE NULL
              END
            WHEN (UPPER(ISNULL(@regionKey,'')) = 'APAC' OR t1.PartitionName2 LIKE 'APAC.%' OR t1.PartitionName2 LIKE 'APAC%')
            THEN
              CASE
                WHEN t1.ObjectName2 LIKE 'APAC_PI%' THEN 'Taguig City'
                WHEN t1.ObjectName2 LIKE 'APAC_PH%' THEN 'Quezon City'
                WHEN t1.ObjectName2 LIKE '%PUN%' THEN 'Pune'
                WHEN t1.ObjectName2 LIKE '%HYD%' THEN 'Hyderabad'
                ELSE NULL
              END
            ELSE NULL
          END) = @location
        )
      )
      AND (
        UPPER(ISNULL(@admitFilter,'all')) = 'ALL'
        OR (UPPER(@admitFilter) = 'ADMIT'  AND t1.MessageType = 'CardAdmitted')
        OR (UPPER(@admitFilter) = 'REJECT' AND t1.MessageType = 'CardRejected')
      )
      AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
      /* optional employees filter: CSV of tokens - match against EmployeeID, Name or CardNumber */
      AND (
        @employees IS NULL
        OR EXISTS (
          SELECT 1 FROM STRING_SPLIT(@employees,',') AS E
          WHERE LTRIM(RTRIM(E.value)) <> ''
            AND (
                -- match numeric/text employee id (EmployeeID column already unified)
                (CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR) END) LIKE '%' + LTRIM(RTRIM(E.value)) + '%'
                OR t2.Text1 LIKE '%' + LTRIM(RTRIM(E.value)) + '%'
                OR SCard.[value] LIKE '%' + LTRIM(RTRIM(E.value)) + '%'
            )
        )
      )
  )
  SELECT
    LocaleMessageTime,
    CONVERT(date,    LocaleMessageTime) AS DateOnly,
    CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
    EmployeeID,
    ObjectName1,
    PersonnelType,
    Location,
    CardNumber,
    AdmitCode,
    Direction,
    Door,
    Rejection_Type
  FROM CombinedQuery
  ORDER BY LocaleMessageTime ASC;
  `;

  const filename = `Raw_${region}_${startDateIso.replace(/-/g,'')}_to_${endDateIso.replace(/-/g,'')}.xlsx`;
  res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
  res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
  res.setHeader('Cache-Control', 'no-cache');

  // create streaming workbook with styles enabled
  const workbook = new ExcelJS.stream.xlsx.WorkbookWriter({ stream: res, useSharedStrings: true, useStyles: true });

  // configuration
  const MAX_ROWS_PER_SHEET = 700000;

  let headers = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','Location','CardNumber'];

  const admit = 'AdmitCode';
  const rej = 'Rejection_Type';
  const tail = ['Direction','Door'];

  const af = (String(admitFilter || 'all')).toLowerCase();
  if (af === 'admit') {
    headers = headers.concat([admit, ...tail]);
  } else if (af === 'reject') {
    headers = headers.concat([...tail, rej]);
  } else {
    headers = headers.concat([admit, ...tail, rej]);
  }

  const defaultWidths = {
    LocaleMessageTime: 22, DateOnly: 12, Swipe_Time: 12, EmployeeID: 15,
    ObjectName1: 30, PersonnelType: 18, Location: 20, CardNumber: 20,
    AdmitCode: 14, Direction: 10, Door: 22, Rejection_Type: 22
  };

  // helpers
  const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  function humanMonthNameFromKey(key) {
    if (!key || key === 'unknown') return 'Unknown';
    const [y,m] = key.split('-');
    const mm = parseInt(m,10);
    const mon = MONTH_ABBR[mm - 1] || m;
    return `${mon}-${y}`;
  }

  let currentMonthKey = null;
  let worksheet = null;
  let sheetIndexForMonth = {};

  function addFooterRowForOutsideBorder(ws, headersLen) {
    const footerValues = new Array(headersLen).fill('');
    const footer = ws.addRow(footerValues);
    const lastColIndex = headersLen;
    footer.eachCell((cell, colNumber) => {
      const border = {
        top: { style: 'thick' },
        left: colNumber === 1 ? { style: 'thick' } : (cell.border && cell.border.left ? cell.border.left : { style: 'thin' }),
        right: colNumber === lastColIndex ? { style: 'thick' } : (cell.border && cell.border.right ? cell.border.right : { style: 'thin' }),
        bottom: { style: 'thin' }
      };
      cell.border = border;
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
    });
    footer.commit();
  }

  function createWorksheetFor(monthKey) {
    sheetIndexForMonth[monthKey] = (sheetIndexForMonth[monthKey] || 0) + 1;
    const part = sheetIndexForMonth[monthKey];
    const human = humanMonthNameFromKey(monthKey);
    const name = part === 1 ? `${human} Sheet 1` : `${human} Sheet ${part}`;

    const ws = workbook.addWorksheet(name);
    ws.columns = headers.map(h => ({ key: h, width: defaultWidths[h] || 18 }));

    const headerRow = ws.addRow(headers);
    const doorIndex = headers.indexOf('Door') + 1;
    headerRow.eachCell((cell, colNumber) => {
      cell.font = { bold: true };
      cell.alignment = { horizontal: (colNumber === doorIndex ? 'left' : 'center'), vertical: 'middle' };
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFCCE8FF' } };
      cell.border = {
        top: { style: 'thick' },
        left: (colNumber === 1) ? { style: 'thick' } : { style: 'thin' },
        bottom: { style: 'thin' },
        right: (colNumber === headers.length) ? { style: 'thick' } : { style: 'thin' }
      };
    });
    headerRow.commit();

    ws.__written = 1;
    return ws;
  }

  function monthKeyForRow(row) {
    try {
      const iso = row.LocaleMessageTime || row.DateOnly;
      if (iso) {
        const d = new Date(iso);
        if (!isNaN(d.getTime())) {
          const y = d.getUTCFullYear();
          const m = String(d.getUTCMonth() + 1).padStart(2, '0');
          return `${y}-${m}`;
        }
      }
    } catch (e) { /* ignore */ }
    return 'unknown';
  }

  // safe commit helper
  let committed = false;
  async function safeCommit() {
    if (committed) return;
    committed = true;
    try {
      await workbook.commit();
    } catch (e) {
      console.error('safeCommit: workbook.commit failed', e);
    }
  }

  request.stream = true;

  request.on('error', async (err) => {
    console.error('SQL stream error', err);
    try { await safeCommit(); } catch (e) {}
    try { res.end(); } catch (e) {}
  });

  request.on('row', (row) => {
    const monthKey = monthKeyForRow(row);
    if (!worksheet || monthKey !== currentMonthKey || (worksheet.__written >= MAX_ROWS_PER_SHEET)) {
      if (worksheet) {
        try { addFooterRowForOutsideBorder(worksheet, headers.length); } catch (e) {}
        try { worksheet.commit(); } catch (e) {}
      }
      currentMonthKey = monthKey;
      worksheet = createWorksheetFor(monthKey);
    }

    let localeDate = null;
    if (row.LocaleMessageTime) {
      localeDate = (row.LocaleMessageTime instanceof Date) ? row.LocaleMessageTime : new Date(row.LocaleMessageTime);
      if (isNaN(localeDate.getTime())) localeDate = null;
    }
    let dateOnlyDate = null;
    if (row.DateOnly) {
      const d = new Date(row.DateOnly);
      if (!isNaN(d.getTime())) dateOnlyDate = d;
    }
    let swipeDate = null;
    if (row.Swipe_Time) {
      if (row.Swipe_Time instanceof Date && !isNaN(row.Swipe_Time.getTime())) swipeDate = row.Swipe_Time;
      else {
        const t = String(row.Swipe_Time || '').trim();
        if (t) {
          const parts = t.split(':').map(p => parseInt(p || '0', 10));
          if (parts.length >= 2) swipeDate = new Date(Date.UTC(1970,0,1, parts[0], parts[1], parts[2]||0));
        }
      }
    }

    const fullObj = {
      LocaleMessageTime: localeDate || (row.LocaleMessageTime || ''),
      DateOnly: dateOnlyDate || (row.DateOnly || ''),
      Swipe_Time: swipeDate || (row.Swipe_Time || ''),
      EmployeeID: row.EmployeeID || '',
      ObjectName1: row.ObjectName1 || '',
      PersonnelType: row.PersonnelType || '',
      Location: row.Location || row.PartitionName2 || '',
      CardNumber: row.CardNumber || '',
      AdmitCode: row.AdmitCode || '',
      Direction: row.Direction || '',
      Door: row.Door || '',
      Rejection_Type: row.Rejection_Type || ''
    };

    const rowVals = headers.map(h => (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '');
    const wrow = worksheet.addRow(rowVals);

    try {
      const doorIndex = headers.indexOf('Door') + 1;
      for (let ci = 1; ci <= headers.length; ci++) {
        const cell = wrow.getCell(ci);
        const headerName = headers[ci - 1];
        if (headerName === 'LocaleMessageTime' && localeDate) {
          cell.numFmt = 'dd-mmm-yyyy h:mm:ss AM/PM';
        } else if (headerName === 'DateOnly' && dateOnlyDate) {
          cell.numFmt = 'dd-mmm-yy';
        } else if (headerName === 'Swipe_Time' && swipeDate) {
          cell.numFmt = 'h:mm:ss AM/PM';
        }
        const horizontal = (ci === doorIndex) ? 'left' : 'center';
        cell.alignment = { vertical: 'middle', horizontal };
        const border = {
          top: { style: 'thin' },
          bottom: { style: 'thin' },
          left: (ci === 1) ? { style: 'thick' } : { style: 'thin' },
          right: (ci === headers.length) ? { style: 'thick' } : { style: 'thin' }
        };
        cell.border = border;
      }
    } catch (e) {
      console.warn('row styling warning', e && e.message ? e.message : e);
    }

    wrow.commit();
    worksheet.__written++;
  });

  request.on('done', async () => {
    try {
      if (worksheet) {
        try { addFooterRowForOutsideBorder(worksheet, headers.length); } catch (e) {}
        try { worksheet.commit(); } catch (e) {}
      }
      await safeCommit();
    } catch (err) {
      console.error('Workbook commit error', err);
    } finally {
      try { res.end(); } catch (e) {}
    }
  });

  // start streaming query (single invocation)
  try {
    // await so we catch immediate failures; streaming will invoke 'row' events
    await request.query(query);
  } catch (err) {
    console.error('request.query failed', err);
    try { await safeCommit(); } catch (e) {}
    try { res.end(); } catch (e) {}
  }
}



// -------------------- rejectionReport --------------------
export async function rejectionReport(region, { startDate, endDate, location } = {}) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const pool = await getPool(region);
  const req = pool.request();
  req.timeout = 300000;

  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;
  req.input('location', sql.NVarChar(200), locationParam);
  req.input('startDate', sql.Date, startDate);
  req.input('endDate', sql.Date, endDate);
  req.input('regionKey', sql.NVarChar(50), String(region || ''));

  const regionCTEs = buildRegionCTEs(region);

  const query = `
WITH ${regionCTEs},
CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS PartitionName2,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID,
     CASE
      WHEN (UPPER(ISNULL(@regionKey,'')) = 'NAMER' OR t1.PartitionName2 LIKE 'US.%' OR t1.PartitionName2 LIKE 'USA%')
      THEN
        CASE
          WHEN t1.ObjectName2 LIKE '%HQ%' THEN 'Denver-HQ'
          WHEN t1.ObjectName2 LIKE '%Austin%' THEN 'Austin Texas'
          WHEN t1.ObjectName2 LIKE '%Miami%' THEN 'Miami'
          WHEN t1.ObjectName2 LIKE '%NYC%' THEN 'New York'
          ELSE t1.PartitionName2
        END
      WHEN (UPPER(ISNULL(@regionKey,'')) = 'APAC' OR t1.PartitionName2 LIKE 'APAC.%' OR t1.PartitionName2 LIKE 'APAC%')
      THEN
        CASE
          WHEN t1.ObjectName2 LIKE 'APAC_PI%' THEN 'Taguig City'
          WHEN t1.ObjectName2 LIKE 'APAC_PH%' THEN 'Quezon City'
          WHEN t1.ObjectName2 LIKE '%PUN%' THEN 'Pune'
          WHEN t1.ObjectName2 LIKE '%HYD%' THEN 'Hyderabad'
          ELSE t1.PartitionName2
        END
      ELSE t1.PartitionName2
    END AS Location

  FROM AllLogs AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN AllShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN AllShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN AllXml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM AllShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN AllShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType = 'CardRejected'
    AND (
      @location IS NULL
      OR t1.PartitionName2 = @location
      OR (
        (CASE
          WHEN (UPPER(ISNULL(@regionKey,'')) = 'NAMER' OR t1.PartitionName2 LIKE 'US.%' OR t1.PartitionName2 LIKE 'USA%')
          THEN
            CASE
              WHEN t1.ObjectName2 LIKE '%HQ%' THEN 'Denver-HQ'
              WHEN t1.ObjectName2 LIKE '%Austin%' THEN 'Austin Texas'
              WHEN t1.ObjectName2 LIKE '%Miami%' THEN 'Miami'
              WHEN t1.ObjectName2 LIKE '%NYC%' THEN 'New York'
              ELSE NULL
            END
          WHEN (UPPER(ISNULL(@regionKey,'')) = 'APAC' OR t1.PartitionName2 LIKE 'APAC.%' OR t1.PartitionName2 LIKE 'APAC%')
          THEN
            CASE
              WHEN t1.ObjectName2 LIKE 'APAC_PI%' THEN 'Taguig City'
              WHEN t1.ObjectName2 LIKE 'APAC_PH%' THEN 'Quezon City'
              WHEN t1.ObjectName2 LIKE '%PUN%' THEN 'Pune'
              WHEN t1.ObjectName2 LIKE '%HYD%' THEN 'Hyderabad'
              ELSE NULL
            END
          ELSE NULL
        END) = @location
      )
    )
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  Location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM CombinedQuery
ORDER BY LocaleMessageTime DESC;
`;

  const { recordset } = await req.query(query);
  return recordset;
}


// -------------------- dailyAccessReportEMEA --------------------
export async function dailyAccessReportEMEA({ from, to, employees = '' }) {
  const pool = await getPool('emea');
  const req  = pool.request();

  req.input('fromDate', sql.Date, from);
  req.input('toDate',   sql.Date, to);
  const employeesParam = (employees && String(employees).trim()) ? String(employees).trim() : null;
  req.input('employees', sql.NVarChar(sql.MAX), employeesParam);

  // Build region CTEs for EMEA
  const regionCTEs = buildRegionCTEs('emea');

  const query = `
  WITH ${regionCTEs},
  EmpList AS (
    SELECT LTRIM(RTRIM(value)) AS emp
    FROM STRING_SPLIT(ISNULL(@employees,''), ',')
    WHERE LTRIM(RTRIM(value)) <> ''
  ),
  RawSwipes AS (
    SELECT
      t1.ObjectName1,
      t1.ObjectName2,
      t1.MessageType,
      t2.Text12       AS EmployeeID,
      CAST(t2.Int1 AS NVARCHAR(50)) AS NumericEmployeeID,
      t3.Name         AS PersonnelType,
      t1.PartitionName2 AS PartitionName2,
      DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
      CASE
        WHEN dir.Value = 'InDirection'  THEN 'IN'
        WHEN dir.Value = 'OutDirection' THEN 'OUT'
        ELSE 'Unknown'
      END AS Swipe,
      card.Value AS CardNumber
    FROM AllLogs AS t1
    INNER JOIN ACVSCore.Access.Personnel     AS t2
      ON t1.ObjectIdentity1 = t2.GUID
    INNER JOIN ACVSCore.Access.PersonnelType AS t3
      ON t2.PersonnelTypeId = t3.ObjectID
    OUTER APPLY (
      SELECT TOP (1) s.Value
      FROM AllShred AS s
      WHERE s.GUID = t1.XmlGUID
        AND s.Value IN ('InDirection','OutDirection')
    ) AS dir
    OUTER APPLY (
      SELECT TOP (1) s.Value
      FROM AllShred AS s
      WHERE s.GUID = t1.XmlGUID
        AND s.Value NOT IN ('InDirection','OutDirection')
        AND s.Value NOT LIKE '%[^0-9]%'
        AND s.Value IS NOT NULL
        AND LTRIM(RTRIM(s.Value)) <> ''
    ) AS card
  )
  , Windowed AS (
    SELECT *
    FROM RawSwipes
    WHERE
      LocaleMessageTime >= DATEADD(HOUR, 8, CAST(@fromDate AS DATETIME))
      AND LocaleMessageTime <  DATEADD(HOUR, 8, CAST(@toDate AS DATETIME))
      AND Swipe IN ('IN','OUT')
  )
  SELECT
    ObjectName1,
    ObjectName2,
    PersonnelType,
    EmployeeID,
    NumericEmployeeID,
    PartitionName2 AS location,
    MessageType AS Messagetype,
    Swipe,
    CardNumber,
    LocaleMessageTime
  FROM Windowed w
  WHERE
    (
      @employees IS NULL
      OR LTRIM(RTRIM(@employees)) = ''
      OR EXISTS (
        SELECT 1
        FROM EmpList e
        WHERE
          e.emp = LTRIM(RTRIM(w.ObjectName1))
          OR e.emp = w.EmployeeID
          OR e.emp = w.NumericEmployeeID
      )
    )
  ORDER BY LocaleMessageTime;
  `;

  const { recordset } = await req.query(query);
  return recordset;
}

// -------------------- inOutReport --------------------
export async function inOutReport(region, { year, month, doors }) {
  const pool = await getPool(region);
  const req = pool.request();
  req.timeout = 300000;

  req.input('TargetYear',  sql.Int, year);
  req.input('TargetMonth', sql.Int, month);
  doors.forEach((d, i) => req.input(`door${i}`, sql.NVarChar, d));
  const doorList = doors.map((_, i) => `@door${i}`).join(',');

  const query = `
WITH CombinedQuery AS (
  SELECT
    DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
    t1.ObjectName1,
    t1.PartitionName2    AS location,
    t5_card.CardNumber,
    t5_dir.value         AS Direction,
    CASE
      WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
      ELSE CAST(t2.Int1 AS NVARCHAR)
    END                    AS EmployeeID,
    t3.Name               AS PersonnelType
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID
    AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml AS t_xml
    ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard
    ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  WHERE
    YEAR(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetYear
    AND MONTH(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetMonth
    AND t1.ObjectName2 IN (${doorList})
)
SELECT
  FORMAT(LocaleMessageTime,'yyyy-MM')    AS Month,
  ObjectName1                           AS EmployeeName,
  EmployeeID,
  PersonnelType,
  location,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)  AS In_Count,
  SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS Out_Count,
  COUNT(*)                                                 AS TotalSwipes,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)
  - SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS InOut_Difference
FROM CombinedQuery
GROUP BY FORMAT(LocaleMessageTime,'yyyy-MM'),
         ObjectName1, EmployeeID, PersonnelType, location
ORDER BY Month DESC, EmployeeName;
`;

  const { recordset } = await req.query(query);
  return recordset;
}


// -------------------- timeDurationReport --------------------
export async function timeDurationReport(region, { partition = 'Default', startDate }) {
  const pool = await getPool(region);
  const req = pool.request();
  req.timeout = 300000;

  const fullPartition = `${region.toUpperCase()}.${partition}`;
  req.input('partition', sql.NVarChar, fullPartition);
  req.input('startDate', sql.Date, startDate);

  // build CTEs that combine all region journal DBs
  const regionCTEs = buildRegionCTEs(region);

  const query = `
WITH ${regionCTEs}
SELECT 
    t1.[ObjectName1],
    t1.[ObjectName2],
    t1.[PartitionName2],
    CASE
        WHEN t2.[Int1] = 0 THEN t2.[Text12]
        ELSE CAST(t2.[Int1] AS NVARCHAR)
    END AS EmployeeID,
    t3.[Name] AS PersonnelType,
    t2.text5,
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    DATEADD(HOUR, -2, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) AS AdjustedMessageTime
INTO 
    #CombinedEmployeeData
FROM (
    SELECT * FROM AllLogs
) AS t1
INNER JOIN 
    ACVSCore.Access.Personnel AS t2
    ON t1.ObjectIdentity1 = t2.GUID
INNER JOIN 
    ACVSCore.Access.PersonnelType AS t3
    ON t2.[PersonnelTypeId] = t3.[ObjectID];

-- Now the rest of your original timeDurationReport logic can run against #CombinedEmployeeData
-- (kept the original logic; only the source of t1 changed to the combined AllLogs CTE)
WITH DailyDurations AS (
    SELECT 
        [ObjectName1],
        PersonnelType,
        EmployeeID,
        [PartitionName2],
        text5,
        CONVERT(DATE, AdjustedMessageTime) AS ShiftedDate,
        DATEPART(WEEK, AdjustedMessageTime) AS WeekNumber,
        DATEPART(YEAR, AdjustedMessageTime) AS YearNumber,
        MIN(LocaleMessageTime) AS FirstSwipeTime,
        MAX(LocaleMessageTime) AS LastSwipeTime,
        DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) AS DurationMinutes,
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) / 60 AS NVARCHAR), 2)
        + ':' +
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) % 60 AS NVARCHAR), 2) AS DurationHHMM,
        CASE 
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 5 THEN '<5mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 10 THEN '<10mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 20 THEN '<20mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 30 THEN '<30mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 60 THEN '<1hr'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 120 THEN 'Less than <2hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 180 THEN 'Less than <3hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 240 THEN 'Less than <4hrs'
            ELSE '4+ hrs'
        END AS TimeDiffCategory
    FROM 
        #CombinedEmployeeData
  WHERE CONVERT(DATE, AdjustedMessageTime) >= @startDate
   AND [PartitionName2] = 'APAC.Default'
        AND PersonnelType IN ('Employee', 'Terminated Personnel')
    GROUP BY 
        [ObjectName1], EmployeeID, PersonnelType, text5, [PartitionName2],
        CONVERT(DATE, AdjustedMessageTime),
        DATEPART(WEEK, AdjustedMessageTime),
        DATEPART(YEAR, AdjustedMessageTime)
),
WeeklySummary AS (
    SELECT 
        EmployeeID,
        [ObjectName1],
        PersonnelType,
        text5,
        [PartitionName2],
        YearNumber,
        WeekNumber,
        COUNT(DISTINCT ShiftedDate) AS DaysPresentInWeek,
        SUM(CASE WHEN DurationMinutes < 240 THEN 1 ELSE 0 END) AS ViolationDaysInWeek
    FROM 
        DailyDurations
    GROUP BY 
        EmployeeID, [ObjectName1], PersonnelType, text5, [PartitionName2], YearNumber, WeekNumber
)
SELECT 
    dd.EmployeeID,
    dd.ObjectName1,
    dd.PersonnelType,
    dd.text5,
    dd.PartitionName2,
    dd.YearNumber,
    dd.WeekNumber,
    dd.ShiftedDate,
    dd.FirstSwipeTime,
    dd.LastSwipeTime,
    dd.DurationHHMM,
    dd.TimeDiffCategory,
    ws.DaysPresentInWeek,
    ws.ViolationDaysInWeek,
    (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) AS CleanDaysInWeek,
    CASE
        WHEN (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) < 3 THEN 'Yes'
        ELSE 'No'
    END AS Defaulter
FROM 
    DailyDurations dd
JOIN 
    WeeklySummary ws
    ON dd.EmployeeID = ws.EmployeeID
    AND dd.WeekNumber = ws.WeekNumber
    AND dd.YearNumber = ws.YearNumber
ORDER BY 
    dd.YearNumber DESC, dd.WeekNumber DESC, dd.EmployeeID, dd.ShiftedDate;
  `;

  const { recordset } = await req.query(query);
  return recordset;
}

// -------------------- eurocAdmitRejectionReport --------------------
export async function eurocAdmitRejectionReport(region, { reportDate }) {
  const pool = await getPool(region);
  const req = pool.request();
  req.timeout = 300000;

  req.input('location', sql.NVarChar, 'LT.Vilnius');
  req.input('reportDate', sql.Date, reportDate);

  const regionCTEs = buildRegionCTEs(region);

  const query = `
WITH ${regionCTEs},
CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM AllLogs AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN AllShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN AllShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN AllXml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM AllShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN AllShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    AND t1.PartitionName2 = @location
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @reportDate
)
-- rest of logic unchanged: splits into admits/rejections and summary (use CombinedQuery)
SELECT
  LocaleMessageTime,
  CONVERT(date, LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  MessageType
INTO #Combined
FROM CombinedQuery;

SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  ROW_NUMBER() OVER (PARTITION BY ISNULL(EmployeeID, CardNumber) ORDER BY LocaleMessageTime ASC) AS rn
INTO #Admits
FROM #Combined
WHERE MessageType = 'CardAdmitted'
  AND PersonnelType IN('Employee', 'Terminated Personnel');

SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
INTO #Rejections
FROM #Combined
WHERE MessageType = 'CardRejected';

SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Admits
WHERE rn = 1
ORDER BY LocaleMessageTime ASC;

SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Rejections
ORDER BY LocaleMessageTime ASC;

SELECT
  ISNULL(Rejection_Type, 'Unknown') AS Rejection_Type,
  COUNT(*) AS CountVal
FROM #Rejections
GROUP BY ISNULL(Rejection_Type, 'Unknown')
ORDER BY CountVal DESC;

DROP TABLE IF EXISTS #Admits;
DROP TABLE IF EXISTS #Rejections;
DROP TABLE IF EXISTS #Combined;
`;

  const result = await req.query(query);
  const recordsets = result.recordsets || [];
  const admitRows = (recordsets[0] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const rejectRows = (recordsets[1] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Rejection_Type: r.Rejection_Type,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const summaryRows = (recordsets[2] || []).map(r => ({ Rejection_Type: r.Rejection_Type, Count: r.CountVal }));

  return { admit: admitRows, rejection: rejectRows, summary: summaryRows };
}









// frontend/src/pages/ReportsPage.jsx
import React, { useState, useEffect, useRef } from 'react';
import {
  Box, FormControl, InputLabel, Select, OutlinedInput,
  Checkbox, ListItemText, MenuItem, Button,
  CircularProgress, Typography, TextField, Tabs, Tab, Grid, Paper, IconButton, Divider, Autocomplete
} from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import axios from 'axios';
import ExcelJS from 'exceljs';
import * as XLSX from 'xlsx';
import { useAuth } from '../context/AuthContext';

import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import PlaceIcon from '@mui/icons-material/Place';
import PeopleIcon from '@mui/icons-material/People';
import DownloadIcon from '@mui/icons-material/CloudDownload';
import FilterListIcon from '@mui/icons-material/FilterList';
import Avatar from '@mui/material/Avatar';
import { generateDailyAccessExcelFromRows } from './DailyAccessReport';

// Static lists
const EMPLOYEE_OPTIONS = [
  'Vainilaitis, Valdas',
  'Tomasevic, Kazimez',
  'Sesickis, Janas',
  'Valiunas, Sigitas',
  'JANCUKOVIC, VACLAVA',
  'Kalpokiene, Alina',
  'Korkus, Vanda',
  'Kvaraciejiene, Maryte',
  'ZNAMEROVSKIS, DARIUS',
  'Dovgialo, Liucija'
];

const REGION_OPTIONS = ['global', 'apac', 'emea', 'laca', 'namer'];
const LOCATION_MAP = {
  apac: ['Pune', 'JP.Tokyo', 'Taguig City','Quezon City' ,'MY.Kuala Lumpur','Hyderabad'],
  emea: ['AUT.Vienna', 'DU.Abu Dhab', 'IE.Dublin', 'IT.Rome', 'LT.Vilnius', 'MA.Casablanca', 'RU.Moscow', 'UK.London', 'ES.Madrid'],
  laca: ['AR.Cordoba', 'CR.Costa Rica Partition', 'MX.Mexico City', 'PE.Lima', 'BR.Sao Paulo', 'PA.Panama City'],
  // NAMER: show friendly names strictly (frontend shows these in dropdown)
   namer: ['Denver-HQ', 'Austin Texas', 'Miami', 'New York'],

  global: []
};

function formatDisplayDate(date) {
  if (!date) return '';
  const d = new Date(date);
  const day = d.getDate();
  const suf = day % 10 === 1 && day !== 11 ? 'st'
    : day % 10 === 2 && day !== 12 ? 'nd'
      : day % 10 === 3 && day !== 13 ? 'rd' : 'th';
  const mon = d.toLocaleString('default', { month: 'long' });
  return `${day}${suf} ${mon} ${d.getFullYear()}`;
}

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');

 // ---------- helpers for Excel formatting ----------
  const HEADER_FILL = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFCCE8FF' } }; // light blue
  const THIN_BORDER = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
  const THICK_BORDER = { top: { style: 'thick' }, left: { style: 'thick' }, bottom: { style: 'thick' }, right: { style: 'thick' } };

  function hideGridLines(ws) {
    try {
      ws.views = [{ showGridLines: false }];
    } catch (e) { /* ignore */ }
  }

  function applyHeaderStyles(row) {
    row.eachCell(cell => {
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.fill = HEADER_FILL;
      cell.border = THICK_BORDER;
    });
  }

  function applyThinBordersToWorksheet(ws, headerRowIndex = 1) {
    ws.eachRow((row, rIdx) => {
      row.eachCell(cell => {
        // skip header row (we already applied thick border)
        if (rIdx === headerRowIndex) return;
        // ensure border exists
        cell.border = THIN_BORDER;
        if (!cell.alignment) cell.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });
  }

  function autosizeColumns(ws) {
    // simple heuristic: compute max text length per column
    const colCount = ws.columnCount || (ws._columns && ws._columns.length) || 0;
    for (let c = 1; c <= colCount; c++) {
      let maxLen = 10; // minimal
      ws.eachRow((row) => {
        const cell = row.getCell(c);
        const v = cell && cell.value !== undefined && cell.value !== null ? String(cell.value) : '';
        if (v.length > maxLen) maxLen = v.length;
      });
      // width heuristic: a little padding, cap to reasonable value
      const width = Math.min(60, Math.max(10, Math.ceil(maxLen * 1.2)));
      try {
        ws.getColumn(c).width = width;
      } catch (e) { /* ignore if impossible */ }
    }
  }
  // ---------- end helpers ----------


// --- Helper functions (unchanged from your original) ---
function _extractServerDateTimeParts(iso) {
  if (!iso) return null;
  const s = String(iso);
  let datePart = '', timePart = '';
  if (s.includes('T')) {
    [datePart, timePart] = s.split('T');
  } else if (s.includes(' ')) {
    [datePart, timePart] = s.split(' ');
  } else {
    return null;
  }
  datePart = datePart.slice(0, 10);
  timePart = (timePart || '').replace(/Z|[+-]\d{2}:\d{2}$/, '').replace(/\.\d+$/, '');
  const dParts = datePart.split('-').map(p => parseInt(p, 10));
  const tParts = timePart.split(':').map(p => parseInt(p || '0', 10));
  return {
    year: dParts[0] || 0,
    month: dParts[1] || 0,
    day: dParts[2] || 0,
    hour: tParts[0] || 0,
    minute: tParts[1] || 0,
    second: tParts[2] || 0
  };
}

function formatDateFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  const y = dt.getUTCFullYear();
  const m = dt.getUTCMonth(); // 0..11
  const d = dt.getUTCDate();
  const yrShort = String(y).slice(-2);
  return `${pad2(d)}-${MONTH_ABBR[m]}-${yrShort}`;         // e.g. "12-Aug-25"
}

function formatTimeFromServerISO(iso) {
  if (!iso) return '';
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const hh = p.hour;
  const mm = p.minute || 0;
  const ss = p.second || 0;
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1;
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
}

function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10);
  if (!swipeIso) {
    return `${datePart}T00:00:00.000`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000`;
  }
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000`;
}

const getServerISO = (r) => {
  if (!r) return '';
  if (r.LocaleMessageTime) return r.LocaleMessageTime;
  if (r.DateOnly) return buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  return '';
};

const getServerYMD = (r) => {
  const iso = getServerISO(r);
  if (!iso) return '';
  return iso.slice(0, 10);
};

const isoDateOnlyToLocalDate = (iso) => {
  if (!iso) return null;
  const s = iso.toString().slice(0, 10);
  const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
  return new Date(y, m - 1, d);
};

const buildLocalDateFromDateOnlyAndSwipe = (dateOnly, swipeTime) => {
  if (!dateOnly) return null;
  const dateStr = dateOnly.toString().slice(0, 10);
  const [yy, mm, dd] = dateStr.split('-').map(n => parseInt(n, 10));

  let hh = 0, min = 0, ss = 0;
  if (swipeTime) {
    const parsed = new Date(swipeTime);
    if (!isNaN(parsed.getTime())) {
      hh = parsed.getUTCHours();
      min = parsed.getUTCMinutes();
      ss = parsed.getUTCSeconds();
    } else {
      const parts = swipeTime.split(':').map(p => parseInt(p, 10));
      if (parts.length >= 2) {
        hh = parts[0] || 0;
        min = parts[1] || 0;
        ss = parts[2] || 0;
      }
    }
  }
  return new Date(yy, mm - 1, dd, hh, min, ss);
};



export default function ReportsPage() {
  const auth = useAuth();

  // --- state ---
  const [tab, setTab] = useState(0);

  // default region now set to 'emea' for initial tab 0 behavior
  const [region, setRegion] = useState('emea');
  const [location, setLocation] = useState('LT.Vilnius');
  const [from, setFrom] = useState(null);
  const [to, setTo] = useState(null);
  const [showFromCal, setShowFromCal] = useState(false);
  const [showToCal, setShowToCal] = useState(false);
  const [selectedEmps, setSelectedEmps] = useState([]);
  const [loading, setLoading] = useState(false);
  const [generatingMessage, setGeneratingMessage] = useState('');

  const [rawSearch, setRawSearch] = useState('');
  const [rawAdmitFilter, setRawAdmitFilter] = useState('all');
  const [newEmployee, setNewEmployee] = useState('');

  const [availableLocations, setAvailableLocations] = useState([]);
  const [selectedLocations, setSelectedLocations] = useState([]);
  const [rawEmpOptions, setRawEmpOptions] = useState([]);
  const [selectedRawEmps, setSelectedRawEmps] = useState([]);
  const empQueryRef = useRef(null);

  // Provide region options depending on tab
  const regionOptionsForTab = () => {
    if (tab === 0) return ['emea'];            // Daily Access -> only EMEA
    if (tab === 3) return ['emea'];            // EUROC -> only EMEA
    if (tab === 4) return ['apac'];            // Time Duration -> only APAC
    if (tab === 6) return ['namer'];           // Denver -> NAMER
    return REGION_OPTIONS;                     // default (Raw, Rejection, HeadCount, etc.)
  };

  // Provide location options depending on tab & region
  const locationOptionsForTab = (r) => {
    const rr = r || region;
    if (tab === 0) return ['LT.Vilnius']; // Daily Access -> only Vilnius
    if (tab === 6) return ['Denver']; // Denver -> Denver only (friendly)
    if (tab === 3) {
      return availableLocations.length ? availableLocations : (LOCATION_MAP['emea'] || []);
    }
    if (tab === 4) {
      return availableLocations.length ? availableLocations : (LOCATION_MAP['apac'] || []);
    }
    if (tab === 1) {
      return availableLocations.length ? availableLocations : (LOCATION_MAP[rr] || []);
    }
    return availableLocations.length ? availableLocations : (LOCATION_MAP[rr] || []);
  };

  // fetch availableLocations for the currently selected region (runs on region change)
  useEffect(() => {
    let mounted = true;
    const load = async () => {
      setAvailableLocations([]);
      if (!region) return;
      const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];

      try {
        if (region === 'global') {
          const promises = MULTI_REGIONS.map(r => fetchLocationsForRegion(r));
          const results = await Promise.all(promises);
          const merged = results.flat();
          if (!mounted) return;
          setAvailableLocations(Array.from(new Set(merged)).sort());
        } else {
          const list = await fetchLocationsForRegion(region);
          if (!mounted) return;
          setAvailableLocations(Array.from(new Set(list)).sort());
        }
      } catch (err) {
        console.error('load locations error', err);
        // fallback to static map
        const key = (region || '').toLowerCase();
        setAvailableLocations((LOCATION_MAP[key] || []).slice());
      }
    };

    if (region) {
      load();
    } else {
      setAvailableLocations([]);
    }

    return () => { mounted = false; };
  }, [region, tab]);

  // Helper: fetch locations for a single region key (backend endpoint: GET /api/locations?region=apac)
  const fetchLocationsForRegion = async (r) => {
    try {
      if (!r) return [];
      const resp = await axios.get('/api/locations', { params: { region: r } });
      const listRaw = (resp.data && (resp.data.data || resp.data)) || [];
      const list = Array.isArray(listRaw)
        ? listRaw.map(item => {
            if (typeof item === 'string') return item;
            return item.PartitionName2 || item.partition || item.location || item.name || (item.label ? item.label : null);
          }).filter(Boolean)
        : [];
      if (!list.length) {
        const key = (r || '').toLowerCase();
        return (LOCATION_MAP[key] || []).slice();
      }
      return Array.from(new Set(list)).sort();
    } catch (e) {
      console.warn('fetchLocationsForRegion error', r, e);
      const key = (r || '').toLowerCase();
      return (LOCATION_MAP[key] || []).slice();
    }
  };

  // Handle tab switch (Daily / Raw / Rejection / etc.)
  const handleTabChange = (_, v) => {
    setTab(v);

    // Reset shared filters
    setFrom(null);
    setTo(null);
    setSelectedEmps([]);
    setRawSearch('');
    setRawAdmitFilter('all');
    setSelectedLocations([]);
    setSelectedRawEmps([]);
    setNewEmployee('');
    setRawEmpOptions([]);
    setGeneratingMessage('');

    // Default region/location per tab (as requested)
    if (v === 0) {         // Daily Access -> EMEA + Vilnius
      setRegion('emea');
      setLocation('LT.Vilnius');
    } else if (v === 1) {  // Raw -> keep default region (emea) but let user change
      setRegion('emea');
      setLocation('');
    } else if (v === 2) {  // Rejection -> default emea
      setRegion('emea');
      setLocation('');
    } else if (v === 3) {  // EUROC -> EMEA only, allow multi locations
      setRegion('emea');
      setLocation('');
    } else if (v === 4) {  // Time Duration -> APAC only
      setRegion('apac');
      setLocation('');
    } else if (v === 5) {  // HeadCount -> default emea
      setRegion('emea');
      setLocation('');
    } else if (v === 6) {  // Denver -> NAMER + Denver
      setRegion('namer');
      setLocation('Denver');
    }
  };



// ---------- generateTimeDurationExcel (unchanged) ----------
const generateTimeDurationExcel = async data => {
  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Time Duration');

  hideGridLines(ws);

  const headers = [
    'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
    'Partition', 'Text5', 'Year', 'Week', 'Date',
    'First Swipe', 'Last Swipe', 'Duration', 'Category',
    'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
  ];
  const lastCol = headers.length;

  // Title (merged across all header columns)
  ws.mergeCells(1, 1, 1, lastCol);
  ws.getCell('A1').value =
    `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
  ws.getCell('A1').font = { bold: true, size: 14 };
  ws.getCell('A1').alignment = { horizontal: 'center', vertical: 'middle' };
  ws.getRow(1).height = 22;

  const headerRow = ws.addRow(headers);
  applyHeaderStyles(headerRow);

  ws.columns = [
    { key: 'sr', width: 8 },
    { key: 'name', width: 25 },
    { key: 'id', width: 15 },
    { key: 'ptype', width: 18 },
    { key: 'part', width: 15 },
    { key: 'txt5', width: 20 },
    { key: 'year', width: 8 },
    { key: 'week', width: 6 },
    { key: 'date', width: 12 },
    { key: 'first', width: 16 },
    { key: 'last', width: 16 },
    { key: 'dur', width: 10 },
    { key: 'cat', width: 12 },
    { key: 'dpw', width: 12 },
    { key: 'vdw', width: 14 },
    { key: 'cdw', width: 12 },
    { key: 'def', width: 10 }
  ];

  // Apply HEADER_FILL + thick border to the merged title cells (1..lastCol)
  for (let c = 1; c <= lastCol; c++) {
    const cell = ws.getCell(1, c);
    cell.fill = HEADER_FILL;
    cell.font = { bold: true, size: 14 };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    // initial thick border for title area (outer edges will be enforced later)
    cell.border = THICK_BORDER;
  }

  data.forEach((r, idx) => {
    const first = r.FirstSwipeTime ? new Date(r.FirstSwipeTime) : null;
    const last = r.LastSwipeTime ? new Date(r.LastSwipeTime) : null;
    const date = r.ShiftedDate ? new Date(r.ShiftedDate) : null;
    const row = ws.addRow([
      idx + 1,
      r.ObjectName1,
      r.EmployeeID,
      r.PersonnelType,
      r.PartitionName2,
      r.text5,
      r.YearNumber,
      r.WeekNumber,
      date,
      first,
      last,
      r.DurationHHMM,
      r.TimeDiffCategory,
      r.DaysPresentInWeek,
      r.ViolationDaysInWeek,
      r.CleanDaysInWeek,
      r.Defaulter
    ]);

    if (date) {
      row.getCell(9).numFmt = 'dd-mmm-yy';
      row.getCell(9).alignment = { vertical: 'middle', horizontal: 'center' };
    }
    if (first) {
      row.getCell(10).numFmt = 'h:mm:ss AM/PM';
      row.getCell(10).alignment = { vertical: 'middle', horizontal: 'center' };
    }
    if (last) {
      row.getCell(11).numFmt = 'h:mm:ss AM/PM';
      row.getCell(11).alignment = { vertical: 'middle', horizontal: 'center' };
    }

    // center align all cells in this row
    row.eachCell(c => {
      c.border = THIN_BORDER;
      c.alignment = { vertical: 'middle', horizontal: 'center' };
    });
  });

  // NOTE: autosize removed per request (do NOT call autosizeColumns)

  ws.autoFilter = `A2:${String.fromCharCode(64 + lastCol)}2`; // A2:Q2 etc.

  // Apply thick outside border around the entire used area (include title row)
  const firstRow = 1; // include merged title row
  const lastRow = ws.lastRow ? ws.lastRow.number : headerRow.number;
  const firstCol = 1;

  // Ensure all interior cells have at least thin border / centered alignment (preserve header styling)
  for (let r = firstRow; r <= lastRow; r++) {
    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(r, c);
      if (r !== headerRow.number) {
        cell.border = THIN_BORDER;
      }
      // enforce center alignment for any cell missing alignment
      if (!cell.alignment) cell.alignment = { vertical: 'middle', horizontal: 'center' };
    }
  }

  // Now override outer edges to be thick
  for (let r = firstRow; r <= lastRow; r++) {
    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(r, c);
      const currTop = (cell.border && cell.border.top) ? cell.border.top : { style: 'thin' };
      const currBottom = (cell.border && cell.border.bottom) ? cell.border.bottom : { style: 'thin' };
      const currLeft = (cell.border && cell.border.left) ? cell.border.left : { style: 'thin' };
      const currRight = (cell.border && cell.border.right) ? cell.border.right : { style: 'thin' };

      const border = {
        top: (r === firstRow) ? { style: 'thick' } : currTop,
        bottom: (r === lastRow) ? { style: 'thick' } : currBottom,
        left: (c === firstCol) ? { style: 'thick' } : currLeft,
        right: (c === lastCol) ? { style: 'thick' } : currRight
      };
      cell.border = border;
    }
  }

  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], {
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
  });

  const filename =
    `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;

  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
};

// ---------- generateRejectionExcel (updated to prefer single Location property) ----------
const generateRejectionExcel = async data => {
  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Rejection');

  const GRAY_FILL = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };

  // hide gridlines
  hideGridLines(ws);

  // --- Prepare layout: skip first row and first column (A) ---
  ws.addRow([]); // row 1 (blank)

  // Title in row 2, columns B..K (10 headers -> B..K)
  const title = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}`;
  ws.addRow([null]); // ensure row 2 exists
  ws.mergeCells('B2:K2');
  ws.getCell('B2').value = title;
  ws.getCell('B2').font = { bold: true, size: 14 };
  ws.getCell('B2').alignment = { horizontal: 'center', vertical: 'middle' };
  ws.getRow(2).height = 22;
  // style merged title cells (B2..K2)
  for (let c = 2; c <= 11; c++) {
    const cell = ws.getCell(2, c);
    cell.fill = GRAY_FILL;
    cell.font = { bold: true, size: 14 };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.border = THICK_BORDER;
  }

  // Headers in row 3 (we add a row where first element null keeps column A blank)
  const headers = [
    'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
    'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
  ];
  const headerRow = ws.addRow([null, ...headers]); // this will be row 3
  headerRow.height = 20;
  headerRow.eachCell((cell, colNumber) => {
    // colNumber counts across the entire row including the null at col A; header cells are cols 2..11
    if (colNumber >= 2 && colNumber <= 11) {
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.fill = GRAY_FILL;
      cell.border = THICK_BORDER;
    }
  });

  // setup columns widths (A blank column + 10 content columns B..K)
  ws.columns = [
    { key: 'blankA', width: 3 }, // column A (skipped)
    { key: 'sr', width: 8 },     // B
    { key: 'date', width: 12 },  // C
    { key: 'time', width: 12 },  // D
    { key: 'name', width: 30 },  // E
    { key: 'id', width: 15 },    // F
    { key: 'card', width: 18 },  // G
    { key: 'type', width: 18 },  // H
    { key: 'door', width: 40 },  // I
    { key: 'loc', width: 18 },   // J
    { key: 'swipe', width: 12 }  // K
  ];

  // Column alignment sets (absolute column indices)
  // With blank A, the content cols shift by +1: Sr -> 2, Date -> 3, ..., Swipe -> 11
  const centerCols = new Set([2,3,4,5,6,7,8,10,11]); // Sr,Date,Time,Name,ID,Card,Type,Location,Swipe
  const leftCols = new Set([9]); // Door Name only (I)

  // Add data rows (starting from row 4)
  data.forEach((r, idx) => {
    const iso = getServerISO(r);
    const dateStr = iso ? formatDateFromServerISO(iso) : (r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '');
    const timeStr = iso ? formatTimeFromServerISO(iso) : (r.Swipe_Time ? formatTimeFromServerISO(r.Swipe_Time) : '');

    const rowVals = [
      null, // column A blank
      idx + 1,
      dateStr,
      timeStr,
      r.ObjectName1 || '',
      r.EmployeeID || '',
      r.CardNumber || '',
      r.Rejection_Type || '',
      r.Door || r.ObjectName2 || '',
      // Prefer backend-provided single Location; fall back to logical/partition
      r.Location || r.LogicalLocation || r.location || '',
      r.Direction || r.Swipe || ''
    ];

    const row = ws.addRow(rowVals);

    row.eachCell((cell, colNumber) => {
      // only style cells inside B..K
      if (colNumber >= 2 && colNumber <= 11) {
        cell.border = THIN_BORDER;
        const horiz = leftCols.has(colNumber) ? 'left' : (centerCols.has(colNumber) ? 'center' : 'left');
        cell.alignment = { vertical: 'middle', horizontal: horiz };
      }
    });
  });

  // Apply thick outside border around header + data (columns B..K)
  const headerRowIndex = 3;
  const firstDataRow = headerRowIndex; // include header when constructing outer border
  const lastDataRow = ws.lastRow ? ws.lastRow.number : headerRowIndex;
  const firstCol = 2; // column B
  const lastCol = 11; // column K

  for (let r = firstDataRow; r <= lastDataRow; r++) {
    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(r, c);
      if (!cell.border) cell.border = THIN_BORDER;
      const border = {
        top: (r === firstDataRow) ? { style: 'thick' } : (cell.border.top || { style: 'thin' }),
        bottom: (r === lastDataRow) ? { style: 'thick' } : (cell.border.bottom || { style: 'thin' }),
        left: (c === firstCol) ? { style: 'thick' } : (cell.border.left || { style: 'thin' }),
        right: (c === lastCol) ? { style: 'thick' } : (cell.border.right || { style: 'thin' })
      };
      cell.border = border;
    }
  }

  // ---------- Summary block placed to the RIGHT of the table ----------
  // We'll leave one blank column after the last data column, then place summary (2 columns wide)
  const summaryStartCol = lastCol + 2; // skip one column after Swipe
  const summaryTitleRow = headerRowIndex + 1; // place summary title starting near header (row 4)
  const summaryHdrRow = summaryTitleRow + 1;

  // Build counts by Rejection_Type
  const countsMap = {};
  data.forEach(r => {
    const key = (r.Rejection_Type || 'Unknown').toString();
    countsMap[key] = (countsMap[key] || 0) + 1;
  });
  const countEntries = Object.entries(countsMap);

  // Summary title (merged across two summary columns)
  const colLetter = (c => {
    // helper to convert 1-indexed col number to letter(s)
    let n = c, s = '';
    while (n > 0) {
      const m = (n - 1) % 26;
      s = String.fromCharCode(65 + m) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  });
  const sA = colLetter(summaryStartCol);
  const sB = colLetter(summaryStartCol + 1);
  ws.mergeCells(`${sA}${summaryTitleRow}:${sB}${summaryTitleRow}`);
  ws.getCell(`${sA}${summaryTitleRow}`).value = 'Summary';
  ws.getCell(`${sA}${summaryTitleRow}`).font = { bold: true };
  ws.getCell(`${sA}${summaryTitleRow}`).alignment = { horizontal: 'center', vertical: 'middle' };
  ws.getCell(`${sA}${summaryTitleRow}`).fill = GRAY_FILL;
  ws.getCell(`${sA}${summaryTitleRow}`).border = THICK_BORDER;
  ws.getCell(`${sB}${summaryTitleRow}`).fill = GRAY_FILL;
  ws.getCell(`${sB}${summaryTitleRow}`).border = THICK_BORDER;

  // Header row for summary - NOW using THICK_BORDER for header columns
  ws.getCell(summaryHdrRow, summaryStartCol).value = 'Rejection';
  ws.getCell(summaryHdrRow, summaryStartCol + 1).value = 'Count';
  [summaryStartCol, summaryStartCol + 1].forEach(c => {
    const cell = ws.getCell(summaryHdrRow, c);
    cell.font = { bold: true };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.fill = GRAY_FILL;
    // <<== make header cells have thick outside border as requested
    cell.border = THICK_BORDER;
  });

  // Summary detail rows (start below summaryHdrRow)
  let cur = summaryHdrRow + 1;
  countEntries.forEach(([type, cnt]) => {
    ws.getCell(cur, summaryStartCol).value = type;
    ws.getCell(cur, summaryStartCol + 1).value = cnt;
    ws.getCell(cur, summaryStartCol).alignment = { horizontal: 'left', vertical: 'middle' };
    ws.getCell(cur, summaryStartCol + 1).alignment = { horizontal: 'center', vertical: 'middle' };
    ws.getCell(cur, summaryStartCol).border = THIN_BORDER;
    ws.getCell(cur, summaryStartCol + 1).border = THIN_BORDER;
    cur++;
  });

  // Grand Total row - make Grand Total cells bold + thick border
  const grandTotal = data.length || 0;
  ws.getCell(cur, summaryStartCol).value = 'Grand Total';
  ws.getCell(cur, summaryStartCol + 1).value = grandTotal;
  [summaryStartCol, summaryStartCol + 1].forEach(c => {
    const cell = ws.getCell(cur, c);
    cell.font = { bold: true };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.fill = GRAY_FILL;
    // <<== make grand total cells have thick outside border as requested
    cell.border = THICK_BORDER;
  });

  // Apply thick outside border for summary block (this will preserve header/grandTotal thick borders)
  for (let r = summaryTitleRow; r <= cur; r++) {
    for (let c = summaryStartCol; c <= summaryStartCol + 1; c++) {
      const cell = ws.getCell(r, c);
      if (!cell.border) cell.border = THIN_BORDER;
      const border = {
        top: (r === summaryTitleRow) ? { style: 'thick' } : (cell.border.top || { style: 'thin' }),
        bottom: (r === cur) ? { style: 'thick' } : (cell.border.bottom || { style: 'thin' }),
        left: (c === summaryStartCol) ? { style: 'thick' } : (cell.border.left || { style: 'thin' }),
        right: (c === (summaryStartCol + 1)) ? { style: 'thick' } : (cell.border.right || { style: 'thin' })
      };
      cell.border = border;
    }
  }

  // Final workbook buffer & download (filename)
  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const filename = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}.xlsx`;
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
};

// ---------- generateRawExcel (updated to prefer single Location property) ----------
const generateRawExcel = async (rows, opts = {}) => {
  const formatTimeFromSwipe = (swipeIso) => {
    if (!swipeIso) return '';
    const dt = new Date(swipeIso);
    if (!isNaN(dt.getTime())) {
      return formatTimeFromServerISO(swipeIso);
    }
    const parts = ('' + swipeIso).split(':').map(p => parseInt(p || 0, 10));
    const hh = parts[0] || 0;
    const mm = parts[1] || 0;
    const ss = parts[2] || 0;
    const ampm = hh >= 12 ? 'PM' : 'AM';
    const hh12 = ((hh + 11) % 12) + 1;
    return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
  };

  const admitFilter = (opts.rawAdmitFilter || 'all').toString().toLowerCase();

  // unified headers: use "Location" (single column) instead of separate location/LogicalLocation
  const baseHeaders = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','Location','CardNumber'];
  const admitCol = 'AdmitCode';
  const rejCol = 'Rejection_Type';
  const tailCols = ['Direction','Door'];

  let headers = [...baseHeaders];
  if (admitFilter === 'all') {
    headers.push(admitCol, ...tailCols, rejCol);
  } else if (admitFilter === 'admit') {
    headers.push(admitCol, ...tailCols);
  } else if (admitFilter === 'reject') {
    headers.push(...tailCols, rejCol);
  } else {
    headers.push(admitCol, ...tailCols, rejCol);
  }

  const wb = new ExcelJS.Workbook();
  const MAX_ROWS_PER_SHEET = 700000;
  const AUTOSIZE_LIMIT = 20000;

  // helper to split by month (same as existing)
  const monthKeyForRow = (r) => {
    try {
      const iso = getServerISO(r);
      if (iso) {
        const d = new Date(iso);
        if (!isNaN(d.getTime())) {
          const y = d.getUTCFullYear();
          const m = pad2(d.getUTCMonth() + 1);
          return `${y}-${m}`;
        }
      }
      if (r.DateOnly) {
        const dt = isoDateOnlyToLocalDate(r.DateOnly);
        if (dt) {
          const y = dt.getFullYear();
          const m = pad2(dt.getMonth() + 1);
          return `${y}-${m}`;
        }
      }
    } catch (e) { /* ignore */ }
    return 'unknown';
  };

  let rowsByMonth = {};
  if (Array.isArray(rows) && rows.length) {
    rows.forEach(r => {
      const key = monthKeyForRow(r);
      rowsByMonth[key] = rowsByMonth[key] || [];
      rowsByMonth[key].push(r);
    });
  } else {
    rowsByMonth['empty'] = [];
  }

  // Decide whether to split by month — keep original logic
  let shouldSplitByMonth = false;
  try {
    if (opts.from && opts.to) {
      const f = new Date(opts.from);
      const t = new Date(opts.to);
      if (!isNaN(f.getTime()) && !isNaN(t.getTime())) {
        const monthSpan = (t.getFullYear() - f.getFullYear()) * 12 + (t.getMonth() - f.getMonth());
        if (monthSpan >= 1) shouldSplitByMonth = true;
      }
    }
  } catch (e) { /* ignore */ }
  if ((Array.isArray(rows) && rows.length > MAX_ROWS_PER_SHEET)) shouldSplitByMonth = true;

  // helper to style header and apply thick outside border after writing data
  function applyHeaderAndBorders(ws, headerRowIndex = 1) {
    const doorCol = headers.indexOf('Door') + 1; // 1-based
    // style header row (headerRowIndex)
    const headerRow = ws.getRow(headerRowIndex);
    headerRow.eachCell((cell, idx) => {
      cell.font = { bold: true };
      cell.alignment = { horizontal: (idx === doorCol ? 'left' : 'center'), vertical: 'middle' };
      cell.fill = HEADER_FILL;
      // top thick and left/right thick edges handled below when we do outside border
    });
    // ensure thin border for all inner cells, then add thick outside border afterwards
    ws.eachRow((row, rIdx) => {
      row.eachCell((cell, cIdx) => {
        // skip header for alignment only; borders we'll set here
        cell.border = THIN_BORDER;
        // alignment: Door left, others center
        if (!cell.alignment) cell.alignment = { vertical: 'middle', horizontal: (cIdx === doorCol ? 'left' : 'center') };
      });
    });

    // Now apply thick outside border for header+data
    const firstDataRow = headerRowIndex;
    const lastDataRow = ws.lastRow ? ws.lastRow.number : headerRowIndex;
    const firstCol = 1;
    const lastCol = headers.length;

    for (let r = firstDataRow; r <= lastDataRow; r++) {
      for (let c = firstCol; c <= lastCol; c++) {
        const cell = ws.getCell(r, c);
        const border = {
          top: (r === firstDataRow) ? { style: 'thick' } : (cell.border && cell.border.top ? cell.border.top : { style: 'thin' }),
          bottom: (r === lastDataRow) ? { style: 'thick' } : (cell.border && cell.border.bottom ? cell.border.bottom : { style: 'thin' }),
          left: (c === firstCol) ? { style: 'thick' } : (cell.border && cell.border.left ? cell.border.left : { style: 'thin' }),
          right: (c === lastCol) ? { style: 'thick' } : (cell.border && cell.border.right ? cell.border.right : { style: 'thin' })
        };
        cell.border = border;
      }
    }
  }

  // Create sheets either single Raw or per month
  const monthKeys = shouldSplitByMonth ? Object.keys(rowsByMonth).sort() : ['all'];
  if (!shouldSplitByMonth) {
    // all rows into a single sheet (or empty header if no rows)
    const allRows = Array.isArray(rows) ? rows : [];
    const parts = Math.max(1, Math.ceil(allRows.length / MAX_ROWS_PER_SHEET));
    for (let p = 0; p < parts; p++) {
      const chunk = allRows.slice(p * MAX_ROWS_PER_SHEET, (p + 1) * MAX_ROWS_PER_SHEET);
      const wsName = (parts === 1) ? 'Raw' : `Raw Sheet ${p + 1}`;
      const ws = wb.addWorksheet(wsName);
      hideGridLines(ws);

      // add header explicitly
      const hdr = ws.addRow(headers);
      applyHeaderStyles(hdr); // this reuses your helper to set header font/fill/alignment center; we'll override final borders later

      // add all rows
      chunk.forEach(r => {
        const iso = getServerISO(r);
        const dateStr = iso ? formatDateFromServerISO(iso) : (r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '');
        const timeStr = iso ? formatTimeFromServerISO(iso) : (r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '');
        const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');
        const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';
        const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

        const fullObj = {
          LocaleMessageTime: localeMsgFormatted,
          DateOnly: dateOnlyFormatted,
          Swipe_Time: swipeTimeFormatted,
          EmployeeID: r.EmployeeID || '',
          ObjectName1: r.ObjectName1 || '',
          PersonnelType: r.PersonnelType || '',
          // <-- prefer server-provided unified Location
          Location: r.Location || r.LogicalLocation || r.location || '',
          CardNumber: r.CardNumber || '',
          AdmitCode: r.AdmitCode || r.Messagetype || '',
          Direction: r.Direction || r.Swipe || '',
          Door: r.Door || r.ObjectName2 || '',
          Rejection_Type: r.Rejection_Type || ''
        };


        const rowVals = headers.map(h => (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '');
        const added = ws.addRow(rowVals);
        // set row cell defaults; we'll finalize outside border later
        added.eachCell(c => {
          c.border = THIN_BORDER;
          c.alignment = { vertical: 'middle', horizontal: 'left' }; // default; will be overridden by applyHeaderAndBorders
        });
      });

      // autosize if small
      if (allRows.length < AUTOSIZE_LIMIT) autosizeColumns(ws);

      // finalize header alignment & thick outside border
      applyHeaderAndBorders(ws, 1);
    }
  } else {
    // split by month keys
    const sortedKeys = Object.keys(rowsByMonth).sort();
    sortedKeys.forEach(monthKey => {
      const mrows = rowsByMonth[monthKey] || [];
      const humanMonth = (monthKey === 'unknown') ? 'Unknown' : (() => {
        const [y,m] = monthKey.split('-'); const mm = parseInt(m,10);
        const monName = MONTH_ABBR[mm-1] || m;
        return `${monName}-${y}`;
      })();

      for (let i = 0; i < mrows.length; i += MAX_ROWS_PER_SHEET) {
        const chunk = mrows.slice(i, i + MAX_ROWS_PER_SHEET);
        const part = Math.floor(i / MAX_ROWS_PER_SHEET) + 1;
        const sheetName = (part === 1) ? `${humanMonth} Sheet 1` : `${humanMonth} Sheet ${part}`;
        const ws = wb.addWorksheet(sheetName);
        hideGridLines(ws);

        const hdr = ws.addRow(headers);
        applyHeaderStyles(hdr);

        chunk.forEach(r => {
          const iso = getServerISO(r);
          const dateStr = iso ? formatDateFromServerISO(iso) : (r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '');
          const timeStr = iso ? formatTimeFromServerISO(iso) : (r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '');
          const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');
          const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';
          const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

          const fullObj = {
            LocaleMessageTime: localeMsgFormatted,
            DateOnly: dateOnlyFormatted,
            Swipe_Time: swipeTimeFormatted,
            EmployeeID: r.EmployeeID || '',
            ObjectName1: r.ObjectName1 || '',
            PersonnelType: r.PersonnelType || '',
            Location: r.Location || r.LogicalLocation || r.location || '',
            CardNumber: r.CardNumber || '',
            AdmitCode: r.AdmitCode || r.Messagetype || '',
            Direction: r.Direction || r.Swipe || '',
            Door: r.Door || r.ObjectName2 || '',
            Rejection_Type: r.Rejection_Type || ''
          };

          const rowVals = headers.map(h => (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '');
          const added = ws.addRow(rowVals);
          added.eachCell(c => {
            c.border = THIN_BORDER;
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        if (mrows.length < AUTOSIZE_LIMIT) autosizeColumns(ws);

        applyHeaderAndBorders(ws, 1);
      }
    });
  }

  const filename = buildRawFileName(opts);
  try {
    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  } catch (err) {
    console.error('generateRawExcel writeBuffer error', err);
    try {
      const fallbackWb = new ExcelJS.Workbook();
      const ws = fallbackWb.addWorksheet('Export_Failed');
      ws.getCell('A1').value = 'Export failed because the result set is too large for browser export.';
      ws.getCell('A2').value = 'Please reduce the date range (choose 1 month or less) or filter by location/employee and try again.';
      const buf2 = await fallbackWb.xlsx.writeBuffer();
      const blob2 = new Blob([buf2], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const link2 = document.createElement('a');
      link2.href = URL.createObjectURL(blob2);
      link2.download = filename.replace('.xlsx', '_FAILED.xlsx');
      link2.click();
    } catch (e) {
      alert('Failed to generate raw export: ' + (e && e.message ? e.message : String(e)));
    }
  }
};

  function buildRawFileName(opts = {}) {
    const safe = s => (s === undefined || s === null) ? '' : String(s).replace(/[\/\\:?<>|"]/g, '_').trim();
    const regionPart = opts.region ? safe(opts.region).toUpperCase() : 'RAW';
    const locationPart = opts.location ? `_${safe(opts.location).replace('.', '_')}` : '';
    const admitPart = opts.rawAdmitFilter ? `_${safe(opts.rawAdmitFilter)}` : '';
    const searchPart = opts.rawSearch ? `_${safe(opts.rawSearch).replace(/\s+/g, '_')}` : '';
    const formatDateForName = d => {
      if (!d) return '';
      try {
        if (d instanceof Date) return `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}`;
        const dt = new Date(d);
        if (!isNaN(dt.getTime())) return `${dt.getFullYear()}${pad2(dt.getMonth()+1)}${pad2(dt.getDate())}`;
      } catch (e) { /* ignore */ }
      return safe(d).slice(0,10).replace(/[-\s:]/g,'');
    };

    const fromPart = opts.from ? `_from_${formatDateForName(opts.from)}` : '';
    const toPart   = opts.to   ? `_to_${formatDateForName(opts.to)}` : '';
    const filename = `Raw_${regionPart}${locationPart}${fromPart}${toPart}${admitPart}${searchPart}.xlsx`;
    return filename;
  }

// export permissions helper and rest of UI logic unchanged from original file...
  const exportPermsForTab = () => {
    if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
    if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
    if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
    if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
    if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
    if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
    if (tab === 6) return ['gsoc_reports.denver_monthly', 'gsoc_reports'];
    return ['gsoc_reports'];
  };

  const disabled = loading
    || (tab !== 6 && !region)
    || (tab === 0 && (!from || !to || selectedEmps.length === 0))
    || (tab === 1 && (!from || !to))
    || (tab === 2 && (!from || !to))
    || (tab === 3 && !from)
    || (tab === 4 && (!from || !to));

  const navDisabled = (tab !== 6 && !region) || loading;
  const exportAllowed = auth.hasPermission(exportPermsForTab());

  // Format helpers used in handleGenerate (copied from your file)
  const formatLocalDate = (date, endOfDay = false) => {
    const d = new Date(date);
    if (endOfDay) d.setHours(23, 59, 59, 999);
    else d.setHours(0, 0, 0, 0);
    const pad = n => n.toString().padStart(2, '0');
    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}` +
           `T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  };

  const toLocalYMD = date => `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`;




  const handleGenerate = async () => {
    const requirePermissionForTab = () => {
      if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
      if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
      if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
      if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
      if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
      if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
      if (tab === 6) return ['gsoc_reports.denver_monthly', 'gsoc_reports'];
      return ['gsoc_reports'];
    };

    if (!auth.hasPermission(requirePermissionForTab())) {
      alert('You do not have permission to generate this report.');
      return;
    }

    // set user-visible generating message (different per tab)
    const messages = {
      0: 'Generating Daily Access report...',
      1: 'Generating Raw report...',
      2: 'Generating Rejection report...',
      3: 'Generating EUROC Admit-Reject report...',
      4: 'Generating Time Duration report...',
      5: 'Opening HeadCount...',
      6: 'Generating Denver Attendance report...'
    };
    setGeneratingMessage(messages[tab] || 'Generating report...');
    setLoading(true);

    try {
      const baseParams = { region, location: location || undefined };

      // ----- 0: Daily Access -----
      if (tab === 0) {
        const fromDateOnly = `${from.getFullYear()}-${pad2(from.getMonth() + 1)}-${pad2(from.getDate())}`;
        const toDateOnly = `${to.getFullYear()}-${pad2(to.getMonth() + 1)}-${pad2(to.getDate())}`;

        const params = {
          ...baseParams,
          from: fromDateOnly,
          to: toDateOnly,
          employees: selectedEmps.join(',')
        };
        const resp = await axios.get('/api/reports/daily-access', { params });
        const rows = (resp.data && resp.data.data) || [];
        await generateDailyAccessExcelFromRows(rows, { from: fromDateOnly, to: toDateOnly, selectedEmps, region });
        return;
      }



 //  // ----- 1: Raw (server-side /raw-download path) -----
    if (tab === 1) {
      // raw-download expects startDate/endDate as YYYY-MM-DD (use toLocalYMD)
      const startDate = toLocalYMD(new Date(from));
      const endDate = toLocalYMD(new Date(to));
      const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];

      // collect requests to perform (we will download one blob per request)
      const downloads = [];

      const pushDownload = (regionParam, locationParam = undefined) => {
        const params = { region: regionParam, startDate, endDate, admitFilter: rawAdmitFilter };
        if (locationParam) params.location = locationParam;
        downloads.push(params);
      };

      // build download jobs according to region/global and selectedLocations:
      if (region === 'global') {
        if (selectedLocations && selectedLocations.length) {
          // group by region-key derived from location prefix (e.g. "US.Denver" -> "us")
          const regionMap = {};
          selectedLocations.forEach(loc => {
            const parts = String(loc).split('.');
            const rKey = (parts[0] || '').toString().toLowerCase();
            regionMap[rKey] = regionMap[rKey] || [];
            regionMap[rKey].push(loc);
          });
          Object.entries(regionMap).forEach(([rKey, locs]) => {
            if (MULTI_REGIONS.includes(rKey)) {
              // for known region key call raw-download once per location (keeps server filter narrow)
              locs.forEach(loc => pushDownload(rKey, loc));
            } else {
              // unknown prefix -> call without region (backend may treat as partition)
              locs.forEach(loc => pushDownload(undefined, loc));
            }
          });
        } else {
          // no specific locations => request each known region
          MULTI_REGIONS.forEach(r => pushDownload(r));
        }
      } else {
        // single region selected
        if (selectedLocations && selectedLocations.length) {
          selectedLocations.forEach(loc => pushDownload(region, loc));
        } else {
          pushDownload(region);
        }
      }

      // If no downloads added (shouldn't happen), add current region
      if (!downloads.length) pushDownload(region);

      // perform the downloads sequentially to avoid overwhelming client/network
      for (const params of downloads) {
        try {
          setGeneratingMessage(`Preparing server export for ${params.region || params.location || 'region'}...`);
          const resp = await axios.get('/api/reports/raw-download', {
            params,
            responseType: 'blob',
            timeout: 20 * 60 * 1000, // 20 minutes
            headers: {
              Accept: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/octet-stream'
            }
          });

          // determine filename
          let filename = buildRawFileName({
            region: params.region || 'RAW',
            location: params.location || (Array.isArray(selectedLocations) ? selectedLocations.join(',') : location),
            from,
            to,
            rawAdmitFilter
          });

          // prefer Content-Disposition if server provided it
          const cd = resp.headers['content-disposition'];
          if (cd) {
            const m = cd.match(/filename\*?=(?:UTF-8'')?["']?([^;"']+)/);
            if (m && m[1]) {
              try { filename = decodeURIComponent(m[1]); } catch (e) { filename = m[1]; }
            }
          }

          const blob = new Blob([resp.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          // cleanup
          setTimeout(() => {
            URL.revokeObjectURL(link.href);
            try { document.body.removeChild(link); } catch (e) {}
          }, 5000);
        } catch (err) {
          console.error('raw download failed for params', params, err);
          let msg = `Failed to download raw report for ${params.region || params.location || 'region'}`;
          if (err?.response?.data) {
            msg += `: ${err.response?.data?.detail || err.message || JSON.stringify(err.response.data)}`;
          } else if (err?.message) {
            msg += `: ${err.message}`;
          }
          // show error but continue with other downloads
          alert(msg);
        }
      }

      return;
    }

      // ----- 2: Rejection -----
      if (tab === 2) {
        const params = { ...baseParams, startDate: formatLocalDate(from), endDate: formatLocalDate(to, true) };
        const resp = await axios.get('/api/reports/rejection', { params });
        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);
        const rowsSrc = (resp.data && resp.data.data) || [];
        const rows = rowsSrc.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          return date >= startDate && date <= endDate;
        });
        await generateRejectionExcel(rows);
        return;
      }

      // ----- 3: EUROC Admit-Reject (single day) -----
      if (tab === 3) {
        if (region.toLowerCase() !== 'emea') {
          alert('EUROC report is only available for region EMEA. Please select EMEA.');
          return;
        }
        if (!from) {
          alert('Please select a date (From) for EUROC report.');
          return;
        }

        // If user selected specific locations (selectedLocations) then pass them to backend as comma separated
        const dateParam = toLocalYMD(new Date(from));
        const params = { region: 'emea', date: dateParam };
        if (selectedLocations && selectedLocations.length) params.locations = selectedLocations.join(',');
        const resp = await axios.get('/api/reports/euroc-admit-rejection', { params });
        const { data } = resp.data || {};

        // ---------- EUROC Admit-Reject generation (updated formatting) ----------
        {
          const wb = new ExcelJS.Workbook();

          // common constants
          const GRAY_FILL_LOCAL = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };

          // helper: convert 1-index col num to letter
          const colLetterLocal = (c => {
            let n = c, s = '';
            while (n > 0) {
              const m = (n - 1) % 26;
              s = String.fromCharCode(65 + m) + s;
              n = Math.floor((n - 1) / 26);
            }
            return s;
          });

          // --- helper to build a formatted sheet ---
          function createFormattedSheet(sheetName, titleText, headers, rowsData) {
            const ws = wb.addWorksheet(sheetName);
            hideGridLines(ws);

            // Skip first row
            ws.addRow([]);

            // Title (row 2) merged across content columns (content will start at col B)
            const contentCols = headers.length; // number of content columns
            const startCol = 2; // B
            const endCol = startCol + contentCols - 1;
            const startLetter = colLetterLocal(startCol);
            const endLetter = colLetterLocal(endCol);

            // ensure row 2 exists
            ws.addRow([null]);
            ws.mergeCells(`${startLetter}2:${endLetter}2`);
            ws.getCell(`${startLetter}2`).value = titleText;
            ws.getCell(`${startLetter}2`).font = { bold: true, size: 14 };
            ws.getCell(`${startLetter}2`).alignment = { horizontal: 'center', vertical: 'middle' };
            ws.getRow(2).height = 22;

            // style merged title cells (thick border + gray fill)
            for (let c = startCol; c <= endCol; c++) {
              const cell = ws.getCell(2, c);
              cell.fill = GRAY_FILL_LOCAL;
              cell.font = { bold: true, size: 14 };
              cell.alignment = { horizontal: 'center', vertical: 'middle' };
              cell.border = THICK_BORDER;
            }

            // Header row (row 3) - insert with a null at col A so column A remains blank
            const headerRow = ws.addRow([null, ...headers]);
            headerRow.height = 20;
            headerRow.eachCell((cell, colNumber) => {
              if (colNumber >= startCol && colNumber <= endCol) {
                cell.font = { bold: true };
                cell.alignment = { horizontal: 'center', vertical: 'middle' };
                cell.fill = GRAY_FILL_LOCAL;
                cell.border = THICK_BORDER;
              }
            });

            // set columns (include blank A)
            const cols = [{ key: 'blankA', width: 3 }];
            headers.forEach(h => cols.push({ key: h.replace(/\s+/g, '').toLowerCase(), width: 18 }));
            ws.columns = cols;

            // All data columns center aligned (including "Door Name")
            const centerCols = new Set();
            for (let c = startCol; c <= endCol; c++) centerCols.add(c);

            // Data rows start at row 4
            (rowsData || []).forEach((r, idx) => {
              // map row values in same order as headers
              const vals = headers.map(h => {
                // pick common fields or fallback to empty
                const key = h.toString();
                if (/Sr\.?\s*No/i.test(key)) return idx + 1;
                if (/Date/i.test(key)) {
                  // prefer formatted date if available
                  const iso = getServerISO(r);
                  return iso ? formatDateFromServerISO(iso) : (r.DateOnly || '');
                }
                if (/Time/i.test(key)) {
                  const iso = getServerISO(r);
                  return iso ? formatTimeFromServerISO(iso) : (r.Swipe_Time || r.Direction || '');
                }
                if (/Employee Name/i.test(key)) return r.ObjectName1 || r.EmployeeName || '';
                if (/Employee ID/i.test(key)) return r.EmployeeID || '';
                if (/Access Card/i.test(key)) return r.CardNumber || r.Card || r.CardNo || '';
                if (/Rejection Type/i.test(key)) return r.Rejection_Type || r.RejectType || '';
                if (/Personnel Type/i.test(key)) return r.PersonnelType || '';
                if (/Door Name/i.test(key)) return r.Door || r.ObjectName2 || '';
                if (/Location/i.test(key)) return r.Location || r.LogicalLocation || r.location || '';
                if (/Swipe/i.test(key)) return r.Direction || r.Swipe || '';
                return (r[key] !== undefined && r[key] !== null) ? r[key] : '';
              });

              // prepend null for column A
              const row = ws.addRow([null, ...vals]);

              row.eachCell((cell, colNumber) => {
                if (colNumber >= startCol && colNumber <= endCol) {
                  cell.border = THIN_BORDER;
                  cell.alignment = { vertical: 'middle', horizontal: (centerCols.has(colNumber) ? 'center' : 'left') };
                }
              });
            });

            // apply thick outside border around header + data (B..end)
            const headerRowIndex = 3;
            const firstDataRow = headerRowIndex;
            const lastDataRow = ws.lastRow ? ws.lastRow.number : headerRowIndex;
            for (let r = firstDataRow; r <= lastDataRow; r++) {
              for (let c = startCol; c <= endCol; c++) {
                const cell = ws.getCell(r, c);
                if (!cell.border) cell.border = THIN_BORDER;
                const border = {
                  top: (r === firstDataRow) ? { style: 'thick' } : (cell.border.top || { style: 'thin' }),
                  bottom: (r === lastDataRow) ? { style: 'thick' } : (cell.border.bottom || { style: 'thin' }),
                  left: (c === startCol) ? { style: 'thick' } : (cell.border.left || { style: 'thin' }),
                  right: (c === endCol) ? { style: 'thick' } : (cell.border.right || { style: 'thin' })
                };
                cell.border = border;
              }
            }

            // return metadata so caller can add a summary block to the right
            return { ws, startCol, endCol, headerRowIndex, lastDataRow };
          }

          // Build admit sheet
          const admitHeaders = [
            'Sr. No.', 'Date', 'Time', 'Employee Name',
            'Access Card No.', 'Personnel Type', 'Door Name', 'Location', 'Swipe'
          ];
          const admitRows = (data && data.admit) ? (data.admit.map(r => r)) : [];
          const admitMeta = createFormattedSheet('EUROC Admit', `EUROC Admit Report - ${formatDisplayDate(from)}`, admitHeaders, admitRows);

          // Build rejection sheet
          const rejHeaders = [
            'Sr. No.', 'Date', 'Time', 'Employee Name', 'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
          ];
          const rejRows = (data && data.rejection) ? (data.rejection.map(r => r)) : [];
          const rejMeta = createFormattedSheet('EUROC Rejection', `EUROC Rejection Report - ${formatDisplayDate(from)}`, rejHeaders, rejRows);

          // ---------- Summary placement & formatting (same style as Rejection) ----------
          // We'll add a summary block on the REJECTION sheet (rejMeta) to the right of the table
          (function addSummaryToRejectionSheet() {
            const ws2 = rejMeta.ws;
            const lastCol = rejMeta.endCol;
            const summaryStartCol = lastCol + 2; // skip one blank column after Swipe
            const summaryTitleRow = rejMeta.headerRowIndex + 1; // one row below header (row 4)
            const summaryHdrRow = summaryTitleRow + 1;

            // Build counts map
            const countsMap = {};
            if (data && Array.isArray(data.summary) && data.summary.length) {
              (data.summary || []).forEach(c => {
                const key = c.Rejection_Type || c.rejectionType || 'Unknown';
                const cnt = (typeof c.Count === 'number') ? c.Count : c.count || 0;
                countsMap[key] = (countsMap[key] || 0) + cnt;
              });
            }
            // fallback: if summary empty, compute from rejection rows
            if (Object.keys(countsMap).length === 0) {
              (rejRows || []).forEach(r => {
                const k = (r.Rejection_Type || 'Unknown').toString();
                countsMap[k] = (countsMap[k] || 0) + 1;
              });
            }
            const entries = Object.entries(countsMap);

            const sA = colLetterLocal(summaryStartCol);
            const sB = colLetterLocal(summaryStartCol + 1);
            ws2.mergeCells(`${sA}${summaryTitleRow}:${sB}${summaryTitleRow}`);
            ws2.getCell(`${sA}${summaryTitleRow}`).value = 'Summary';
            ws2.getCell(`${sA}${summaryTitleRow}`).font = { bold: true };
            ws2.getCell(`${sA}${summaryTitleRow}`).alignment = { horizontal: 'center', vertical: 'middle' };
            ws2.getCell(`${sA}${summaryTitleRow}`).fill = GRAY_FILL_LOCAL;
            ws2.getCell(`${sA}${summaryTitleRow}`).border = THICK_BORDER;
            ws2.getCell(`${sB}${summaryTitleRow}`).fill = GRAY_FILL_LOCAL;
            ws2.getCell(`${sB}${summaryTitleRow}`).border = THICK_BORDER;

            // header row for summary (use THICK_BORDER on header cells)
            ws2.getCell(summaryHdrRow, summaryStartCol).value = 'Rejection';
            ws2.getCell(summaryHdrRow, summaryStartCol + 1).value = 'Count';
            [summaryStartCol, summaryStartCol + 1].forEach(c => {
              const cell = ws2.getCell(summaryHdrRow, c);
              cell.font = { bold: true };
              cell.alignment = { horizontal: 'center', vertical: 'middle' };
              cell.fill = GRAY_FILL_LOCAL;
              cell.border = THICK_BORDER;
            });

            // detail rows
            let cur = summaryHdrRow + 1;
            entries.forEach(([type, cnt]) => {
              ws2.getCell(cur, summaryStartCol).value = type;
              ws2.getCell(cur, summaryStartCol + 1).value = cnt;
              ws2.getCell(cur, summaryStartCol).alignment = { horizontal: 'left', vertical: 'middle' };
              ws2.getCell(cur, summaryStartCol + 1).alignment = { horizontal: 'center', vertical: 'middle' };
              ws2.getCell(cur, summaryStartCol).border = THIN_BORDER;
              ws2.getCell(cur, summaryStartCol + 1).border = THIN_BORDER;
              cur++;
            });

            // grand total (make thick border & gray fill)
            const total = (rejRows || []).length;
            ws2.getCell(cur, summaryStartCol).value = 'Grand Total';
            ws2.getCell(cur, summaryStartCol + 1).value = total;
            [summaryStartCol, summaryStartCol + 1].forEach(c => {
              const cell = ws2.getCell(cur, c);
              cell.font = { bold: true };
              cell.alignment = { horizontal: 'center', vertical: 'middle' };
              cell.fill = GRAY_FILL_LOCAL;
              cell.border = THICK_BORDER;
            });

            // enforce thick outside border for the entire summary block
            for (let r = summaryTitleRow; r <= cur; r++) {
              for (let c = summaryStartCol; c <= summaryStartCol + 1; c++) {
                const cell = ws2.getCell(r, c);
                if (!cell.border) cell.border = THIN_BORDER;
                const border = {
                  top: (r === summaryTitleRow) ? { style: 'thick' } : (cell.border.top || { style: 'thin' }),
                  bottom: (r === cur) ? { style: 'thick' } : (cell.border.bottom || { style: 'thin' }),
                  left: (c === summaryStartCol) ? { style: 'thick' } : (cell.border.left || { style: 'thin' }),
                  right: (c === (summaryStartCol + 1)) ? { style: 'thick' } : (cell.border.right || { style: 'thin' })
                };
                cell.border = border;
              }
            }
          })();

          // write file
          const buf = await wb.xlsx.writeBuffer();
          const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
          const filename = `EUROC_Admit_Rejection_${dateParam}.xlsx`;
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = filename;
          link.click();
        }

        return;
      }

      // ----- 4: Time Duration -----
      if (tab === 4) {
        if (!from || !to) {
          alert('Please select both Start Date and End Date for Time Duration report.');
          return;
        }
        const startParam = toLocalYMD(new Date(from));
        const endParam = toLocalYMD(new Date(to));
        const params = {
          region,
          startDate: startParam,
          endDate: endParam,
          partition: location ? location.split('.').pop() : 'Default'
        };
        const resp = await axios.get('/api/reports/time-duration', { params });
        await generateTimeDurationExcel(resp.data.data || []);
        return;
      }

     //       // ----- 5: HeadCount / External navigation -----
       if (tab === 5) {
      // final permission check (region specific)
      const permCandidates = [`headcount.${region}`, 'headcount', 'global_access'];
      if (!auth.hasPermission(permCandidates)) {
        alert(`You do not have permission to view HeadCount for ${region.toUpperCase()}.`);
        setLoading(false);
        return;
      }

      let url = '';

      // helper to resolve headcount URL by trying multiple variants of the selected location:
      const resolveUrl = (mapObj, loc) => {
        if (!loc) return null;
        const full = String(loc);
        const short = full.split('.').pop();
        // try exact key, then short key, then normalized (space/percent encodings)
        return mapObj[full] || mapObj[short] || mapObj[decodeURIComponent(full)] || mapObj[decodeURIComponent(short)] || null;
      };

      if (region === 'laca') {
        if (!location) url = 'http://10.199.22.57:3003/history';
        else {
          const LACA_URLS = {
            'CR.Costa Rica Partition': 'http://10.199.22.57:3003/partition/CR.Costa%20Rica%20Partition/history',
            'MX.Mexico City': 'http://10.199.22.57:3003/partition/MX.Mexico%20City/history',
            'AR.Cordoba': 'http://10.199.22.57:3003/partition/AR.Cordoba/history',
            'PA.Panama City': 'http://10.199.22.57:3003/partition/PA.Panama%20City/history',
            'PE.Lima': 'http://10.199.22.57:3003/partition/PE.Lima/history',
            'BR.Sao Paulo': 'http://10.199.22.57:3003/partition/BR.Sao%20Paulo/history'
          };
          url = resolveUrl(LACA_URLS, location) || 'http://10.199.22.57:3003/history';
        }
      } else if (region === 'namer') {
        if (!location) url = 'http://10.199.22.57:3002/history';
        else {
          const NAMER_URLS = {
            'Denver-HQ': 'http://10.199.22.57:3002/partition/US.CO.OBS/history',
            'Denver': 'http://10.199.22.57:3002/partition/US.CO.OBS/history',
            'US.Denver': 'http://10.199.22.57:3002/partition/US.CO.OBS/history',
            'Miami': 'http://10.199.22.57:3002/partition/US.FL.Miami/history',
            'New York': 'http://10.199.22.57:3002/partition/US.NYC/history',
            'Austin Texas': 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default/history',
            'Austin': 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default/history',
            'USA/Canada Default': 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default/history'
          };
          url = resolveUrl(NAMER_URLS, location) || 'http://10.199.22.57:3002/history';
        }
      } else if (region === 'apac') {
        if (!location) url = 'http://10.199.22.57:3000/history';
        else {
          const APAC_URLS = {
            'Pune': 'http://10.199.22.57:3000/partition/Pune/history',
            'APAC.Pune': 'http://10.199.22.57:3000/partition/Pune/history',
            'Hyderabad':'http://10.199.22.57:3000/partition/IN.HYD/history',
            'IN.HYD':'http://10.199.22.57:3000/partition/IN.HYD/history',
            'MY.Kuala Lumpur': 'http://10.199.22.57:3000/partition/MY.Kuala Lumpur/history',
            'Quezon City': 'http://10.199.22.57:3000/partition/Quezon%20City/history',
            'JP.Tokyo': 'http://10.199.22.57:3000/partition/JP.Tokyo/history',
            'Taguig City': 'http://10.199.22.57:3000/partition/Taguig%20City/history'
          };
          url = resolveUrl(APAC_URLS, location) || 'http://10.199.22.57:3000/history';
        }
      } else if (region === 'emea') {
        if (!location) url = 'http://10.199.22.57:3001/history';
        else {
          const EMEA_URLS = {
            'AUT.Vienna': 'http://10.199.22.57:3001/history',
            'DU.Abu Dhabi': 'http://10.199.22.57:3001/history',
            'IE.Dublin': 'http://10.199.22.57:3001/history',
            'IT.Rome': 'http://10.199.22.57:3001/history',
            'LT.Vilnius': 'http://10.199.22.57:3001/history',
            'MA.Casablanca': 'http://10.199.22.57:3001/history',
            'RU.Moscow': 'http://10.199.22.57:3001/history',
            'UK.London': 'http://10.199.22.57:3001/history',
            'ES.Madrid': 'http://10.199.22.57:3001/history'
          };
          url = resolveUrl(EMEA_URLS, location) || 'http://10.199.22.57:3001/history';
        }
      }

      if (url) window.location.href = url;
      else alert('Invalid region or location selected.');
      return;
    }



// ----- Denver Monthly (tab 6) -----
if (tab === 6) {
  try {
    // If user selected both From and To, send full date range to backend.
    // Otherwise fall back to single-month behaviour (existing behavior).
    let params = {};
    if (from && to) {
      params = {
        from_date: toLocalYMD(new Date(from)),
        to_date: toLocalYMD(new Date(to))
      };
    } else if (from) {
      const d = new Date(from);
      params = { year: d.getFullYear(), month: d.getMonth() + 1 };
    } else {
      // fallback: previous month (preserve existing UX)
      const dt = new Date();
      dt.setDate(1); dt.setHours(0,0,0,0);
      dt.setMonth(dt.getMonth() - 1);
      params = { year: dt.getFullYear(), month: dt.getMonth() + 1 };
    }

const resp = await axios.get('/api/reports/denver-attendance', {
  params,
  responseType: 'blob',
  timeout: 20 * 60 * 1000, // 20 minutes (ms) — adjust if you expect even longer runs
  headers: {
    Accept: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/octet-stream'
  }
});

    // Construct a friendly filename:
    let filename = 'denver_attendance.xlsx';
    // if range provided, prefer from-to name
    if (params.from_date && params.to_date) {
      filename = `denver_attendance_${params.from_date.replace(/-/g,'')}_to_${params.to_date.replace(/-/g,'')}.xlsx`;
    } else if (params.year && params.month) {
      filename = `denver_attendance_${params.year}${String(params.month).padStart(2,'0')}.xlsx`;
    }

    // Respect backend Content-Disposition if present
    const cd = resp.headers['content-disposition'];
    if (cd) {
      const m = cd.match(/filename\*?=(?:UTF-8'')?["']?([^;"']+)/);
      if (m && m[1]) {
        try { filename = decodeURIComponent(m[1]); } catch (e) { filename = m[1]; }
      }
    }

    const blob = new Blob([resp.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const link = document.createElement('a');
    link.href = window.URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  } catch (err) {
    console.error('Denver attendance download error', err);
    let msg = 'Failed to download Denver attendance report';
    if (err?.response?.data) {
      msg += `: ${err.response?.data?.detail || err.message || JSON.stringify(err.response.data)}`;
    } else if (err?.message) {
      msg += `: ${err.message}`;
    }
    alert(msg);
  }
  return;
}





    } catch (err) {
      console.error('handleGenerate error:', err);
      let msg = 'Failed to generate report';
      if (err?.response?.data) {
        const d = err.response.data;
        const serverMsg = (typeof d === 'string') ? d
                          : (d.error || d.message || JSON.stringify(d));
        msg += `: ${serverMsg}`;
      } else if (err?.message) {
        msg += `: ${err.message}`;
      }
      alert(msg);
    } finally {
      setLoading(false);
      setGeneratingMessage('');
    }
  };

  // --- UI render ---
  const regionOptions = regionOptionsForTab();
  const locationOptions = locationOptionsForTab();

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
        {/* Topbar / Header */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            px: 3,
            py: 2,
            borderBottom: '1px solid rgba(255,204,0,0.08)',
            background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
          }}
        >
          <Avatar sx={{ bgcolor: '#000', border: '3px solid #FFCC00', width: 56, height: 56 }}>
            <Typography sx={{ color: '#FFCC00', fontWeight: 900 }}>WU</Typography>
          </Avatar>

          <Box sx={{ flex: 1 }}>
            <Typography variant="h5" sx={{ fontWeight: 900, letterSpacing: 0.6 }}>
              Global Security Operation Center
            </Typography>
            <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
              Reports & Exports — Secure access, fast insights
            </Typography>
          </Box>

          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
            <Button
              startIcon={<DownloadIcon />}
              onClick={handleGenerate}
              disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
              sx={{
                bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                color: '#000',
                fontWeight: 800,
                px: 3,
                py: 1,
                borderRadius: 3,
                boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
                transformOrigin: 'center',
                '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-2px)' : 'none' }
              }}
            >
              {loading ? 'Loading…' : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
            </Button>
          </Box>
        </Box>

        {/* Generating banner */}
        {generatingMessage && (
          <Box sx={{ px: 3, py: 1, bgcolor: 'rgba(255,255,255,0.02)', borderBottom: '1px solid rgba(255,204,0,0.04)', display: 'flex', alignItems: 'center', gap: 2 }}>
            <CircularProgress size={20} />
            <Typography variant="body2" sx={{ color: '#FFCC00', fontWeight: 700 }}>{generatingMessage}</Typography>
          </Box>
        )}

        {/* Main content */}
        <Grid container sx={{ px: 3, py: 4 }} spacing={3}>
          <Grid item xs={12} md={3}>
            <Paper elevation={8} sx={{ p: 2.5, borderRadius: 3, height: { xs: 'auto', md: 'calc(100vh - 150px)' }, overflow: 'auto', background: 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015))', border: '1px solid rgba(255,204,0,0.06)' }}>
              <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
                <Box>
                  <Typography variant="subtitle1" sx={{ fontWeight: 800, color: '#FFCC00' }}>Filters</Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Narrow down by region, date and employees
                  </Typography>
                </Box>
                <IconButton size="small" sx={{ color: '#FFCC00' }}>
                  <FilterListIcon />
                </IconButton>
              </Box>

              <Divider sx={{ my: 1, borderColor: 'rgba(255,204,0,0.06)' }} />

              {/* Region - show per-tab region options */}
              {regionOptions.length > 0 && (
                <Box sx={{ mt: 1 }}>
                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Region</InputLabel>
                    <Select
                      value={region}
                      onChange={e => { setRegion(e.target.value); setLocation(''); }}
                      input={<OutlinedInput label="Region" />}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.24)' }
                      }}
                    >
                      {regionOptions.map(r => <MenuItem key={r} value={r}>{r.toUpperCase()}</MenuItem>)}
                    </Select>
                  </FormControl>
                </Box>
              )}

              {/* Location */}
              <Box sx={{ mt: 2 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Location</InputLabel>

                  {/* RAW (tab 1) keeps multi Autocomplete */}
                  {tab === 1 ? (
                    <Autocomplete
                      multiple
                      freeSolo={false}
                      options={availableLocations}
                      value={selectedLocations}
                      onChange={(e, v) => setSelectedLocations(v)}
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          placeholder="Choose 0..n locations (leave empty = all)"
                          InputLabelProps={{ style: { color: '#FFCC00' } }}
                          sx={{
                            '& .MuiInputBase-input': { color: '#fff' },
                            '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                          }}
                        />
                      )}
                      getOptionLabel={(opt) => String(opt)}
                      isOptionEqualToValue={(opt, val) => opt === val}
                      disabled={!region}
                    />
                  ) : null}

                  {/* EUROC (tab 3) -> multi-select Autocomplete of EMEA locations */}
                  {tab === 3 ? (
                    <Autocomplete
                      multiple
                      freeSolo={false}
                      options={availableLocations.length ? availableLocations : (LOCATION_MAP['emea'] || [])}
                      value={selectedLocations}
                      onChange={(e, v) => setSelectedLocations(v)}
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          placeholder="Select 0..n locations (leave empty = all EMEA)"
                          InputLabelProps={{ style: { color: '#FFCC00' } }}
                          sx={{
                            '& .MuiInputBase-input': { color: '#fff' },
                            '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                          }}
                        />
                      )}
                      getOptionLabel={(opt) => String(opt)}
                      isOptionEqualToValue={(opt, val) => opt === val}
                      disabled={!region}
                    />
                  ) : null}

                  {/* For Time Duration (tab 4) and others (including Denver tab 6), single-select */}
                  {tab !== 1 && tab !== 3 && tab !== 6 && (
                    <Select
                      value={location}
                      onChange={e => setLocation(e.target.value)}
                      input={<OutlinedInput label="Location" />}
                      disabled={(regionOptions.length === 0)}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                      }}
                    >
                      { (locationOptions && locationOptions.length) ? locationOptions.map(loc => (
                          <MenuItem key={loc} value={loc}>
                            {String(loc).split('.').pop()}
                          </MenuItem>
                        ))
                        : ((LOCATION_MAP[region] || []).map(loc => (
                          <MenuItem key={loc} value={loc}>{String(loc).split('.').pop()}</MenuItem>
                        )))
                      }
                    </Select>
                  )}

                  {/* Denver (tab 6) - single select but only Denver */}
                  {tab === 6 && (
                    <Select
                      value={location}
                      onChange={e => setLocation(e.target.value)}
                      input={<OutlinedInput label="Location" />}
                      disabled={false}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                      }}
                    >
                      <MenuItem value="US.Denver">Denver</MenuItem>
                    </Select>
                  )}
                </FormControl>
              </Box>

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />

              {/* Employee input area (Daily and Raw) */}
              {tab === 1 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employee (name or ID) — multiple
                  </Typography>

                  <Autocomplete
                    multiple
                    freeSolo
                    filterSelectedOptions
                    options={rawEmpOptions}
                    value={selectedRawEmps}
                    onChange={(e, v) => setSelectedRawEmps(v)}
                    onInputChange={async (e, value, reason) => {
                      if (empQueryRef.current) clearTimeout(empQueryRef.current);
                      if (!value || value.length < 2) {
                        empQueryRef.current = setTimeout(() => setRawEmpOptions([]), 150);
                        return;
                      }
                      empQueryRef.current = setTimeout(async () => {
                        try {
                          const params = { q: value };
                          if (region && region !== 'global') params.region = region;
                          const resp = await axios.get('/api/employees', { params });
                          const raw = (resp.data && (resp.data.data || resp.data)) || [];
                          const normalized = Array.isArray(raw) ? raw.map(item => {
                            if (typeof item === 'string') return item;
                            const id = item.EmployeeID || item.id || item.NumericEmployeeID || item.Employee || '';
                            const name = item.Name || item.name || item.ObjectName1 || '';
                            if (name && id) return `${name} (${id})`;
                            if (id) return String(id);
                            if (name) return String(name);
                            return JSON.stringify(item);
                          }) : [];
                          setRawEmpOptions(Array.from(new Set(normalized)));
                        } catch (err) {
                          console.warn('employee suggestions error', err);
                          setRawEmpOptions([]);
                        }
                      }, 300);
                    }}
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        placeholder="Type name or ID (2+ chars) — select multiple"
                        InputLabelProps={{ style: { color: '#FFCC00' } }}
                        sx={{
                          '& .MuiInputBase-input': { color: '#fff' },
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                        }}
                      />
                    )}
                    getOptionLabel={(opt) => (typeof opt === 'string' ? opt : (opt.label || opt.name || String(opt)))}
                    renderOption={(props, option) => <li {...props}>{typeof option === 'string' ? option : (option.label || option.name || String(option))}</li>}
                    ListboxProps={{ style: { maxHeight: 240 } }}
                  />

                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                    Leave empty to export all raw rows for the date range. Type 2+ chars to get suggestions for employee names or IDs.
                  </Typography>

                  <Box sx={{ mt: 2 }}>
                    <FormControl fullWidth>
                      <InputLabel sx={{ color: '#FFCC00' }}>Admit / Reject</InputLabel>
                      <Select
                        value={rawAdmitFilter}
                        onChange={(e) => setRawAdmitFilter(e.target.value)}
                        input={<OutlinedInput label="Admit / Reject" />}
                        sx={{
                          color: '#fff',
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                        }}
                      >
                        <MenuItem value="all">All (Admitted + Rejected)</MenuItem>
                        <MenuItem value="admit">Admitted only</MenuItem>
                        <MenuItem value="reject">Rejected only</MenuItem>
                      </Select>
                    </FormControl>
                    <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                      Default = All.
                    </Typography>
                  </Box>
                </Box>
              )}

              {/* Dates (shown for all tabs except external navigation tab 5) */}
              {tab !== 5 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Date Range
                  </Typography>
                  <Box sx={{ display: 'grid', gap: 1.25 }}>
                    <TextField
                      label={tab === 0 ? 'From Date' : 'Start Date'}
                      value={from ? from.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowFromCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                    <TextField
                      label={tab === 0 ? 'To Date' : 'End Date'}
                      value={to ? to.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowToCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                  </Box>

                  {showFromCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={from}
                        onChange={(newValue) => setFrom(newValue)}
                        onAccept={() => setShowFromCal(false)}
                        onClose={() => setShowFromCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                  {showToCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={to}
                        onChange={(newValue) => setTo(newValue)}
                        onAccept={() => setShowToCal(false)}
                        onClose={() => setShowToCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                </Box>
              )}

              {/* Daily employees block */}
              {tab === 0 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employees
                  </Typography>

                  <Box sx={{ display: 'flex', gap: 1, mb: 1 }}>
                    <TextField
                      fullWidth
                      placeholder="Add name or ID (e.g. 'Vainilaitis, Valdas' or '323471')"
                      value={newEmployee}
                      onChange={(e) => setNewEmployee(e.target.value)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                      InputLabelProps={{ style: { color: '#FFCC00' } }}
                    />
                    <Button
                      variant="contained"
                      onClick={() => {
                        const v = (newEmployee || '').toString().trim();
                        if (!v) return;
                        if (!selectedEmps.includes(v)) {
                          setSelectedEmps(prev => [...prev, v]);
                        }
                        setNewEmployee('');
                      }}
                      sx={{
                        bgcolor: '#FFCC00',
                        color: '#000',
                        fontWeight: 800,
                        px: 2,
                        '&:hover': { bgcolor: '#ffd84d' }
                      }}
                    >
                      Add
                    </Button>
                  </Box>

                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Employees</InputLabel>

                    <Select
                      multiple
                      value={selectedEmps}
                      onChange={e => setSelectedEmps(e.target.value)}
                      input={<OutlinedInput label="Employees" />}
                      renderValue={vals => vals.join(', ')}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                      }}
                    >
                      {[
                        ...EMPLOYEE_OPTIONS,
                        ...selectedEmps.filter(s => !EMPLOYEE_OPTIONS.includes(s))
                      ].map(n => (
                        <MenuItem key={n} value={n}>
                          <Checkbox checked={selectedEmps.includes(n)} />
                          <ListItemText primary={n} />
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              )}

              <Box sx={{ mt: 3, p: 2, borderRadius: 2, background: 'rgba(255,255,255,0.02)' }}>
                <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                  Tip: For daily exports pick employees & a single day range. For Time Duration choose the required partition via Location.
                </Typography>
              </Box>
            </Paper>
          </Grid>

          {/* Main panel */}
          <Grid item xs={12} md={9}>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              <Paper elevation={3} sx={{ px: 2, py: 1, borderRadius: 2, display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 2, border: '1px solid rgba(255,204,0,0.04)' }}>
                <Tabs value={tab} onChange={handleTabChange} sx={{ '& .MuiTab-root': { textTransform: 'none', minWidth: 120, fontWeight: 700, color: 'rgba(255,255,255,0.8)' }, '& .Mui-selected': { color: '#FFCC00' } }}>
                  <Tab icon={<CalendarTodayIcon />} label="Daily Access" />
                  <Tab icon={<PeopleIcon />} label="Raw" />
                  <Tab icon={<PlaceIcon />} label="Rejection" />
                  <Tab icon={<PeopleIcon />} label="EUROC Admit-Reject" />
                  <Tab icon={<CalendarTodayIcon />} label="Time Duration" />
                  <Tab icon={<PeopleIcon />} label="HeadCount" />
                  <Tab icon={<PeopleIcon />} label="Denver Monthly" />
                </Tabs>

                <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                  <Button variant="text" startIcon={<FilterListIcon />} sx={{ color: 'rgba(255,255,255,0.65)', textTransform: 'none' }} onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}>
                    Reset View
                  </Button>
                </Box>
              </Paper>

              <Paper elevation={6} sx={{ p: 3, borderRadius: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 2 }}>
                <Box>
                  <Typography variant="h6" sx={{ fontWeight: 900 }}>Export Center</Typography>
                  <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                   
                    {/* Selected Region: <strong style={{ color: '#FFCC00' }}>{region ? region.toUpperCase() : '—'}</strong> {location ? `• ${location.split('.').pop() === 'Denver' ? 'Denver' : location.split('.').pop()}` : ''} */}
                  
                  Selected Region: <strong style={{ color: '#FFCC00' }}>{region ? region.toUpperCase() : '—'}</strong> {location ? `• ${location}` : ''}

                  </Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Choose tab, select filters and export reports in Excel.
                  </Typography>
                </Box>

                <Box>
                  <Button
                    startIcon={loading ? <CircularProgress size={20} /> : <DownloadIcon />}
                    disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
                    onClick={handleGenerate}
                    sx={{
                      bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                      color: '#000',
                      fontWeight: 900,
                      px: 4,
                      py: 1,
                      borderRadius: 3,
                      boxShadow: '0 8px 30px rgba(255,204,0,0.22)',
                      '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-3px)' : 'none' }
                    }}
                  >
                    {loading
                      ? 'Loading…'
                      : (tab === 5
                          ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`)
                          : 'Export to Excel')}
                  </Button>
                </Box>
              </Paper>
            </Box>
          </Grid>
        </Grid>
      </Box>
    </LocalizationProvider>
  );
}



