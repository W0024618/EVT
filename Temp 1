export async function rawReportStreamToResponse(res, region, { startDate, endDate, location, admitFilter = 'all' }) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const pool = await getPool(region);
  const request = pool.request();
  // allow long running query on server side
  request.timeout = 10 * 60 * 1000; // 10 minutes (adjust as needed)

  // Accept NULL for location => all partitions
  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;
  request.input('location', sql.NVarChar(200), locationParam);
  request.input('startDate', sql.Date, startDate);
  request.input('endDate', sql.Date, endDate);
  request.input('admitFilter', sql.NVarChar(20), String(admitFilter || 'all'));

  // --- FULL SQL (same as rawReport) ---
  const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    -- message types we consider
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    -- location optional filter
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    -- admit/reject filter: 'all' | 'admit' | 'reject' (case-insensitive)
    AND (
      UPPER(ISNULL(@admitFilter,'all')) = 'ALL'
      OR (UPPER(@admitFilter) = 'ADMIT'  AND t1.MessageType = 'CardAdmitted')
      OR (UPPER(@admitFilter) = 'REJECT' AND t1.MessageType = 'CardRejected')
    )
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM CombinedQuery
ORDER BY LocaleMessageTime ASC;
`;

  // Prepare response headers for streaming xlsx
  const filename = `Raw_${region}_${startDate.replace(/-/g,'')}_to_${endDate.replace(/-/g,'')}.xlsx`;
  res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
  res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
  res.setHeader('Cache-Control', 'no-cache');

  // Workbook writer streams directly to res
  const workbook = new ExcelJS.stream.xlsx.WorkbookWriter({ stream: res, useSharedStrings: true, useStyles: true });

  // We'll split into sheets by year-month (YYYY-MM). Track sheet state.
  let currentMonthKey = null;
  let worksheet = null;
  let sheetIndexForMonth = {}; // track part numbers per month if > max per sheet
  const MAX_ROWS_PER_SHEET = 100000; // server-side sheet chunk size (adjust if needed)
  const headers = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber','AdmitCode','Direction','Door','Rejection_Type'];

  // helper to format human sheet name from monthKey
  const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  function humanMonthNameFromKey(key) {
    if (!key || key === 'unknown') return 'Unknown';
    const [y,m] = key.split('-');
    const mm = parseInt(m,10);
    const mon = MONTH_ABBR[mm - 1] || m;
    return `${mon}-${y}`;
  }

  // helper to create a new worksheet for given monthKey (and part number)
  function createWorksheetFor(monthKey) {
    sheetIndexForMonth[monthKey] = (sheetIndexForMonth[monthKey] || 0) + 1;
    const part = sheetIndexForMonth[monthKey];
    const human = humanMonthNameFromKey(monthKey);
    const name = part === 1 ? `${human} Sheet 1` : `${human} Sheet ${part}`;
    const ws = workbook.addWorksheet(name);
    // write header row
    const headerRow = ws.addRow(headers);
    headerRow.commit();
    // return ws and current row count (we don't rely on ws.rowCount in streaming mode)
    ws.__written = 1; // we track number of rows added to decide when to rotate sheets
    return ws;
  }

  // extract month key from row values (row.LocaleMessageTime or DateOnly)
  function monthKeyForRow(row) {
    try {
      const iso = row.LocaleMessageTime || row.DateOnly;
      if (iso) {
        const d = new Date(iso);
        if (!isNaN(d.getTime())) {
          const y = d.getUTCFullYear();
          const m = String(d.getUTCMonth() + 1).padStart(2, '0');
          return `${y}-${m}`;
        }
      }
    } catch (e) { /* ignore */ }
    return 'unknown';
  }

  // enable streaming on request
  request.stream = true;

  // safe commit helper to avoid calling workbook.commit() multiple times
  let committed = false;
  async function safeCommit() {
    if (committed) return;
    committed = true;
    try {
      await workbook.commit();
    } catch (e) {
      console.error('safeCommit: workbook.commit failed', e);
    }
  }

  // hook up streaming events
  request.on('error', async (err) => {
    console.error('SQL stream error', err);
    // finalize workbook once and end response
    try {
      await safeCommit();
    } catch (e) { /* already logged inside safeCommit */ }
    try { res.end(); } catch (e) { /* ignore */ }
  });

  request.on('row', (row) => {
    // determine which sheet to write to
    const monthKey = monthKeyForRow(row);
    if (!worksheet || monthKey !== currentMonthKey || (worksheet.__written >= MAX_ROWS_PER_SHEET)) {
      // rotate / create new sheet
      if (worksheet) {
        try { worksheet.commit(); } catch (e) { /* ignore */ }
      }
      currentMonthKey = monthKey;
      worksheet = createWorksheetFor(monthKey);
    }

    // create row values in same header order
    const rowVals = [
      row.LocaleMessageTime || '',
      row.DateOnly || '',
      row.Swipe_Time || '',
      row.EmployeeID || '',
      row.ObjectName1 || '',
      row.PersonnelType || '',
      row.location || '',
      row.CardNumber || '',
      row.AdmitCode || '',
      row.Direction || '',
      row.Door || '',
      row.Rejection_Type || ''
    ];
    const wrow = worksheet.addRow(rowVals);
    wrow.commit();
    worksheet.__written++;
  });

  request.on('done', async () => {
    try {
      if (worksheet) {
        try { worksheet.commit(); } catch (e) { /* ignore */ }
      }
      await safeCommit(); // finalizes workbook and flushes to res
    } catch (err) {
      console.error('Workbook commit error', err);
    } finally {
      try { res.end(); } catch (e) {}
    }
  });

  // finally execute the query (this starts the streaming)
  request.query(query).catch(async (err) => {
    console.error('request.query failed', err);
    // ensure workbook/res closed once
    try { await safeCommit(); } catch (e) {}
    try { res.end(); } catch (e) {}
  });
}




















When i try to run report we got this error check error carefully and fix the issue carefully 


üåç Global-backend listening on http://localhost:3008
SQL stream error RequestError: Incorrect syntax near 'SQL'.
    at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:384:15)    
    at Connection.emit (node:events:518:28)
    at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18)   
    at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
    at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
    at Readable.emit (node:events:518:28)
    at addChunk (node:internal/streams/readable:561:12)
    at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
    at Readable.push (node:internal/streams/readable:393:5)
    at nextAsync (node:internal/streams/from:194:22)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
  code: 'EREQUEST',
  originalError: Error: Incorrect syntax near 'SQL'.
      at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:382:19)  
      at Connection.emit (node:events:518:28)
      at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18) 
      at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
      at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
      at Readable.emit (node:events:518:28)
      at addChunk (node:internal/streams/readable:561:12)
      at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
      at Readable.push (node:internal/streams/readable:393:5)
      at nextAsync (node:internal/streams/from:194:22)
      at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
    info: ErrorMessageToken {
      name: 'ERROR',
      handlerName: 'onErrorMessage',
      number: 102,
      state: 1,
      class: 15,
      message: "Incorrect syntax near 'SQL'.",
      serverName: 'SRVWUPNQ0986V',
      procName: '',
      lineNumber: 1
    }
  },
  number: 102,
  lineNumber: 1,
  state: 1,
  class: 15,
  serverName: 'SRVWUPNQ0986V',
  procName: ''
}
Workbook commit error ArchiverError: archive already finalizing
    at Archiver.finalize (C:\Users\W0024618\Desktop\global-page\node_modules\archiver\lib\core.js:778:27)      
    at C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:342:16    
    at new Promise (<anonymous>)
    at WorkbookWriter._finalize (C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:335:12)
    at WorkbookWriter.commit (C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:111:17)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async Request.<anonymous> (file:///C:/Users/W0024618/Desktop/global-page/backend/services/reportService.js:1860:7) {
  code: 'FINALIZING',
  data: undefined
}

node:internal/process/promises:394
    triggerUncaughtException(err, true /* fromPromise */);
    ^
ArchiverError: archive already finalizing
    at Archiver.finalize (C:\Users\W0024618\Desktop\global-page\node_modules\archiver\lib\core.js:778:27)      
    at C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:342:16    
    at new Promise (<anonymous>)
    at WorkbookWriter._finalize (C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:335:12)
    at WorkbookWriter.commit (C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:111:17)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async Request.<anonymous> (file:///C:/Users/W0024618/Desktop/global-page/backend/services/reportService.js:1860:7) {
  code: 'FINALIZING',
  data: undefined
}

Node.js v22.17.0
PS C:\Users\W0024618\Desktop\global-page\backend> npm run start:backend

> global-page@1.0.0 start:backend
> cd backend && node index.js

üåç Global-backend listening on http://localhost:3008
SQL stream error RequestError: Incorrect syntax near 'SQL'.
    at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:384:15)    
    at Connection.emit (node:events:518:28)
    at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18)   
    at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
    at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
    at Readable.emit (node:events:518:28)
    at addChunk (node:internal/streams/readable:561:12)
    at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
    at Readable.push (node:internal/streams/readable:393:5)
    at nextAsync (node:internal/streams/from:194:22)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
  code: 'EREQUEST',
  originalError: Error: Incorrect syntax near 'SQL'.
      at handleError (C:\Users\W0024618\Desktop\global-page\node_modules\mssql\lib\tedious\request.js:382:19)  
      at Connection.emit (node:events:518:28)
      at Connection.emit (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\connection.js:970:18) 
      at RequestTokenHandler.onErrorMessage (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\handler.js:284:21)
      at Readable.<anonymous> (C:\Users\W0024618\Desktop\global-page\node_modules\tedious\lib\token\token-stream-parser.js:19:33)
      at Readable.emit (node:events:518:28)
      at addChunk (node:internal/streams/readable:561:12)
      at readableAddChunkPushObjectMode (node:internal/streams/readable:538:3)
      at Readable.push (node:internal/streams/readable:393:5)
      at nextAsync (node:internal/streams/from:194:22)
      at process.processTicksAndRejections (node:internal/process/task_queues:105:5) {
    info: ErrorMessageToken {
      name: 'ERROR',
      handlerName: 'onErrorMessage',
      number: 102,
      state: 1,
      class: 15,
      message: "Incorrect syntax near 'SQL'.",
      serverName: 'SRVWUFRA0986V',
      procName: '',
      lineNumber: 1
    }
  },
  number: 102,
  lineNumber: 1,
  state: 1,
  class: 15,
  serverName: 'SRVWUFRA0986V',
  procName: ''
}
Workbook commit error ArchiverError: archive already finalizing
    at Archiver.finalize (C:\Users\W0024618\Desktop\global-page\node_modules\archiver\lib\core.js:778:27)      
    at C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:342:16    
    at new Promise (<anonymous>)
    at WorkbookWriter._finalize (C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:335:12)
    at WorkbookWriter.commit (C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:111:17)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async Request.<anonymous> (file:///C:/Users/W0024618/Desktop/global-page/backend/services/reportService.js:1860:7) {
  code: 'FINALIZING',
  data: undefined
}

node:internal/process/promises:394
    triggerUncaughtException(err, true /* fromPromise */);
    ^
ArchiverError: archive already finalizing
    at Archiver.finalize (C:\Users\W0024618\Desktop\global-page\node_modules\archiver\lib\core.js:778:27)      
    at C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:342:16    
    at new Promise (<anonymous>)
    at WorkbookWriter._finalize (C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:335:12)
    at WorkbookWriter.commit (C:\Users\W0024618\Desktop\global-page\node_modules\exceljs\lib\stream\xlsx\workbook-writer.js:111:17)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async Request.<anonymous> (file:///C:/Users/W0024618/Desktop/global-page/backend/services/reportService.js:1860:7) {
  code: 'FINALIZING',
  data: undefined
}

Node.js v22.17.0
PS C:\Users\W0024618\Desktop\global-page\backend> 











//C:\Users\W0024618\Desktop\global-page\backend\services\reportService.js

 import { getPool, sql } from '../config/dbConfig.js';
 

import ExcelJS from 'exceljs';



export async function listLocations(region) {
  if (!region) throw new Error('region required');
  const pool = await getPool(region);
  const req = pool.request();
  // get distinct PartitionName2 values
  const q = `SELECT DISTINCT PartitionName2 FROM ACVSUJournalLog WHERE PartitionName2 IS NOT NULL ORDER BY PartitionName2`;
  const { recordset } = await req.query(q);
  return (recordset || []).map(r => r.PartitionName2).filter(Boolean);
}

/**
 * Search employees by name or employee id fragment
 * q: search string (partial), region: region key for getPool
 */
export async function searchEmployees(region = 'emea', q = '') {
  const pool = await getPool(region);
  const req = pool.request();
  const like = `%${q}%`;
  req.input('q', sql.NVarChar(200), like);

  // search common personnel name field (Text1) and numeric EmployeeID (Int1) and Text12 (contractor id)
  const query = `
    SELECT TOP (200)
      CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR(50)) END AS EmployeeID,
      ISNULL(t2.Text1, '') AS Name
    FROM ACVSCore.Access.Personnel AS t2
    LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId = t3.ObjectID
    WHERE (t2.Text1 LIKE @q) OR (CAST(t2.Int1 AS NVARCHAR(50)) LIKE @q) OR (t2.Text12 LIKE @q)
    ORDER BY t2.Text1;
  `;
  const { recordset } = await req.query(query);
  return (recordset || []).map(r => ({ EmployeeID: r.EmployeeID, Name: r.Name }));
}






/**
 * Stream raw report as an Excel file (multi-sheet split by month).
 * Writes directly to res ‚Äî does not load whole resultset into memory.
 *
 * Usage: call this from an Express route handler and do NOT also send other response content.
 */
export async function rawReportStreamToResponse(res, region, { startDate, endDate, location, admitFilter = 'all' }) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  const pool = await getPool(region);
  const request = pool.request();
  // allow long running query on server side
  request.timeout = 10 * 60 * 1000; // 10 minutes (adjust as needed)

  // Accept NULL for location => all partitions
  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;
  request.input('location', sql.NVarChar(200), locationParam);
  request.input('startDate', sql.Date, startDate);
  request.input('endDate', sql.Date, endDate);
  request.input('admitFilter', sql.NVarChar(20), String(admitFilter || 'all'));

  // the same query you already have (kept identical)
  const query = `...your existing SQL here...`; // replace with same query string you already use

  // Prepare response headers for streaming xlsx
  const filename = `Raw_${region}_${startDate.replace(/-/g,'')}_to_${endDate.replace(/-/g,'')}.xlsx`;
  res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
  res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
  res.setHeader('Cache-Control', 'no-cache');

  // Workbook writer streams directly to res
  const workbook = new ExcelJS.stream.xlsx.WorkbookWriter({ stream: res, useSharedStrings: true, useStyles: true });

  // We'll split into sheets by year-month (YYYY-MM). Track sheet state.
  let currentMonthKey = null;
  let worksheet = null;
  let sheetIndexForMonth = {}; // track part numbers per month if > max per sheet
  const MAX_ROWS_PER_SHEET = 100000; // server-side sheet chunk size (adjust if needed)
  const headers = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber','AdmitCode','Direction','Door','Rejection_Type'];

  // helper to format human sheet name from monthKey
  const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  function humanMonthNameFromKey(key) {
    if (!key || key === 'unknown') return 'Unknown';
    const [y,m] = key.split('-');
    const mm = parseInt(m,10);
    const mon = MONTH_ABBR[mm - 1] || m;
    return `${mon}-${y}`;
  }

  // helper to create a new worksheet for given monthKey (and part number)
  function createWorksheetFor(monthKey) {
    sheetIndexForMonth[monthKey] = (sheetIndexForMonth[monthKey] || 0) + 1;
    const part = sheetIndexForMonth[monthKey];
    const human = humanMonthNameFromKey(monthKey);
    const name = part === 1 ? `${human} Sheet 1` : `${human} Sheet ${part}`;
    const ws = workbook.addWorksheet(name);
    // write header row
    const headerRow = ws.addRow(headers);
    headerRow.commit();
    // return ws and current row count (we don't rely on ws.rowCount in streaming mode)
    ws.__written = 1; // we track number of rows added to decide when to rotate sheets
    return ws;
  }

  // extract month key from row values (row.LocaleMessageTime or DateOnly)
  function monthKeyForRow(row) {
    try {
      const iso = row.LocaleMessageTime || row.DateOnly;
      if (iso) {
        const d = new Date(iso);
        if (!isNaN(d.getTime())) {
          const y = d.getUTCFullYear();
          const m = String(d.getUTCMonth() + 1).padStart(2, '0');
          return `${y}-${m}`;
        }
      }
    } catch (e) { /* ignore */ }
    return 'unknown';
  }

  // enable streaming on request
  request.stream = true;

  // hook up streaming events
  request.on('error', async (err) => {
    console.error('SQL stream error', err);
    try {
      // abort workbook gracefully
      await workbook.commit();
    } catch (e) { /* ignore */ }
    // ensure response ends
    try { res.end(); } catch (e) {}
  });

  request.on('row', (row) => {
    // determine which sheet to write to
    const monthKey = monthKeyForRow(row);
    if (!worksheet || monthKey !== currentMonthKey || (worksheet.__written >= MAX_ROWS_PER_SHEET)) {
      // rotate / create new sheet
      if (worksheet) {
        worksheet.commit();
      }
      currentMonthKey = monthKey;
      worksheet = createWorksheetFor(monthKey);
    }

    // create row values in same header order
    const rowVals = [
      row.LocaleMessageTime || '',
      row.DateOnly || '',
      row.Swipe_Time || '',
      row.EmployeeID || '',
      row.ObjectName1 || '',
      row.PersonnelType || '',
      row.location || '',
      row.CardNumber || '',
      row.AdmitCode || '',
      row.Direction || '',
      row.Door || '',
      row.Rejection_Type || ''
    ];
    const wrow = worksheet.addRow(rowVals);
    wrow.commit();
    worksheet.__written++;
  });

  request.on('done', async () => {
    try {
      if (worksheet) worksheet.commit();
      await workbook.commit(); // finalizes workbook and flushes to res
    } catch (err) {
      console.error('Workbook commit error', err);
    } finally {
      try { res.end(); } catch (e) {}
    }
  });

  // finally execute the query (this starts the streaming)
  request.query(query).catch(async (err) => {
    console.error('request.query failed', err);
    // ensure workbook/res closed
    try { await workbook.commit(); } catch (e) {}
    try { res.end(); } catch (e) {}
  });
}


export async function rawReport(region, { startDate, endDate, location, admitFilter = 'all' }) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  // const pool = await getPool(region);
  // const req = pool.request();

  const pool = await getPool(region);
  const req = pool.request();
  // increase timeout for this request (ms) ‚Äî set to 5 minutes
  req.timeout = 300000;


  // Accept NULL for location to mean "all partitions in this region DB"
  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;

  req.input('location', sql.NVarChar(200), locationParam);
  req.input('startDate', sql.Date, startDate);
  req.input('endDate', sql.Date, endDate);
  req.input('admitFilter', sql.NVarChar(20), String(admitFilter || 'all'));

  const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    -- message types we consider
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    -- location optional filter
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    -- admit/reject filter: 'all' | 'admit' | 'reject' (case-insensitive)
    AND (
      UPPER(ISNULL(@admitFilter,'all')) = 'ALL'
      OR (UPPER(@admitFilter) = 'ADMIT'  AND t1.MessageType = 'CardAdmitted')
      OR (UPPER(@admitFilter) = 'REJECT' AND t1.MessageType = 'CardRejected')
    )
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM CombinedQuery
ORDER BY LocaleMessageTime ASC;
`;

  const { recordset } = await req.query(query);
  return recordset;
}





export async function rejectionReport(region, { startDate, endDate, location } = {}) {
  if (!region) throw new Error('region required');
  if (!startDate || !endDate) throw new Error('startDate and endDate required');

  // const pool = await getPool(region);
  // const req = pool.request();

   const pool = await getPool(region);
  const req = pool.request();
  // increase timeout for this request (ms) ‚Äî set to 5 minutes
  req.timeout = 300000;


  const locationParam = (location && String(location).trim()) ? String(location).trim() : null;

  req.input('location', sql.NVarChar(200), locationParam);
  req.input('startDate', sql.Date, startDate);
  req.input('endDate', sql.Date, endDate);

  const query = `
WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType = 'CardRejected'
    AND (@location IS NULL OR t1.PartitionName2 = @location)
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) BETWEEN @startDate AND @endDate
),
Unified AS (
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Lost'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Clearance'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type IN ('CardDisabled','Disabled')
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Stolen'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'Expired'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'PIN'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'UnknownCard'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'SiteCode'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'NotActivated'
  UNION ALL
  SELECT * FROM CombinedQuery WHERE Rejection_Type = 'FacilityCode'
)
SELECT
  LocaleMessageTime,
  CONVERT(date,    LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM Unified
ORDER BY LocaleMessageTime DESC;
`;

  const { recordset } = await req.query(query);
  return recordset;
}

// // backend/services/reportService.js
export async function dailyAccessReportEMEA({ from, to, employees = '' }) {
  const pool = await getPool('emea');
  const req  = pool.request();

  req.input('fromDate', sql.Date, from);
  req.input('toDate',   sql.Date, to);
  const employeesParam = (employees && String(employees).trim()) ? String(employees).trim() : null;
  req.input('employees', sql.NVarChar(sql.MAX), employeesParam);

  const query = `

  -- expects parameters: @fromDate (DATE), @toDate (DATE), @employees (NVARCHAR(MAX) | NULL)
DECLARE @empCSV NVARCHAR(MAX) = @employees;

;WITH EmpList AS (
  SELECT LTRIM(RTRIM(value)) AS emp
  FROM STRING_SPLIT(ISNULL(@empCSV,''), ',')
  WHERE LTRIM(RTRIM(value)) <> ''
)

-- Raw rows: compute LocaleMessageTime once and use OUTER APPLY to avoid duplicate shreddes
, RawSwipes AS (
  SELECT
    t1.ObjectName1,
    t1.ObjectName2,
    t1.MessageType,
    t2.Text12       AS EmployeeID,
    CAST(t2.Int1 AS NVARCHAR(50)) AS NumericEmployeeID,
    t3.Name         AS PersonnelType,
    t1.PartitionName2 AS PartitionName2,

    -- compute local wall-clock once (DO NOT change sign here; using your -1 * MessageLocaleOffset)
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,

    -- direction/value picked by OUTER APPLY (single row)
    CASE
      WHEN dir.Value = 'InDirection'  THEN 'IN'
      WHEN dir.Value = 'OutDirection' THEN 'OUT'
      ELSE 'Unknown'
    END AS Swipe,

    card.Value AS CardNumber
  FROM ACVSUJournal_00011028.dbo.ACVSUJournalLog AS t1
  INNER JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  INNER JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID

  -- pick at most one direction shred row (InDirection/OutDirection)
  OUTER APPLY (
    SELECT TOP (1) s.Value
    FROM ACVSUJournal_00011028.dbo.ACVSUJournalLogxmlShred AS s
    WHERE s.GUID = t1.XmlGUID
      AND s.Value IN ('InDirection','OutDirection')
  ) AS dir

  -- pick at most one numeric card value (exclude direction values, ensure numeric)
  OUTER APPLY (
    SELECT TOP (1) s.Value
    FROM ACVSUJournal_00011028.dbo.ACVSUJournalLogxmlShred AS s
    WHERE s.GUID = t1.XmlGUID
      AND s.Value NOT IN ('InDirection','OutDirection')
      AND s.Value NOT LIKE '%[^0-9]%'
      AND s.Value IS NOT NULL
      AND LTRIM(RTRIM(s.Value)) <> ''
  ) AS card
)

-- Strict time window: >= 08:00 on @fromDate, and < 08:00 on @toDate
, Windowed AS (
  SELECT *
  FROM RawSwipes
  WHERE
    LocaleMessageTime >= DATEADD(HOUR, 8, CAST(@fromDate AS DATETIME))
    -- NOTE: removed extra DATEADD(DAY,1,...) ‚Äî upper bound should be < toDate 08:00
    AND LocaleMessageTime <  DATEADD(HOUR, 8, CAST(@toDate AS DATETIME))
    AND Swipe IN ('IN','OUT') -- only real swipes
)

-- final projection + optional employee filter (supports CSV of names or IDs)
SELECT
  ObjectName1,
  ObjectName2,
  PersonnelType,
  EmployeeID,
  NumericEmployeeID,
  -- alias PartitionName2 -> location so frontend sees r.location
  PartitionName2 AS location,
  -- alias MessageType -> Messagetype so frontend sees r.Messagetype
  MessageType AS Messagetype,
  Swipe,
  CardNumber,
  LocaleMessageTime
FROM Windowed w
WHERE
  (
    @empCSV IS NULL
    OR LTRIM(RTRIM(@empCSV)) = ''
    OR EXISTS (
      SELECT 1
      FROM EmpList e
      WHERE
        e.emp = LTRIM(RTRIM(w.ObjectName1))
        OR e.emp = w.EmployeeID
        OR e.emp = w.NumericEmployeeID
    )
  )
ORDER BY LocaleMessageTime;

`;

  const { recordset } = await req.query(query);
  return recordset;
}






/**
 * In-vs-Out Report (parameterized) ‚Äî groups by employee & month
 */
export async function inOutReport(region, { year, month, doors }) {
 // const pool = await getPool(region);
  // const req  = pool.request();

    const pool = await getPool(region);
  const req = pool.request();
  // increase timeout for this request (ms) ‚Äî set to 5 minutes
  req.timeout = 300000;


  req.input('TargetYear',  sql.Int, year);
  req.input('TargetMonth', sql.Int, month);
  doors.forEach((d, i) => req.input(`door${i}`, sql.NVarChar, d));
  const doorList = doors.map((_, i) => `@door${i}`).join(',');

  const query = `
WITH CombinedQuery AS (
  SELECT
    DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
    t1.ObjectName1,
    t1.PartitionName2    AS location,
    t5_card.CardNumber,
    t5_dir.value         AS Direction,
    CASE
      WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
      ELSE CAST(t2.Int1 AS NVARCHAR)
    END                    AS EmployeeID,
    t3.Name               AS PersonnelType
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2
    ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3
    ON t2.PersonnelTypeId = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID
    AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml AS t_xml
    ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard
    ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  WHERE
    YEAR(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetYear
    AND MONTH(DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @TargetMonth
    AND t1.ObjectName2 IN (${doorList})
)
SELECT
  FORMAT(LocaleMessageTime,'yyyy-MM')    AS Month,
  ObjectName1                           AS EmployeeName,
  EmployeeID,
  PersonnelType,
  location,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)  AS In_Count,
  SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS Out_Count,
  COUNT(*)                                                 AS TotalSwipes,
  SUM(CASE WHEN Direction='InDirection' THEN 1 ELSE 0 END)
  - SUM(CASE WHEN Direction='OutDirection' THEN 1 ELSE 0 END) AS InOut_Difference
FROM CombinedQuery
GROUP BY FORMAT(LocaleMessageTime,'yyyy-MM'),
         ObjectName1, EmployeeID, PersonnelType, location
ORDER BY Month DESC, EmployeeName;
`;

  const { recordset } = await req.query(query);
  return recordset;
}



/**
 * Time Duration Report (parameterized by region, partition, startDate)
 */
export async function timeDurationReport(region, { partition = 'Default', startDate }) {
  // const pool = await getPool(region);
  // const req  = pool.request();

    const pool = await getPool(region);
 const req = pool.request();
 // increase timeout for this request (ms) ‚Äî set to 5 minutes
  req.timeout = 300000;


  // bind inputs
  const fullPartition = `${region.toUpperCase()}.${partition}`;
  req.input('partition', sql.NVarChar, fullPartition);
  req.input('startDate', sql.Date, startDate);

  const query = `

SELECT 
    t1.[ObjectName1],
    t1.[ObjectName2],
    t1.[PartitionName2],
    CASE
        WHEN t2.[Int1] = 0 THEN t2.[Text12]
        ELSE CAST(t2.[Int1] AS NVARCHAR)
    END AS EmployeeID,
    t3.[Name] AS PersonnelType,
    t2.text5,
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    DATEADD(HOUR, -2, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) AS AdjustedMessageTime
INTO 
    #CombinedEmployeeData
FROM 
    [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] AS t1
INNER JOIN 
    [ACVSCore].[Access].[Personnel] AS t2
    ON t1.ObjectIdentity1 = t2.GUID
INNER JOIN 
    [ACVSCore].[Access].[PersonnelType] AS t3
    ON t2.[PersonnelTypeId] = t3.[ObjectID];

-- Step 2: Daily duration per employee
WITH DailyDurations AS (
    SELECT 
        [ObjectName1],
        PersonnelType,
        EmployeeID,
        [PartitionName2],
        text5,
        CONVERT(DATE, AdjustedMessageTime) AS ShiftedDate,
        DATEPART(WEEK, AdjustedMessageTime) AS WeekNumber,
        DATEPART(YEAR, AdjustedMessageTime) AS YearNumber,
        MIN(LocaleMessageTime) AS FirstSwipeTime,
        MAX(LocaleMessageTime) AS LastSwipeTime,
        DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) AS DurationMinutes,
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) / 60 AS NVARCHAR), 2)
        + ':' +
        RIGHT('00' + CAST(DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) % 60 AS NVARCHAR), 2) AS DurationHHMM,
        CASE 
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 5 THEN '<5mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 10 THEN '<10mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 20 THEN '<20mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 30 THEN '<30mins'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 60 THEN '<1hr'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 120 THEN 'Less than <2hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 180 THEN 'Less than <3hrs'
            WHEN DATEDIFF(MINUTE, MIN(LocaleMessageTime), MAX(LocaleMessageTime)) < 240 THEN 'Less than <4hrs'
            ELSE '4+ hrs'
        END AS TimeDiffCategory
    FROM 
        #CombinedEmployeeData



  WHERE CONVERT(DATE, AdjustedMessageTime) >= @startDate

   AND [PartitionName2] = 'APAC.Default'
        AND PersonnelType IN ('Employee', 'Terminated Personnel')
    GROUP BY 
        [ObjectName1], EmployeeID, PersonnelType, text5, [PartitionName2],
        CONVERT(DATE, AdjustedMessageTime),
        DATEPART(WEEK, AdjustedMessageTime),
        DATEPART(YEAR, AdjustedMessageTime)
),

-- Step 3: Weekly summary
WeeklySummary AS (
    SELECT 
        EmployeeID,
        [ObjectName1],
        PersonnelType,
        text5,
        [PartitionName2],
        YearNumber,
        WeekNumber,
        COUNT(DISTINCT ShiftedDate) AS DaysPresentInWeek,
        SUM(CASE WHEN DurationMinutes < 240 THEN 1 ELSE 0 END) AS ViolationDaysInWeek
    FROM 
        DailyDurations
    GROUP BY 
        EmployeeID, [ObjectName1], PersonnelType, text5, [PartitionName2], YearNumber, WeekNumber
)

-- Step 4: Final output with daily duration, category, and defaulter flag
SELECT 
    dd.EmployeeID,
    dd.ObjectName1,
    dd.PersonnelType,
    dd.text5,
    dd.PartitionName2,
    dd.YearNumber,
    dd.WeekNumber,
    dd.ShiftedDate,
    dd.FirstSwipeTime,
    dd.LastSwipeTime,
    dd.DurationHHMM,
    dd.TimeDiffCategory,
    ws.DaysPresentInWeek,
    ws.ViolationDaysInWeek,
    (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) AS CleanDaysInWeek,
    CASE
        WHEN (ws.DaysPresentInWeek - ws.ViolationDaysInWeek) < 3 THEN 'Yes'
        ELSE 'No'
    END AS Defaulter
FROM 
    DailyDurations dd
JOIN 
    WeeklySummary ws
    ON dd.EmployeeID = ws.EmployeeID
    AND dd.WeekNumber = ws.WeekNumber
    AND dd.YearNumber = ws.YearNumber
ORDER BY 
    dd.YearNumber DESC, dd.WeekNumber DESC, dd.EmployeeID, dd.ShiftedDate;
  `;

  const { recordset } = await req.query(query);
  return recordset;
}


//EUROC 




export async function eurocAdmitRejectionReport(region, { reportDate }) {
  // const pool = await getPool(region);
  // const req  = pool.request();

    const pool = await getPool(region);
  const req = pool.request();
  // increase timeout for this request (ms) ‚Äî set to 5 minutes
  req.timeout = 300000;


  // enforce location LT.Vilnius (as requested)
  req.input('location', sql.NVarChar, 'LT.Vilnius');
  // reportDate should be YYYY-MM-DD or Date ‚Äî bind as sql.Date
  req.input('reportDate', sql.Date, reportDate);

  const query = `
/*
  Approach:
  1) Build CombinedQuery as a CTE and SELECT INTO #Combined (materialize)
  2) Build #Admits (with ROW_NUMBER) and #Rejections from #Combined
  3) Return three resultsets: admits (rn=1), rejections (all), summary (counts)
*/

WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
     t1.ObjectName1,
     t1.PartitionName2       AS location,
     t5_card.CardNumber,
     t5_admit.value          AS AdmitCode,
     t5_dir.value            AS Direction,
     t1.ObjectName2          AS Door,
     t5_rej.value            AS Rejection_Type,
     CASE WHEN t3.Name IN ('Contractor','Terminated Contractor')
          THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
     END                       AS EmployeeID,
     t3.Name                  AS PersonnelType,
     t1.MessageType,
     t1.XmlGUID
  FROM ACVSUJournalLog AS t1
  LEFT JOIN ACVSCore.Access.Personnel     AS t2 ON t1.ObjectIdentity1 = t2.GUID
  LEFT JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeId   = t3.ObjectID
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID AND t5_admit.Name = 'AdmitCode'
  LEFT JOIN ACVSUJournalLogxmlShred       AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID AND t5_dir.Value IN ('InDirection','OutDirection')
  LEFT JOIN ACVSUJournalLogxml             AS t_xml ON t1.XmlGUID = t_xml.GUID
  LEFT JOIN (
    SELECT GUID, [value]
    FROM ACVSUJournalLogxmlShred
    WHERE [Name] IN ('Card','CHUID')
  ) AS SCard ON t1.XmlGUID = SCard.GUID
  OUTER APPLY (
    SELECT COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
      SCard.[value]
    ) AS CardNumber
  ) AS t5_card
  LEFT JOIN ACVSUJournalLogxmlShred AS t5_rej
    ON t1.XmlGUID = t5_rej.GUID AND t5_rej.Name = 'RejectCode'
  WHERE
    t1.MessageType IN ('CardAdmitted' , 'CardRejected')
    AND t1.PartitionName2 = @location
    AND CONVERT(date, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC)) = @reportDate
)

-- materialize CombinedQuery into a temp table
SELECT
  LocaleMessageTime,
  CONVERT(date, LocaleMessageTime) AS DateOnly,
  CONVERT(time(0), LocaleMessageTime) AS Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  MessageType
INTO #Combined
FROM CombinedQuery;

-- create admits with row number (first admit per employee)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type,
  ROW_NUMBER() OVER (PARTITION BY ISNULL(EmployeeID, CardNumber) ORDER BY LocaleMessageTime ASC) AS rn
INTO #Admits
FROM #Combined
WHERE MessageType = 'CardAdmitted'
  AND PersonnelType IN('Employee', 'Terminated Personnel');

-- create rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
INTO #Rejections
FROM #Combined
WHERE MessageType = 'CardRejected';

-- resultset 1: admits (only rn = 1)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Admits
WHERE rn = 1
ORDER BY LocaleMessageTime ASC;

-- resultset 2: rejections (all)
SELECT
  LocaleMessageTime,
  DateOnly,
  Swipe_Time,
  EmployeeID,
  ObjectName1,
  PersonnelType,
  location,
  CardNumber,
  AdmitCode,
  Direction,
  Door,
  Rejection_Type
FROM #Rejections
ORDER BY LocaleMessageTime ASC;

-- resultset 3: summary counts by Rejection_Type
SELECT
  ISNULL(Rejection_Type, 'Unknown') AS Rejection_Type,
  COUNT(*) AS CountVal
FROM #Rejections
GROUP BY ISNULL(Rejection_Type, 'Unknown')
ORDER BY CountVal DESC;

-- cleanup temp tables (optional ‚Äî they scope to the session and will go away automatically,
-- but good practice to drop)
DROP TABLE IF EXISTS #Admits;
DROP TABLE IF EXISTS #Rejections;
DROP TABLE IF EXISTS #Combined;
`;

  const result = await req.query(query);
  // result.recordsets is an array of resultsets
  const recordsets = result.recordsets || [];
  const admitRows = (recordsets[0] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const rejectRows = (recordsets[1] || []).map(r => ({
    LocaleMessageTime: r.LocaleMessageTime,
    DateOnly: r.DateOnly,
    Swipe_Time: r.Swipe_Time,
    ObjectName1: r.ObjectName1,
    EmployeeID: r.EmployeeID,
    PersonnelType: r.PersonnelType,
    CardNumber: r.CardNumber,
    Rejection_Type: r.Rejection_Type,
    Door: r.Door,
    location: r.location,
    Direction: r.Direction
  }));
  const summaryRows = (recordsets[2] || []).map(r => ({ Rejection_Type: r.Rejection_Type, Count: r.CountVal }));

  return { admit: admitRows, rejection: rejectRows, summary: summaryRows };
}

