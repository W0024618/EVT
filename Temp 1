const generateTimeDurationExcel = async data => {
  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Time Duration');

  hideGridLines(ws);

  const headers = [
    'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
    'Partition', 'Text5', 'Year', 'Week', 'Date',
    'First Swipe', 'Last Swipe', 'Duration', 'Category',
    'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
  ];
  const lastCol = headers.length;

  // Title (merged across all header columns)
  ws.mergeCells(1, 1, 1, lastCol);
  ws.getCell('A1').value =
    `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
  ws.getCell('A1').font = { bold: true, size: 14 };
  ws.getCell('A1').alignment = { horizontal: 'center', vertical: 'middle' };
  ws.getRow(1).height = 22;

  const headerRow = ws.addRow(headers);
  applyHeaderStyles(headerRow);

  ws.columns = [
    { key: 'sr', width: 8 },
    { key: 'name', width: 25 },
    { key: 'id', width: 15 },
    { key: 'ptype', width: 18 },
    { key: 'part', width: 15 },
    { key: 'txt5', width: 20 },
    { key: 'year', width: 8 },
    { key: 'week', width: 6 },
    { key: 'date', width: 12 },
    { key: 'first', width: 16 },
    { key: 'last', width: 16 },
    { key: 'dur', width: 10 },
    { key: 'cat', width: 12 },
    { key: 'dpw', width: 12 },
    { key: 'vdw', width: 14 },
    { key: 'cdw', width: 12 },
    { key: 'def', width: 10 }
  ];

  // Apply HEADER_FILL + thick border to the merged title cells (1..lastCol)
  for (let c = 1; c <= lastCol; c++) {
    const cell = ws.getCell(1, c);
    cell.fill = HEADER_FILL;
    cell.font = { bold: true, size: 14 };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    // initial thick border for title area (outer edges will be enforced later)
    cell.border = THICK_BORDER;
  }

  data.forEach((r, idx) => {
    const first = r.FirstSwipeTime ? new Date(r.FirstSwipeTime) : null;
    const last = r.LastSwipeTime ? new Date(r.LastSwipeTime) : null;
    const date = r.ShiftedDate ? new Date(r.ShiftedDate) : null;
    const row = ws.addRow([
      idx + 1,
      r.ObjectName1,
      r.EmployeeID,
      r.PersonnelType,
      r.PartitionName2,
      r.text5,
      r.YearNumber,
      r.WeekNumber,
      date,
      first,
      last,
      r.DurationHHMM,
      r.TimeDiffCategory,
      r.DaysPresentInWeek,
      r.ViolationDaysInWeek,
      r.CleanDaysInWeek,
      r.Defaulter
    ]);

    if (date) {
      row.getCell(9).numFmt = 'dd-mmm-yy';
      row.getCell(9).alignment = { vertical: 'middle', horizontal: 'center' };
    }
    if (first) {
      row.getCell(10).numFmt = 'h:mm:ss AM/PM';
      row.getCell(10).alignment = { vertical: 'middle', horizontal: 'center' };
    }
    if (last) {
      row.getCell(11).numFmt = 'h:mm:ss AM/PM';
      row.getCell(11).alignment = { vertical: 'middle', horizontal: 'center' };
    }

    // center align all cells in this row
    row.eachCell(c => {
      c.border = THIN_BORDER;
      c.alignment = { vertical: 'middle', horizontal: 'center' };
    });
  });

  // NOTE: autosize removed per request (do NOT call autosizeColumns)

  ws.autoFilter = `A2:${String.fromCharCode(64 + lastCol)}2`; // A2:Q2 etc.

  // Apply thick outside border around the entire used area (include title row)
  const firstRow = 1; // include merged title row
  const lastRow = ws.lastRow ? ws.lastRow.number : headerRow.number;
  const firstCol = 1;

  // Ensure all interior cells have at least thin border / centered alignment (preserve header styling)
  for (let r = firstRow; r <= lastRow; r++) {
    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(r, c);
      if (r !== headerRow.number) {
        cell.border = THIN_BORDER;
      }
      // enforce center alignment for any cell missing alignment
      if (!cell.alignment) cell.alignment = { vertical: 'middle', horizontal: 'center' };
    }
  }

  // Now override outer edges to be thick
  for (let r = firstRow; r <= lastRow; r++) {
    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(r, c);
      const currTop = (cell.border && cell.border.top) ? cell.border.top : { style: 'thin' };
      const currBottom = (cell.border && cell.border.bottom) ? cell.border.bottom : { style: 'thin' };
      const currLeft = (cell.border && cell.border.left) ? cell.border.left : { style: 'thin' };
      const currRight = (cell.border && cell.border.right) ? cell.border.right : { style: 'thin' };

      const border = {
        top: (r === firstRow) ? { style: 'thick' } : currTop,
        bottom: (r === lastRow) ? { style: 'thick' } : currBottom,
        left: (c === firstCol) ? { style: 'thick' } : currLeft,
        right: (c === lastCol) ? { style: 'thick' } : currRight
      };
      cell.border = border;
    }
  }

  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], {
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
  });

  const filename =
    `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;

  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
};

















Now Add same Background colour here also in Top header where we display like 
APAC Time Duration Report - 1st October 2025 to 18th October 2025												

here add background colour all thick outside border 





const generateTimeDurationExcel = async data => {
  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Time Duration');

  hideGridLines(ws);

  // Title (merged)
  ws.mergeCells('A1:M1');
  ws.getCell('A1').value =
    `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
  ws.getCell('A1').font = { bold: true, size: 14 };
  ws.getCell('A1').alignment = { horizontal: 'center', vertical: 'middle' };
  ws.getRow(1).height = 22;

  const headers = [
    'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
    'Partition', 'Text5', 'Year', 'Week', 'Date',
    'First Swipe', 'Last Swipe', 'Duration', 'Category',
    'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
  ];
  const headerRow = ws.addRow(headers);
  applyHeaderStyles(headerRow);

  ws.columns = [
    { key: 'sr', width: 8 },
    { key: 'name', width: 25 },
    { key: 'id', width: 15 },
    { key: 'ptype', width: 18 },
    { key: 'part', width: 15 },
    { key: 'txt5', width: 20 },
    { key: 'year', width: 8 },
    { key: 'week', width: 6 },
    { key: 'date', width: 12 },
    { key: 'first', width: 16 },
    { key: 'last', width: 16 },
    { key: 'dur', width: 10 },
    { key: 'cat', width: 12 },
    { key: 'dpw', width: 12 },
    { key: 'vdw', width: 14 },
    { key: 'cdw', width: 12 },
    { key: 'def', width: 10 }
  ];

  // Apply HEADER_FILL + thick border to the merged title cells (A1..M1)
  // determine last column from headers length
  const titleFirstCol = 1;
  const titleLastCol = headers.length;
  for (let c = titleFirstCol; c <= titleLastCol; c++) {
    const cell = ws.getCell(1, c);
    cell.fill = HEADER_FILL;
    cell.font = { bold: true, size: 14 };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    // give the title cells a thick border initially (outer edges will be reinforced later)
    cell.border = THICK_BORDER;
  }

  data.forEach((r, idx) => {
    const first = r.FirstSwipeTime ? new Date(r.FirstSwipeTime) : null;
    const last = r.LastSwipeTime ? new Date(r.LastSwipeTime) : null;
    const date = r.ShiftedDate ? new Date(r.ShiftedDate) : null;
    const row = ws.addRow([
      idx + 1,
      r.ObjectName1,
      r.EmployeeID,
      r.PersonnelType,
      r.PartitionName2,
      r.text5,
      r.YearNumber,
      r.WeekNumber,
      date,
      first,
      last,
      r.DurationHHMM,
      r.TimeDiffCategory,
      r.DaysPresentInWeek,
      r.ViolationDaysInWeek,
      r.CleanDaysInWeek,
      r.Defaulter
    ]);

    if (date) row.getCell(9).numFmt = 'dd-mmm-yy';
    if (first) row.getCell(10).numFmt = 'h:mm:ss AM/PM';
    if (last) row.getCell(11).numFmt = 'h:mm:ss AM/PM';

    row.eachCell(c => {
      c.border = THIN_BORDER;
      c.alignment = { vertical: 'middle', horizontal: 'left' };
    });
  });

  // NOTE: autosize removed per request (do NOT call autosizeColumns)

  ws.autoFilter = 'A2:Q2';

  // Apply thick outside border around the entire used area (include title row)
  // compute used range
  const firstRow = 1; // include merged title row
  const lastRow = ws.lastRow ? ws.lastRow.number : headerRow.number;
  const firstCol = 1;
  const lastCol = headers.length;

  // Ensure all interior cells have at least thin border / alignment (preserve header styling)
  for (let r = firstRow; r <= lastRow; r++) {
    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(r, c);
      // If header row already styled by applyHeaderStyles, do not overwrite its border here.
      if (r !== headerRow.number) {
        cell.border = THIN_BORDER;
      }
      if (!cell.alignment) cell.alignment = { vertical: 'middle', horizontal: 'left' };
    }
  }

  // Now override outer edges to be thick
  for (let r = firstRow; r <= lastRow; r++) {
    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(r, c);
      // get current inner borders if present, otherwise default to thin
      const currTop = (cell.border && cell.border.top) ? cell.border.top : { style: 'thin' };
      const currBottom = (cell.border && cell.border.bottom) ? cell.border.bottom : { style: 'thin' };
      const currLeft = (cell.border && cell.border.left) ? cell.border.left : { style: 'thin' };
      const currRight = (cell.border && cell.border.right) ? cell.border.right : { style: 'thin' };

      const border = {
        top: (r === firstRow) ? { style: 'thick' } : currTop,
        bottom: (r === lastRow) ? { style: 'thick' } : currBottom,
        left: (c === firstCol) ? { style: 'thick' } : currLeft,
        right: (c === lastCol) ? { style: 'thick' } : currRight
      };
      cell.border = border;
    }
  }

  const buf = await wb.xlsx.writeBuffer();
  const blob = new Blob([buf], {
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
  });

  const filename =
    `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;

  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
};






