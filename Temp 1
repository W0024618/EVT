// src/pages/History.jsx

import React, { useEffect, useState, useMemo } from 'react';
import { useParams } from 'react-router-dom';
import {
  Container, Box, Button, Typography, Table,
  TableHead, TableBody, TableRow, TableCell,
  Paper, TextField
} from '@mui/material';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider, DatePicker } from '@mui/x-date-pickers';
import { format } from 'date-fns';
import { saveAs } from 'file-saver';

import Header from '../components/Header';
import Footer from '../components/Footer';
import LoadingSpinner from '../components/LoadingSpinner';
import { fetchHistory } from '../api/occupancy.service';

// Map partition code → friendly city/country
const partitionToDisplay = {
  'US.CO.OBS': { city: 'Denver', country: 'United States' },
  'US.FL.Miami': { city: 'Miami', country: 'United States' },
  'US.NYC': { city: 'New York', country: 'United States' },
  'USA/Canada Default': { city: 'Austin TX', country: 'United States' }
};

// LogicalLocation ↔ city (human readable)
const logicalToCity = {
  'Denver-HQ': 'Denver',
  'Austin Texas': 'Austin TX',
  'Miami': 'Miami',
  'New York': 'New York'
};

// LogicalLocation -> canonical partition mapping (used for robust filtering)
const logicalToPartition = {
  'Denver-HQ': 'US.CO.OBS',
  'Austin Texas': 'USA/Canada Default',
  'Miami': 'US.FL.Miami',
  'New York': 'US.NYC'
};

// NOTE: we do NOT import exceljs at top-level (avoid top-level await issues).
// Will lazy-import inside handleExport.

export default function History() {
  const { partition: partitionParam } = useParams();
  const decodedKey = partitionParam ? decodeURIComponent(partitionParam) : null;

  // stable list of partitions to show (either selected partition or all)
  const filteredPartitionKeys = useMemo(
    () => decodedKey ? [decodedKey] : Object.keys(partitionToDisplay),
    [decodedKey]
  );

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [pickedDate, setPickedDate] = useState(null);
  const [showDetails, setShowDetails] = useState(false);

  const getIsoDate = (r) =>
    (r?.SwipeDate && typeof r.SwipeDate === 'string' && r.SwipeDate.slice(0, 10)) ||
    (r?.LocaleMessageTime && typeof r.LocaleMessageTime === 'string' && r.LocaleMessageTime.slice(0, 10)) ||
    '';

  // 12-hour time formatter for API ISO timestamps
  const formatApiTime12 = (isoOrTime) => {
    if (!isoOrTime || typeof isoOrTime !== 'string') return '';
    const m = isoOrTime.match(/T?(\d{2}):(\d{2}):(\d{2})/);
    if (!m) return '';
    let hh = parseInt(m[1], 10);
    const mm = m[2];
    const ss = m[3];
    if (Number.isNaN(hh)) return `${m[1]}:${mm}:${ss}`;
    const ampm = hh >= 12 ? 'PM' : 'AM';
    let h12 = hh % 12;
    if (h12 === 0) h12 = 12;
    return `${String(h12).padStart(2, '0')}:${mm}:${ss} ${ampm}`;
  };

  // helper: does this row belong to partition pk?
  const rowBelongsToPartition = (r, pk) => {
    if (!r) return false;
    const mapped = (r.MappedPartition || '').toString();
    const partitionName = r.PartitionName2 || '';
    if (mapped === pk) return true;
    if (partitionName === pk) return true;

    // check logical location mapping
    const logical = r.LogicalLocation || '';
    const logicalMappedPartition = logicalToPartition[logical];
    if (logicalMappedPartition === pk) return true;

    return false;
  };

  // Build partitionRows from details (prefer MappedPartition -> PartitionName2 -> LogicalLocation)
  const partitionRows = useMemo(() => {
    if (!data || !pickedDate) return [];
    const ds = format(pickedDate, 'yyyy-MM-dd');
    const result = [];

    filteredPartitionKeys.forEach(pk => {
      // Filter details for date and partition using robust criteria
      const rowsForPartition = (data.details || []).filter(r => {
        const dateMatch = getIsoDate(r) === ds;
        if (!dateMatch) return false;
        return rowBelongsToPartition(r, pk);
      });

      if (rowsForPartition.length === 0) {
        const disp = partitionToDisplay[pk];
        result.push({
          country: disp?.country || '',
          city: disp?.city || pk,
          employee: 0,
          contractor: 0,
          total: 0
        });
        return;
      }

      // Sort by time, keep last per person
      rowsForPartition.sort((a, b) => (a.LocaleMessageTime || '').localeCompare(b.LocaleMessageTime || ''));
      const lastByPerson = {};
      rowsForPartition.forEach(r => { lastByPerson[r.PersonGUID] = r; });

      const counts = { Employee: 0, Contractor: 0, Other: 0 };
      Object.values(lastByPerson).forEach(r => {
        if (r.Direction !== 'InDirection') return; // only count people currently inside
        const ptype = (r.PersonnelType || '').toLowerCase();
        if (ptype.includes('contractor')) counts.Contractor += 1;
        else if (ptype.includes('employee')) counts.Employee += 1;
        else counts.Other += 1;
      });

      const disp = partitionToDisplay[pk];
      result.push({
        country: disp?.country || '',
        city: disp?.city || pk,
        employee: counts.Employee,
        contractor: counts.Contractor,
        total: counts.Employee + counts.Contractor + counts.Other
      });
    });

    return result;
  }, [data, pickedDate, filteredPartitionKeys]);

  // detailRows for the details table: include rows where PartitionName2 OR MappedPartition OR LogicalLocation maps to selected keys
  const detailRows = useMemo(() => {
    if (!data || !pickedDate) return [];
    const ds = format(pickedDate, 'yyyy-MM-dd');

    const all = (data.details || []).filter(r => {
      const dateMatch = getIsoDate(r) === ds;
      if (!dateMatch) return false;

      // if any selected pk matches by any mapping, include the row
      return filteredPartitionKeys.some(pk => rowBelongsToPartition(r, pk));
    });

    all.sort((a, b) => ((a.LocaleMessageTime || '')).localeCompare((b.LocaleMessageTime || '')));

    const lastByPerson = {};
    all.forEach(r => { lastByPerson[r.PersonGUID] = r; });

    return Object.values(lastByPerson).filter(r => r.Direction === 'InDirection');
  }, [data, pickedDate, filteredPartitionKeys]);

  // Fetch history once on mount
  useEffect(() => {
    setLoading(true);
    fetchHistory()
      .then(json => setData(json))
      .finally(() => setLoading(false));
  }, []);

  if (loading) return <LoadingSpinner />;
  if (!data) return null;

  // Excel export (lazy import exceljs)
  const handleExport = async () => {
    if (!pickedDate) return;

    try {
      const excelModule = await import('exceljs');
      const Excel = excelModule.default || excelModule;
      let wb;

      if (Excel && Excel.Workbook) wb = new Excel.Workbook();
      else if (typeof Excel === 'function') wb = new Excel();
      else throw new Error('ExcelJS Workbook constructor not found');

      // ---------- SHEET 1: WU Employee ----------
      const wsDetails = wb.addWorksheet('WU Employee');

      const detailsHeaders = [
        'Sr.No', 'Date', 'Time',
        'Employee Name', 'Employee ID', 'Personal Type',
        'Door Name', 'Location'
      ];

      wsDetails.mergeCells(`A1:${String.fromCharCode(64 + detailsHeaders.length)}1`);
      const detailsTitle = wsDetails.getCell('A1');
      detailsTitle.value = `${format(pickedDate, 'EEEE, d MMMM, yyyy')}`;
      detailsTitle.alignment = { horizontal: 'center', vertical: 'middle' };
      detailsTitle.font = { name: 'Calibri', size: 12, bold: true };

      const hdrRow = wsDetails.addRow(detailsHeaders);
      hdrRow.eachCell(cell => {
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFC107' } };
        cell.font = { bold: true, color: { argb: 'FF000000' } };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
      });

      (detailRows || []).forEach((r, i) => {
        const dateVal = (r.LocaleMessageTime?.slice(0, 10)) || (r.SwipeDate?.slice(0, 10)) || '';
        const timeVal = formatApiTime12(r.LocaleMessageTime) || '';
        const name = r.ObjectName1 || '';
        const empId = r.EmployeeID || '';
        const ptype = r.PersonnelType || '';
        const door = r.Door || r.ObjectName2 || '';

        const location = (r.LogicalLocation && logicalToCity[r.LogicalLocation])
          || (r.MappedPartition && partitionToDisplay[r.MappedPartition]?.city)
          || (r.PartitionName2 && partitionToDisplay[r.PartitionName2]?.city)
          || r.PrimaryLocation
          || r.PartitionName2
          || '';

        const row = wsDetails.addRow([i + 1, dateVal, timeVal, name, empId, ptype, door, location]);

        row.eachCell((cell, colNumber) => {
          cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
          cell.font = { name: 'Calibri', size: 11 };
          cell.alignment = colNumber === 1 ? { horizontal: 'center', vertical: 'middle' } : { horizontal: 'left', vertical: 'middle' };
        });

        if (i % 2 === 1) {
          row.eachCell(cell => {
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF7F7F7' } };
          });
        }
      });

      // Auto-fit columns
      wsDetails.columns.forEach((col, idx) => {
        let maxLen = 0;
        col.eachCell({ includeEmpty: true }, c => {
          const v = c.value === null || c.value === undefined ? '' : String(c.value).trim();
          if (v.length > maxLen) maxLen = v.length;
        });
        let width = maxLen + 2;
        if (idx === 0) width = Math.min(Math.max(width, 6), 10);
        else if (idx === 1) width = Math.min(Math.max(width, 10), 15);
        else if (idx === 2) width = Math.min(Math.max(width, 8), 12);
        else if (idx === 3) width = Math.min(Math.max(width, 15), 30);
        else if (idx === 4) width = Math.min(Math.max(width, 10), 18);
        else if (idx === 5) width = Math.min(Math.max(width, 12), 20);
        else if (idx === 6) width = Math.min(Math.max(width, 18), 40);
        else if (idx === 7) width = Math.min(Math.max(width, 18), 40);
        col.width = width;
      });

      wsDetails.views = [{ state: 'frozen', ySplit: 2 }];

      // ---------- SHEET 2: WU Summary ----------
      const ws = wb.addWorksheet('WU Summary');
      const r1 = ws.addRow(['Country', 'City', format(pickedDate, 'EEEE, d MMMM, yyyy'), null, null]);
      ws.mergeCells('C1:E1');
      const dateCell = ws.getCell('C1');
      dateCell.alignment = { horizontal: 'center', vertical: 'middle' };
      dateCell.font = { bold: true, size: 12 };
      dateCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };

      r1.eachCell((cell, colNumber) => {
        if (colNumber <= 2) {
          cell.font = { bold: true, size: 12 };
          cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };
        } else if (colNumber === 3) {
          cell.font = { bold: true, size: 12 };
          cell.alignment = { horizontal: 'center', vertical: 'middle' };
          cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };
        }
        cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
      });

      const r2 = ws.addRow(['', '', 'Employee', 'Contractors', 'Total']);
      r2.eachCell(cell => {
        cell.font = { bold: true, size: 12 };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };
        cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
      });

      (partitionRows || []).forEach(r => {
        const row = ws.addRow([r.country || '', r.city || '', r.employee || 0, r.contractor || 0, r.total || 0]);
        row.eachCell((cell, colNumber) => {
          cell.alignment = { vertical: 'middle', horizontal: colNumber >= 3 ? 'center' : 'left' };
          cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
        });
      });

      const totalEmployees = (partitionRows || []).reduce((s, r) => s + (r.employee || 0), 0);
      const totalContractors = (partitionRows || []).reduce((s, r) => s + (r.contractor || 0), 0);
      const totalTotals = (partitionRows || []).reduce((s, r) => s + (r.total || 0), 0);

      const totalsRow = ws.addRow(['Total', '', totalEmployees, totalContractors, totalTotals]);
      totalsRow.eachCell((cell) => {
        cell.font = { bold: true, size: 12, color: { argb: 'FFFFFFFF' } };
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF808080' } };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
      });

      ws.columns.forEach((col, idx) => {
        let maxLen = 0;
        col.eachCell({ includeEmpty: true }, c => {
          const v = c.value === null || c.value === undefined ? '' : String(c.value).trim();
          if (v.length > maxLen) maxLen = v.length;
        });
        let width = maxLen + 2;
        if (idx === 0) width = Math.min(Math.max(width, 10), 20);
        else if (idx === 1) width = Math.min(Math.max(width, 10), 25);
        else if (idx === 2) width = Math.min(Math.max(width, 12), 20);
        else if (idx === 3) width = Math.min(Math.max(width, 12), 20);
        else if (idx === 4) width = Math.min(Math.max(width, 12), 20);
        col.width = width;
      });
      ws.views = [{ state: 'frozen', ySplit: 2 }];

      let cityName = '';
      if (filteredPartitionKeys.length === 1) {
        const selectedKey = filteredPartitionKeys[0];
        cityName = partitionToDisplay[selectedKey]?.city || '';
      }
      const filename = cityName
        ? `Western Union NAMER (${cityName}) Headcount Report - ${format(pickedDate, 'd MMMM yyyy')}.xlsx`
        : `Western Union NAMER Headcount Report - ${format(pickedDate, 'd MMMM yyyy')}.xlsx`;

      const buf = await wb.xlsx.writeBuffer();
      saveAs(new Blob([buf]), filename);

    } catch (err) {
      console.error('handleExport error:', err);
    }
  };

  return (
    <>
      <Header />
      <Container maxWidth={false} disableGutters sx={{ pt: 2, pb: 4 }}>
        {/* Top: always show DatePicker so user can pick a date */}
        <Box sx={{ px: 2, mb: 2 }}>
          <LocalizationProvider dateAdapter={AdapterDateFns}>
            <DatePicker
              label="Select date"
              value={pickedDate}
              onChange={d => { setPickedDate(d); setShowDetails(false); }}
              renderInput={params => <TextField fullWidth {...params} />}
            />
          </LocalizationProvider>
          {!pickedDate && (
            <Typography variant="body1" color="textSecondary" sx={{ mt: 2 }}>
              Please pick a date to view region summary.
            </Typography>
          )}
        </Box>

        {/* Summary block: only render once a date is picked */}
        {pickedDate && (
          <Box display="flex" alignItems="flex-start" sx={{ px: 2, mb: 2, gap: 1 }}>
            <Box sx={{ flex: 1, maxWidth: 900, display: 'flex', flexDirection: 'column', gap: 2 }}>
              <Paper elevation={3} sx={{ px: 4, py: 3, border: '3px solid #000', borderRadius: 2 }}>
                <Table sx={{ border: '2px solid #000' }}>
                  <TableHead>
                    <TableRow>
                      <TableCell colSpan={5} align="center"
                        sx={{ fontWeight: 'bold', fontSize: 16, bgcolor: '#000', color: '#FFC107', border: '2px solid #000' }}
                      >
                        {format(pickedDate, 'EEEE, d MMMM, yyyy')}
                      </TableCell>
                    </TableRow>
                    <TableRow sx={{ bgcolor: '#FFC107' }}>
                      {['Country', 'City', 'Employees', 'Contractors', 'Total'].map(h => (
                        <TableCell key={h}
                          align={['Country', 'City'].includes(h) ? 'left' : 'right'}
                          sx={{ color: '#000', fontWeight: 'bold', fontSize: 14, border: '2px solid #000' }}
                        >
                          {h}
                        </TableCell>
                      ))}
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {partitionRows.map((r, i) => (
                      <TableRow key={i}>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.country}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.city}</TableCell>
                        <TableCell align="right" sx={{ border: '2px solid #000' }}>{r.employee}</TableCell>
                        <TableCell align="right" sx={{ border: '2px solid #000' }}>{r.contractor}</TableCell>
                        <TableCell align="right" sx={{ bgcolor: '#FFC107', fontWeight: 'bold', border: '2px solid #000' }}>
                          {r.total}
                        </TableCell>
                      </TableRow>
                    ))}
                    <TableRow sx={{ bgcolor: '#666' }}>
                      <TableCell colSpan={2} align="right"
                        sx={{ color: '#fff', fontWeight: 'bold', border: '2px solid #000' }}>
                        Total
                      </TableCell>
                      <TableCell align="right"
                        sx={{ color: '#fff', fontWeight: 'bold', border: '2px solid #000' }}>
                        {partitionRows.reduce((s, r) => s + r.employee, 0)}
                      </TableCell>
                      <TableCell align="right"
                        sx={{ color: '#fff', fontWeight: 'bold', border: '2px solid #000' }}>
                        {partitionRows.reduce((s, r) => s + r.contractor, 0)}
                      </TableCell>
                      <TableCell align="right"
                        sx={{ color: '#fff', fontWeight: 'bold', bgcolor: '#333', border: '2px solid #000' }}>
                        {partitionRows.reduce((s, r) => s + r.total, 0)}
                      </TableCell>
                    </TableRow>
                  </TableBody>
                </Table>

                <Box display="flex" justifyContent="center" sx={{ mt: 1 }}>
                  <Button variant="contained" sx={{ bgcolor: '#FFC107', color: '#000' }}
                    onClick={() => setShowDetails(v => !v)}>
                    {showDetails ? 'Hide Details' : 'See Details'}
                  </Button>
                  {showDetails && (
                    <Button variant="outlined" sx={{ ml: 2, borderColor: '#FFC107', color: '#FFC107' }}
                      onClick={handleExport}>
                      Export to Excel
                    </Button>
                  )}
                </Box>
              </Paper>
            </Box>
          </Box>
        )}

        {/* Details table */}
        {showDetails && (
          <Box display="flex" justifyContent="center" mb={2} sx={{ width: '100%' }}>
            <Paper elevation={1} sx={{ px: 4, py: 1, width: '100%', border: '3px solid #000', borderRadius: 2 }}>
              {detailRows.length > 0 ? (
                <Table sx={{ border: '2px solid #000', borderCollapse: 'collapse' }}>
                  <TableHead>
                    <TableRow sx={{ bgcolor: '#000' }}>
                      {['Sr', 'Date', 'Time', 'Emp ID', 'Name', 'Type', 'Card', 'Door', 'Partition']
                        .map(h => (
                          <TableCell key={h} align="center"
                            sx={{ color: '#FFC107', fontWeight: 'bold', fontSize: 14, border: '2px solid #000' }}>
                            {h}
                          </TableCell>
                        ))}
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {detailRows.map((r, i) => (
                      <TableRow key={r.PersonGUID}>
                        <TableCell sx={{ border: '2px solid #000' }}>{i + 1}</TableCell>

                        <TableCell sx={{ border: '2px solid #000' }}>
                          {getIsoDate(r)}
                        </TableCell>

                        <TableCell sx={{ border: '2px solid #000' }}>
                          {formatApiTime12(r.LocaleMessageTime || r.Swipe_Time || '')}
                        </TableCell>

                        <TableCell sx={{ border: '2px solid #000' }}>{r.EmployeeID}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.ObjectName1}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.PersonnelType}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.CardNumber}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.Door}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>
                          {(r.LogicalLocation && logicalToCity[r.LogicalLocation])
                            || (r.MappedPartition && partitionToDisplay[r.MappedPartition]?.city)
                            || partitionToDisplay[r.PartitionName2]?.city
                            || r.PartitionName2}
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              ) : (
                <Typography variant="body2" sx={{
                  color: '#666', textAlign: 'center', mt: 2, fontStyle: 'italic'
                }}>
                  No swipe records found for this date.
                </Typography>
              )}
            </Paper>
          </Box>
        )}
      </Container>
      <Footer />
    </>
  );
}























Now Only issue is 
When Export in Excel We got Correct Count ...
alos when i filter Denver from Header we got correct Denver Count ...
But When i filter Austin Texas from Header 

We Got 2 door in Austin texas where partation is Denver ... see below example


24	2025-10-23	08:43:28 AM	321425	Davidson, Jennifer Jaworski	Employee	604171	US.CO.HQ. 15. 15th Floor Executive South Entrance 15.312B	Denver
54	2025-10-23	11:03:53 AM	324994	Whalen, Karen Lorraine	Employee	613885	US.CO.HQ. 15. 15th Floor Executive South Entrance 15.312B	Denver

See this Entryy...





// src/pages/History.jsx

import React, { useEffect, useState, useMemo } from 'react';
import { useParams } from 'react-router-dom';
import {
  Container, Box, Button, Typography, Table,
  TableHead, TableBody, TableRow, TableCell,
  Paper, TextField
} from '@mui/material';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider, DatePicker } from '@mui/x-date-pickers';
import { format } from 'date-fns';
import { saveAs } from 'file-saver';

import Header from '../components/Header';
import Footer from '../components/Footer';
import LoadingSpinner from '../components/LoadingSpinner';
import { fetchHistory } from '../api/occupancy.service';

// Map partition code → friendly city/country
const partitionToDisplay = {
  'US.CO.OBS': { city: 'Denver', country: 'United States' },
  'US.FL.Miami': { city: 'Miami', country: 'United States' },
  'US.NYC': { city: 'New York', country: 'United States' },
  'USA/Canada Default': { city: 'Austin TX', country: 'United States' }
};

// LogicalLocation ↔ city
const logicalToCity = {
  'Denver-HQ': 'Denver',
  'Austin Texas': 'Austin TX',
  'Miami': 'Miami',
  'New York': 'New York'
};

// NOTE: we do NOT import exceljs at top-level (avoid top-level await issues).
// Will lazy-import inside handleExport.

export default function History() {
  const { partition: partitionParam } = useParams();
  const decodedKey = partitionParam ? decodeURIComponent(partitionParam) : null;

  // stable list of partitions to show (either selected partition or all)
  const filteredPartitionKeys = useMemo(
    () => decodedKey ? [decodedKey] : Object.keys(partitionToDisplay),
    [decodedKey]
  );

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [pickedDate, setPickedDate] = useState(null);
  const [showDetails, setShowDetails] = useState(false);

  const getIsoDate = (r) =>
    (r?.SwipeDate && typeof r.SwipeDate === 'string' && r.SwipeDate.slice(0, 10)) ||
    (r?.LocaleMessageTime && typeof r.LocaleMessageTime === 'string' && r.LocaleMessageTime.slice(0, 10)) ||
    '';

  // 12-hour time formatter for API ISO timestamps
  const formatApiTime12 = (isoOrTime) => {
    if (!isoOrTime || typeof isoOrTime !== 'string') return '';
    const m = isoOrTime.match(/T?(\d{2}):(\d{2}):(\d{2})/);
    if (!m) return '';
    let hh = parseInt(m[1], 10);
    const mm = m[2];
    const ss = m[3];
    if (Number.isNaN(hh)) return `${m[1]}:${mm}:${ss}`;
    const ampm = hh >= 12 ? 'PM' : 'AM';
    let h12 = hh % 12;
    if (h12 === 0) h12 = 12;
    return `${String(h12).padStart(2, '0')}:${mm}:${ss} ${ampm}`;
  };

  // Build partitionRows from details (door-first MappedPartition if available)
  const partitionRows = useMemo(() => {
    if (!data || !pickedDate) return [];
    const ds = format(pickedDate, 'yyyy-MM-dd');

    const result = [];

    filteredPartitionKeys.forEach(pk => {
      // Filter details for date and partition (either MappedPartition or original PartitionName2)
      const rowsForPartition = (data.details || []).filter(r => {
        const dateMatch = getIsoDate(r) === ds;
        if (!dateMatch) return false;
        const mapped = (r.MappedPartition || '').toString();
        const partitionName = r.PartitionName2 || '';
        return mapped === pk || partitionName === pk;
      });

      if (rowsForPartition.length === 0) {
        const disp = partitionToDisplay[pk];
        result.push({
          country: disp?.country || '',
          city: disp?.city || pk,
          employee: 0,
          contractor: 0,
          total: 0
        });
        return;
      }

      // Sort by time, keep last per person
      rowsForPartition.sort((a, b) => (a.LocaleMessageTime || '').localeCompare(b.LocaleMessageTime || ''));
      const lastByPerson = {};
      rowsForPartition.forEach(r => { lastByPerson[r.PersonGUID] = r; });

      const counts = { Employee: 0, Contractor: 0, Other: 0 };
      Object.values(lastByPerson).forEach(r => {
        if (r.Direction !== 'InDirection') return; // only count people currently inside
        const ptype = (r.PersonnelType || '').toLowerCase();
        if (ptype.includes('contractor')) counts.Contractor += 1;
        else if (ptype.includes('employee')) counts.Employee += 1;
        else counts.Other += 1;
      });

      const disp = partitionToDisplay[pk];
      result.push({
        country: disp?.country || '',
        city: disp?.city || pk,
        employee: counts.Employee,
        contractor: counts.Contractor,
        total: counts.Employee + counts.Contractor + counts.Other
      });
    });

    return result;
  }, [data, pickedDate, filteredPartitionKeys]);

  // detailRows for the details table: include rows where either PartitionName2 or MappedPartition matches
  const detailRows = useMemo(() => {
    if (!data || !pickedDate) return [];
    const ds = format(pickedDate, 'yyyy-MM-dd');

    const all = (data.details || []).filter(r => {
      const dateMatch = getIsoDate(r) === ds;
      if (!dateMatch) return false;
      const partitionMatch = filteredPartitionKeys.includes(r.PartitionName2);
      const mappedMatch = filteredPartitionKeys.includes(r.MappedPartition);
      return partitionMatch || mappedMatch;
    });

    all.sort((a, b) => ((a.LocaleMessageTime || '')).localeCompare((b.LocaleMessageTime || '')));

    const lastByPerson = {};
    all.forEach(r => { lastByPerson[r.PersonGUID] = r; });

    return Object.values(lastByPerson).filter(r => r.Direction === 'InDirection');
  }, [data, pickedDate, filteredPartitionKeys]);

  // Fetch history once on mount
  useEffect(() => {
    setLoading(true);
    fetchHistory()
      .then(json => setData(json))
      .finally(() => setLoading(false));
  }, []);

  if (loading) return <LoadingSpinner />;
  if (!data) return null;

  // Excel export (lazy import exceljs)
  const handleExport = async () => {
    if (!pickedDate) return;

    try {
      const excelModule = await import('exceljs');
      const Excel = excelModule.default || excelModule;
      let wb;

      if (Excel && Excel.Workbook) wb = new Excel.Workbook();
      else if (typeof Excel === 'function') wb = new Excel();
      else throw new Error('ExcelJS Workbook constructor not found');

      // ---------- SHEET 1: WU Employee ----------
      const wsDetails = wb.addWorksheet('WU Employee');

      const detailsHeaders = [
        'Sr.No', 'Date', 'Time',
        'Employee Name', 'Employee ID', 'Personal Type',
        'Door Name', 'Location'
      ];

      wsDetails.mergeCells(`A1:${String.fromCharCode(64 + detailsHeaders.length)}1`);
      const detailsTitle = wsDetails.getCell('A1');
      detailsTitle.value = `${format(pickedDate, 'EEEE, d MMMM, yyyy')}`;
      detailsTitle.alignment = { horizontal: 'center', vertical: 'middle' };
      detailsTitle.font = { name: 'Calibri', size: 12, bold: true };

      const hdrRow = wsDetails.addRow(detailsHeaders);
      hdrRow.eachCell(cell => {
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFC107' } };
        cell.font = { bold: true, color: { argb: 'FF000000' } };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
      });

      (detailRows || []).forEach((r, i) => {
        const dateVal = (r.LocaleMessageTime?.slice(0, 10)) || (r.SwipeDate?.slice(0, 10)) || '';
        const timeVal = formatApiTime12(r.LocaleMessageTime) || '';
        const name = r.ObjectName1 || '';
        const empId = r.EmployeeID || '';
        const ptype = r.PersonnelType || '';
        const door = r.Door || r.ObjectName2 || '';

        const location = (r.LogicalLocation && logicalToCity[r.LogicalLocation])
          || (r.MappedPartition && partitionToDisplay[r.MappedPartition]?.city)
          || (r.PartitionName2 && partitionToDisplay[r.PartitionName2]?.city)
          || r.PrimaryLocation
          || r.PartitionName2
          || '';

        const row = wsDetails.addRow([i + 1, dateVal, timeVal, name, empId, ptype, door, location]);

        row.eachCell((cell, colNumber) => {
          cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
          cell.font = { name: 'Calibri', size: 11 };
          cell.alignment = colNumber === 1 ? { horizontal: 'center', vertical: 'middle' } : { horizontal: 'left', vertical: 'middle' };
        });

        if (i % 2 === 1) {
          row.eachCell(cell => {
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF7F7F7' } };
          });
        }
      });

      // Auto-fit columns
      wsDetails.columns.forEach((col, idx) => {
        let maxLen = 0;
        col.eachCell({ includeEmpty: true }, c => {
          const v = c.value === null || c.value === undefined ? '' : String(c.value).trim();
          if (v.length > maxLen) maxLen = v.length;
        });
        let width = maxLen + 2;
        if (idx === 0) width = Math.min(Math.max(width, 6), 10);
        else if (idx === 1) width = Math.min(Math.max(width, 10), 15);
        else if (idx === 2) width = Math.min(Math.max(width, 8), 12);
        else if (idx === 3) width = Math.min(Math.max(width, 15), 30);
        else if (idx === 4) width = Math.min(Math.max(width, 10), 18);
        else if (idx === 5) width = Math.min(Math.max(width, 12), 20);
        else if (idx === 6) width = Math.min(Math.max(width, 18), 40);
        else if (idx === 7) width = Math.min(Math.max(width, 18), 40);
        col.width = width;
      });

      wsDetails.views = [{ state: 'frozen', ySplit: 2 }];

      // ---------- SHEET 2: WU Summary ----------
      const ws = wb.addWorksheet('WU Summary');
      const r1 = ws.addRow(['Country', 'City', format(pickedDate, 'EEEE, d MMMM, yyyy'), null, null]);
      ws.mergeCells('C1:E1');
      const dateCell = ws.getCell('C1');
      dateCell.alignment = { horizontal: 'center', vertical: 'middle' };
      dateCell.font = { bold: true, size: 12 };
      dateCell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };

      r1.eachCell((cell, colNumber) => {
        if (colNumber <= 2) {
          cell.font = { bold: true, size: 12 };
          cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };
        } else if (colNumber === 3) {
          cell.font = { bold: true, size: 12 };
          cell.alignment = { horizontal: 'center', vertical: 'middle' };
          cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };
        }
        cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
      });

      const r2 = ws.addRow(['', '', 'Employee', 'Contractors', 'Total']);
      r2.eachCell(cell => {
        cell.font = { bold: true, size: 12 };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };
        cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
      });

      (partitionRows || []).forEach(r => {
        const row = ws.addRow([r.country || '', r.city || '', r.employee || 0, r.contractor || 0, r.total || 0]);
        row.eachCell((cell, colNumber) => {
          cell.alignment = { vertical: 'middle', horizontal: colNumber >= 3 ? 'center' : 'left' };
          cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
        });
      });

      const totalEmployees = (partitionRows || []).reduce((s, r) => s + (r.employee || 0), 0);
      const totalContractors = (partitionRows || []).reduce((s, r) => s + (r.contractor || 0), 0);
      const totalTotals = (partitionRows || []).reduce((s, r) => s + (r.total || 0), 0);

      const totalsRow = ws.addRow(['Total', '', totalEmployees, totalContractors, totalTotals]);
      totalsRow.eachCell((cell) => {
        cell.font = { bold: true, size: 12, color: { argb: 'FFFFFFFF' } };
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF808080' } };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
      });

      ws.columns.forEach((col, idx) => {
        let maxLen = 0;
        col.eachCell({ includeEmpty: true }, c => {
          const v = c.value === null || c.value === undefined ? '' : String(c.value).trim();
          if (v.length > maxLen) maxLen = v.length;
        });
        let width = maxLen + 2;
        if (idx === 0) width = Math.min(Math.max(width, 10), 20);
        else if (idx === 1) width = Math.min(Math.max(width, 10), 25);
        else if (idx === 2) width = Math.min(Math.max(width, 12), 20);
        else if (idx === 3) width = Math.min(Math.max(width, 12), 20);
        else if (idx === 4) width = Math.min(Math.max(width, 12), 20);
        col.width = width;
      });
      ws.views = [{ state: 'frozen', ySplit: 2 }];

      let cityName = '';
      if (filteredPartitionKeys.length === 1) {
        const selectedKey = filteredPartitionKeys[0];
        cityName = partitionToDisplay[selectedKey]?.city || '';
      }
      const filename = cityName
        ? `Western Union NAMER (${cityName}) Headcount Report - ${format(pickedDate, 'd MMMM yyyy')}.xlsx`
        : `Western Union NAMER Headcount Report - ${format(pickedDate, 'd MMMM yyyy')}.xlsx`;

      const buf = await wb.xlsx.writeBuffer();
      saveAs(new Blob([buf]), filename);

    } catch (err) {
      console.error('handleExport error:', err);
    }
  };

  return (
    <>
      <Header />
      <Container maxWidth={false} disableGutters sx={{ pt: 2, pb: 4 }}>
        {/* Top: always show DatePicker so user can pick a date */}
        <Box sx={{ px: 2, mb: 2 }}>
          <LocalizationProvider dateAdapter={AdapterDateFns}>
            <DatePicker
              label="Select date"
              value={pickedDate}
              onChange={d => { setPickedDate(d); setShowDetails(false); }}
              renderInput={params => <TextField fullWidth {...params} />}
            />
          </LocalizationProvider>
          {!pickedDate && (
            <Typography variant="body1" color="textSecondary" sx={{ mt: 2 }}>
              Please pick a date to view region summary.
            </Typography>
          )}
        </Box>

        {/* Summary block: only render once a date is picked */}
        {pickedDate && (
          <Box display="flex" alignItems="flex-start" sx={{ px: 2, mb: 2, gap: 1 }}>
            <Box sx={{ flex: 1, maxWidth: 900, display: 'flex', flexDirection: 'column', gap: 2 }}>
              <Paper elevation={3} sx={{ px: 4, py: 3, border: '3px solid #000', borderRadius: 2 }}>
                <Table sx={{ border: '2px solid #000' }}>
                  <TableHead>
                    <TableRow>
                      <TableCell colSpan={5} align="center"
                        sx={{ fontWeight: 'bold', fontSize: 16, bgcolor: '#000', color: '#FFC107', border: '2px solid #000' }}
                      >
                        {format(pickedDate, 'EEEE, d MMMM, yyyy')}
                      </TableCell>
                    </TableRow>
                    <TableRow sx={{ bgcolor: '#FFC107' }}>
                      {['Country', 'City', 'Employees', 'Contractors', 'Total'].map(h => (
                        <TableCell key={h}
                          align={['Country', 'City'].includes(h) ? 'left' : 'right'}
                          sx={{ color: '#000', fontWeight: 'bold', fontSize: 14, border: '2px solid #000' }}
                        >
                          {h}
                        </TableCell>
                      ))}
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {partitionRows.map((r, i) => (
                      <TableRow key={i}>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.country}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.city}</TableCell>
                        <TableCell align="right" sx={{ border: '2px solid #000' }}>{r.employee}</TableCell>
                        <TableCell align="right" sx={{ border: '2px solid #000' }}>{r.contractor}</TableCell>
                        <TableCell align="right" sx={{ bgcolor: '#FFC107', fontWeight: 'bold', border: '2px solid #000' }}>
                          {r.total}
                        </TableCell>
                      </TableRow>
                    ))}
                    <TableRow sx={{ bgcolor: '#666' }}>
                      <TableCell colSpan={2} align="right"
                        sx={{ color: '#fff', fontWeight: 'bold', border: '2px solid #000' }}>
                        Total
                      </TableCell>
                      <TableCell align="right"
                        sx={{ color: '#fff', fontWeight: 'bold', border: '2px solid #000' }}>
                        {partitionRows.reduce((s, r) => s + r.employee, 0)}
                      </TableCell>
                      <TableCell align="right"
                        sx={{ color: '#fff', fontWeight: 'bold', border: '2px solid #000' }}>
                        {partitionRows.reduce((s, r) => s + r.contractor, 0)}
                      </TableCell>
                      <TableCell align="right"
                        sx={{ color: '#fff', fontWeight: 'bold', bgcolor: '#333', border: '2px solid #000' }}>
                        {partitionRows.reduce((s, r) => s + r.total, 0)}
                      </TableCell>
                    </TableRow>
                  </TableBody>
                </Table>

                <Box display="flex" justifyContent="center" sx={{ mt: 1 }}>
                  <Button variant="contained" sx={{ bgcolor: '#FFC107', color: '#000' }}
                    onClick={() => setShowDetails(v => !v)}>
                    {showDetails ? 'Hide Details' : 'See Details'}
                  </Button>
                  {showDetails && (
                    <Button variant="outlined" sx={{ ml: 2, borderColor: '#FFC107', color: '#FFC107' }}
                      onClick={handleExport}>
                      Export to Excel
                    </Button>
                  )}
                </Box>
              </Paper>
            </Box>
          </Box>
        )}

        {/* Details table */}
        {showDetails && (
          <Box display="flex" justifyContent="center" mb={2} sx={{ width: '100%' }}>
            <Paper elevation={1} sx={{ px: 4, py: 1, width: '100%', border: '3px solid #000', borderRadius: 2 }}>
              {detailRows.length > 0 ? (
                <Table sx={{ border: '2px solid #000', borderCollapse: 'collapse' }}>
                  <TableHead>
                    <TableRow sx={{ bgcolor: '#000' }}>
                      {['Sr', 'Date', 'Time', 'Emp ID', 'Name', 'Type', 'Card', 'Door', 'Partition']
                        .map(h => (
                          <TableCell key={h} align="center"
                            sx={{ color: '#FFC107', fontWeight: 'bold', fontSize: 14, border: '2px solid #000' }}>
                            {h}
                          </TableCell>
                        ))}
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {detailRows.map((r, i) => (
                      <TableRow key={r.PersonGUID}>
                        <TableCell sx={{ border: '2px solid #000' }}>{i + 1}</TableCell>

                        <TableCell sx={{ border: '2px solid #000' }}>
                          {getIsoDate(r)}
                        </TableCell>

                        <TableCell sx={{ border: '2px solid #000' }}>
                          {formatApiTime12(r.LocaleMessageTime || r.Swipe_Time || '')}
                        </TableCell>

                        <TableCell sx={{ border: '2px solid #000' }}>{r.EmployeeID}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.ObjectName1}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.PersonnelType}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.CardNumber}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.Door}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>
                          {(r.LogicalLocation && logicalToCity[r.LogicalLocation])
                            || (r.MappedPartition && partitionToDisplay[r.MappedPartition]?.city)
                            || partitionToDisplay[r.PartitionName2]?.city
                            || r.PartitionName2}
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              ) : (
                <Typography variant="body2" sx={{
                  color: '#666', textAlign: 'center', mt: 2, fontStyle: 'italic'
                }}>
                  No swipe records found for this date.
                </Typography>
              )}
            </Paper>
          </Box>
        )}
      </Container>
      <Footer />
    </>
  );
}









// src/components/Header.jsx

// ── ALL IMPORTS AT THE VERY TOP ───────────────────────────────────────────────
import React, { useEffect, useState } from 'react';

// MUI core + pickers
import {
  AppBar,
  Toolbar,
  Box,
  Typography,
  Select,
  MenuItem,
  IconButton,
  Popover,
  TextField,
  Button
} from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import { DatePicker, TimePicker } from '@mui/x-date-pickers';

// Day.js + plugins
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import timezone from 'dayjs/plugin/timezone';

// React Router
import { useNavigate, useLocation, Link } from 'react-router-dom';

// Icons
import HomeIcon from '@mui/icons-material/Home';
import HistoryIcon from '@mui/icons-material/History';
import InfoIcon from '@mui/icons-material/Info';
import AccessTimeIcon from '@mui/icons-material/AccessTime';
import LiveTvIcon from '@mui/icons-material/LiveTv';

// Assets & hooks
import WuLogo from '../assets/wu-logo.png';
import DenverFlag from '../assets/flags/denver.png';
import MiamiFlag from '../assets/flags/miami.png';
import NewYorkFlag from '../assets/flags/new-york.png';
import AustinFlag from '../assets/flags/austin.png';
import DefaultFlag from '../assets/flags/default.png';

import { partitionList } from '../services/occupancy.service';
import { useLiveOccupancy } from '../hooks/useLiveOccupancy';

// ── Initialize Day.js UTC/timezone ────────────────────────────────────────────
dayjs.extend(utc);
dayjs.extend(timezone);
dayjs.tz.setDefault('UTC');

// ── Display name map ─────────────────────────────────────────────────────────
const displayNameMap = {
  'US.CO.OBS': 'Denver',
  'US.FL.Miami': 'Miami',
  'US.NYC': 'New York',
  'USA/Canada Default': 'Austin Texas'
};

// ── Header Component ──────────────────────────────────────────────────────────
export default function Header({
  title,
  mode,
  onTimeSelect,
  onLiveClick
}) {
  const navigate = useNavigate();
  const location = useLocation();
  const { data } = useLiveOccupancy(1000);

  const [lastUpdate, setLastUpdate] = useState('');
  const [anchorEl, setAnchorEl] = useState(null);
  const [draftDate, setDraftDate] = useState(dayjs().utc());

  // Update the “last update” timestamp on each live fetch
  useEffect(() => {
    if (data) setLastUpdate(new Date().toLocaleTimeString());
  }, [data]);

  


  // ── Routing logic ──────────────────────────────────────────────────────────
  // Update the routing logic to properly detect the current view
  const segments = location.pathname.split('/').filter(Boolean);
  const isPartitionPage = segments[0] === 'partition' && Boolean(segments[1]);
  const currentPartition = isPartitionPage ? decodeURIComponent(segments[1]) : '';

  // Detect current view more accurately
  let currentView = null;
  if (isPartitionPage && segments.length > 2) {
    // For partition pages with a view (details/history)
    currentView = segments[2];
  } else if (segments.length === 1 && segments[0] === 'history') {
    // For the standalone history page
    currentView = 'history';
  }


  const flagMap = {
    'US.CO.OBS': DenverFlag,
    'US.FL.Miami': MiamiFlag,
    'US.NYC': NewYorkFlag,
    'USA/Canada Default': AustinFlag
  };
  const selectedFlag = flagMap[currentPartition] || DefaultFlag;






  // Update handlePartitionChange to handle all cases
  const handlePartitionChange = newPartition => {
    if (!newPartition) return navigate('/');

    let path = `/partition/${encodeURIComponent(newPartition)}`;

    // Preserve the current view if it exists
    if (currentView) {
      path += `/${currentView}`;
    } else if (location.pathname === '/history') {
      // Special case: if we're on the standalone history page
      path += '/history';
    }

    navigate(path);
  };



  // Update handleDetailsClick to be consistent
  const handleDetailsClick = () => {
    if (isPartitionPage) {
      navigate(`/partition/${encodeURIComponent(currentPartition)}/details`);
    } else {
      navigate('/partition/US.CO.OBS/details');
    }
  };


  // ── Date/Time popover handlers ─────────────────────────────────────────────
  const openPopover = e => {
    setDraftDate(dayjs().utc());
    setAnchorEl(e.currentTarget);
  };
  const closePopover = () => setAnchorEl(null);
  const handleGo = () => {
    onTimeSelect(draftDate.toISOString());
    closePopover();
  };

  return (
    <>
      <AppBar position="static" color="primary" sx={{ mb: 2 }}>
        <Toolbar sx={{ justifyContent: 'space-between', alignItems: 'center' }}>

          {/* ── Left: logo, title, nav & time/live icons ── */}
          <Box display="flex" alignItems="center" sx={{ flexGrow: 1 }}>
            <Box component="img" src={WuLogo} alt="WU Logo" sx={{ height: 36, mr: 2 }} />

            <Typography variant="h6" sx={{ fontWeight: 600, mr: 3 }}>
              {title}
              {currentPartition ? ` • ${displayNameMap[currentPartition]}` : ''}
            </Typography>

          


            <IconButton
  component={Link}
  to="/"
  color="inherit"
>
  <HomeIcon />
</IconButton>


            <IconButton
              component={Link}
              to={
                currentPartition
                  ? `/partition/${encodeURIComponent(currentPartition)}/history`
                  : '/history'
              }
              color="inherit"
            >
              <HistoryIcon />
            </IconButton>

            <IconButton onClick={handleDetailsClick} color="inherit">
              <InfoIcon />
            </IconButton>

            <IconButton
              color={mode === 'time' ? 'secondary' : 'inherit'}
              onClick={openPopover}
              title="Jump to specific time"
            >
              <AccessTimeIcon />
            </IconButton>

            <IconButton
              color={mode === 'live' ? 'secondary' : 'inherit'}
              onClick={onLiveClick}
              title="Return to live"
            >
              <LiveTvIcon />
            </IconButton>
          </Box>

          {/* ── Right: region selector, flag, last-update/historic label ── */}
          <Box display="flex" alignItems="center" gap={1}>
            <Select
              size="small"
              value={currentPartition}
              displayEmpty
              onChange={e => handlePartitionChange(e.target.value)}
              sx={{ bgcolor: 'background.paper', mr: 1, minWidth: 160 }}
            >
              <MenuItem value="">— Select Region —</MenuItem>
              {partitionList.map(p => (
                <MenuItem key={p} value={p}>
                  {displayNameMap[p] || p}
                </MenuItem>
              ))}
            </Select>

            <Box component="img" src={selectedFlag} alt="Flag" sx={{ height: 32, mr: 2 }} />

            <Typography variant="body2" sx={{ color: '#FFF' }}>
              {mode === 'live'
                ? `Last update: ${lastUpdate}`
                : 'Viewing historic'}
            </Typography>
          </Box>
        </Toolbar>
      </AppBar>

      <Popover
        open={Boolean(anchorEl)}
        anchorEl={anchorEl}
        onClose={closePopover}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Box p={2} display="flex" flexDirection="column" gap={2}>
          <LocalizationProvider dateAdapter={AdapterDayjs}>
            <DatePicker
              label="Select Date (UTC)"
              value={draftDate}
              onChange={newVal => setDraftDate(newVal)}
              renderInput={props => <TextField {...props} />}
            />
            <TimePicker
              label="Select Time (UTC)"
              value={draftDate}
              onChange={newVal => setDraftDate(newVal)}
              renderInput={props => <TextField {...props} />}
            />
          </LocalizationProvider>
          <Box display="flex" justifyContent="flex-end" gap={1}>
            <Button onClick={closePopover}>Cancel</Button>
            <Button variant="contained" onClick={handleGo}>Go</Button>
          </Box>
        </Box>
      </Popover>
    </>
  );
}














