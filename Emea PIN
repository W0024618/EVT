<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>EMEA PIN Dashboard — Live</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- reuse your style -->
  <link rel="stylesheet" href="style.css">
  <style>
    /* small overrides for this page */
    .topbar { margin-bottom: 8px; }
    .small-card { padding: 12px; text-align: center; }
    .top-controls { display:flex; gap:8px; align-items:center; }
    .chart-small { height:220px; }
    .compact-table td { padding:6px; font-size:13px; }
    .muted { color:#9aa4b2; }
    .month-panel { display:flex; gap:12px; margin-top:12px; align-items:center; }
    .month-chart-wrap { height:200px; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
  (function () {
    const { useState, useEffect, useRef } = React;

    // CHANGE THESE as needed:
    const API_BASE = "http://localhost:8003";
    const API_ENDPOINT = API_BASE + "/api/emea_pin_live";

    const EMEA_PARTITIONS = ["LT.Vilnius","IT.Rome","UK.London","IE.DUblin","DU.Abu Dhab","ES.Madrid","AUT.Vienna","MA.Casablanca","RU.Moscow"];
    const MONTH_NAMES = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

    function formatDateShort(d) {
      if (!d) return '-';
      try {
        const dt = new Date(d);
        if (isNaN(dt.getTime())) return String(d).slice(0,19);
        return dt.toLocaleString();
      } catch (e) { return String(d); }
    }

    function downloadCSV(rows, filename = 'export.csv') {
      if (!rows || rows.length === 0) { alert("No data to export"); return; }
      const cols = Object.keys(rows[0]);
      const lines = [];
      lines.push(cols.join(','));
      rows.forEach(r => {
        const line = cols.map(c => {
          const v = r[c] === null || r[c] === undefined ? '' : String(r[c]).replace(/\n/g,' ');
          return JSON.stringify(v);
        }).join(',');
        lines.push(line);
      });
      const blob = new Blob([lines.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = filename; a.click(); URL.revokeObjectURL(url);
    }

    function EmeaPinApp() {
      const [year, setYear] = useState(new Date().getFullYear());
      const [location, setLocation] = useState('All locations');
      const [live, setLive] = useState(true);
      const [loading, setLoading] = useState(false);
      const [lastFetch, setLastFetch] = useState(null);

      const [total, setTotal] = useState(0);
      const [uniqueEmployees, setUniqueEmployees] = useState(0);
      const [repeatersCount, setRepeatersCount] = useState(0);

      // main lists
      const [byLocation, setByLocation] = useState([]);
      const [byEmployee, setByEmployee] = useState([]);
      const [recent, setRecent] = useState([]);

      // month-wise
      const [monthTotals, setMonthTotals] = useState([]); // array length up to 12 -> {Month, MonthName, count}
      const [monthByLocation, setMonthByLocation] = useState([]); // records {Month, MonthName, PartitionName2, count}
      const [monthByEmployee, setMonthByEmployee] = useState([]); // records {Month, MonthName, person_uid, count}

      const [selectedMonth, setSelectedMonth] = useState(new Date().getMonth()+1); // 1..12

      const pollingRef = useRef(null);
      const inFlightRef = useRef(false);

      // chart refs
      const locChartRef = useRef(null);
      const locChartInst = useRef(null);
      const monthChartRef = useRef(null);
      const monthChartInst = useRef(null);

      // Helper: update (or create) a Chart.js instance cleanly (silent update)
      function updateOrCreateChart(instRef, canvas, config) {
        if (!canvas) return;
        try {
          if (instRef.current) {
            // update data & options if possible
            instRef.current.data = config.data;
            instRef.current.options = config.options || instRef.current.options;
            instRef.current.update();
            return instRef.current;
          } else {
            instRef.current = new Chart(canvas.getContext('2d'), config);
            return instRef.current;
          }
        } catch (e) {
          // fallback: destroy + create
          try { if (instRef.current) instRef.current.destroy(); } catch (_) {}
          instRef.current = new Chart(canvas.getContext('2d'), config);
          return instRef.current;
        }
      }

      // Core fetch — silent update pattern:
      async function fetchOnce() {
        if (inFlightRef.current) return;
        inFlightRef.current = true;
        // setLoading just for indicator; we MUST NOT clear UI state here
        setLoading(true);

        try {
          const params = new URLSearchParams();
          if (year) params.set('year', String(year));
          if (location && location !== 'All locations') params.set('location', location);
          const url = API_ENDPOINT + '?' + params.toString();

          const r = await fetch(url, { cache: 'no-store' });
          if (!r.ok) {
            const txt = await r.text().catch(()=>'');
            throw new Error('API error: ' + r.status + ' ' + txt);
          }
          const js = await r.json();

          // parse results into local variables first (do not mutate state yet)
          const total_rejections = (js.total_rejections !== undefined) ? js.total_rejections
            : (js.total !== undefined ? js.total : (js.totalRejections || 0));

          const rawByLoc = js.by_location || js.byLocation || js.location_counts || [];
          const normalizedByLoc = Array.isArray(rawByLoc) ? rawByLoc.map(x => {
            const k = x.PartitionName2 || x.partition || x.location || x.name || x.PartitionName || '';
            const c = x.count !== undefined ? x.count : (x.value !== undefined ? x.value : 0);
            return { name: String(k || '').trim(), count: Number(c || 0) };
          }) : [];

          const rawByEmp = js.by_employee || js.byEmployee || js.employee_counts || [];
          const normalizedByEmp = Array.isArray(rawByEmp) ? rawByEmp.map(x => {
            const id = x.person_uid || x.EmployeeID || x.employee_id || x.id || x.person || '';
            const c = x.count !== undefined ? x.count : (x.value !== undefined ? x.value : 0);
            return { id: String(id || '').trim(), count: Number(c || 0) };
          }) : [];

          const rawRecent = js.recent || js.rows || js.events || js.recent_rows || [];

          // month-wise
          const rawMonthTotals = js.month_totals || js.monthTotals || [];
          const normalizedMonthTotals = Array.isArray(rawMonthTotals) ? rawMonthTotals.map(x => ({
            Month: Number(x.Month || x.month || 0),
            MonthName: x.MonthName || x.MonthName || (x.monthname || "").toString(),
            count: Number(x.count || x.value || 0)
          })) : [];

          const rawMonthByLoc = js.month_by_location || js.monthByLocation || [];
          const normalizedMonthByLoc = Array.isArray(rawMonthByLoc) ? rawMonthByLoc.map(x => ({
            Month: Number(x.Month || x.month || 0),
            MonthName: x.MonthName || x.MonthName || (x.monthname || "").toString(),
            PartitionName2: x.PartitionName2 || x.Partition || x.location || "",
            count: Number(x.count || x.value || 0)
          })) : [];

          const rawMonthByEmp = js.month_by_employee || js.monthByEmployee || [];
          const normalizedMonthByEmp = Array.isArray(rawMonthByEmp) ? rawMonthByEmp.map(x => ({
            Month: Number(x.Month || x.month || 0),
            MonthName: x.MonthName || x.MonthName || (x.monthname || "").toString(),
            person_uid: x.person_uid || x.EmployeeID || x.employee_id || x.id || "",
            count: Number(x.count || x.value || 0)
          })) : [];

          // compute derived metrics locally
          const unique = new Set((normalizedByEmp || []).map(e => e.id).filter(Boolean));
          const repeaters = (normalizedByEmp || []).filter(e => e.count > 1);

          // Now update React state in one go (atomic-ish)
          setTotal(Number(total_rejections || 0));
          setByLocation(normalizedByLoc);
          setByEmployee(normalizedByEmp);
          setRecent(Array.isArray(rawRecent) ? rawRecent : []);
          setUniqueEmployees(unique.size);
          setRepeatersCount(repeaters.length);

          setMonthTotals(normalizedMonthTotals);
          setMonthByLocation(normalizedMonthByLoc);
          setMonthByEmployee(normalizedMonthByEmp);

          // update charts in-place (no flicker)
          // Location chart (top N)
          if (locChartRef.current) {
            const topLoc = (normalizedByLoc || []).slice(0,12);
            const labels = topLoc.map(x => x.name || 'Unknown');
            const values = topLoc.map(x => x.count || 0);
            updateOrCreateChart(locChartInst, locChartRef.current, {
              type: 'bar',
              data: { labels, datasets: [{ label: 'PIN rejections', data: values }] },
              options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}} , scales:{ y:{beginAtZero:true} } }
            });
          }

          // Month totals chart
          if (monthChartRef.current) {
            // ensure we have an array length 12 sorted
            const monthArr = Array.from({length:12}, (_,i) => {
              const m = i+1;
              const rec = normalizedMonthTotals.find(r => Number(r.Month) === m);
              return Number(rec?.count || 0);
            });
            updateOrCreateChart(monthChartInst, monthChartRef.current, {
              type: 'line',
              data: { labels: MONTH_NAMES, datasets: [{ label: 'Monthly PIN rejections', data: monthArr }] },
              options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
            });
          }

          setLastFetch(new Date().toISOString());

        } catch (err) {
          console.error("Fetch EMEA PIN failed", err);
        } finally {
          setLoading(false);
          inFlightRef.current = false;
        }
      }

      // start / stop polling
      useEffect(() => {
        // immediate first fetch (do not clear UI)
        fetchOnce();

        if (live) {
          pollingRef.current = setInterval(fetchOnce, 1000); // keep 1s but updates are silent
        }
        return () => {
          if (pollingRef.current) {
            clearInterval(pollingRef.current);
            pollingRef.current = null;
          }
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [live, year, location]);

      // when page mounts create empty charts to avoid flash
      useEffect(() => {
        // create empty loc chart stub to keep UI stable
        if (locChartRef.current && !locChartInst.current) {
          updateOrCreateChart(locChartInst, locChartRef.current, {
            type: 'bar',
            data: { labels: [], datasets: [{ label: 'PIN rejections', data: [] }]},
            options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
          });
        }
        if (monthChartRef.current && !monthChartInst.current) {
          updateOrCreateChart(monthChartInst, monthChartRef.current, {
            type: 'line',
            data: { labels: MONTH_NAMES, datasets: [{ label: 'Monthly PIN rejections', data: Array(12).fill(0) }]},
            options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
          });
        }
      }, []);

      // helper to derive top locations/employees for selected month
      function topForSelectedMonthByLocation(limit=20) {
        const rows = (monthByLocation || []).filter(r => Number(r.Month) === Number(selectedMonth));
        return rows.sort((a,b)=>b.count - a.count).slice(0,limit);
      }
      function topForSelectedMonthByEmployee(limit=20) {
        const rows = (monthByEmployee || []).filter(r => Number(r.Month) === Number(selectedMonth));
        return rows.sort((a,b)=>b.count - a.count).slice(0,limit);
      }

      function exportMonthByLocationCSV() {
        const rows = topForSelectedMonthByLocation(500).map(r => ({
          Month: r.Month,
          MonthName: r.MonthName,
          Location: r.PartitionName2,
          Count: r.count
        }));
        if (rows.length===0) { alert("No month-by-location data for selected month"); return; }
        downloadCSV(rows, `emea_pin_month_${selectedMonth}_by_location.csv`);
      }

      return (
        <div className="container" >
          <div className="topbar" role="banner" style={{ marginBottom: 10 }}>
            <div style={{ display:'flex', alignItems:'center', gap:12 }}>
              <div className="wu-logo">WU</div>
              <div>
                <h1 style={{ margin: 0, color: 'var(--wu-yellow)',fontSize: 18 }}>EMEA PIN — Live Dashboard</h1>
                <div style={{ fontSize: 13, color: '#e6e6e6' }}>Live PIN rejections</div>
              </div>
            </div>

            <div className="header-actions" style={{ alignItems:'center' }}>
              <div style={{ display:'flex', gap:8, alignItems:'center' }} className="top-controls">
                <label className="small" style={{ color:'#e6e6e6' }}>Year</label>
                <input type="number" value={year} onChange={(e)=>setYear(Number(e.target.value||new Date().getFullYear()))} style={{ width:100, padding:6, borderRadius:6 }} />
                <label className="small" style={{ color:'#e6e6e6' }}>Location</label>
                <select value={location} onChange={e=>setLocation(e.target.value)} style={{ padding:6, borderRadius:6 }}>
                  <option>All locations</option>
                  {EMEA_PARTITIONS.map(p => <option key={p} value={p}>{p}</option>)}
                </select>

                <button className="btn-ghost" onClick={() => { setLive(!live); }}>{live ? 'Pause' : 'Resume'}</button>
                <button className="btn-primary" onClick={fetchOnce} disabled={loading}>Refresh</button>
                <button className="small-button" onClick={() => exportMonthByLocationCSV()}>Export Month-By-Location</button>
              </div>
            </div>
          </div>

          <div style={{ display:'flex', gap:12 }}>
            <div style={{ flex:1 }}>
              <div className="cards" style={{ marginBottom:10 }}>
                <div className="card">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{total.toLocaleString()}</h3>
                      <p>Total rejections</p>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{uniqueEmployees.toLocaleString()}</h3>
                      <p>Unique employees</p>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{repeatersCount.toLocaleString()}</h3>
                      <p>Repeat offenders</p>
                    </div>
                  </div>
                </div>
              </div>

              <div style={{ background:'#fff', padding:12, borderRadius:10, boxShadow:'0 6px 18px rgba(2,6,23,0.04)' }}>
                <h3 style={{ marginTop:0 }}>Location wise (top)</h3>
                <div className="chart-wrap chart-small" style={{ marginBottom:12 }}>
                  <canvas ref={locChartRef}></canvas>
                </div>

                <div style={{ display:'flex', gap:12 }}>
                  <div style={{ flex:1 }}>
                    <h4 style={{ margin: '6px 0' }}>Top repeaters</h4>
                    <div className="table-scroll" style={{ maxHeight:220 }}>
                      <table className="compact-table">
                        <thead>
                          <tr><th>Employee</th><th>Count</th></tr>
                        </thead>
                        <tbody>
                          {(byEmployee || []).slice(0,15).map((r,i) => (
                            <tr key={i}><td style={{ padding:'6px 8px' }}>{r.id}</td><td style={{ padding:'6px 8px' }}>{r.count}</td></tr>
                          ))}
                          {(!byEmployee || byEmployee.length===0) && <tr><td colSpan="2" className="muted">No data</td></tr>}
                        </tbody>
                      </table>
                    </div>
                  </div>

                  <div style={{ width: 320 }}>
                    <h4 style={{ margin: '6px 0' }}>Recent events</h4>
                    <div className="table-scroll" style={{ maxHeight:220 }}>
                      <table className="compact-table">
                        <thead><tr><th>Time</th><th>Loc</th><th>Emp</th></tr></thead>
                        <tbody>
                          {(recent || []).slice(0,12).map((r,i) => (
                            <tr key={i}>
                              <td style={{ padding:'6px 8px' }}>{formatDateShort(r.LocaleMessageTime || r.Date || r.Timestamp)}</td>
                              <td style={{ padding:'6px 8px' }}>{r.PartitionName2 || r.Partition || r.location || '-'}</td>
                              <td style={{ padding:'6px 8px' }}>{r.EmployeeName || r.EmployeeID || r.person_uid || '-'}</td>
                            </tr>
                          ))}
                          {(!recent || recent.length===0) && <tr><td colSpan="3" className="muted">No recent events</td></tr>}
                        </tbody>
                      </table>
                    </div>
                  </div>
                </div>

                <div style={{ marginTop:10, fontSize:13, color:'#64748b' }}>
                  Last fetch: {lastFetch ? new Date(lastFetch).toLocaleString() : 'never'} {loading ? ' • loading…' : ''}
                </div>
              </div>

              {/* Month panel */}
              <div style={{ marginTop:12, background:'#fff', padding:12, borderRadius:10, boxShadow:'0 6px 18px rgba(2,6,23,0.04)' }}>
                <h3 style={{ marginTop:0 }}>Month-wise analysis</h3>

                <div className="month-panel">
                  <label className="small muted">Select month</label>
                  <select value={selectedMonth} onChange={e=>setSelectedMonth(Number(e.target.value))} style={{ padding:6, borderRadius:6 }}>
                    {Array.from({length:12},(_,i)=>i+1).map(m => <option key={m} value={m}>{MONTH_NAMES[m-1]} ({m})</option>)}
                  </select>

                  <div style={{ marginLeft: 8 }}>
                    <button className="small-button" onClick={() => exportMonthByLocationCSV()}>Export Month Location CSV</button>
                  </div>
                </div>

                <div className="chart-wrap month-chart-wrap" style={{ marginTop:10 }}>
                  <canvas ref={monthChartRef}></canvas>
                </div>

                <div style={{ display:'flex', gap:12, marginTop:12 }}>
                  <div style={{ flex:1 }}>
                    <h4 style={{ margin:'6px 0' }}>Top locations — {MONTH_NAMES[selectedMonth-1]}</h4>
                    <div className="table-scroll" style={{ maxHeight:220 }}>
                      <table className="compact-table">
                        <thead><tr><th>Location</th><th>Count</th></tr></thead>
                        <tbody>
                          {topForSelectedMonthByLocation(50).map((r,i)=>(
                            <tr key={i}><td style={{ padding:'6px 8px' }}>{r.PartitionName2 || '-'}</td><td style={{ padding:'6px 8px' }}>{r.count}</td></tr>
                          ))}
                          {(topForSelectedMonthByLocation(50).length===0) && <tr><td colSpan="2" className="muted">No data for selected month</td></tr>}
                        </tbody>
                      </table>
                    </div>
                  </div>

                  <div style={{ width: 320 }}>
                    <h4 style={{ margin:'6px 0' }}>Top employees — {MONTH_NAMES[selectedMonth-1]}</h4>
                    <div className="table-scroll" style={{ maxHeight:220 }}>
                      <table className="compact-table">
                        <thead><tr><th>Employee</th><th>Count</th></tr></thead>
                        <tbody>
                          {topForSelectedMonthByEmployee(50).map((r,i)=>(
                            <tr key={i}><td style={{ padding:'6px 8px' }}>{r.person_uid || '-'}</td><td style={{ padding:'6px 8px' }}>{r.count}</td></tr>
                          ))}
                          {(topForSelectedMonthByEmployee(50).length===0) && <tr><td colSpan="2" className="muted">No data for selected month</td></tr>}
                        </tbody>
                      </table>
                    </div>
                  </div>
                </div>

              </div>

            </div>

            <aside style={{ width: 340 }}>
              <div className="card" style={{ padding:10 }}>
                <h4 style={{ marginTop:0 }}>Details</h4>
                <div className="small muted">This dashboard polls the API every second. UI will update silently — no blank flashes.</div>
                <hr />
                <div>
                  <b>Total rejections:</b> {total}
                </div>
                <div><b>Unique employees:</b> {uniqueEmployees}</div>
                <div><b>Repeaters:</b> {repeatersCount}</div>
                <hr />
                <div>
                  <h5 style={{ margin:'6px 0' }}>Top locations</h5>
                  <div style={{ maxHeight:300, overflow:'auto' }}>
                    <table className="compact-table">
                      <thead><tr><th>Location</th><th>Count</th></tr></thead>
                      <tbody>
                        {(byLocation || []).slice(0,50).map((r,i) => (
                          <tr key={i}><td style={{ padding:'6px 8px' }}>{r.name || '-'}</td><td style={{ padding:'6px 8px' }}>{r.count}</td></tr>
                        ))}
                        {(!byLocation || byLocation.length===0) && <tr><td colSpan="2" className="muted">No location data</td></tr>}
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>

              <div style={{ height:12 }} />
              <div className="card" style={{ padding:10 }}>
                <h4 style={{ marginTop:0 }}>Actions</h4>
                <div style={{ display:'flex', gap:8 }}>
                  <button className="small-button" onClick={() => { setLocation('All locations'); setYear(new Date().getFullYear()); }}>Reset</button>
                  <button className="small-button" onClick={() => downloadCSV((recent||[]).slice(0,200), `emea_pin_recent_${year}.csv`)}>Export Recent</button>
                </div>
              </div>

            </aside>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(EmeaPinApp));
  })();
  </script>
</body>
</html>












Now As per Backend Update Employee wise , Location Wise Montly upadte 
in Frontend 
refer backend month wise logic and update month wise logic in Frontend carefully alos from frontend we have see one isse which is 
daata pool every second 
this Afftet Ui 
like when 
UI display blank 
afer loading display data 
again Blank like 
i dont want reflect this itteration on Ui keep upadate live data 
silentely 
upadte file carefullya snd share me updated files carefully

#C:\Users\W0024618\Desktop\Trend Analysis\backend\api_server.py
from pathlib import Path
from datetime import datetime, date
import time
import traceback
import sys
import importlib
import logging
from typing import Any

# ----- ensure project root on sys.path (do this before other imports) -----
HERE = Path(__file__).resolve()
PROJECT_ROOT = HERE.parent.parent  # <project-root> (one level above backend/)
if str(PROJECT_ROOT) not in sys.path:
    sys.path.insert(0, str(PROJECT_ROOT))

# now safe to import FastAPI etc.
from fastapi import FastAPI, Query, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import pandas as pd

LOG = logging.getLogger("emea.api")
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")

# ----- try to import backend.emea_pin in a robust way (clear error if fails) -----
ep = None
try:
    ep = importlib.import_module("backend.emea_pin")
    LOG.info("Imported backend.emea_pin via package import")
except Exception as first_exc:
    LOG.warning("Package import backend.emea_pin failed: %s", first_exc)
    try:
        ep = importlib.import_module("emea_pin")
        LOG.info("Imported emea_pin as top-level module")
    except Exception as second_exc:
        tb = traceback.format_exc()
        LOG.error("Failed to import emea_pin module.\nPackage import error: %s\nFallback error: %s\nTrace:\n%s",
                  first_exc, second_exc, tb)
        raise RuntimeError(f"Failed to import emea_pin module (see server logs). Primary error: {first_exc}") from second_exc

# create app
app = FastAPI(title="EMEA PIN API (wrapper)")

# permissive CORS for local/dev
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["GET", "OPTIONS", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)

# cache for DataFrame
CACHE = {"ts": 0.0, "year": None, "df": None}
CACHE_TTL = 5  # seconds

def _load_fallback_csv(project_root: Path):
    fallback = project_root / "out" / "emea_pin_raw.csv"
    if fallback.exists():
        LOG.info("Loading fallback CSV: %s", fallback)
        try:
            df = pd.read_csv(fallback, parse_dates=["LocaleMessageTime"], keep_default_na=False)
            # sanitize DateOnly if present: ensure string
            if "LocaleMessageTime" in df.columns:
                df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")
            if "DateOnly" in df.columns:
                # ensure DateOnly is string
                df["DateOnly"] = df["DateOnly"].astype(str)
            return df
        except Exception as e:
            LOG.exception("Failed to parse fallback CSV: %s", e)
            raise
    raise FileNotFoundError(str(fallback))

# --- sanitizer helpers to make response JSON-safe ---
def _serialize_value(v: Any) -> Any:
    """Convert common non-JSON types to JSON-safe primitives."""
    # basic primitives
    if v is None:
        return None
    if isinstance(v, (str, bool, int, float)):
        return v

    # datetime / date
    if isinstance(v, (datetime, date)):
        return v.isoformat()

    # pandas Timestamp / Timedelta / NaT
    try:
        if isinstance(v, pd.Timestamp):
            if pd.isna(v):
                return None
            return v.isoformat()
        if isinstance(v, pd.Timedelta):
            return str(v)
        # pandas NaT check
        if v is pd.NaT:
            return None
    except Exception:
        pass

    # numpy scalar / datetime64
    try:
        import numpy as _np
        if isinstance(v, _np.generic):
            return v.item()
        if isinstance(v, _np.datetime64):
            # convert via pandas
            try:
                ts = pd.to_datetime(v)
                return ts.isoformat()
            except Exception:
                return str(v)
    except Exception:
        pass

    # fallback: try to convert to builtin
    try:
        return str(v)
    except Exception:
        return None

def _sanitize(obj: Any) -> Any:
    """Recursively walk `obj` and convert values to JSON-safe types."""
    if isinstance(obj, dict):
        return {str(k): _sanitize(v) for k, v in obj.items()}
    if isinstance(obj, (list, tuple)):
        return [_sanitize(v) for v in obj]
    # DataFrame / Series -> records
    if isinstance(obj, pd.DataFrame):
        try:
            return _sanitize(obj.fillna("").to_dict(orient="records"))
        except Exception:
            return []
    if isinstance(obj, pd.Series):
        try:
            return _sanitize(obj.fillna("").to_list())
        except Exception:
            return []

    # primitive or other: convert
    return _serialize_value(obj)

@app.get("/api/emea_pin_live")
def emea_pin_live(year: int | None = None, location: str | None = Query(None)):
    target_year = int(year or datetime.now().year)
    now = time.time()

    # refresh cache as needed
    if CACHE["df"] is None or CACHE["year"] != target_year or (now - CACHE["ts"]) > CACHE_TTL:
        try:
            df = ep.fetch_pin_rows_for_year(target_year)
            LOG.info("Fetched df from emea_pin (rows=%d)", len(df) if getattr(df, "shape", None) is not None else -1)
        except Exception as e:
            LOG.warning("fetch_pin_rows_for_year failed: %s", e)
            try:
                df = _load_fallback_csv(PROJECT_ROOT)
            except Exception as e2:
                tb = traceback.format_exc()
                LOG.error("Failed both live fetch and fallback CSV: %s\n%s", e2, tb)
                raise HTTPException(status_code=500, detail=f"Failed to fetch PIN rows: {e}\nFallback error: {e2}\n{tb}")

        if df is None:
            df = pd.DataFrame()
        CACHE.update({"ts": now, "year": target_year, "df": df})
    else:
        df = CACHE["df"]

    # defensive column existence
    for col in ["LocaleMessageTime", "PartitionName2", "person_uid", "EmployeeName", "EmployeeID", "CardNumber", "DateOnly", "Month", "MonthName"]:
        if col not in df.columns:
            # Make sure Month is integer-like and MonthName string
            if col == "Month":
                df[col] = pd.NA
            else:
                df[col] = pd.NA

    # ensure LocaleMessageTime parsed
    if "LocaleMessageTime" in df.columns:
        df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")

    # ensure Month/MonthName derived (in case they weren't present)
    if "Month" not in df.columns or df["Month"].isnull().all():
        df["Month"] = df["LocaleMessageTime"].dt.month.fillna(0).astype("Int64")
    if "MonthName" not in df.columns or df["MonthName"].isnull().all():
        df["MonthName"] = df["LocaleMessageTime"].dt.strftime("%b").fillna("")

    # optional location filter for recent rows
    df_for_recent = df
    if location and location.strip() and location.strip().lower() != "all locations":
        try:
            df_for_recent = df_for_recent[df_for_recent["PartitionName2"].astype(str) == location]
        except Exception:
            LOG.exception("Location filtering failed; using unfiltered df_for_recent")
            df_for_recent = df

    # compute aggregates safely
    try:
        by_loc = df.groupby("PartitionName2", dropna=False).size().reset_index(name="count").sort_values("count", ascending=False)
    except Exception:
        by_loc = pd.DataFrame(columns=["PartitionName2", "count"])
    try:
        by_emp = df.groupby("person_uid", dropna=False).size().reset_index(name="count").sort_values("count", ascending=False)
    except Exception:
        by_emp = pd.DataFrame(columns=["person_uid", "count"])

    # MONTH-WISE aggregates (location & employee)
    try:
        month_totals_df = (df.groupby(["Month", "MonthName"], dropna=False)
                           .size()
                           .reset_index(name="count")
                           .sort_values(["Month"]))
    except Exception:
        month_totals_df = pd.DataFrame(columns=["Month", "MonthName", "count"])

    try:
        month_by_location_df = (df.groupby(["Month", "MonthName", "PartitionName2"], dropna=False)
                                 .size()
                                 .reset_index(name="count")
                                 .sort_values(["Month", "count"], ascending=[True, False]))
    except Exception:
        month_by_location_df = pd.DataFrame(columns=["Month", "MonthName", "PartitionName2", "count"])

    try:
        month_by_employee_df = (df.groupby(["Month", "MonthName", "person_uid"], dropna=False)
                                 .size()
                                 .reset_index(name="count")
                                 .sort_values(["Month", "count"], ascending=[True, False]))
    except Exception:
        month_by_employee_df = pd.DataFrame(columns=["Month", "MonthName", "person_uid", "count"])

    recent = df_for_recent.copy()
    if "LocaleMessageTime" in recent.columns:
        try:
            recent = recent.sort_values("LocaleMessageTime", ascending=False)
        except Exception:
            LOG.debug("Could not sort recent by LocaleMessageTime")
    recent = recent.head(500)

    # convert to records (strings / primitives) and sanitize recursively
    by_loc_records = _sanitize(by_loc.fillna("").to_dict(orient="records"))
    by_emp_records = _sanitize(by_emp.fillna("").to_dict(orient="records"))
    recent_records = _sanitize(recent.fillna("").to_dict(orient="records"))

    month_totals_records = _sanitize(month_totals_df.fillna("").to_dict(orient="records"))
    month_by_location_records = _sanitize(month_by_location_df.fillna("").to_dict(orient="records"))
    month_by_employee_records = _sanitize(month_by_employee_df.fillna("").to_dict(orient="records"))

    # ensure LocaleMessageTime and DateOnly are ISO strings inside recent_records
    for r in recent_records:
        if isinstance(r, dict):
            if r.get("LocaleMessageTime") is not None:
                try:
                    v = r.get("LocaleMessageTime")
                    if isinstance(v, (datetime, date)):
                        r["LocaleMessageTime"] = v.isoformat()
                except Exception:
                    r["LocaleMessageTime"] = str(r.get("LocaleMessageTime"))
            if r.get("DateOnly") is not None and not isinstance(r.get("DateOnly"), str):
                try:
                    r["DateOnly"] = str(r.get("DateOnly"))
                except Exception:
                    r["DateOnly"] = ""

    resp = {
        "total_rejections": int(len(df)),
        "by_location": by_loc_records,
        "by_employee": by_emp_records,
        "recent": recent_records,
        # month-wise additions
        "month_totals": month_totals_records,
        "month_by_location": month_by_location_records,
        "month_by_employee": month_by_employee_records,
    }

    # Final safety: sanitize the whole response once more
    safe_resp = _sanitize(resp)
    return JSONResponse(safe_resp)









#C:\Users\W0024618\Desktop\Trend Analysis\backend\emea_pin.py
"""
EMEA PIN violation analysis.

Usage:
    python -m backend.emea_pin --year 2024 --outdir ./out
"""
from __future__ import annotations

import argparse
import logging
from datetime import date
from pathlib import Path
from typing import List
import sys

import pandas as pd

# Robust import for duration_report (works when module loaded as package or as plain module)
try:
    from backend import duration_report as dr
except Exception:
    try:
        import duration_report as dr
    except Exception as e:
        raise RuntimeError(f"Could not import duration_report (tried 'backend.duration_report' and 'duration_report'): {e}") from e

# local alias (may be None if duration_report couldn't supply it)
pyodbc = getattr(dr, "pyodbc", None)

LOG = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")


SQL_DB_TEMPLATE = r"""
SELECT
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    t1.ObjectName1 AS EmployeeName,
    t1.PartitionName2 AS PartitionName2,
    COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
      sc.value,
      NULLIF(CAST(t2.[Int1] AS NVARCHAR),'0'),
      t2.[Text12]
    ) AS CardNumber,
    t5rej.value AS Rejection_Type,
    CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR) END AS EmployeeID,
    t3.Name AS PersonnelType,
    t1.ObjectName2 AS DoorName,
    t1.XmlGUID
FROM [{db}].dbo.ACVSUJournalLog t1
LEFT JOIN ACVSCore.Access.Personnel t2 ON t1.ObjectIdentity1 = t2.GUID
LEFT JOIN ACVSCore.Access.PersonnelType t3 ON t2.PersonnelTypeID = t3.ObjectID
LEFT JOIN [{db}].dbo.ACVSUJournalLogxml t_xml ON t1.XmlGUID = t_xml.GUID
LEFT JOIN [{db}].dbo.ACVSUJournalLogxmlShred sc ON t1.XmlGUID = sc.GUID AND sc.Name IN ('Card','CHUID')
LEFT JOIN [{db}].dbo.ACVSUJournalLogxmlShred t5rej ON t1.XmlGUID = t5rej.GUID AND t5rej.Name = 'RejectCode'
WHERE
    t1.MessageType = 'CardRejected'
    AND t5rej.value = 'PIN'
    AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) BETWEEN '{start}' AND '{end}'
"""

def _get_emea_databases() -> List[str]:
    rc = dr.REGION_CONFIG.get("emea")
    if not rc:
        raise RuntimeError("No 'emea' region config found in duration_report.py")
    candidates = dr._get_candidate_databases(rc)
    valid = dr._filter_existing_databases(rc, candidates)
    return valid or candidates

def _connect_to_db(server: str, database: str, user: str, password: str):
    if pyodbc is None:
        raise RuntimeError("pyodbc not available; install pyodbc to run queries.")
    conn_str = (
        f"DRIVER={{{dr.ODBC_DRIVER}}};"
        f"SERVER={server};DATABASE={database};UID={user};PWD={password};"
        "TrustServerCertificate=Yes;"
    )
    return pyodbc.connect(conn_str, autocommit=True)

def fetch_pin_rows_for_year(target_year: int) -> pd.DataFrame:
    rc = dr.REGION_CONFIG["emea"]
    start = date(target_year, 1, 1).strftime("%Y-%m-%d")
    end = date(target_year, 12, 31).strftime("%Y-%m-%d")
    dbs = _get_emea_databases()
    LOG.info("Querying EMEA databases: %s", dbs)

    frames = []
    for db in dbs:
        sql = SQL_DB_TEMPLATE.format(db=db, start=start, end=end)
        LOG.info("Running query against %s.%s (rows may be large)", rc["server"], db)
        conn = None
        try:
            conn = _connect_to_db(rc["server"], db, rc["user"], rc["password"])
            # pandas will pull the results into a DataFrame
            df = pd.read_sql(sql, conn)
            if not df.empty:
                frames.append(df)
        except Exception:
            LOG.exception("Failed to fetch from database %s", db)
        finally:
            try:
                if conn is not None:
                    conn.close()
            except Exception:
                pass

    if not frames:
        return pd.DataFrame(columns=[
            "LocaleMessageTime", "EmployeeName", "PartitionName2", "CardNumber",
            "Rejection_Type", "EmployeeID", "PersonnelType", "DoorName", "XmlGUID"
        ])
    out = pd.concat(frames, ignore_index=True)
    # normalize types
    out["LocaleMessageTime"] = pd.to_datetime(out["LocaleMessageTime"], errors="coerce")

    # IMPORTANT CHANGE: store DateOnly AS STRING (ISO) to avoid python date objects
    out["DateOnly"] = out["LocaleMessageTime"].dt.strftime("%Y-%m-%d")

    # Add Month and MonthName for month-wise analysis
    out["Month"] = out["LocaleMessageTime"].dt.month.fillna(0).astype("Int64")  # pandas nullable int
    out["MonthName"] = out["LocaleMessageTime"].dt.strftime("%b").fillna("")

    # ensure columns exist
    for c in ["EmployeeID", "EmployeeName", "CardNumber", "PartitionName2"]:
        if c not in out.columns:
            out[c] = None
    # restrict to PersonnelType == 'Employee' (defensive)
    if "PersonnelType" in out.columns:
        out = out[out["PersonnelType"].fillna("").str.strip().str.lower() == "employee"].copy()
    # canonical person uid using helper from duration_report
    def make_person_uid(row):
        try:
            return dr._canonical_person_uid_from_row(row)
        except Exception:
            # fallback: prefer EmployeeID -> CardNumber -> EmployeeName
            for cand in ("EmployeeID", "CardNumber", "EmployeeName"):
                v = row.get(cand)
                if v is not None and str(v).strip():
                    return str(v).strip()
            return None
    if not out.empty:
        out["person_uid"] = out.apply(make_person_uid, axis=1)
    return out

def analyze_pin_df(df: pd.DataFrame, outdir: Path) -> dict:
    outdir.mkdir(parents=True, exist_ok=True)
    results = {}
    total = len(df)
    results["total_rejections"] = int(total)
    LOG.info("Total PIN rejections in dataset: %d", total)

    # ensure month columns exist and are in friendly form
    if "Month" not in df.columns:
        df["Month"] = pd.to_datetime(df.get("LocaleMessageTime", None), errors="coerce").dt.month.fillna(0).astype(int)
    if "MonthName" not in df.columns:
        df["MonthName"] = pd.to_datetime(df.get("LocaleMessageTime", None), errors="coerce").dt.strftime("%b").fillna("")

    # by location (PartitionName2)
    by_loc = df.groupby("PartitionName2", dropna=False).size().reset_index(name="count").sort_values("count", ascending=False)
    results["by_location"] = by_loc
    by_loc.to_csv(outdir / "emea_pin_by_location.csv", index=False)

    # by employee (person_uid) - top offenders
    by_emp = df.groupby("person_uid", dropna=False).size().reset_index(name="count").sort_values("count", ascending=False)
    results["by_employee"] = by_emp
    by_emp.to_csv(outdir / "emea_pin_by_employee.csv", index=False)

    # repeaters: employees with count > 1
    repeaters = by_emp[by_emp["count"] > 1].copy()
    results["repeaters"] = repeaters
    repeaters.to_csv(outdir / "emea_pin_repeaters.csv", index=False)

    # MONTH-WISE: total by month
    month_totals = (df.groupby(["Month", "MonthName"], dropna=False)
                    .size()
                    .reset_index(name="count")
                    .sort_values(["Month"]))
    results["month_totals"] = month_totals
    month_totals.to_csv(outdir / "emea_pin_month_totals.csv", index=False)

    # MONTH-WISE: location-wise counts per month
    month_loc = (df.groupby(["Month", "MonthName", "PartitionName2"], dropna=False)
                 .size()
                 .reset_index(name="count")
                 .sort_values(["Month", "count"], ascending=[True, False]))
    results["month_by_location"] = month_loc
    month_loc.to_csv(outdir / "emea_pin_month_by_location.csv", index=False)

    # MONTH-WISE: employee-wise counts per month
    month_emp = (df.groupby(["Month", "MonthName", "person_uid"], dropna=False)
                 .size()
                 .reset_index(name="count")
                 .sort_values(["Month", "count"], ascending=[True, False]))
    results["month_by_employee"] = month_emp
    month_emp.to_csv(outdir / "emea_pin_month_by_employee.csv", index=False)

    # summary stats
    results["unique_employees"] = int(by_emp["person_uid"].nunique()) if "person_uid" in by_emp.columns else int(by_emp.shape[0])
    results["repeat_count_total"] = int(repeaters["count"].sum()) if not repeaters.empty else 0
    results["num_repeaters"] = int(len(repeaters))
    LOG.info("Unique employees with PIN rejects: %s", results["unique_employees"])
    LOG.info("Number of repeaters (count>1): %s, total repeat events: %s", results["num_repeaters"], results["repeat_count_total"])

    # Save full raw dataframe for audit (DateOnly as string avoids JSON issues)
    df.to_csv(outdir / "emea_pin_raw.csv", index=False)

    return results

def main():
    parser = argparse.ArgumentParser(description="EMEA PIN rejection analysis (yearly).")
    parser.add_argument("--year", type=int, required=False, default=date.today().year, help="Year to analyze (e.g. 2024)")
    parser.add_argument("--outdir", required=False, default="./out", help="Output directory for CSVs")
    args = parser.parse_args()

    target_year = int(args.year)
    outdir = Path(args.outdir)

    LOG.info("Starting EMEA PIN analysis for year %d", target_year)
    df = fetch_pin_rows_for_year(target_year)
    LOG.info("Rows fetched: %d", len(df))
    results = analyze_pin_df(df, outdir)
    # print short summary
    print("==== EMEA PIN analysis summary ====")
    print(f"Year: {target_year}")
    print(f"Total PIN rejections: {results.get('total_rejections', 0)}")
    print(f"Unique employees with rejects: {results.get('unique_employees', 0)}")
    print(f"Repeaters (employees with >1 reject): {results.get('num_repeaters', 0)}  (repeat events total: {results.get('repeat_count_total', 0)})")
    print(f"CSV outputs saved to: {outdir.resolve()}")

if __name__ == "__main__":
    main()






C:\Users\W0024618\Desktop\Trend Analysis\frontend\emea_pin.html

<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>EMEA PIN Dashboard — Live</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- reuse your style -->
  <link rel="stylesheet" href="style.css">
  <style>
    /* small overrides for this page */
    .topbar { margin-bottom: 8px; }
    .small-card { padding: 12px; text-align: center; }
    .top-controls { display:flex; gap:8px; align-items:center; }
    .chart-small { height:220px; }
    .compact-table td { padding:6px; font-size:13px; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
  (function () {
    const { useState, useEffect, useRef } = React;

    // CHANGE THESE as needed:
    const API_BASE = "http://localhost:8003"; // keep same host as other frontends
    // The frontend will call `${API_ENDPOINT}?year=2024&location=UK.London` (location optional)
    // Update to match your backend route if different.
    const API_ENDPOINT = API_BASE + "/api/emea_pin_live"; // <--- change if your backend uses a different route

    // Default region partitions for EMEA (keeps UI consistent)
    const EMEA_PARTITIONS = ["LT.Vilnius","IT.Rome","UK.London","IE.DUblin","DU.Abu Dhab","ES.Madrid","AUT.Vienna","MA.Casablanca","RU.Moscow"];

    function formatDateShort(d) {
      if (!d) return '-';
      try {
        const dt = new Date(d);
        if (isNaN(dt.getTime())) return String(d).slice(0,19);
        return dt.toLocaleString();
      } catch (e) { return String(d); }
    }

    function downloadCSV(rows, filename = 'export.csv') {
      if (!rows || rows.length === 0) { alert("No data to export"); return; }
      const cols = Object.keys(rows[0]);
      const lines = [];
      lines.push(cols.join(','));
      rows.forEach(r => {
        const line = cols.map(c => {
          const v = r[c] === null || r[c] === undefined ? '' : String(r[c]).replace(/\n/g,' ');
          return JSON.stringify(v);
        }).join(',');
        lines.push(line);
      });
      const blob = new Blob([lines.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = filename; a.click(); URL.revokeObjectURL(url);
    }

    function EmeaPinApp() {
      const [year, setYear] = useState(new Date().getFullYear());
      const [location, setLocation] = useState('All locations');
      const [live, setLive] = useState(true);
      const [loading, setLoading] = useState(false);
      const [lastFetch, setLastFetch] = useState(null);

      const [total, setTotal] = useState(0);
      const [uniqueEmployees, setUniqueEmployees] = useState(0);
      const [repeatersCount, setRepeatersCount] = useState(0);
      const [byLocation, setByLocation] = useState([]);
      const [byEmployee, setByEmployee] = useState([]);
      const [recent, setRecent] = useState([]);

      const pollingRef = useRef(null);
      const inFlightRef = useRef(false);
      const chartRef = useRef(null);
      const chartInst = useRef(null);

      async function fetchOnce() {
        if (inFlightRef.current) return;
        inFlightRef.current = true;
        setLoading(true);
        try {
          const params = new URLSearchParams();
          if (year) params.set('year', String(year));
          if (location && location !== 'All locations') params.set('location', location);
          const url = API_ENDPOINT + '?' + params.toString();

          const r = await fetch(url, { cache: 'no-store' });
          if (!r.ok) {
            // try to read body to help debugging
            const txt = await r.text().catch(() => '');
            throw new Error('API error: ' + r.status + ' ' + txt);
          }
          const js = await r.json();

          // Try to adapt multiple shapes
          // Preferred keys: total_rejections, by_location, by_employee, recent
          const total_rejections = (js.total_rejections !== undefined) ? js.total_rejections
            : (js.total !== undefined ? js.total : (js.totalRejections || 0));

          const rawByLoc = js.by_location || js.byLocation || js.location_counts || [];
          const normalizedByLoc = Array.isArray(rawByLoc) ? rawByLoc.map(x => {
            // accept either {PartitionName2, count} or {partition, count} or {location, count}
            const k = x.PartitionName2 || x.partition || x.location || x.name || x.PartitionName || '';
            const c = x.count !== undefined ? x.count : (x.value !== undefined ? x.value : 0);
            return { name: String(k || '').trim(), count: Number(c || 0) };
          }) : [];

          const rawByEmp = js.by_employee || js.byEmployee || js.employee_counts || [];
          const normalizedByEmp = Array.isArray(rawByEmp) ? rawByEmp.map(x => {
            // accept {person_uid, count} or {EmployeeID, count}
            const id = x.person_uid || x.EmployeeID || x.employee_id || x.id || x.person || '';
            const c = x.count !== undefined ? x.count : (x.value !== undefined ? x.value : 0);
            return { id: String(id || '').trim(), count: Number(c || 0) };
          }) : [];

          const rawRecent = js.recent || js.rows || js.events || js.recent_rows || [];

          setTotal(Number(total_rejections || 0));
          setByLocation(normalizedByLoc);
          setByEmployee(normalizedByEmp);
          setRecent(Array.isArray(rawRecent) ? rawRecent : []);
          // compute unique employees & repeaters
          const unique = new Set((normalizedByEmp || []).map(e => e.id).filter(Boolean));
          setUniqueEmployees(unique.size);
          const repeaters = (normalizedByEmp || []).filter(e => e.count > 1);
          setRepeatersCount(repeaters.length);

          setLastFetch(new Date().toISOString());
        } catch (err) {
          console.error("Fetch EMEA PIN failed", err);
        } finally {
          setLoading(false);
          inFlightRef.current = false;
        }
      }

      // start / stop polling
      useEffect(() => {
        // immediate first fetch
        fetchOnce();

        if (live) {
          // setInterval with 1 second
          pollingRef.current = setInterval(fetchOnce, 1000);
        }
        return () => {
          if (pollingRef.current) {
            clearInterval(pollingRef.current);
            pollingRef.current = null;
          }
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [live, year, location]);

      // build chart when byLocation updates
      useEffect(() => {
        const labels = (byLocation || []).slice(0, 12).map(x => x.name || 'Unknown');
        // const labels = [...byLocation].map(x => x.name || 'Unknown');
        const values = (byLocation || []).slice(0, 12).map(x => x.count || 0);
        // const values = [...byLocation].map(x => x.count || 0);
        const ctx = chartRef.current && chartRef.current.getContext ? chartRef.current.getContext('2d') : null;
        if (!ctx) return;
        try { if (chartInst.current) chartInst.current.destroy(); } catch (e) {}

        // chartInst.current = new Chart(ctx, {
        //   type: 'line',
        //   data: {
        //     labels,
        //     datasets: [{
        //       label: 'PIN rejections',
        //       data: values,
        //       backgroundColor: labels.map((l,i)=> 'rgba(37,99,235,0.9)'),
        //     }]
        //   },
        //   options: {
        //     maintainAspectRatio: false,
        //     plugins: { legend: { display: false } },
        //     scales: { y: { beginAtZero: true, ticks: { precision:0 } } }
        //   }
        // });

        chartInst.current = new Chart(ctx, {
  type: 'line',
  data: {
    labels: labels,
    datasets: [{
      label: 'PIN rejections',
      data: values,
      borderColor: '#2563eb',
      backgroundColor: 'rgba(37,99,235,0.2)',
      fill: true,
      tension: 0.3,
      pointBackgroundColor: '#2563eb',
      pointRadius: 5,
      pointHoverRadius: 7,
      borderWidth: 2
    }]
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: { display: false },
      tooltip: {
        callbacks: {
          label: function (context) {
            return context.parsed.y + ' cases';
          }
        }
      }
    },
    scales: {
        
      y: { beginAtZero: true, ticks: { precision: 0 } }
    }
  }
});

        // eslint-disable-next-line
      }, [byLocation]);

      function exportAll() {
        // merge top lists into csv-friendly rows
        const rows = [];
        (recent || []).forEach(r => {
          rows.push({
            Timestamp: r.LocaleMessageTime || r.Date || r.time || '',
            EmployeeName: r.EmployeeName || r.Employee || '',
            EmployeeID: r.EmployeeID || r.person_uid || '',
            PartitionName2: r.PartitionName2 || r.location || '',
            Door: r.DoorName || r.Door || r.ObjectName2 || '',
            CardNumber: r.CardNumber || r.Card || ''
          });
        });
        if (rows.length === 0) {
          alert('No recent events to export');
          return;
        }
        downloadCSV(rows, `emea_pin_recent_${String(year)}.csv`);
      }

      return (
        <div className="container" >
          <div className="topbar" role="banner" style={{ marginBottom: 10 }}>
            <div style={{ display:'flex', alignItems:'center', gap:12 }}>
              <div className="wu-logo">WU</div>
              <div>
                <h1 style={{ margin: 0, color: 'var(--wu-yellow)',fontSize: 18, }}>EMEA PIN — Live Dashboard</h1>
                <div style={{ fontSize: 13, color: '#e6e6e6' }}>Live PIN rejections</div>
              </div>
            </div>

            <div className="header-actions" style={{ alignItems:'center' }}>
              <div style={{ display:'flex', gap:8, alignItems:'center' }} className="top-controls">
                <label className="small" style={{ color:'#e6e6e6' }}>Year</label>
                <input type="number" value={year} onChange={(e)=>setYear(Number(e.target.value||new Date().getFullYear()))} style={{ width:100, padding:6, borderRadius:6 }} />
                <label className="small" style={{ color:'#e6e6e6' }}>Location</label>
                <select value={location} onChange={e=>setLocation(e.target.value)} style={{ padding:6, borderRadius:6 }}>
                  <option>All locations</option>
                  {EMEA_PARTITIONS.map(p => <option key={p} value={p}>{p}</option>)}
                </select>

                <button className="btn-ghost" onClick={() => { setLive(!live); }}>{live ? 'Pause' : 'Resume'}</button>
                <button className="btn-primary" onClick={fetchOnce} disabled={loading}>Refresh</button>
                <button className="small-button" onClick={exportAll}>Export Recent</button>
              </div>
            </div>
          </div>

          <div style={{ display:'flex', gap:12 }}>
            <div style={{ flex:1 }}>
              <div className="cards" style={{ marginBottom:10 }}>
                <div className="card">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{total.toLocaleString()}</h3>
                      <p>Total rejections</p>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{uniqueEmployees.toLocaleString()}</h3>
                      <p>Unique employees</p>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{repeatersCount.toLocaleString()}</h3>
                      <p>Repeat offenders</p>
                    </div>
                  </div>
                </div>
              </div>

              <div style={{ background:'#fff', padding:12, borderRadius:10, boxShadow:'0 6px 18px rgba(2,6,23,0.04)' }}>
                <h3 style={{ marginTop:0 }}>Location wise (top)</h3>
                <div className="chart-wrap chart-small" style={{ marginBottom:12 }}>
                  <canvas ref={chartRef}></canvas>
                </div>

                <div style={{ display:'flex', gap:12 }}>
                  <div style={{ flex:1 }}>
                    <h4 style={{ margin: '6px 0' }}>Top repeaters</h4>
                    <div className="table-scroll" style={{ maxHeight:220 }}>
                      <table className="compact-table">
                        <thead>
                          <tr><th>Employee</th><th>Count</th></tr>
                        </thead>
                        <tbody>
                          {(byEmployee || []).slice(0,15).map((r,i) => (
                            <tr key={i}><td style={{ padding:'6px 8px' }}>{r.id}</td><td style={{ padding:'6px 8px' }}>{r.count}</td></tr>
                          ))}
                          {(!byEmployee || byEmployee.length===0) && <tr><td colSpan="2" className="muted">No data</td></tr>}
                        </tbody>
                      </table>
                    </div>
                  </div>

                  <div style={{ width: 320 }}>
                    <h4 style={{ margin: '6px 0' }}>Recent events</h4>
                    <div className="table-scroll" style={{ maxHeight:220 }}>
                      <table className="compact-table">
                        <thead><tr><th>Time</th><th>Loc</th><th>Emp</th></tr></thead>
                        <tbody>
                          {(recent || []).slice(0,12).map((r,i) => (
                            <tr key={i}>
                              <td style={{ padding:'6px 8px' }}>{formatDateShort(r.LocaleMessageTime || r.Date || r.Timestamp)}</td>
                              <td style={{ padding:'6px 8px' }}>{r.PartitionName2 || r.Partition || r.location || '-'}</td>
                              <td style={{ padding:'6px 8px' }}>{r.EmployeeName || r.EmployeeID || r.person_uid || '-'}</td>
                            </tr>
                          ))}
                          {(!recent || recent.length===0) && <tr><td colSpan="3" className="muted">No recent events</td></tr>}
                        </tbody>
                      </table>
                    </div>
                  </div>
                </div>

                <div style={{ marginTop:10, fontSize:13, color:'#64748b' }}>
                  Last fetch: {lastFetch ? new Date(lastFetch).toLocaleString() : 'never'} {loading ? ' • loading…' : ''}
                </div>
              </div>

            </div>

            <aside style={{ width: 340 }}>
              <div className="card" style={{ padding:10 }}>
                <h4 style={{ marginTop:0 }}>Details</h4>
                <div className="small muted">This dashboard polls the API every second. Use the Year / Location controls to scope results.</div>
                <hr />
                <div>
                  <b>Total rejections:</b> {total}
                </div>
                <div><b>Unique employees:</b> {uniqueEmployees}</div>
                <div><b>Repeaters:</b> {repeatersCount}</div>
                <hr />
                <div>
                  <h5 style={{ margin:'6px 0' }}>Top locations</h5>
                  <div style={{ maxHeight:300, overflow:'auto' }}>
                    <table className="compact-table">
                      <thead><tr><th>Location</th><th>Count</th></tr></thead>
                      <tbody>
                        {(byLocation || []).slice(0,50).map((r,i) => (
                          <tr key={i}><td style={{ padding:'6px 8px' }}>{r.name || '-'}</td><td style={{ padding:'6px 8px' }}>{r.count}</td></tr>
                        ))}
                        {(!byLocation || byLocation.length===0) && <tr><td colSpan="2" className="muted">No location data</td></tr>}
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>

              <div style={{ height:12 }} />
              <div className="card" style={{ padding:10 }}>
                <h4 style={{ marginTop:0 }}>Actions</h4>
                <div style={{ display:'flex', gap:8 }}>
                  <button className="small-button" onClick={() => { setLocation('All locations'); setYear(new Date().getFullYear()); }}>Reset</button>
                  <button className="small-button" onClick={() => downloadCSV((recent||[]).slice(0,200), `emea_pin_recent_${year}.csv`)}>Export Recent</button>
                </div>
              </div>

            </aside>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(EmeaPinApp));
  })();
  </script>
</body>
</html>


