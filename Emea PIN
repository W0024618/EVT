<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>EMEA PIN Dashboard — Live</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <link rel="stylesheet" href="style.css">
  <style>
    /* ---------- Global visual updates ---------- */
    :root {
      --green-accent: rgba(15,157,88,0.6); /* Green Accent 6, lighter ~60% */
      --green-accent-border: rgb(11,128,67);
      --panel-border: 3px solid #d1d5db; /* default thick border for panels */
      --thick-border: 3px solid #cbd5e1;
    }

    html, body {
      margin:0; padding:0; font-family: Inter, Arial, sans-serif; background:#f4f6f8;
    }

    .container {
      padding: 12px;
      /* thick outside border around whole file */
      border: var(--thick-border);
      border-radius: 8px;
      background: #fff;
    }

    .topbar {
      margin-bottom: 8px;
      padding: 10px;
      border: 3px solid var(--green-accent-border); /* thick outside border for header */
      background: var(--green-accent); /* header background green accent */
      border-radius: 8px;
      color: #fff;
      /* center header content */
      text-align: center;
    }

    .topbar .wu-logo { display:inline-block; background:#0b1114; color:#fff; padding:6px 10px; border-radius:6px; font-weight:700; margin-right:8px; vertical-align:middle; }

    /* center the main title */
    .topbar h1 { margin:0; font-size:18px; text-align:center; color:white; }

    /* card/panel styling - all thick borders */
    .card, .cards .card {
      border: var(--panel-border);
      padding: 10px;
      border-radius: 8px;
      background: #fff;
      margin-bottom: 8px;
    }

    /* keep chart containers neat */
    .chart-wrap { padding:8px; border: var(--panel-border); border-radius:8px; background:#fff; }
    .month-chart-wrap { height:200px; }

    .top-controls { display:flex; gap:8px; align-items:center; }

    /* tables: thick borders and header center alignment */
    .compact-table { width:100%; border-collapse:collapse; }
    .compact-table th, .compact-table td {
      border: 2px solid #cbd5e1; /* thick-ish border for table cells */
      padding: 8px;
      font-size:13px;
    }
    .compact-table thead th {
      background: #f3f4f6;
      text-align:center; /* header center aligned */
      font-weight:600;
    }

    /* Sr.No column narrower */
    .srcol { width: 48px; text-align:center; }

    /* EmployeeName and DoorName left align */
    .col-name, .col-door { text-align:left; }

    /* Filters row inputs */
    .filter-input {
      width: 100%;
      box-sizing: border-box;
      padding:6px;
      border-radius:4px;
      border:1px solid #cbd5e1;
    }

    /* Make header controls still visible but not cluttered */
    .header-actions { margin-top:10px; display:flex; justify-content:center; }

    /* Buttons */
    .btn-primary { padding:6px 10px; border-radius:6px; background:#2563eb; color:#fff; border:none; cursor:pointer; }
    .btn-ghost { padding:6px 10px; border-radius:6px; background:transparent; border:1px solid #e5e7eb; cursor:pointer; color:#fff; }
    .small-button { padding:6px 8px; border-radius:6px; border:1px solid #e5e7eb; background:#fff; cursor:pointer; }

    .muted { color:#6b7280; }

    /* Responsive tweaks */
    @media (max-width:900px) {
      .top-controls { flex-wrap:wrap; justify-content:center; }
      aside { width:100% !important; }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
  (function () {
    const { useState, useEffect, useRef, useMemo } = React;

    // CHANGE THESE as needed:
    const API_BASE = "http://localhost:8003";
    const API_ENDPOINT = API_BASE + "/api/emea_pin_live";

    const EMEA_PARTITIONS = ["LT.Vilnius","IT.Rome","UK.London","IE.DUblin","DU.Abu Dhab","ES.Madrid","AUT.Vienna","MA.Casablanca","RU.Moscow"];
    const MONTH_NAMES = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    
    function downloadCSV(rows, filename = 'export.csv', columnsOrder = null) {
      if (!rows || rows.length === 0) { alert("No data to export"); return; }
      // columnsOrder override keeps header order and excludes undesired fields
      const cols = columnsOrder || Object.keys(rows[0]);
      const lines = [];
      // header
      lines.push(cols.join(','));
      rows.forEach(r => {
        const line = cols.map(c => {
          const v = r[c] === null || r[c] === undefined ? '' : String(r[c]).replace(/\n/g,' ');
          return JSON.stringify(v);
        }).join(',');
        lines.push(line);
      });
      const blob = new Blob([lines.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = filename; a.click(); URL.revokeObjectURL(url);
    }

    function EmeaPinApp() {
      const [year, setYear] = useState(new Date().getFullYear());
      const [location, setLocation] = useState('All locations');

      // IMPORTANT: default live=false so no automatic polling starts on load.
      const [live, setLive] = useState(false);

      // month selector in header. 0 === All months, 1..12 specific month
      const [selectedMonth, setSelectedMonth] = useState(0);

      const [loading, setLoading] = useState(false);
      const [lastFetch, setLastFetch] = useState(null);

      const [total, setTotal] = useState(0);
      const [uniqueEmployees, setUniqueEmployees] = useState(0);
      const [repeatersCount, setRepeatersCount] = useState(0);

      // main lists (raw normalized arrays from API)
      const [byLocationRaw, setByLocationRaw] = useState([]); // array of {name, count}
      const [byEmployeeRaw, setByEmployeeRaw] = useState([]); // array of {id, count, EmployeeID, EmployeeName}
      const [recent, setRecent] = useState([]);

      // person map from API: { person_uid: { EmployeeID, EmployeeName } }
      const [personMap, setPersonMap] = useState({});

      // month-wise raw arrays from API
      const [monthTotalsRaw, setMonthTotalsRaw] = useState([]); // {Month, MonthName, count}
      const [monthByLocationRaw, setMonthByLocationRaw] = useState([]); // {Month, MonthName, PartitionName2, count}
      const [monthByEmployeeRaw, setMonthByEmployeeRaw] = useState([]); // {Month, MonthName, person_uid, count, EmployeeID, EmployeeName}

      // day-wise arrays returned by API when a specific month is requested
      const [dayTotalsRaw, setDayTotalsRaw] = useState([]); // {Day, count}
      const [dayByLocationRaw, setDayByLocationRaw] = useState([]); // {Day, PartitionName2, count}

      const pollingRef = useRef(null);
      const inFlightRef = useRef(false);

      // chart refs
      const locChartRef = useRef(null);
      const locChartInst = useRef(null);
      const monthChartRef = useRef(null);
      const monthChartInst = useRef(null);

      // which page to show: 'dashboard' or 'details'
      const [view, setView] = useState('dashboard');

      // details page state
      const [detailsEmployeeId, setDetailsEmployeeId] = useState('');
      const [detailsFromDate, setDetailsFromDate] = useState(''); // YYYY-MM-DD
      const [detailsToDate, setDetailsToDate] = useState('');     // YYYY-MM-DD
      const [detailsLimit, setDetailsLimit] = useState(200);
      const [detailsOffset, setDetailsOffset] = useState(0);
      const [detailsRows, setDetailsRows] = useState([]);
      const [detailsTotal, setDetailsTotal] = useState(0);
      const [detailsLoading, setDetailsLoading] = useState(false);

      // column filters for details table (client-side)
      const [columnFilters, setColumnFilters] = useState({
        employeeId: '', name: '', date: '', time: '', card: '', direction: '', door: '', alert: '', location: ''
      });

      // Helper to update a single filter key
      function setFilter(key, value) {
        setColumnFilters(prev => ({ ...prev, [key]: value }));
      }

      // Helper: update (or create) a Chart.js instance cleanly (silent update)
      function updateOrCreateChart(instRef, canvas, config) {
        if (!canvas) return;
        try {
          if (instRef.current) {
            instRef.current.data = config.data;
            instRef.current.options = config.options || instRef.current.options;
            instRef.current.update();
            return instRef.current;
          } else {
            instRef.current = new Chart(canvas.getContext('2d'), config);
            return instRef.current;
          }
        } catch (e) {
          try { if (instRef.current) instRef.current.destroy(); } catch (_) {}
          instRef.current = new Chart(canvas.getContext('2d'), config);
          return instRef.current;
        }
      }

      // ... (I kept all your existing utility functions and fetch logic unchanged) ...
      // For brevity I will reuse your previous functions like aggregateMonthByLocationForAllMonths,
      // buildLocationChartData, fetchOnce, fetchDetails, etc. (they are unchanged except for exportDetailsCSV below).

      // --- paste unchanged utility functions from your original file here ---
      // (To keep snippet compact I will include the unchanged functions below exactly as in your original file.)
      // You can keep everything else exactly the same; the only functional changes are:
      // 1) client-side filtering UI & logic
      // 2) Sr.No column and left-align for Name/Door
      // 3) client-side export that only exports UI columns
      // 4) borders / CSS changes above

      // For completeness, the important changed functions are below (fetchOnce remains unchanged):
      // (---- fetchOnce & other helpers code -----)
      // I'm going to paste your existing fetchOnce and supporting functions right here (unchanged).
      
      function aggregateMonthByLocationForAllMonths(raw) {
        const map = {};
        (raw || []).forEach(r => {
          const loc = r.PartitionName2 || r.Partition || r.location || '';
          const c = Number(r.count || 0);
          if (!map[loc]) map[loc] = 0;
          map[loc] += c;
        });
        return Object.keys(map).map(k => ({ PartitionName2: k, count: map[k] })).sort((a,b)=>b.count-a.count);
      }

      function aggregateMonthByEmployeeForAllMonths(raw) {
        const map = {};
        (raw || []).forEach(r => {
          const id = r.person_uid || r.EmployeeID || r.employee_id || r.id || '';
          const c = Number(r.count || 0);
          if (!map[id]) map[id] = 0;
          map[id] += c;
        });
        return Object.keys(map).map(k => ({ person_uid: k, count: map[k] })).sort((a,b)=>b.count-a.count);
      }

      async function fetchOnce() {
        if (inFlightRef.current) return;
        inFlightRef.current = true;
        setLoading(true);

        try {
          const params = new URLSearchParams();
          if (year) params.set('year', String(year));
          if (selectedMonth && Number(selectedMonth) !== 0) params.set('month', String(selectedMonth));
          if (location && location !== 'All locations') params.set('location', location);
          const url = API_ENDPOINT + '?' + params.toString();

          const r = await fetch(url, { cache: 'no-store' });
          if (!r.ok) {
            const txt = await r.text().catch(()=>'');
            throw new Error('API error: ' + r.status + ' ' + txt);
          }
          const js = await r.json();

          // parse results into local variables first (do not mutate state yet)
          const total_rejections = (js.total_rejections !== undefined) ? js.total_rejections
            : (js.total !== undefined ? js.total : (js.totalRejections || 0));

          const rawByLoc = js.by_location || js.byLocation || js.location_counts || [];
          const normalizedByLoc = Array.isArray(rawByLoc) ? rawByLoc.map(function(x) {
            var k = x.PartitionName2 || x.partition || x.location || x.name || x.PartitionName || '';
            var c = x.count !== undefined ? x.count : (x.value !== undefined ? x.value : 0);
            return { name: String(k || '').trim(), count: Number(c || 0) };
          }) : [];

          const rawByEmp = js.by_employee || js.byEmployee || js.employee_counts || [];
          const normalizedByEmp = Array.isArray(rawByEmp) ? rawByEmp.map(function(x) {
            var id = x.person_uid || x.EmployeeID || x.employee_id || x.id || x.person || '';
            var c = x.count !== undefined ? x.count : (x.value !== undefined ? x.value : 0);
            var empIdCol = x.EmployeeID || x.EmployeeId || x.employee_id || '';
            var empNameCol = x.EmployeeName || x.Employee || x.EmployeeName || '';
            return { id: String(id || '').trim(), count: Number(c || 0), EmployeeID: empIdCol || '', EmployeeName: empNameCol || '' };
          }) : [];

          const rawRecent = js.recent || js.rows || js.events || js.recent_rows || [];

          // month-wise
          const rawMonthTotals = js.month_totals || js.monthTotals || [];
          const normalizedMonthTotals = Array.isArray(rawMonthTotals) ? rawMonthTotals.map(function(x) {
            return {
              Month: Number(x.Month || x.month || 0),
              MonthName: x.MonthName || x.monthName || x.monthname || "",
              count: Number(x.count || x.value || 0)
            };
          }) : [];

          const rawMonthByLoc = js.month_by_location || js.monthByLocation || [];
          const normalizedMonthByLoc = Array.isArray(rawMonthByLoc) ? rawMonthByLoc.map(function(x) {
            return {
              Month: Number(x.Month || x.month || 0),
              MonthName: x.MonthName || x.monthName || x.monthname || "",
              PartitionName2: x.PartitionName2 || x.Partition || x.location || "",
              count: Number(x.count || x.value || 0)
            };
          }) : [];

          const rawMonthByEmp = js.month_by_employee || js.monthByEmployee || [];
          const normalizedMonthByEmp = Array.isArray(rawMonthByEmp) ? rawMonthByEmp.map(function(x) {
            return {
              Month: Number(x.Month || x.month || 0),
              MonthName: x.MonthName || x.monthName || x.monthname || "",
              person_uid: x.person_uid || x.EmployeeID || x.employee_id || x.id || "",
              count: Number(x.count || x.value || 0),
              EmployeeID: x.EmployeeID || x.employee_id || '',
              EmployeeName: x.EmployeeName || ''
            };
          }) : [];

          // day-wise (for selected month) — optional
          const rawDayTotals = js.day_totals || js.dayTotals || [];
          const normalizedDayTotals = Array.isArray(rawDayTotals) ? rawDayTotals.map(function(x) {
            return {
              Day: Number(x.Day || x.day || 0),
              count: Number(x.count || x.value || 0)
            };
          }) : [];

          const rawDayByLoc = js.day_by_location || js.dayByLocation || [];
          const normalizedDayByLoc = Array.isArray(rawDayByLoc) ? rawDayByLoc.map(function(x) {
            return {
              Day: Number(x.Day || x.day || 0),
              PartitionName2: x.PartitionName2 || x.Partition || x.location || "",
              count: Number(x.count || x.value || 0)
            };
          }) : [];

          // parse person_map (if provided)
          const rawPersonMap = js.person_map || js.personMap || {};
          const normalizedPersonMap = {};
          Object.keys(rawPersonMap || {}).forEach(k => {
            const v = rawPersonMap[k] || {};
            normalizedPersonMap[String(k)] = {
              EmployeeID: v.EmployeeID || v.employeeId || v.EmployeeId || '',
              EmployeeName: v.EmployeeName || v.EmployeeName || v.name || ''
            };
          });

          // compute derived metrics locally
          const unique = new Set((normalizedByEmp || []).map(function(e){ return e.id; }).filter(Boolean));
          const repeaters = (normalizedByEmp || []).filter(function(e){ return e.count > 1; });

          // Now update React state in one go
          setTotal(Number(total_rejections || 0));
          setByLocation(normalizedByLoc);
          setByEmployee(normalizedByEmp);
          setRecent(Array.isArray(rawRecent) ? rawRecent : []);
          setUniqueEmployees(unique.size);
          setRepeatersCount(repeaters.length);

          setMonthTotals(normalizedMonthTotals);
          setMonthByLocation(normalizedMonthByLoc);
          setMonthByEmployee(normalizedMonthByEmp);

          setPersonMap(normalizedPersonMap);
          setDayTotals(normalizedDayTotals);
          setDayByLocation(normalizedDayByLoc);

          // update charts in-place (no flicker)
          if (locChartRef.current) {
            const topLoc = (normalizedByLoc || []).slice(0,12);
            const labels = topLoc.map(function(x){ return x.name || 'Unknown'; });
            const values = topLoc.map(function(x){ return x.count || 0; });
            updateOrCreateChart(locChartInst, locChartRef.current, {
              type: 'line',
              data: {
                labels: labels,
                datasets: [{
                  label: 'PIN rejections',
                  data: values,
                  borderColor: '#2563eb',
                  backgroundColor: 'rgba(37,99,235,0.2)',
                  fill: true,
                  tension: 0.3,
                  pointBackgroundColor: '#2563eb',
                  pointRadius: 5,
                  pointHoverRadius: 7,
                  borderWidth: 2
                }]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: { x: { type: 'category' }, y: { beginAtZero: true, ticks: { precision: 0 } } }
              }
            });
          }

          // Month / Day totals chart
          if (monthChartRef.current) {
            if (selectedMonth === 0) {
              // monthly view (12 month buckets)
              var monthArr = Array.from({length:12}, function(_,i) {
                var m = i + 1;
                var rec = null;
                for (var ri = 0; ri < normalizedMonthTotals.length; ri++) {
                  var cand = normalizedMonthTotals[ri];
                  if (Number(cand.Month) === m) { rec = cand; break; }
                }
                return rec && rec.count ? Number(rec.count) : 0;
              });
              updateOrCreateChart(monthChartInst, monthChartRef.current, {
                type: 'line',
                data: { labels: MONTH_NAMES, datasets: [{ label: 'Monthly PIN rejections', data: monthArr, fill:false, tension:0.3 }] },
                options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
              });
            } else {
              // day-wise view for the selected month
              const daysInMonth = new Date(Number(year), Number(selectedMonth), 0).getDate();
              const labels = Array.from({length: daysInMonth}, (_,i) => String(i+1));
              const dayArr = Array.from({length: daysInMonth}, function(_,i) {
                const d = i + 1;
                var rec = null;
                for (var ri = 0; ri < normalizedDayTotals.length; ri++) {
                  var cand = normalizedDayTotals[ri];
                  if (Number(cand.Day) === d) { rec = cand; break; }
                }
                return rec && rec.count ? Number(rec.count) : 0;
              });
              updateOrCreateChart(monthChartInst, monthChartRef.current, {
                type: 'line',
                data: { labels: labels, datasets: [{ label: `Day-wise for ${MONTH_NAMES[selectedMonth-1]}`, data: dayArr, fill:false, tension:0.3 }] },
                options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
              });
            }
          }

          setLastFetch(new Date().toISOString());

        } catch (err) {
          console.error("Fetch EMEA PIN failed", err);
        } finally {
          setLoading(false);
          inFlightRef.current = false;
        }
      }

      // details fetch unchanged (keeps server-side filter + pagination). We'll still use it.
      async function fetchDetails(opts = {}) {
        const emp = opts.employeeId !== undefined ? opts.employeeId : detailsEmployeeId;
        const fromD = opts.fromDate !== undefined ? opts.fromDate : detailsFromDate;
        const toD = opts.toDate !== undefined ? opts.toDate : detailsToDate;
        const lim = opts.limit !== undefined ? opts.limit : detailsLimit;
        const off = opts.offset !== undefined ? opts.offset : detailsOffset;
        const loc = opts.location !== undefined ? opts.location : location;
        const yr = opts.year !== undefined ? opts.year : year;

        setDetailsLoading(true);
        try {
          const params = new URLSearchParams();
          if (yr) params.set('year', String(yr));
          if (loc && loc !== 'All locations') params.set('location', loc);
          if (emp) params.set('employee_id', emp);
          if (fromD) params.set('from_date', fromD);
          if (toD) params.set('to_date', toD);
          params.set('limit', String(lim));
          params.set('offset', String(off));

          const url = API_ENDPOINT.replace('/api/emea_pin_live','/api/emea_pin_details') + '?' + params.toString();
          const r = await fetch(url, { cache: 'no-store' });
          if (!r.ok) {
            const txt = await r.text().catch(()=> '');
            throw new Error('Details API error: ' + r.status + ' ' + txt);
          }
          const js = await r.json();
          setDetailsRows(js.rows || []);
          setDetailsTotal(js.total || 0);
          setDetailsLimit(js.limit || lim);
          setDetailsOffset(js.offset || off);
        } catch (err) {
          console.error("Fetch details failed", err);
          alert("Failed to load details: " + err.message);
        } finally {
          setDetailsLoading(false);
        }
      }

      // --------- CLIENT-SIDE EXPORT (exports exactly what UI shows) ----------
      function exportDetailsCSVClient() {
        // We export ALL filtered rows (not only current page) to match UI filtering.
        const filtered = getFilteredDetailsAll();
        if (!filtered || filtered.length === 0) { alert("No rows to export"); return; }

        // Prepare row objects with exact columns/order
        const rowsForCsv = filtered.map((r, idx) => ({
          "Sr. No": idx + 1,
          "EmployeeID": r.EmployeeID || r.person_uid || '',
          "EmployeeName": r.EmployeeName || '',
          "Date": r.Date || r.DateOnly || '',
          "Time": r.Time || '',
          "Card": r.CardNumber || '',
          "Direction": r.Direction || '',
          "Door": r.DoorName || '',
          "Alert Type": r.Rejection_Type || r.RejectionType || '',
          "Location": r.Location || r.PartitionName2 || ''
        }));

        const filename = `emea_pin_details_${year}_${(detailsFromDate||'')}_${(detailsToDate||'')}.csv`.replace(/__+/g,'_').replace(/(^_|_$)/g,'');
        const columnsOrder = ["Sr. No","EmployeeID","EmployeeName","Date","Time","Card","Direction","Door","Alert Type","Location"];
        downloadCSV(rowsForCsv, filename, columnsOrder);
      }

      // Helper: return all filtered details (not paginated)
      function getFilteredDetailsAll() {
        if (!detailsRows || detailsRows.length === 0) return [];
        const f = detailsRows.filter(r => {
          // apply every active filter (substring match, case-insensitive)
          const checks = [
            { key: 'employeeId', val: (r.EmployeeID||r.person_uid||'') },
            { key: 'name', val: (r.EmployeeName||'') },
            { key: 'date', val: (r.Date||r.DateOnly||'') },
            { key: 'time', val: (r.Time||'') },
            { key: 'card', val: (r.CardNumber||'') },
            { key: 'direction', val: (r.Direction||'') },
            { key: 'door', val: (r.DoorName||'') },
            { key: 'alert', val: (r.Rejection_Type||r.RejectionType||'') },
            { key: 'location', val: (r.Location||r.PartitionName2||'') }
          ];
          for (let i=0;i<checks.length;i++){
            const key = checks[i].key;
            const fieldVal = String(checks[i].val || '').toLowerCase();
            const filterVal = String(columnFilters[key] || '').toLowerCase().trim();
            if (filterVal && !fieldVal.includes(filterVal)) return false;
          }
          return true;
        });
        return f;
      }

      // When returning to dashboard, destroy chart instances so they are recreated (keeps charts fresh)
      useEffect(() => {
        if (view === 'dashboard') {
          try { if (locChartInst.current) { locChartInst.current.destroy(); } } catch(_) {}
          try { if (monthChartInst.current) { monthChartInst.current.destroy(); } } catch(_) {}
          locChartInst.current = null;
          monthChartInst.current = null;
          fetchOnce();
        }
      }, [view]);

      // initial mount: create placeholder charts (unchanged)
      useEffect(function() {
        if (locChartRef.current && !locChartInst.current) {
          updateOrCreateChart(locChartInst, locChartRef.current, {
            type: 'line',
            data: { labels: [], datasets: [{ label: 'PIN rejections', data: [], borderColor:'#2563eb', backgroundColor:'rgba(37,99,235,0.2)', fill:true, tension:0.3 }]},
            options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
          });
        }
        if (monthChartRef.current && !monthChartInst.current) {
          updateOrCreateChart(monthChartInst, monthChartRef.current, {
            type: 'line',
            data: { labels: MONTH_NAMES, datasets: [{ label: 'Monthly PIN rejections', data: Array(12).fill(0), fill:false, tension:0.3 }]},
            options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
          });
        }
      }, []);

      // Derived: filtered & paginated rows for display in the details table
      const filteredAll = useMemo(() => getFilteredDetailsAll(), [detailsRows, columnFilters]);
      const paginatedRows = useMemo(() => {
        const start = Math.max(0, detailsOffset || 0);
        const lim = Math.max(1, detailsLimit || 200);
        return filteredAll.slice(start, start + lim);
      }, [filteredAll, detailsOffset, detailsLimit]);

      // ---- DetailsPanel component (updated with filters, sr.no and export change) ----
      const DetailsPanel = () => {
        const start = detailsOffset || 0;
        const end = Math.min(detailsTotal, start + detailsLimit);

        return (
          <div style={{ padding:12, background:'#fff', borderRadius:10, border: '2px solid #e6eefb' }}>
            <div style={{ display:'flex', gap:8, alignItems:'center', marginBottom:12 }}>
              <label style={{ fontSize:13 }}>Employee ID</label>
              <input type="text" value={detailsEmployeeId} onChange={e=>setDetailsEmployeeId(e.target.value)} style={{ padding:6, borderRadius:6 }} />
              <label style={{ fontSize:13 }}>From</label>
              <input type="date" value={detailsFromDate} onChange={e=>setDetailsFromDate(e.target.value)} style={{ padding:6, borderRadius:6 }} />
              <label style={{ fontSize:13 }}>To</label>
              <input type="date" value={detailsToDate} onChange={e=>setDetailsToDate(e.target.value)} style={{ padding:6, borderRadius:6 }} />
              <button className="btn-primary" onClick={() => { setDetailsOffset(0); fetchDetails({ employeeId: detailsEmployeeId, fromDate: detailsFromDate, toDate: detailsToDate, offset:0 }); }}>Search</button>
              <button className="small-button" onClick={() => { setDetailsEmployeeId(''); setDetailsFromDate(''); setDetailsToDate(''); setDetailsOffset(0); fetchDetails({ employeeId:'', fromDate:'', toDate:'', offset:0 }); }}>Reset</button>
              <button className="small-button" onClick={() => exportDetailsCSVClient()}>Export CSV</button>
              <button className="small-button" onClick={() => setView('dashboard')}>Back</button>
            </div>

            <div style={{ maxHeight:520, overflow:'auto', border:'2px solid #e6eefb', padding:8 }}>
              <table className="compact-table" style={{ width:'100%', borderCollapse:'collapse' }}>
                <thead>
                  <tr>
                    <th className="srcol">Sr. No</th>
                    <th>EmployeeID</th>
                    <th>Name</th>
                    <th>Date</th>
                    <th>Time</th>
                    <th>Card</th>
                    <th>Direction</th>
                    <th>Door</th>
                    <th>Alert Type</th>
                    <th>Location</th>
                  </tr>
                  {/* FILTER ROW */}
                  <tr>
                    <th className="srcol"><input className="filter-input" placeholder="—" disabled/></th>
                    <th><input className="filter-input" placeholder="Filter ID" value={columnFilters.employeeId} onChange={e=>setFilter('employeeId', e.target.value)} /></th>
                    <th><input className="filter-input" placeholder="Filter Name" value={columnFilters.name} onChange={e=>setFilter('name', e.target.value)} /></th>
                    <th><input className="filter-input" placeholder="YYYY-MM-DD" value={columnFilters.date} onChange={e=>setFilter('date', e.target.value)} /></th>
                    <th><input className="filter-input" placeholder="HH:MM:SS" value={columnFilters.time} onChange={e=>setFilter('time', e.target.value)} /></th>
                    <th><input className="filter-input" placeholder="Filter Card" value={columnFilters.card} onChange={e=>setFilter('card', e.target.value)} /></th>
                    <th><input className="filter-input" placeholder="In/Out" value={columnFilters.direction} onChange={e=>setFilter('direction', e.target.value)} /></th>
                    <th><input className="filter-input" placeholder="Filter Door" value={columnFilters.door} onChange={e=>setFilter('door', e.target.value)} /></th>
                    <th><input className="filter-input" placeholder="Filter Alert" value={columnFilters.alert} onChange={e=>setFilter('alert', e.target.value)} /></th>
                    <th><input className="filter-input" placeholder="Filter Location" value={columnFilters.location} onChange={e=>setFilter('location', e.target.value)} /></th>
                  </tr>
                </thead>
                <tbody>
                  {detailsLoading && <tr><td colSpan="10" className="muted">Loading…</td></tr>}
                  {!detailsLoading && paginatedRows.length===0 && <tr><td colSpan="10" className="muted">No rows</td></tr>}
                  {!detailsLoading && paginatedRows.map((r,i)=>(
                    <tr key={i}>
                      <td style={{ padding:6, textAlign:'center' }}>{start + i + 1}</td>
                      <td style={{ padding:6, textAlign:'center' }}>{r.EmployeeID || r.person_uid || '-'}</td>
                      <td style={{ padding:6 }} className="col-name">{r.EmployeeName || '-'}</td>
                      <td style={{ padding:6, textAlign:'center' }}>{r.Date || r.DateOnly || '-'}</td>
                      <td style={{ padding:6, textAlign:'center' }}>{r.Time || '-'}</td>
                      <td style={{ padding:6, textAlign:'center' }}>{r.CardNumber || '-'}</td>
                      <td style={{ padding:6, textAlign:'center' }}>{r.Direction || '-'}</td>
                      <td style={{ padding:6 }} className="col-door">{r.DoorName || '-'}</td>
                      <td style={{ padding:6, textAlign:'center' }}>{r.Rejection_Type || r.RejectionType || '-'}</td>
                      <td style={{ padding:6, textAlign:'center' }}>{r.Location || r.PartitionName2 || '-'}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>

            <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginTop:8 }}>
              <div style={{ fontSize:13 }}>{`Showing ${start+1} - ${Math.min(start + paginatedRows.length, filteredAll.length)} of ${filteredAll.length}`}</div>
              <div style={{ display:'flex', gap:8 }}>
                <button className="small-button" onClick={() => { const no = Math.max(0, detailsOffset - detailsLimit); setDetailsOffset(no); }} disabled={detailsOffset <= 0}>Prev</button>
                <button className="small-button" onClick={() => { const no = detailsOffset + detailsLimit; if (no < filteredAll.length) { setDetailsOffset(no); } }} disabled={detailsOffset + detailsLimit >= filteredAll.length}>Next</button>
                <select value={detailsLimit} onChange={e=>{ const l = Number(e.target.value||200); setDetailsLimit(l); setDetailsOffset(0); }}>
                  <option value={50}>50</option>
                  <option value={100}>100</option>
                  <option value={200}>200</option>
                  <option value={500}>500</option>
                </select>
              </div>
            </div>
          </div>
        );
      };

      // ---- Render (keeps rest of your dashboard unchanged) ----
      return (
        <div className="container" >
          {/* TOPBAR (common) */}
          <div className="topbar" role="banner">
            <div style={{ display:'flex', alignItems:'center', gap:12, justifyContent:'center' }}>
              <div className="wu-logo">WU</div>
              <div style={{ flex: 1 }}>
                <h1 style={{ margin: 0, fontSize: 18 }}>EMEA PIN — Live Dashboard</h1>
                <div style={{ fontSize: 13, color: 'rgba(255,255,255,0.9)' }}>Live PIN rejections</div>
              </div>
            </div>

            <div className="header-actions">
              <div style={{ display:'flex', gap:8, alignItems:'center' }} className="top-controls">
                <label className="small" style={{ color:'#fff' }}>Year</label>
                <input type="number" value={year} onChange={(e)=>setYear(Number(e.target.value||new Date().getFullYear()))} style={{ width:100, padding:6, borderRadius:6 }} />

                <label className="small" style={{ color:'#fff' }}>Month</label>
                <select value={selectedMonth} onChange={e=>setSelectedMonth(Number(e.target.value))} style={{ padding:6, borderRadius:6 }}>
                  <option value={0}>All months</option>
                  {Array.from({length:12},(_,i)=>i+1).map(m => <option key={m} value={m}>{MONTH_NAMES[m-1]} ({m})</option>)}
                </select>

                <label className="small" style={{ color:'#fff' }}>Location</label>
                <select value={location} onChange={e=>setLocation(e.target.value)} style={{ padding:6, borderRadius:6 }}>
                  <option>All locations</option>
                  {EMEA_PARTITIONS.map(p => <option key={p} value={p}>{p}</option>)}
                </select>

                <button className="btn-ghost" onClick={() => { setLive(!live); }}>{live ? 'Pause' : 'Resume'}</button>
                <button className="btn-primary" onClick={fetchOnce} disabled={loading}>Refresh</button>
                <button className="small-button" onClick={() => {/* unchanged */}}>Export Month-By-Location</button>
              </div>
            </div>
          </div>

          {/* MAIN BODY (unchanged layout) */}
          { view === 'dashboard' ? (
            <div style={{ display:'flex', gap:12 }}>
              <div style={{ flex:1 }}>
                <div className="cards" style={{ marginBottom:10 }}>
                  <div className="card">
                    <div className="card-content">
                      <div className="card-text" style={{ textAlign:'center' }}>
                        <h3>{total.toLocaleString()}</h3>
                        <p>Total rejections</p>
                      </div>
                    </div>
                  </div>
                  <div className="card">
                    <div className="card-content">
                      <div className="card-text" style={{ textAlign:'center' }}>
                        <h3>{uniqueEmployees.toLocaleString()}</h3>
                        <p>Unique employees</p>
                      </div>
                    </div>
                  </div>
                  <div className="card">
                    <div className="card-content">
                      <div className="card-text" style={{ textAlign:'center' }}>
                        <h3>{repeatersCount.toLocaleString()}</h3>
                        <p>Repeat offenders</p>
                      </div>
                    </div>
                  </div>
                </div>

                <div style={{ background:'#fff', padding:12, borderRadius:10, boxShadow:'0 6px 18px rgba(2,6,23,0.04)' }}>
                  <h3 style={{ marginTop:0, textAlign:'center' }}>Location wise</h3>
                  <div className="chart-wrap chart-small" style={{ marginBottom:12 }}>
                    <canvas ref={locChartRef}></canvas>
                  </div>

                  <div style={{ marginTop:10, fontSize:13, color:'#64748b' }}>
                    Last fetch: {lastFetch ? new Date(lastFetch).toLocaleString() : 'never'} {loading ? ' • loading…' : ''}
                  </div>
                </div>

                {/* Month panel */}
                <div style={{ marginTop:12, background:'#fff', padding:12, borderRadius:10, boxShadow:'0 6px 18px rgba(2,6,23,0.04)' }}>
                  <h3 style={{ marginTop:0, textAlign:'center' }}>Month-wise analysis</h3>

                  <div className="month-panel">
                    <div style={{ marginLeft: 8 }}>
                      <button className="small-button" onClick={() => {/* unchanged */}}>Export Month Location CSV</button>
                    </div>
                  </div>

                  <div className="chart-wrap month-chart-wrap" style={{ marginTop:10 }}>
                    <canvas ref={monthChartRef}></canvas>
                  </div>
                </div>

              </div>

              <aside style={{ width: 340 }}>
                <div className="card" style={{ padding:10, textAlign:'center' }}>
                  <h4 style={{ marginTop:0 }}>Details</h4>
                  <hr />
                  <div>
                    <b>Total rejections:</b> {total}
                  </div>
                  <div><b>Unique employees:</b> {uniqueEmployees}</div>
                  <div><b>Repeaters:</b> {repeatersCount}</div>
                  <hr />
                  <div>
                    <h5 style={{ margin:'6px 0', textAlign:'center' }}>
                      Top locations{selectedMonth === 0 ? " — All months" : ` - ${MONTH_NAMES[selectedMonth-1]}`}
                    </h5>
                    <div style={{ maxHeight:300, overflow:'auto' }}>
                      <table className="compact-table">
                        <thead><tr><th>Location</th><th>Count</th></tr></thead>
                        <tbody>
                          {topForSelectedMonthByLocation(50).map((r,i) => (
                            <tr key={i}><td style={{ padding:'6px 8px', textAlign:'center' }}>{r.PartitionName2 || r.name || '-'}</td><td style={{ padding:'6px 8px', textAlign:'center' }}>{r.count}</td></tr>
                          ))}
                          {(topForSelectedMonthByLocation(50).length===0) && <tr><td colSpan="2" className="muted">No location data</td></tr>}
                        </tbody>
                      </table>
                    </div>
                  </div>
                </div>

                <div style={{ height:12 }} />

                <div className="card" style={{ padding:10, textAlign:'center' }}>
                  <h4 style={{ marginTop:0 }}>Top repeaters{selectedMonth === 0 ? " — All months" : ` - ${MONTH_NAMES[selectedMonth-1]}`}</h4>
                  <div style={{ maxHeight:260, overflow:'auto' }}>
                    <table className="compact-table">
                      <thead><tr><th>EmployeeID</th><th>Name</th><th>Count</th></tr></thead>
                      <tbody>
                        {displayTopRepeaters.map((r,i)=>(
                          <tr key={i}>
                            <td style={{ padding:'6px 8px', textAlign:'center' }}>{r.id || '-'}</td>
                            <td style={{ padding:'6px 8px', textAlign:'left' }}>{r.name || '-'}</td>
                            <td style={{ padding:'6px 8px', textAlign:'center' }}>{r.count}</td>
                          </tr>
                        ))}
                        {(displayTopRepeaters.length===0) && <tr><td colSpan="3" className="muted">No repeaters data</td></tr>}
                      </tbody>
                    </table>
                  </div>
                </div>

                <div style={{ height:12 }} />
                <div className="card" style={{ padding:10, textAlign:'center' }}>
                  <h4 style={{ marginTop:0 }}>Actions</h4>
                  <div style={{ display:'flex', gap:8, justifyContent:'center' }}>
                    <button className="small-button" onClick={() => { setLocation('All locations'); setYear(new Date().getFullYear()); setSelectedMonth(0); }}>Reset</button>
                    <button className="small-button" onClick={() => {
                      // Export recent (use current recent array)
                      const rows = (recent||[]).slice(0,200).map((r, idx) => ({
                        "Sr. No": idx+1,
                        "EmployeeID": r.EmployeeID || r.person_uid || '',
                        "EmployeeName": r.EmployeeName || '',
                        "Date": r.Date || r.DateOnly || '',
                        "Time": r.Time || '',
                        "Card": r.CardNumber || '',
                        "Direction": r.Direction || '',
                        "Door": r.DoorName || '',
                        "Alert Type": r.Rejection_Type || r.RejectionType || '',
                        "Location": r.Location || r.PartitionName2 || ''
                      }));
                      const cols = ["Sr. No","EmployeeID","EmployeeName","Date","Time","Card","Direction","Door","Alert Type","Location"];
                      downloadCSV(rows, `emea_pin_recent_${year}.csv`, cols);
                    }}>Export Recent</button>
                    <button className="small-button" onClick={() => { setView('details'); setDetailsOffset(0); fetchDetails({ offset:0 }); }}>Details</button>
                  </div>
                </div>

              </aside>
            </div>
          ) : (
            // DETAILS PAGE — full-width, no aside/summary
            <div style={{ paddingBottom: 20 }}>
              <div style={{ marginBottom: 12 }}>
                <button className="small-button" onClick={() => setView('dashboard')}>← Back to dashboard</button>
              </div>
              <DetailsPanel />
            </div>
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(EmeaPinApp));
  })();
  </script>
</body>
</html>















#C:\Users\W0024618\Desktop\Trend Analysis\backend\emea_pin.py
"""
EMEA PIN violation analysis.

Usage:
    python -m backend.emea_pin --year 2024 --outdir ./out
"""
from __future__ import annotations

import argparse
import logging
from datetime import date
from pathlib import Path
from typing import List
import sys

import pandas as pd

# Robust import for duration_report (works when module loaded as package or as plain module)
try:
    from backend import duration_report as dr
except Exception:
    try:
        import duration_report as dr
    except Exception as e:
        raise RuntimeError(f"Could not import duration_report (tried 'backend.duration_report' and 'duration_report'): {e}") from e

# local alias (may be None if duration_report couldn't supply it)
pyodbc = getattr(dr, "pyodbc", None)

LOG = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")


SQL_DB_TEMPLATE = r"""
SELECT
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    t1.ObjectName1 AS EmployeeName,
    t1.PartitionName2 AS PartitionName2,
    COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
      sc.value,
      NULLIF(CAST(t2.[Int1] AS NVARCHAR),'0'),
      t2.[Text12]
    ) AS CardNumber,
    t5rej.value AS Rejection_Type,
    CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR) END AS EmployeeID,
    t3.Name AS PersonnelType,
    t1.ObjectName2 AS DoorName,
    t5dir.value AS Direction,
    t1.XmlGUID
FROM [{db}].dbo.ACVSUJournalLog t1
LEFT JOIN ACVSCore.Access.Personnel t2 ON t1.ObjectIdentity1 = t2.GUID
LEFT JOIN ACVSCore.Access.PersonnelType t3 ON t2.PersonnelTypeID = t3.ObjectID
LEFT JOIN [{db}].dbo.ACVSUJournalLogxml t_xml ON t1.XmlGUID = t_xml.GUID
LEFT JOIN [{db}].dbo.ACVSUJournalLogxmlShred sc ON t1.XmlGUID = sc.GUID AND sc.Name IN ('Card','CHUID')
-- shredded RejectCode
LEFT JOIN [{db}].dbo.ACVSUJournalLogxmlShred t5rej ON t1.XmlGUID = t5rej.GUID AND t5rej.Name = 'RejectCode'
-- shredded Direction: sometimes value contains InDirection / OutDirection
LEFT JOIN [{db}].dbo.ACVSUJournalLogxmlShred t5dir ON t1.XmlGUID = t5dir.GUID AND (t5dir.Value IN ('InDirection','OutDirection') OR t5dir.Name IN ('Direction','Dir'))
WHERE
    t1.MessageType = 'CardRejected'
    AND t5rej.value = 'PIN'
  
    AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) BETWEEN '{start}' AND '{end}'
"""

def _get_emea_databases() -> List[str]:
    rc = dr.REGION_CONFIG.get("emea")
    if not rc:
        raise RuntimeError("No 'emea' region config found in duration_report.py")
    candidates = dr._get_candidate_databases(rc)
    valid = dr._filter_existing_databases(rc, candidates)
    return valid or candidates

def _connect_to_db(server: str, database: str, user: str, password: str):
    if pyodbc is None:
        raise RuntimeError("pyodbc not available; install pyodbc to run queries.")
    conn_str = (
        f"DRIVER={{{dr.ODBC_DRIVER}}};"
        f"SERVER={server};DATABASE={database};UID={user};PWD={password};"
        "TrustServerCertificate=Yes;"
    )
    return pyodbc.connect(conn_str, autocommit=True)

def fetch_pin_rows_for_year(target_year: int) -> pd.DataFrame:
    rc = dr.REGION_CONFIG["emea"]
    start = date(target_year, 1, 1).strftime("%Y-%m-%d")
    end = date(target_year, 12, 31).strftime("%Y-%m-%d")
    dbs = _get_emea_databases()
    LOG.info("Querying EMEA databases: %s", dbs)

    frames = []
    for db in dbs:
        sql = SQL_DB_TEMPLATE.format(db=db, start=start, end=end)
        LOG.info("Running query against %s.%s (rows may be large)", rc["server"], db)
        conn = None
        try:
            conn = _connect_to_db(rc["server"], db, rc["user"], rc["password"])
            # pandas will pull the results into a DataFrame
            df = pd.read_sql(sql, conn)
            if not df.empty:
                frames.append(df)
        except Exception:
            LOG.exception("Failed to fetch from database %s", db)
        finally:
            try:
                if conn is not None:
                    conn.close()
            except Exception:
                pass

    if not frames:
        return pd.DataFrame(columns=[
            "LocaleMessageTime", "EmployeeName", "PartitionName2", "CardNumber",
            "Rejection_Type", "EmployeeID", "PersonnelType", "DoorName", "Direction", "XmlGUID"
        ])
    out = pd.concat(frames, ignore_index=True)
    # normalize types
    out["LocaleMessageTime"] = pd.to_datetime(out["LocaleMessageTime"], errors="coerce")

    # IMPORTANT CHANGE: store DateOnly AS STRING (ISO) to avoid python date objects
    out["DateOnly"] = out["LocaleMessageTime"].dt.strftime("%Y-%m-%d")

    # Add Month and MonthName for month-wise analysis
    out["Month"] = out["LocaleMessageTime"].dt.month.fillna(0).astype("Int64")  # pandas nullable int
    out["MonthName"] = out["LocaleMessageTime"].dt.strftime("%b").fillna("")

    # ensure columns exist
    for c in ["EmployeeID", "EmployeeName", "CardNumber", "PartitionName2", "Direction"]:
        if c not in out.columns:
            out[c] = None

    # Normalize Direction values to friendly 'In'/'Out'
    if "Direction" in out.columns:
        try:
            def _norm_dir(v):
                if v is None:
                    return None
                s = str(v).strip()
                if not s:
                    return None
                ls = s.lower()
                if "in" in ls:
                    return "In"
                if "out" in ls:
                    return "Out"
                # fallback: common labels
                if ls in ("entry", "enter", "entered"):
                    return "In"
                if ls in ("exit", "leave", "left"):
                    return "Out"
                return s  # keep original as last resort
            out["Direction"] = out["Direction"].apply(_norm_dir)
        except Exception:
            LOG.exception("Failed to normalize Direction values; leaving raw values")

    # restrict to PersonnelType == 'Employee' (defensive)
    if "PersonnelType" in out.columns:
        out = out[out["PersonnelType"].fillna("").str.strip().str.lower() == "employee"].copy()
    # canonical person uid using helper from duration_report
    def make_person_uid(row):
        try:
            return dr._canonical_person_uid_from_row(row)
        except Exception:
            # fallback: prefer EmployeeID -> CardNumber -> EmployeeName
            for cand in ("EmployeeID", "CardNumber", "EmployeeName"):
                v = row.get(cand)
                if v is not None and str(v).strip():
                    return str(v).strip()
            return None
    if not out.empty:
        out["person_uid"] = out.apply(make_person_uid, axis=1)
    return out

def analyze_pin_df(df: pd.DataFrame, outdir: Path) -> dict:
    outdir.mkdir(parents=True, exist_ok=True)
    results = {}
    total = len(df)
    results["total_rejections"] = int(total)
    LOG.info("Total PIN rejections in dataset: %d", total)

    # ensure month columns exist and are in friendly form
    if "Month" not in df.columns:
        df["Month"] = pd.to_datetime(df.get("LocaleMessageTime", None), errors="coerce").dt.month.fillna(0).astype(int)
    if "MonthName" not in df.columns:
        df["MonthName"] = pd.to_datetime(df.get("LocaleMessageTime", None), errors="coerce").dt.strftime("%b").fillna("")

    # by location (PartitionName2)
    by_loc = df.groupby("PartitionName2", dropna=False).size().reset_index(name="count").sort_values("count", ascending=False)
    results["by_location"] = by_loc
    by_loc.to_csv(outdir / "emea_pin_by_location.csv", index=False)

    # by employee (person_uid) - top offenders
    by_emp = df.groupby("person_uid", dropna=False).size().reset_index(name="count").sort_values("count", ascending=False)
    results["by_employee"] = by_emp
    by_emp.to_csv(outdir / "emea_pin_by_employee.csv", index=False)

    # repeaters: employees with count > 1
    repeaters = by_emp[by_emp["count"] > 1].copy()
    results["repeaters"] = repeaters
    repeaters.to_csv(outdir / "emea_pin_repeaters.csv", index=False)

    # MONTH-WISE: total by month
    month_totals = (df.groupby(["Month", "MonthName"], dropna=False)
                    .size()
                    .reset_index(name="count")
                    .sort_values(["Month"]))
    results["month_totals"] = month_totals
    month_totals.to_csv(outdir / "emea_pin_month_totals.csv", index=False)

    # MONTH-WISE: location-wise counts per month
    month_loc = (df.groupby(["Month", "MonthName", "PartitionName2"], dropna=False)
                 .size()
                 .reset_index(name="count")
                 .sort_values(["Month", "count"], ascending=[True, False]))
    results["month_by_location"] = month_loc
    month_loc.to_csv(outdir / "emea_pin_month_by_location.csv", index=False)

    # MONTH-WISE: employee-wise counts per month
    month_emp = (df.groupby(["Month", "MonthName", "person_uid"], dropna=False)
                 .size()
                 .reset_index(name="count")
                 .sort_values(["Month", "count"], ascending=[True, False]))
    results["month_by_employee"] = month_emp
    month_emp.to_csv(outdir / "emea_pin_month_by_employee.csv", index=False)

    # summary stats
    results["unique_employees"] = int(by_emp["person_uid"].nunique()) if "person_uid" in by_emp.columns else int(by_emp.shape[0])
    results["repeat_count_total"] = int(repeaters["count"].sum()) if not repeaters.empty else 0
    results["num_repeaters"] = int(len(repeaters))
    LOG.info("Unique employees with PIN rejects: %s", results["unique_employees"])
    LOG.info("Number of repeaters (count>1): %s, total repeat events: %s", results["num_repeaters"], results["repeat_count_total"])

    # Save full raw dataframe for audit (DateOnly as string avoids JSON issues)
    df.to_csv(outdir / "emea_pin_raw.csv", index=False)

    return results

def main():
    parser = argparse.ArgumentParser(description="EMEA PIN rejection analysis (yearly).")
    parser.add_argument("--year", type=int, required=False, default=date.today().year, help="Year to analyze (e.g. 2024)")
    parser.add_argument("--outdir", required=False, default="./out", help="Output directory for CSVs")
    args = parser.parse_args()

    target_year = int(args.year)
    outdir = Path(args.outdir)

    LOG.info("Starting EMEA PIN analysis for year %d", target_year)
    df = fetch_pin_rows_for_year(target_year)
    LOG.info("Rows fetched: %d", len(df))
    results = analyze_pin_df(df, outdir)
    # print short summary
    print("==== EMEA PIN analysis summary ====")
    print(f"Year: {target_year}")
    print(f"Total PIN rejections: {results.get('total_rejections', 0)}")
    print(f"Unique employees with rejects: {results.get('unique_employees', 0)}")
    print(f"Repeaters (employees with >1 reject): {results.get('num_repeaters', 0)}  (repeat events total: {results.get('repeat_count_total', 0)})")
    print(f"CSV outputs saved to: {outdir.resolve()}")

if __name__ == "__main__":
    main()
















From backend We dont get Direction correct once check Direction logic carefully and fix Direction logic in backned 
Check this Direction 
  t5_dir.Value AS Direction,




WITH CombinedQuery AS(
  SELECT 
     DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    t1.ObjectName1 AS EmployeeName,
    t1.PartitionName2 AS location,
    t5_card.CardNumber,
    t5_admit.value AS AdmitCode,
    t5_dir.Value AS Direction,
    t1.ObjectName2 AS DoorName,
    t5_rej.value AS Rejection_Type,

    CASE 
        WHEN t3.Name IN ('Contractor', 'Terminated Contractor') THEN t2.Text12
        ELSE CAST(t2.Int1 AS NVARCHAR)
    END AS EmployeeID,
    t3.Name AS PersonnelType,
    t1.MessageType,
    t1.XmlGUID
 FROM
    [ACVSUJournal_00011029].[dbo].[ACVSUJournalLog] AS t1
LEFT JOIN
    [ACVSCore].[Access].[Personnel] AS t2
    ON t1.ObjectIdentity1 = t2.GUID
LEFT JOIN
    [ACVSCore].[Access].[PersonnelType] AS t3
    ON t2.[PersonnelTypeId] = t3.[ObjectID]
LEFT JOIN
    [ACVSUJournal_00011029].[dbo].[ACVSUJournalLogxmlShred] AS t5_admit
    ON t1.XmlGUID = t5_admit.GUID
    AND t5_admit.Name = 'AdmitCode'
LEFT JOIN
    [ACVSUJournal_00011029].[dbo].[ACVSUJournalLogxmlShred] AS t5_dir
    ON t1.XmlGUID = t5_dir.GUID
    AND t5_dir.Value IN ('InDirection', 'OutDirection')
LEFT JOIN 
    [ACVSUJournal_00011029].[dbo].[ACVSUJournalLogxml] AS t_xml
    ON t1.XmlGUID = t_xml.GUID
-- Pre-pull shredded Card row
LEFT JOIN (
    SELECT GUID, [value]
    FROM [ACVSUJournal_00011029].[dbo].[ACVSUJournalLogxmlShred]
    WHERE [Name] IN ('Card', 'CHUID')
) AS SCard
ON t1.XmlGUID = SCard.GUID
/* NEW: three-stage CardNumber resolution */
OUTER APPLY (
    SELECT COALESCE(
        TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]', 'varchar(50)'),
        TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]', 'varchar(50)'),
        SCard.[value]
    ) AS CardNumber
) AS t5_card
LEFT JOIN
    [ACVSUJournal_00011029].[dbo].[ACVSUJournalLogxmlShred] AS t5_Rej
    ON t1.XmlGUID = t5_Rej.GUID
    AND t5_Rej.Name = 'RejectCode'
WHERE
    MessageType = 'CardRejected'
),
-- Return only Wrong PIN alerts for PersonnelType = 'Employee' (includes location)
WrongPinOnly AS (
    SELECT        
         EmployeeName,
		 EmployeeID,
        PersonnelType,
        CardNumber,
	  'Wrong PIN' AS Alert_Type,
        DoorName,	
		Direction,
        location,
        CONVERT(TIME(0), LocaleMessageTime) AS Swipe_Time,
        CONVERT(DATE, LocaleMessageTime) AS DateOnly
    FROM CombinedQuery
    WHERE Rejection_Type = 'PIN'
      AND PersonnelType = 'Employee'
)
SELECT *
FROM WrongPinOnly
ORDER BY DateOnly DESC, Swipe_Time DESC;




Upadte this logic in Backend 


#C:\Users\W0024618\Desktop\Trend Analysis\backend\emea_pin.py
"""
EMEA PIN violation analysis.

Usage:
    python -m backend.emea_pin --year 2024 --outdir ./out
"""
from __future__ import annotations

import argparse
import logging
from datetime import date
from pathlib import Path
from typing import List
import sys

import pandas as pd

# Robust import for duration_report (works when module loaded as package or as plain module)
try:
    from backend import duration_report as dr
except Exception:
    try:
        import duration_report as dr
    except Exception as e:
        raise RuntimeError(f"Could not import duration_report (tried 'backend.duration_report' and 'duration_report'): {e}") from e

# local alias (may be None if duration_report couldn't supply it)
pyodbc = getattr(dr, "pyodbc", None)

LOG = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")


SQL_DB_TEMPLATE = r"""
SELECT
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    t1.ObjectName1 AS EmployeeName,
    t1.PartitionName2 AS PartitionName2,
    COALESCE(
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
      TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
      sc.value,
      NULLIF(CAST(t2.[Int1] AS NVARCHAR),'0'),
      t2.[Text12]
    ) AS CardNumber,
    t5rej.value AS Rejection_Type,
    CASE WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR) END AS EmployeeID,
    t3.Name AS PersonnelType,
    t1.ObjectName2 AS DoorName,
   
    t1.XmlGUID
FROM [{db}].dbo.ACVSUJournalLog t1
LEFT JOIN ACVSCore.Access.Personnel t2 ON t1.ObjectIdentity1 = t2.GUID
LEFT JOIN ACVSCore.Access.PersonnelType t3 ON t2.PersonnelTypeID = t3.ObjectID
LEFT JOIN [{db}].dbo.ACVSUJournalLogxml t_xml ON t1.XmlGUID = t_xml.GUID
LEFT JOIN [{db}].dbo.ACVSUJournalLogxmlShred sc ON t1.XmlGUID = sc.GUID AND sc.Name IN ('Card','CHUID')
LEFT JOIN [{db}].dbo.ACVSUJournalLogxmlShred t5rej ON t1.XmlGUID = t5rej.GUID AND t5rej.Name = 'RejectCode'
WHERE
    t1.MessageType = 'CardRejected'
    AND t5rej.value = 'PIN'
  
    AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) BETWEEN '{start}' AND '{end}'
"""

def _get_emea_databases() -> List[str]:
    rc = dr.REGION_CONFIG.get("emea")
    if not rc:
        raise RuntimeError("No 'emea' region config found in duration_report.py")
    candidates = dr._get_candidate_databases(rc)
    valid = dr._filter_existing_databases(rc, candidates)
    return valid or candidates

def _connect_to_db(server: str, database: str, user: str, password: str):
    if pyodbc is None:
        raise RuntimeError("pyodbc not available; install pyodbc to run queries.")
    conn_str = (
        f"DRIVER={{{dr.ODBC_DRIVER}}};"
        f"SERVER={server};DATABASE={database};UID={user};PWD={password};"
        "TrustServerCertificate=Yes;"
    )
    return pyodbc.connect(conn_str, autocommit=True)

def fetch_pin_rows_for_year(target_year: int) -> pd.DataFrame:
    rc = dr.REGION_CONFIG["emea"]
    start = date(target_year, 1, 1).strftime("%Y-%m-%d")
    end = date(target_year, 12, 31).strftime("%Y-%m-%d")
    dbs = _get_emea_databases()
    LOG.info("Querying EMEA databases: %s", dbs)

    frames = []
    for db in dbs:
        sql = SQL_DB_TEMPLATE.format(db=db, start=start, end=end)
        LOG.info("Running query against %s.%s (rows may be large)", rc["server"], db)
        conn = None
        try:
            conn = _connect_to_db(rc["server"], db, rc["user"], rc["password"])
            # pandas will pull the results into a DataFrame
            df = pd.read_sql(sql, conn)
            if not df.empty:
                frames.append(df)
        except Exception:
            LOG.exception("Failed to fetch from database %s", db)
        finally:
            try:
                if conn is not None:
                    conn.close()
            except Exception:
                pass

    if not frames:
        return pd.DataFrame(columns=[
            "LocaleMessageTime", "EmployeeName", "PartitionName2", "CardNumber",
            "Rejection_Type", "EmployeeID", "PersonnelType", "DoorName", "XmlGUID"
        ])
    out = pd.concat(frames, ignore_index=True)
    # normalize types
    out["LocaleMessageTime"] = pd.to_datetime(out["LocaleMessageTime"], errors="coerce")

    # IMPORTANT CHANGE: store DateOnly AS STRING (ISO) to avoid python date objects
    out["DateOnly"] = out["LocaleMessageTime"].dt.strftime("%Y-%m-%d")

    # Add Month and MonthName for month-wise analysis
    out["Month"] = out["LocaleMessageTime"].dt.month.fillna(0).astype("Int64")  # pandas nullable int
    out["MonthName"] = out["LocaleMessageTime"].dt.strftime("%b").fillna("")

    # ensure columns exist
    for c in ["EmployeeID", "EmployeeName", "CardNumber", "PartitionName2"]:
        if c not in out.columns:
            out[c] = None
    # restrict to PersonnelType == 'Employee' (defensive)
    if "PersonnelType" in out.columns:
        out = out[out["PersonnelType"].fillna("").str.strip().str.lower() == "employee"].copy()
    # canonical person uid using helper from duration_report
    def make_person_uid(row):
        try:
            return dr._canonical_person_uid_from_row(row)
        except Exception:
            # fallback: prefer EmployeeID -> CardNumber -> EmployeeName
            for cand in ("EmployeeID", "CardNumber", "EmployeeName"):
                v = row.get(cand)
                if v is not None and str(v).strip():
                    return str(v).strip()
            return None
    if not out.empty:
        out["person_uid"] = out.apply(make_person_uid, axis=1)
    return out

def analyze_pin_df(df: pd.DataFrame, outdir: Path) -> dict:
    outdir.mkdir(parents=True, exist_ok=True)
    results = {}
    total = len(df)
    results["total_rejections"] = int(total)
    LOG.info("Total PIN rejections in dataset: %d", total)

    # ensure month columns exist and are in friendly form
    if "Month" not in df.columns:
        df["Month"] = pd.to_datetime(df.get("LocaleMessageTime", None), errors="coerce").dt.month.fillna(0).astype(int)
    if "MonthName" not in df.columns:
        df["MonthName"] = pd.to_datetime(df.get("LocaleMessageTime", None), errors="coerce").dt.strftime("%b").fillna("")

    # by location (PartitionName2)
    by_loc = df.groupby("PartitionName2", dropna=False).size().reset_index(name="count").sort_values("count", ascending=False)
    results["by_location"] = by_loc
    by_loc.to_csv(outdir / "emea_pin_by_location.csv", index=False)

    # by employee (person_uid) - top offenders
    by_emp = df.groupby("person_uid", dropna=False).size().reset_index(name="count").sort_values("count", ascending=False)
    results["by_employee"] = by_emp
    by_emp.to_csv(outdir / "emea_pin_by_employee.csv", index=False)

    # repeaters: employees with count > 1
    repeaters = by_emp[by_emp["count"] > 1].copy()
    results["repeaters"] = repeaters
    repeaters.to_csv(outdir / "emea_pin_repeaters.csv", index=False)

    # MONTH-WISE: total by month
    month_totals = (df.groupby(["Month", "MonthName"], dropna=False)
                    .size()
                    .reset_index(name="count")
                    .sort_values(["Month"]))
    results["month_totals"] = month_totals
    month_totals.to_csv(outdir / "emea_pin_month_totals.csv", index=False)

    # MONTH-WISE: location-wise counts per month
    month_loc = (df.groupby(["Month", "MonthName", "PartitionName2"], dropna=False)
                 .size()
                 .reset_index(name="count")
                 .sort_values(["Month", "count"], ascending=[True, False]))
    results["month_by_location"] = month_loc
    month_loc.to_csv(outdir / "emea_pin_month_by_location.csv", index=False)

    # MONTH-WISE: employee-wise counts per month
    month_emp = (df.groupby(["Month", "MonthName", "person_uid"], dropna=False)
                 .size()
                 .reset_index(name="count")
                 .sort_values(["Month", "count"], ascending=[True, False]))
    results["month_by_employee"] = month_emp
    month_emp.to_csv(outdir / "emea_pin_month_by_employee.csv", index=False)

    # summary stats
    results["unique_employees"] = int(by_emp["person_uid"].nunique()) if "person_uid" in by_emp.columns else int(by_emp.shape[0])
    results["repeat_count_total"] = int(repeaters["count"].sum()) if not repeaters.empty else 0
    results["num_repeaters"] = int(len(repeaters))
    LOG.info("Unique employees with PIN rejects: %s", results["unique_employees"])
    LOG.info("Number of repeaters (count>1): %s, total repeat events: %s", results["num_repeaters"], results["repeat_count_total"])

    # Save full raw dataframe for audit (DateOnly as string avoids JSON issues)
    df.to_csv(outdir / "emea_pin_raw.csv", index=False)

    return results

def main():
    parser = argparse.ArgumentParser(description="EMEA PIN rejection analysis (yearly).")
    parser.add_argument("--year", type=int, required=False, default=date.today().year, help="Year to analyze (e.g. 2024)")
    parser.add_argument("--outdir", required=False, default="./out", help="Output directory for CSVs")
    args = parser.parse_args()

    target_year = int(args.year)
    outdir = Path(args.outdir)

    LOG.info("Starting EMEA PIN analysis for year %d", target_year)
    df = fetch_pin_rows_for_year(target_year)
    LOG.info("Rows fetched: %d", len(df))
    results = analyze_pin_df(df, outdir)
    # print short summary
    print("==== EMEA PIN analysis summary ====")
    print(f"Year: {target_year}")
    print(f"Total PIN rejections: {results.get('total_rejections', 0)}")
    print(f"Unique employees with rejects: {results.get('unique_employees', 0)}")
    print(f"Repeaters (employees with >1 reject): {results.get('num_repeaters', 0)}  (repeat events total: {results.get('repeat_count_total', 0)})")
    print(f"CSV outputs saved to: {outdir.resolve()}")

if __name__ == "__main__":
    main()









#C:\Users\W0024618\Desktop\Trend Analysis\backend\api_server.py
from pathlib import Path
from datetime import datetime, date
import time
import traceback
import sys
import importlib
import logging
from typing import Any
from fastapi.responses import JSONResponse, Response

# ----- ensure project root on sys.path (do this before other imports) -----
HERE = Path(__file__).resolve()
PROJECT_ROOT = HERE.parent.parent  # <project-root> (one level above backend/)
if str(PROJECT_ROOT) not in sys.path:
    sys.path.insert(0, str(PROJECT_ROOT))

# now safe to import FastAPI etc.
from fastapi import FastAPI, Query, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import pandas as pd

LOG = logging.getLogger("emea.api")
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")

# ----- try to import backend.emea_pin in a robust way (clear error if fails) -----
ep = None
try:
    ep = importlib.import_module("backend.emea_pin")
    LOG.info("Imported backend.emea_pin via package import")
except Exception as first_exc:
    LOG.warning("Package import backend.emea_pin failed: %s", first_exc)
    try:
        ep = importlib.import_module("emea_pin")
        LOG.info("Imported emea_pin as top-level module")
    except Exception as second_exc:
        tb = traceback.format_exc()
        LOG.error("Failed to import emea_pin module.\nPackage import error: %s\nFallback error: %s\nTrace:\n%s",
                  first_exc, second_exc, tb)
        raise RuntimeError(f"Failed to import emea_pin module (see server logs). Primary error: {first_exc}") from second_exc

# create app
app = FastAPI(title="EMEA PIN API (wrapper)")

# permissive CORS for local/dev
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["GET", "OPTIONS", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)

# cache for DataFrame
CACHE = {"ts": 0.0, "year": None, "df": None}
CACHE_TTL = 5  # seconds

def _load_fallback_csv(project_root: Path):
    fallback = project_root / "out" / "emea_pin_raw.csv"
    if fallback.exists():
        LOG.info("Loading fallback CSV: %s", fallback)
        try:
            df = pd.read_csv(fallback, parse_dates=["LocaleMessageTime"], keep_default_na=False)
            # sanitize DateOnly if present: ensure string
            if "LocaleMessageTime" in df.columns:
                df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")
            if "DateOnly" in df.columns:
                # ensure DateOnly is string
                df["DateOnly"] = df["DateOnly"].astype(str)
            return df
        except Exception as e:
            LOG.exception("Failed to parse fallback CSV: %s", e)
            raise
    raise FileNotFoundError(str(fallback))

# --- sanitizer helpers to make response JSON-safe ---
def _serialize_value(v: Any) -> Any:
    """Convert common non-JSON types to JSON-safe primitives."""
    if v is None:
        return None
    if isinstance(v, (str, bool, int, float)):
        return v
    if isinstance(v, (datetime, date)):
        return v.isoformat()
    try:
        import pandas as pd
        if isinstance(v, pd.Timestamp):
            if pd.isna(v):
                return None
            return v.isoformat()
        if isinstance(v, pd.Timedelta):
            return str(v)
        if v is pd.NaT:
            return None
    except Exception:
        pass
    try:
        import numpy as _np
        if isinstance(v, _np.generic):
            return v.item()
        if isinstance(v, _np.datetime64):
            try:
                ts = pd.to_datetime(v)
                return ts.isoformat()
            except Exception:
                return str(v)
    except Exception:
        pass
    try:
        return str(v)
    except Exception:
        return None

def _sanitize(obj: Any) -> Any:
    """Recursively walk `obj` and convert values to JSON-safe types."""
    if isinstance(obj, dict):
        return {str(k): _sanitize(v) for k, v in obj.items()}
    if isinstance(obj, (list, tuple)):
        return [_sanitize(v) for v in obj]
    if isinstance(obj, pd.DataFrame):
        try:
            return _sanitize(obj.fillna("").to_dict(orient="records"))
        except Exception:
            return []
    if isinstance(obj, pd.Series):
        try:
            return _sanitize(obj.fillna("").to_list())
        except Exception:
            return []
    return _serialize_value(obj)




@app.get("/api/emea_pin_live")
def emea_pin_live(year: int | None = None, month: int | None = Query(None), location: str | None = Query(None)):
    """
    Returns aggregates for the requested year, optional month, and optional location.

    - month: if provided (1..12) the API returns day-level aggregates for that month:
      `day_totals` (per-day counts for the month) and `day_by_location`.
    - All month/day aggregates are computed for the location scope first (i.e. location filter
      is applied before computing month/day breakdowns).
    """
    target_year = int(year or datetime.now().year)
    now = time.time()

    # refresh cache as needed
    if CACHE["df"] is None or CACHE["year"] != target_year or (now - CACHE["ts"]) > CACHE_TTL:
        try:
            df = ep.fetch_pin_rows_for_year(target_year)
            LOG.info("Fetched df from emea_pin (rows=%d)", len(df) if getattr(df, "shape", None) is not None else -1)
        except Exception as e:
            LOG.warning("fetch_pin_rows_for_year failed: %s", e)
            try:
                df = _load_fallback_csv(PROJECT_ROOT)
            except Exception as e2:
                tb = traceback.format_exc()
                LOG.error("Failed both live fetch and fallback CSV: %s\n%s", e2, tb)
                raise HTTPException(status_code=500, detail=f"Failed to fetch PIN rows: {e}\nFallback error: {e2}\n{tb}")

        if df is None:
            df = pd.DataFrame()
        CACHE.update({"ts": now, "year": target_year, "df": df})
    else:
        df = CACHE["df"]

    # defensive column existence
    for col in ["LocaleMessageTime", "PartitionName2", "person_uid", "EmployeeName", "EmployeeID", "CardNumber", "DateOnly", "Month", "MonthName"]:
        if col not in df.columns:
            if col == "Month":
                df[col] = pd.NA
            else:
                df[col] = pd.NA

    # ensure LocaleMessageTime parsed
    if "LocaleMessageTime" in df.columns:
        df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")

    # ensure Month/MonthName derived
    if "Month" not in df.columns or df["Month"].isnull().all():
        df["Month"] = df["LocaleMessageTime"].dt.month.fillna(0).astype("Int64")
    if "MonthName" not in df.columns or df["MonthName"].isnull().all():
        df["MonthName"] = df["LocaleMessageTime"].dt.strftime("%b").fillna("")

    # Build person_map (used for enriching employee display)
    person_map = {}
    try:
        for _, r in df.iterrows():
            pu = r.get("person_uid")
            if pu is None or (isinstance(pu, float) and pd.isna(pu)):
                continue
            key = str(pu)
            entry = person_map.get(key, {"EmployeeID": "", "EmployeeName": ""})
            eid = r.get("EmployeeID") or ""
            ename = r.get("EmployeeName") or ""
            if eid and not entry["EmployeeID"]:
                entry["EmployeeID"] = str(eid)
            if ename and not entry["EmployeeName"]:
                entry["EmployeeName"] = str(ename)
            person_map[key] = entry
    except Exception:
        LOG.exception("Failed to build person_map; proceeding without enriched names")
        person_map = {}

    # --- Apply location filter first (so month/day breakdowns are location-scoped) ---
    df_loc_filtered = df
    if location and str(location).strip() and str(location).strip().lower() != "all locations":
        try:
            df_loc_filtered = df_loc_filtered[df_loc_filtered["PartitionName2"].astype(str) == str(location)]
        except Exception:
            LOG.exception("Location filtering failed; using unfiltered df_loc_filtered")
            df_loc_filtered = df

    # Month-level breakdowns for the (possibly location-filtered) dataset
    try:
        month_totals_df = (df_loc_filtered.groupby(["Month", "MonthName"], dropna=False)
                           .size()
                           .reset_index(name="count")
                           .sort_values(["Month"]))
    except Exception:
        month_totals_df = pd.DataFrame(columns=["Month", "MonthName", "count"])

    try:
        month_by_location_df = (df_loc_filtered.groupby(["Month", "MonthName", "PartitionName2"], dropna=False)
                                 .size()
                                 .reset_index(name="count")
                                 .sort_values(["Month", "count"], ascending=[True, False]))
    except Exception:
        month_by_location_df = pd.DataFrame(columns=["Month", "MonthName", "PartitionName2", "count"])

    try:
        month_by_employee_df = (df_loc_filtered.groupby(["Month", "MonthName", "person_uid"], dropna=False)
                                 .size()
                                 .reset_index(name="count")
                                 .sort_values(["Month", "count"], ascending=[True, False]))
        if not month_by_employee_df.empty:
            month_by_employee_df["EmployeeID"] = month_by_employee_df["person_uid"].apply(lambda x: person_map.get(str(x), {}).get("EmployeeID",""))
            month_by_employee_df["EmployeeName"] = month_by_employee_df["person_uid"].apply(lambda x: person_map.get(str(x), {}).get("EmployeeName",""))
    except Exception:
        month_by_employee_df = pd.DataFrame(columns=["Month", "MonthName", "person_uid", "count", "EmployeeID", "EmployeeName"])

    # parse month param into integer (m) for later use
    m = None
    if month is not None:
        try:
            m = int(month)
        except Exception:
            m = None

    # If a specific month is requested: compute day-level aggregates for that month (scoped by location)
    day_totals_df = pd.DataFrame(columns=["Day", "count"])
    day_by_location_df = pd.DataFrame(columns=["Day", "PartitionName2", "count"])
    if m is not None and 1 <= m <= 12:
        try:
            df_month_scope = df_loc_filtered[df_loc_filtered["Month"].fillna(0).astype(int) == m].copy()
            if "LocaleMessageTime" in df_month_scope.columns:
                df_month_scope["Day"] = df_month_scope["LocaleMessageTime"].dt.day.fillna(0).astype("Int64")
            day_totals_df = (df_month_scope.groupby(["Day"], dropna=False)
                             .size().reset_index(name="count").sort_values(["Day"]))
            day_by_location_df = (df_month_scope.groupby(["Day", "PartitionName2"], dropna=False)
                                  .size().reset_index(name="count").sort_values(["Day", "count"], ascending=[True, False]))
        except Exception:
            LOG.exception("Failed to compute day-level aggregates for month %s", m)
            day_totals_df = pd.DataFrame(columns=["Day", "count"])
            day_by_location_df = pd.DataFrame(columns=["Day", "PartitionName2", "count"])

    # --- Now apply month filter (if any) to produce the main aggregates used by cards/recent/by_location/by_employee ---
    df_agg = df_loc_filtered
    if m is not None and 1 <= m <= 12:
        try:
            df_agg = df_loc_filtered[df_loc_filtered["Month"].fillna(0).astype(int) == m].copy()
        except Exception:
            LOG.exception("Month filtering failed; using unfiltered df_loc_filtered")
            df_agg = df_loc_filtered

    try:
        by_loc = df_agg.groupby("PartitionName2", dropna=False).size().reset_index(name="count").sort_values("count", ascending=False)
    except Exception:
        by_loc = pd.DataFrame(columns=["PartitionName2", "count"])

    try:
        by_emp = df_agg.groupby("person_uid", dropna=False).size().reset_index(name="count").sort_values("count", ascending=False)
    except Exception:
        by_emp = pd.DataFrame(columns=["person_uid", "count"])

    # Enrich by_emp with EmployeeID and EmployeeName
    try:
        if not by_emp.empty:
            by_emp["EmployeeID"] = by_emp["person_uid"].apply(lambda x: person_map.get(str(x), {}).get("EmployeeID", ""))
            by_emp["EmployeeName"] = by_emp["person_uid"].apply(lambda x: person_map.get(str(x), {}).get("EmployeeName", ""))
    except Exception:
        LOG.exception("Failed to enrich by_emp with names")

    # totals and recent (df_agg honors location+month)
    total_rejections_value = int(len(df_agg))
    recent = df_agg.copy()
    if "LocaleMessageTime" in recent.columns:
        try:
            recent = recent.sort_values("LocaleMessageTime", ascending=False)
        except Exception:
            LOG.debug("Could not sort recent by LocaleMessageTime")
    recent = recent.head(500)

    # sanitize outputs
    by_loc_records = _sanitize(by_loc.fillna("").to_dict(orient="records"))
    by_emp_records = _sanitize(by_emp.fillna("").to_dict(orient="records"))
    recent_records = _sanitize(recent.fillna("").to_dict(orient="records"))

    month_totals_records = _sanitize(month_totals_df.fillna("").to_dict(orient="records"))
    month_by_location_records = _sanitize(month_by_location_df.fillna("").to_dict(orient="records"))
    month_by_employee_records = _sanitize(month_by_employee_df.fillna("").to_dict(orient="records"))

    day_totals_records = _sanitize(day_totals_df.fillna("").to_dict(orient="records"))
    day_by_location_records = _sanitize(day_by_location_df.fillna("").to_dict(orient="records"))

    # Ensure person_map values are primitive types (strings)
    safe_person_map = {}
    for k, v in person_map.items():
        safe_person_map[str(k)] = {
            "EmployeeID": _serialize_value(v.get("EmployeeID","")),
            "EmployeeName": _serialize_value(v.get("EmployeeName",""))
        }

    resp = {
        "total_rejections": total_rejections_value,
        "by_location": by_loc_records,
        "by_employee": by_emp_records,
        "recent": recent_records,
        # month-wise (location scoped)
        "month_totals": month_totals_records,
        "month_by_location": month_by_location_records,
        "month_by_employee": month_by_employee_records,
        # day-wise for selected month (if month provided)
        "day_totals": day_totals_records,
        "day_by_location": day_by_location_records,
        # helper map for frontend name lookups
        "person_map": safe_person_map,
    }

    safe_resp = _sanitize(resp)
    return JSONResponse(safe_resp)

# --- New endpoint: details with filtering + export ---
@app.get("/api/emea_pin_details")
def emea_pin_details(
    year: int | None = None,
    location: str | None = Query(None),
    employee_id: str | None = Query(None),
    person_uid: str | None = Query(None),
    from_date: str | None = Query(None),   # "YYYY-MM-DD"
    to_date: str | None = Query(None),     # "YYYY-MM-DD"
    limit: int = 200,
    offset: int = 0,
    export: str | None = Query(None)       # "csv" to download CSV
):
    """
    Return row-level details (filtered). If export=csv, returns CSV download of full filtered results (no pagination).
    Columns returned (JSON / CSV): EmployeeID, EmployeeName, Date, Time, CardNumber, Direction, DoorName, Rejection_Type, PartitionName2, person_uid, XmlGUID
    """
    target_year = int(year or datetime.now().year)
    now = time.time()

    # ensure cache for requested year
    if CACHE["df"] is None or CACHE["year"] != target_year or (now - CACHE["ts"]) > CACHE_TTL:
        try:
            df = ep.fetch_pin_rows_for_year(target_year)
        except Exception as e:
            LOG.exception("Failed to fetch rows for details: %s", e)
            try:
                df = _load_fallback_csv(PROJECT_ROOT)
            except Exception as e2:
                tb = traceback.format_exc()
                LOG.error("Failed both live fetch and fallback CSV: %s\n%s", e2, tb)
                raise HTTPException(status_code=500, detail=f"Failed to fetch PIN rows: {e}\nFallback error: {e2}\n{tb}")
        if df is None:
            df = pd.DataFrame()
        CACHE.update({"ts": now, "year": target_year, "df": df})
    else:
        df = CACHE["df"]

    # defensive columns & parse time
    if "LocaleMessageTime" in df.columns:
        df["LocaleMessageTime"] = pd.to_datetime(df["LocaleMessageTime"], errors="coerce")

    # Make sure DateOnly exists (string) and Time
    if "DateOnly" not in df.columns:
        if "LocaleMessageTime" in df.columns:
            df["DateOnly"] = df["LocaleMessageTime"].dt.strftime("%Y-%m-%d")
        else:
            df["DateOnly"] = ""

    if "TimeOnly" not in df.columns:
        if "LocaleMessageTime" in df.columns:
            df["TimeOnly"] = df["LocaleMessageTime"].dt.strftime("%H:%M:%S")
        else:
            df["TimeOnly"] = ""

    # ensure important columns exist
    for c in ["EmployeeID", "EmployeeName", "CardNumber", "PartitionName2", "DoorName", "Rejection_Type", "person_uid", "XmlGUID"]:
        if c not in df.columns:
            df[c] = ""

    # copy df to filter
    df_f = df.copy()

    # location filter
    if location and location.strip() and location.strip().lower() != "all locations":
        try:
            df_f = df_f[df_f["PartitionName2"].astype(str) == str(location)]
        except Exception:
            LOG.exception("Location filter failed for details; ignoring location filter")

    # employee_id or person_uid filter
    if person_uid and str(person_uid).strip():
        df_f = df_f[df_f["person_uid"].astype(str) == str(person_uid).strip()]
    elif employee_id and str(employee_id).strip():
        # match EmployeeID or person_uid fallback
        emp = str(employee_id).strip()
        df_f = df_f[
            (df_f["EmployeeID"].astype(str) == emp) |
            (df_f["person_uid"].astype(str) == emp)
        ]

    # date range filter (DateOnly expected format YYYY-MM-DD)
    try:
        if from_date:
            from_ts = pd.to_datetime(from_date, format="%Y-%m-%d", errors="coerce")
            if not pd.isna(from_ts):
                df_f = df_f[df_f["LocaleMessageTime"] >= from_ts]
        if to_date:
            # include to_date end of day
            to_ts = pd.to_datetime(to_date, format="%Y-%m-%d", errors="coerce")
            if not pd.isna(to_ts):
                df_f = df_f[df_f["LocaleMessageTime"] <= (to_ts + pd.Timedelta(days=1) - pd.Timedelta(seconds=1))]
    except Exception:
        LOG.exception("Date filtering failed for details; ignoring date filter")

    # sort newest first
    try:
        df_f = df_f.sort_values("LocaleMessageTime", ascending=False)
    except Exception:
        pass

    total_rows = len(df_f)

    # If export=csv -> return full filtered CSV (no pagination)
    if export and str(export).lower() == "csv":
        # select and rename columns for user-friendly CSV
        export_df = df_f.copy()
        export_df["Date"] = export_df["LocaleMessageTime"].dt.strftime("%Y-%m-%d")
        export_df["Time"] = export_df["LocaleMessageTime"].dt.strftime("%H:%M:%S")
        export_cols = [
            ("EmployeeID", "EmployeeID"),
            ("EmployeeName", "EmployeeName"),
            ("Date", "Date"),
            ("Time", "Time"),
            ("CardNumber", "CardNumber"),
            ("DoorName", "DoorName"),
            ("Rejection_Type", "Rejection_Type"),
            ("PartitionName2", "Location"),
            ("person_uid", "person_uid"),
            ("XmlGUID", "XmlGUID"),
        ]
        # keep any additional column if exists e.g. Direction
        if "Direction" in export_df.columns:
            export_cols.insert(5, ("Direction","Direction"))
        cols = [c[0] for c in export_cols]
        # ensure columns exist
        for c in cols:
            if c not in export_df.columns:
                export_df[c] = ""
        try:
            csv_bytes = export_df[cols].to_csv(index=False).encode("utf-8")
            fname = f"emea_pin_details_{target_year}"
            if from_date or to_date:
                fname += f"_{from_date or ''}_{to_date or ''}"
            fname += ".csv"
            headers = {
                "Content-Disposition": f'attachment; filename="{fname}"'
            }
            return Response(content=csv_bytes, media_type="text/csv", headers=headers)
        except Exception:
            LOG.exception("Failed to build CSV export")
            raise HTTPException(status_code=500, detail="Failed to build CSV export")

    # Otherwise return JSON with pagination
    start = int(max(0, offset))
    lim = int(max(1, limit))
    page = df_f.iloc[start:start+lim].copy()

    # map rows to desired JSON-friendly schema
    rows = []
    for _, r in page.iterrows():
        locale_ts = r.get("LocaleMessageTime")
        if pd.isna(locale_ts):
            date_s = r.get("DateOnly", "")
            time_s = r.get("TimeOnly", "")
        else:
            try:
                date_s = pd.to_datetime(locale_ts).strftime("%Y-%m-%d")
                time_s = pd.to_datetime(locale_ts).strftime("%H:%M:%S")
            except Exception:
                date_s = r.get("DateOnly","")
                time_s = r.get("TimeOnly","")
        rows.append({
            "EmployeeID": _serialize_value(r.get("EmployeeID","")),
            "EmployeeName": _serialize_value(r.get("EmployeeName","")),
            "Date": date_s,
            "Time": time_s,
            "CardNumber": _serialize_value(r.get("CardNumber","")),
            "Direction": _serialize_value(r.get("Direction","")) if "Direction" in r else "",
            "DoorName": _serialize_value(r.get("DoorName","")),
            "Rejection_Type": _serialize_value(r.get("Rejection_Type","")),
            "Location": _serialize_value(r.get("PartitionName2","")),
            "person_uid": _serialize_value(r.get("person_uid","")),
            "XmlGUID": _serialize_value(r.get("XmlGUID","")),
        })

    resp = {
        "total": int(total_rows),
        "limit": lim,
        "offset": start,
        "rows": rows
    }

    return JSONResponse(_sanitize(resp))



