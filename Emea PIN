<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>EMEA PIN Dashboard — Live</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <link rel="stylesheet" href="style.css">
  <style>
    .topbar { margin-bottom: 8px; }
    .small-card { padding: 12px; text-align: center; }
    .top-controls { display:flex; gap:8px; align-items:center; }
    .chart-small { height:220px; }
    .compact-table td { padding:6px; font-size:13px; }
    .muted { color:#9aa4b2; }
    .month-panel { display:flex; gap:12px; margin-top:12px; align-items:center; }
    .month-chart-wrap { height:200px; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
  (function () {
    const { useState, useEffect, useRef } = React;

    // CHANGE THESE as needed:
    const API_BASE = "http://localhost:8003";
    const API_ENDPOINT = API_BASE + "/api/emea_pin_live";

    const EMEA_PARTITIONS = ["LT.Vilnius","IT.Rome","UK.London","IE.DUblin","DU.Abu Dhab","ES.Madrid","AUT.Vienna","MA.Casablanca","RU.Moscow"];
    const MONTH_NAMES = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    

    function formatDateShort(d) {
      if (!d) return '-';
      try {
        const dt = new Date(d);
        if (isNaN(dt.getTime())) return String(d).slice(0,19);
        return dt.toLocaleString();
      } catch (e) { return String(d); }
    }

    function downloadCSV(rows, filename = 'export.csv') {
      if (!rows || rows.length === 0) { alert("No data to export"); return; }
      const cols = Object.keys(rows[0]);
      const lines = [];
      lines.push(cols.join(','));
      rows.forEach(r => {
        const line = cols.map(c => {
          const v = r[c] === null || r[c] === undefined ? '' : String(r[c]).replace(/\n/g,' ');
          return JSON.stringify(v);
        }).join(',');
        lines.push(line);
      });
      const blob = new Blob([lines.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = filename; a.click(); URL.revokeObjectURL(url);
    }

    function EmeaPinApp() {
      const [year, setYear] = useState(new Date().getFullYear());
      const [location, setLocation] = useState('All locations');

      // IMPORTANT: default live=false so no automatic polling starts on load.
      const [live, setLive] = useState(false);

      // month selector in header. 0 === All months, 1..12 specific month
      const [selectedMonth, setSelectedMonth] = useState(0);

      const [loading, setLoading] = useState(false);
      const [lastFetch, setLastFetch] = useState(null);

      const [total, setTotal] = useState(0);
      const [uniqueEmployees, setUniqueEmployees] = useState(0);
      const [repeatersCount, setRepeatersCount] = useState(0);

      // main lists (raw normalized arrays from API)
      const [byLocationRaw, setByLocationRaw] = useState([]); // array of {name, count}
      const [byEmployeeRaw, setByEmployeeRaw] = useState([]); // array of {id, count, EmployeeID, EmployeeName}
      const [recent, setRecent] = useState([]);

      // person map from API: { person_uid: { EmployeeID, EmployeeName } }
      const [personMap, setPersonMap] = useState({});

      // month-wise raw arrays from API
      const [monthTotalsRaw, setMonthTotalsRaw] = useState([]); // {Month, MonthName, count}
      const [monthByLocationRaw, setMonthByLocationRaw] = useState([]); // {Month, MonthName, PartitionName2, count}
      const [monthByEmployeeRaw, setMonthByEmployeeRaw] = useState([]); // {Month, MonthName, person_uid, count, EmployeeID, EmployeeName}

      // day-wise arrays returned by API when a specific month is requested
      const [dayTotalsRaw, setDayTotalsRaw] = useState([]); // {Day, count}
      const [dayByLocationRaw, setDayByLocationRaw] = useState([]); // {Day, PartitionName2, count}

      const pollingRef = useRef(null);
      const inFlightRef = useRef(false);

      // chart refs
      const locChartRef = useRef(null);
      const locChartInst = useRef(null);
      const monthChartRef = useRef(null);
      const monthChartInst = useRef(null);

      // which page to show: 'dashboard' or 'details'
      const [view, setView] = useState('dashboard');

      // details page state
      const [detailsEmployeeId, setDetailsEmployeeId] = useState('');
      const [detailsFromDate, setDetailsFromDate] = useState(''); // YYYY-MM-DD
      const [detailsToDate, setDetailsToDate] = useState('');     // YYYY-MM-DD
      const [detailsLimit, setDetailsLimit] = useState(200);
      const [detailsOffset, setDetailsOffset] = useState(0);
      const [detailsRows, setDetailsRows] = useState([]);
      const [detailsTotal, setDetailsTotal] = useState(0);
      const [detailsLoading, setDetailsLoading] = useState(false);

      // Helper: update (or create) a Chart.js instance cleanly (silent update)
      function updateOrCreateChart(instRef, canvas, config) {
        if (!canvas) return;
        try {
          if (instRef.current) {
            instRef.current.data = config.data;
            instRef.current.options = config.options || instRef.current.options;
            instRef.current.update();
            return instRef.current;
          } else {
            instRef.current = new Chart(canvas.getContext('2d'), config);
            return instRef.current;
          }
        } catch (e) {
          try { if (instRef.current) instRef.current.destroy(); } catch (_) {}
          instRef.current = new Chart(canvas.getContext('2d'), config);
          return instRef.current;
        }
      }

      // Utilities for client-side aggregation & filtering
      function aggregateMonthByLocationForAllMonths(raw) {
        const map = {};
        (raw || []).forEach(r => {
          const loc = r.PartitionName2 || r.Partition || r.location || '';
          const c = Number(r.count || 0);
          if (!map[loc]) map[loc] = 0;
          map[loc] += c;
        });
        return Object.keys(map).map(k => ({ PartitionName2: k, count: map[k] })).sort((a,b)=>b.count-a.count);
      }

      function aggregateMonthByEmployeeForAllMonths(raw) {
        const map = {};
        (raw || []).forEach(r => {
          const id = r.person_uid || r.EmployeeID || r.employee_id || r.id || '';
          const c = Number(r.count || 0);
          if (!map[id]) map[id] = 0;
          map[id] += c;
        });
        return Object.keys(map).map(k => ({ person_uid: k, count: map[k] })).sort((a,b)=>b.count-a.count);
      }

      // Build data for Location chart depending on selected month & location
      function buildLocationChartData(byLocation, monthByLocation, selMonth, selLocation) {
        if (selLocation && selLocation !== 'All locations') {
          const monthArr = Array.from({length:12}, (_,i) => {
            const m = i+1;
            let found = null;
            for (let i2=0;i2<monthByLocation.length;i2++){
              const r = monthByLocation[i2];
              if (Number(r.Month) === m) {
                const part = r.PartitionName2 || r.Partition || r.location || '';
                if (String(part) === String(selLocation)) {
                  found = r; break;
                }
              }
            }
            return found && Number(found.count) ? Number(found.count) : 0;
          });
          if (selMonth === 0) {
            return { labels: MONTH_NAMES, data: monthArr, type: 'line' };
          } else {
            const mIndex = selMonth - 1;
            const val = monthArr[mIndex] || 0;
            return { labels: [MONTH_NAMES[mIndex]], data: [val], type: 'bar' };
          }
        } else {
          if (selMonth === 0) {
            const top = (byLocation || []).slice(0,12);
            const labels = top.map(x => x.name || x.PartitionName2 || '');
            const values = top.map(x => Number(x.count || 0));
            return { labels, data: values, type: 'line' };
          } else {
            const rows = (monthByLocation || []).filter(r => Number(r.Month) === Number(selMonth));
            const ag = {};
            rows.forEach(r => {
              const loc = r.PartitionName2 || r.Partition || r.location || '';
              ag[loc] = (ag[loc] || 0) + Number(r.count || 0);
            });
            const arr = Object.keys(ag).map(k => ({ PartitionName2: k, count: ag[k] })).sort((a,b)=>b.count-a.count).slice(0,12);
            const labels = arr.map(x => x.PartitionName2 || '');
            const values = arr.map(x => x.count || 0);
            return { labels, data: values, type: 'line' };
          }
        }
      }

      // Core fetch — silent update pattern:
      async function fetchOnce() {
        if (inFlightRef.current) return;
        inFlightRef.current = true;
        setLoading(true);

        try {
          const params = new URLSearchParams();
          if (year) params.set('year', String(year));
          // send month only when a specific month is selected (selectedMonth: 1..12)
          if (selectedMonth && Number(selectedMonth) !== 0) params.set('month', String(selectedMonth));
          if (location && location !== 'All locations') params.set('location', location);
          const url = API_ENDPOINT + '?' + params.toString();

          const r = await fetch(url, { cache: 'no-store' });
          if (!r.ok) {
            const txt = await r.text().catch(()=>'');
            throw new Error('API error: ' + r.status + ' ' + txt);
          }
          const js = await r.json();

          // parse results into local variables first (do not mutate state yet)
          const total_rejections = (js.total_rejections !== undefined) ? js.total_rejections
            : (js.total !== undefined ? js.total : (js.totalRejections || 0));

          const rawByLoc = js.by_location || js.byLocation || js.location_counts || [];
          const normalizedByLoc = Array.isArray(rawByLoc) ? rawByLoc.map(function(x) {
            var k = x.PartitionName2 || x.partition || x.location || x.name || x.PartitionName || '';
            var c = x.count !== undefined ? x.count : (x.value !== undefined ? x.value : 0);
            return { name: String(k || '').trim(), count: Number(c || 0) };
          }) : [];

          const rawByEmp = js.by_employee || js.byEmployee || js.employee_counts || [];
          const normalizedByEmp = Array.isArray(rawByEmp) ? rawByEmp.map(function(x) {
            var id = x.person_uid || x.EmployeeID || x.employee_id || x.id || x.person || '';
            var c = x.count !== undefined ? x.count : (x.value !== undefined ? x.value : 0);
            var empIdCol = x.EmployeeID || x.EmployeeId || x.employee_id || '';
            var empNameCol = x.EmployeeName || x.Employee || x.EmployeeName || '';
            return { id: String(id || '').trim(), count: Number(c || 0), EmployeeID: empIdCol || '', EmployeeName: empNameCol || '' };
          }) : [];

          const rawRecent = js.recent || js.rows || js.events || js.recent_rows || [];

          // month-wise
          const rawMonthTotals = js.month_totals || js.monthTotals || [];
          const normalizedMonthTotals = Array.isArray(rawMonthTotals) ? rawMonthTotals.map(function(x) {
            return {
              Month: Number(x.Month || x.month || 0),
              MonthName: x.MonthName || x.monthName || x.monthname || "",
              count: Number(x.count || x.value || 0)
            };
          }) : [];

          const rawMonthByLoc = js.month_by_location || js.monthByLocation || [];
          const normalizedMonthByLoc = Array.isArray(rawMonthByLoc) ? rawMonthByLoc.map(function(x) {
            return {
              Month: Number(x.Month || x.month || 0),
              MonthName: x.MonthName || x.monthName || x.monthname || "",
              PartitionName2: x.PartitionName2 || x.Partition || x.location || "",
              count: Number(x.count || x.value || 0)
            };
          }) : [];

          const rawMonthByEmp = js.month_by_employee || js.monthByEmployee || [];
          const normalizedMonthByEmp = Array.isArray(rawMonthByEmp) ? rawMonthByEmp.map(function(x) {
            return {
              Month: Number(x.Month || x.month || 0),
              MonthName: x.MonthName || x.monthName || x.monthname || "",
              person_uid: x.person_uid || x.EmployeeID || x.employee_id || x.id || "",
              count: Number(x.count || x.value || 0),
              EmployeeID: x.EmployeeID || x.employee_id || '',
              EmployeeName: x.EmployeeName || ''
            };
          }) : [];

          // day-wise (for selected month) — optional
          const rawDayTotals = js.day_totals || js.dayTotals || [];
          const normalizedDayTotals = Array.isArray(rawDayTotals) ? rawDayTotals.map(function(x) {
            return {
              Day: Number(x.Day || x.day || 0),
              count: Number(x.count || x.value || 0)
            };
          }) : [];

          const rawDayByLoc = js.day_by_location || js.dayByLocation || [];
          const normalizedDayByLoc = Array.isArray(rawDayByLoc) ? rawDayByLoc.map(function(x) {
            return {
              Day: Number(x.Day || x.day || 0),
              PartitionName2: x.PartitionName2 || x.Partition || x.location || "",
              count: Number(x.count || x.value || 0)
            };
          }) : [];

          // parse person_map (if provided)
          const rawPersonMap = js.person_map || js.personMap || {};
          const normalizedPersonMap = {};
          Object.keys(rawPersonMap || {}).forEach(k => {
            const v = rawPersonMap[k] || {};
            normalizedPersonMap[String(k)] = {
              EmployeeID: v.EmployeeID || v.employeeId || v.EmployeeId || '',
              EmployeeName: v.EmployeeName || v.EmployeeName || v.name || ''
            };
          });

          // compute derived metrics locally
          const unique = new Set((normalizedByEmp || []).map(function(e){ return e.id; }).filter(Boolean));
          const repeaters = (normalizedByEmp || []).filter(function(e){ return e.count > 1; });

          // Now update React state in one go
          setTotal(Number(total_rejections || 0));
          setByLocation(normalizedByLoc);
          setByEmployee(normalizedByEmp);
          setRecent(Array.isArray(rawRecent) ? rawRecent : []);
          setUniqueEmployees(unique.size);
          setRepeatersCount(repeaters.length);

          setMonthTotals(normalizedMonthTotals);
          setMonthByLocation(normalizedMonthByLoc);
          setMonthByEmployee(normalizedMonthByEmp);

          setPersonMap(normalizedPersonMap);
          setDayTotals(normalizedDayTotals);
          setDayByLocation(normalizedDayByLoc);

          // update charts in-place (no flicker)
          if (locChartRef.current) {
            const topLoc = (normalizedByLoc || []).slice(0,12);
            const labels = topLoc.map(function(x){ return x.name || 'Unknown'; });
            const values = topLoc.map(function(x){ return x.count || 0; });
            updateOrCreateChart(locChartInst, locChartRef.current, {
              type: 'line',
              data: {
                labels: labels,
                datasets: [{
                  label: 'PIN rejections',
                  data: values,
                  borderColor: '#2563eb',
                  backgroundColor: 'rgba(37,99,235,0.2)',
                  fill: true,
                  tension: 0.3,
                  pointBackgroundColor: '#2563eb',
                  pointRadius: 5,
                  pointHoverRadius: 7,
                  borderWidth: 2
                }]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: { x: { type: 'category' }, y: { beginAtZero: true, ticks: { precision: 0 } } }
              }
            });
          }

          // Month / Day totals chart
          if (monthChartRef.current) {
            if (selectedMonth === 0) {
              // monthly view (12 month buckets)
              var monthArr = Array.from({length:12}, function(_,i) {
                var m = i + 1;
                var rec = null;
                for (var ri = 0; ri < normalizedMonthTotals.length; ri++) {
                  var cand = normalizedMonthTotals[ri];
                  if (Number(cand.Month) === m) { rec = cand; break; }
                }
                return rec && rec.count ? Number(rec.count) : 0;
              });
              updateOrCreateChart(monthChartInst, monthChartRef.current, {
                type: 'line',
                data: { labels: MONTH_NAMES, datasets: [{ label: 'Monthly PIN rejections', data: monthArr, fill:false, tension:0.3 }] },
                options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
              });
            } else {
              // day-wise view for the selected month
              // determine days in selected month
              const daysInMonth = new Date(Number(year), Number(selectedMonth), 0).getDate();
              const labels = Array.from({length: daysInMonth}, (_,i) => String(i+1));
              const dayArr = Array.from({length: daysInMonth}, function(_,i) {
                const d = i + 1;
                var rec = null;
                for (var ri = 0; ri < normalizedDayTotals.length; ri++) {
                  var cand = normalizedDayTotals[ri];
                  if (Number(cand.Day) === d) { rec = cand; break; }
                }
                return rec && rec.count ? Number(rec.count) : 0;
              });
              updateOrCreateChart(monthChartInst, monthChartRef.current, {
                type: 'line',
                data: { labels: labels, datasets: [{ label: `Day-wise for ${MONTH_NAMES[selectedMonth-1]}`, data: dayArr, fill:false, tension:0.3 }] },
                options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
              });
            }
          }

          setLastFetch(new Date().toISOString());

        } catch (err) {
          console.error("Fetch EMEA PIN failed", err);
        } finally {
          setLoading(false);
          inFlightRef.current = false;
        }
      }

      async function fetchDetails(opts = {}) {
        // opts can contain employeeId, fromDate, toDate, location, limit, offset, year
        const emp = opts.employeeId !== undefined ? opts.employeeId : detailsEmployeeId;
        const fromD = opts.fromDate !== undefined ? opts.fromDate : detailsFromDate;
        const toD = opts.toDate !== undefined ? opts.toDate : detailsToDate;
        const lim = opts.limit !== undefined ? opts.limit : detailsLimit;
        const off = opts.offset !== undefined ? opts.offset : detailsOffset;
        const loc = opts.location !== undefined ? opts.location : location;
        const yr = opts.year !== undefined ? opts.year : year;

        setDetailsLoading(true);
        try {
          const params = new URLSearchParams();
          if (yr) params.set('year', String(yr));
          if (loc && loc !== 'All locations') params.set('location', loc);
          if (emp) params.set('employee_id', emp);
          if (fromD) params.set('from_date', fromD);
          if (toD) params.set('to_date', toD);
          params.set('limit', String(lim));
          params.set('offset', String(off));

          const url = API_ENDPOINT.replace('/api/emea_pin_live','/api/emea_pin_details') + '?' + params.toString();
          const r = await fetch(url, { cache: 'no-store' });
          if (!r.ok) {
            const txt = await r.text().catch(()=> '');
            throw new Error('Details API error: ' + r.status + ' ' + txt);
          }
          const js = await r.json();
          setDetailsRows(js.rows || []);
          setDetailsTotal(js.total || 0);
          setDetailsLimit(js.limit || lim);
          setDetailsOffset(js.offset || off);
        } catch (err) {
          console.error("Fetch details failed", err);
          alert("Failed to load details: " + err.message);
        } finally {
          setDetailsLoading(false);
        }
      }

      function exportDetailsCSV() {
        const params = new URLSearchParams();
        if (year) params.set('year', String(year));
        if (location && location !== 'All locations') params.set('location', location);
        if (detailsEmployeeId) params.set('employee_id', detailsEmployeeId);
        if (detailsFromDate) params.set('from_date', detailsFromDate);
        if (detailsToDate) params.set('to_date', detailsToDate);
        // export=csv triggers backend CSV download
        params.set('export', 'csv');
        const url = API_ENDPOINT.replace('/api/emea_pin_live','/api/emea_pin_details') + '?' + params.toString();
        // trigger download
        window.open(url, '_blank');
      }

      // --- DetailsPanel: must be defined inside EmeaPinApp so it can access state ---
      const DetailsPanel = () => {
        const start = detailsOffset || 0;
        const end = Math.min(detailsTotal, start + detailsLimit);

        return (
          <div style={{ padding:12, background:'#fff', borderRadius:10 }}>
            <div style={{ display:'flex', gap:8, alignItems:'center', marginBottom:12 }}>
              <label style={{ fontSize:13 }}>Employee ID</label>
              <input type="text" value={detailsEmployeeId} onChange={e=>setDetailsEmployeeId(e.target.value)} style={{ padding:6, borderRadius:6 }} />
              <label style={{ fontSize:13 }}>From</label>
              <input type="date" value={detailsFromDate} onChange={e=>setDetailsFromDate(e.target.value)} style={{ padding:6, borderRadius:6 }} />
              <label style={{ fontSize:13 }}>To</label>
              <input type="date" value={detailsToDate} onChange={e=>setDetailsToDate(e.target.value)} style={{ padding:6, borderRadius:6 }} />
              <button className="btn-primary" onClick={() => { setDetailsOffset(0); fetchDetails({ employeeId: detailsEmployeeId, fromDate: detailsFromDate, toDate: detailsToDate, offset:0 }); }}>Search</button>
              <button className="small-button" onClick={() => { setDetailsEmployeeId(''); setDetailsFromDate(''); setDetailsToDate(''); setDetailsOffset(0); fetchDetails({ employeeId:'', fromDate:'', toDate:'', offset:0 }); }}>Reset</button>
              <button className="small-button" onClick={() => exportDetailsCSV()}>Export CSV</button>
              <button className="small-button" onClick={() => setView('dashboard')}>Back</button>
            </div>

            <div style={{ maxHeight:500, overflow:'auto', border:'1px solid #eee', padding:8 }}>
              <table className="compact-table" style={{ width:'100%', borderCollapse:'collapse' }}>
                <thead><tr style={{ background:'#fafafa' }}>
                  <th style={{ padding:6 }}>EmployeeID</th>
                  <th style={{ padding:6 }}>Name</th>
                  <th style={{ padding:6 }}>Date</th>
                  <th style={{ padding:6 }}>Time</th>
                  <th style={{ padding:6 }}>Card</th>
                  <th style={{ padding:6 }}>Direction</th>
                  <th style={{ padding:6 }}>Door</th>
                  <th style={{ padding:6 }}>Alert Type</th>
                  <th style={{ padding:6 }}>Location</th>
                </tr></thead>
                <tbody>
                  {detailsLoading && <tr><td colSpan="9" className="muted">Loading…</td></tr>}
                  {!detailsLoading && detailsRows.length===0 && <tr><td colSpan="9" className="muted">No rows</td></tr>}
                  {!detailsLoading && detailsRows.map((r,i)=>(
                    <tr key={i}>
                      <td style={{ padding:6 }}>{r.EmployeeID || r.person_uid || '-'}</td>
                      <td style={{ padding:6 }}>{r.EmployeeName || '-'}</td>
                      <td style={{ padding:6 }}>{r.Date || r.DateOnly || '-'}</td>
                      <td style={{ padding:6 }}>{r.Time || '-'}</td>
                      <td style={{ padding:6 }}>{r.CardNumber || '-'}</td>
                      <td style={{ padding:6 }}>{r.Direction || '-'}</td>
                      <td style={{ padding:6 }}>{r.DoorName || '-'}</td>
                      <td style={{ padding:6 }}>{r.Rejection_Type || r.RejectionType || '-'}</td>
                      <td style={{ padding:6 }}>{r.Location || r.PartitionName2 || '-'}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>

            <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginTop:8 }}>
              <div style={{ fontSize:13 }}>{`Showing ${start+1} - ${end} of ${detailsTotal}`}</div>
              <div style={{ display:'flex', gap:8 }}>
                <button className="small-button" onClick={() => { const no = Math.max(0, detailsOffset - detailsLimit); setDetailsOffset(no); fetchDetails({ offset: no }); }} disabled={detailsOffset <= 0}>Prev</button>
                <button className="small-button" onClick={() => { const no = detailsOffset + detailsLimit; if (no < detailsTotal) { setDetailsOffset(no); fetchDetails({ offset: no }); } }} disabled={detailsOffset + detailsLimit >= detailsTotal}>Next</button>
                <select value={detailsLimit} onChange={e=>{ const l = Number(e.target.value||200); setDetailsLimit(l); setDetailsOffset(0); fetchDetails({ limit: l, offset: 0 }); }}>
                  <option value={50}>50</option>
                  <option value={100}>100</option>
                  <option value={200}>200</option>
                  <option value={500}>500</option>
                </select>
              </div>
            </div>
          </div>
        );
      };

      // start / stop polling
      useEffect(function() {
        // single immediate fetch on mount or when filters change
        fetchOnce();

        if (live) {
          pollingRef.current = setInterval(fetchOnce, 1000); // silent updates
        }
        return function() {
          if (pollingRef.current) {
            clearInterval(pollingRef.current);
            pollingRef.current = null;
          }
        };
      }, [live, year, location, selectedMonth]); // re-fetch when these change

      // when page mounts create empty charts to avoid flash
      useEffect(function() {
        if (locChartRef.current && !locChartInst.current) {
          updateOrCreateChart(locChartInst, locChartRef.current, {
            type: 'line',
            data: { labels: [], datasets: [{ label: 'PIN rejections', data: [], borderColor:'#2563eb', backgroundColor:'rgba(37,99,235,0.2)', fill:true, tension:0.3 }]},
            options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
          });
        }
        if (monthChartRef.current && !monthChartInst.current) {
          updateOrCreateChart(monthChartInst, monthChartRef.current, {
            type: 'line',
            data: { labels: MONTH_NAMES, datasets: [{ label: 'Monthly PIN rejections', data: Array(12).fill(0), fill:false, tension:0.3 }]},
            options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
          });
        }
      }, []);

      // helper to derive top locations/employees for selectedMonth (0=All months)
      function topForSelectedMonthByLocation(limit=20) {
        if (selectedMonth === 0) {
          const agg = aggregateMonthByLocationForAllMonths(monthByLocationRaw);
          return agg.slice(0,limit);
        } else {
          const rows = (monthByLocationRaw || []).filter(r => Number(r.Month) === Number(selectedMonth));
          const map = {};
          rows.forEach(r => {
            const loc = r.PartitionName2 || r.Partition || r.location || '';
            map[loc] = (map[loc] || 0) + Number(r.count || 0);
          });
          return Object.keys(map).map(k => ({ PartitionName2: k, count: map[k] })).sort((a,b)=>b.count-a.count).slice(0,limit);
        }
      }

      function topForSelectedMonthByEmployee(limit=20) {
        // returns [{person_uid, count, EmployeeID, EmployeeName}]
        if (selectedMonth === 0) {
          // aggregate across all months if monthByEmployeeRaw present
          if (monthByEmployeeRaw && monthByEmployeeRaw.length > 0) {
            const agg = aggregateMonthByEmployeeForAllMonths(monthByEmployeeRaw).slice(0,limit);
            return agg.map(x => ({
              person_uid: x.person_uid,
              count: x.count,
              EmployeeID: (personMap[String(x.person_uid)] || {}).EmployeeID || '',
              EmployeeName: (personMap[String(x.person_uid)] || {}).EmployeeName || ''
            }));
          } else {
            return (byEmployeeRaw || []).slice(0,limit).map(x => ({
              person_uid: x.id,
              count: x.count,
              EmployeeID: x.EmployeeID || ((personMap[String(x.id)] || {}).EmployeeID || ''),
              EmployeeName: x.EmployeeName || ((personMap[String(x.id)] || {}).EmployeeName || '')
            }));
          }
        } else {
          const rows = (monthByEmployeeRaw || []).filter(r => Number(r.Month) === Number(selectedMonth));
          const map = {};
          rows.forEach(r => {
            const id = r.person_uid || '';
            map[id] = (map[id] || 0) + Number(r.count || 0);
          });
          return Object.keys(map).map(k => ({
            person_uid: k,
            count: map[k],
            EmployeeID: (personMap[String(k)] || {}).EmployeeID || '',
            EmployeeName: (personMap[String(k)] || {}).EmployeeName || ''
          })).sort((a,b)=>b.count-a.count).slice(0,limit);
        }
      }

      function exportMonthByLocationCSV() {
        if (selectedMonth === 0) {
          const rows = topForSelectedMonthByLocation(500).map(r => ({
            Month: selectedMonth || 'All',
            MonthName: (selectedMonth === 0 ? 'All' : MONTH_NAMES[selectedMonth-1]),
            Location: r.PartitionName2 || r.name || '',
            Count: r.count
          }));
          if (rows.length===0) { alert("No month-by-location data for selected month"); return; }
          downloadCSV(rows, `emea_pin_month_${selectedMonth || 'all'}_by_location.csv`);
        } else {
          // day-by-location export if available
          const rows = (dayByLocationRaw || []).map(r => ({
            Month: selectedMonth,
            MonthName: MONTH_NAMES[selectedMonth-1],
            Day: r.Day,
            Location: r.PartitionName2 || '',
            Count: r.count
          }));
          if (rows.length===0) { alert("No day-by-location data for selected month"); return; }
          downloadCSV(rows, `emea_pin_month_${selectedMonth}_day_by_location.csv`);
        }
      }

      // produce final repeaters list to show in the sidebar (id, name, count)
      function getTopRepeatersForDisplay(limit=50) {
        // Use personMap to map id -> name reliably
        if (selectedMonth === 0) {
          let base = (byEmployeeRaw && byEmployeeRaw.length > 0) ? byEmployeeRaw.slice(0) : [];
          if (base.length === 0 && monthByEmployeeRaw && monthByEmployeeRaw.length > 0) {
            base = aggregateMonthByEmployeeForAllMonths(monthByEmployeeRaw).map(x => ({ id: x.person_uid, count: x.count }));
          } else {
            base = base.map(x => ({ id: x.id, count: x.count }));
          }
          return base.sort((a,b)=>b.count - a.count).slice(0,limit).map(x => {
            const pid = String(x.id || '');
            const mapping = personMap[pid] || {};
            return {
              id: mapping.EmployeeID || pid || '',
              name: mapping.EmployeeName || '',
              count: x.count || 0
            };
          });
        } else {
          const monthTop = topForSelectedMonthByEmployee(limit);
          return monthTop.map(x => ({
            id: x.EmployeeID || x.person_uid || '',
            name: x.EmployeeName || '',
            count: x.count || 0
          }));
        }
      }

      const displayTopRepeaters = getTopRepeatersForDisplay(50);

      // setState helper wrappers (avoid lint)
      function setByLocation(v){ setByLocationRaw(v); }
      function setByEmployee(v){ setByEmployeeRaw(v); }
      function setMonthTotals(v){ setMonthTotalsRaw(v); }
      function setMonthByLocation(v){ setMonthByLocationRaw(v); }
      function setMonthByEmployee(v){ setMonthByEmployeeRaw(v); }
      function setDayTotals(v){ setDayTotalsRaw(v); }
      function setDayByLocation(v){ setDayByLocationRaw(v); }

      return (
        <div className="container" >
          <div className="topbar" role="banner" style={{ marginBottom: 10 }}>

{ view === 'dashboard' ? (
            <div style={{ display:'flex', alignItems:'center', gap:12 }}>

              <div className="wu-logo">WU</div>
              <div>
                <h1 style={{ margin: 0, color: 'var(--wu-yellow)',fontSize: 18 }}>EMEA PIN — Live Dashboard</h1>
                <div style={{ fontSize: 13, color: '#e6e6e6' }}>Live PIN rejections</div>
              </div>
            </div>
            ) : (
  // Details view: keep same header but show details panel full-width
  <div style={{ display:'flex', gap:12 }}>
    <div style={{ flex:1 }}>
      <DetailsPanel />
    </div>
    <aside style={{ width: 340 }}>
      {/* keep the existing small details summary card on the right for context (optional) */}
      <div className="card" style={{ padding:10 }}>
        <h4 style={{ marginTop:0 }}>Summary</h4>
        <div><b>Total rejections:</b> {total}</div>
        <div><b>Unique employees:</b> {uniqueEmployees}</div>
        <div><b>Repeaters:</b> {repeatersCount}</div>
      </div>
    </aside>
  </div>
)}

            <div className="header-actions" style={{ alignItems:'center' }}>
              <div style={{ display:'flex', gap:8, alignItems:'center' }} className="top-controls">
                <label className="small" style={{ color:'#e6e6e6' }}>Year</label>
                <input type="number" value={year} onChange={(e)=>setYear(Number(e.target.value||new Date().getFullYear()))} style={{ width:100, padding:6, borderRadius:6 }} />

                <label className="small" style={{ color:'#e6e6e6' }}>Month</label>
                <select value={selectedMonth} onChange={e=>setSelectedMonth(Number(e.target.value))} style={{ padding:6, borderRadius:6 }}>
                  <option value={0}>All months</option>
                  {Array.from({length:12},(_,i)=>i+1).map(m => <option key={m} value={m}>{MONTH_NAMES[m-1]} ({m})</option>)}
                </select>

                <label className="small" style={{ color:'#e6e6e6' }}>Location</label>
                <select value={location} onChange={e=>setLocation(e.target.value)} style={{ padding:6, borderRadius:6 }}>
                  <option>All locations</option>
                  {EMEA_PARTITIONS.map(p => <option key={p} value={p}>{p}</option>)}
                </select>

                <button className="btn-ghost" onClick={() => { setLive(!live); }}>{live ? 'Pause' : 'Resume'}</button>
                <button className="btn-primary" onClick={fetchOnce} disabled={loading}>Refresh</button>
                <button className="small-button" onClick={() => exportMonthByLocationCSV()}>Export Month-By-Location</button>
              </div>
            </div>
          </div>

          <div style={{ display:'flex', gap:12 }}>
            <div style={{ flex:1 }}>
              <div className="cards" style={{ marginBottom:10 }}>
                <div className="card">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{total.toLocaleString()}</h3>
                      <p>Total rejections</p>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{uniqueEmployees.toLocaleString()}</h3>
                      <p>Unique employees</p>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{repeatersCount.toLocaleString()}</h3>
                      <p>Repeat offenders</p>
                    </div>
                  </div>
                </div>
              </div>

              <div style={{ background:'#fff', padding:12, borderRadius:10, boxShadow:'0 6px 18px rgba(2,6,23,0.04)' }}>
                <h3 style={{ marginTop:0 }}>Location wise</h3>
                <div className="chart-wrap chart-small" style={{ marginBottom:12 }}>
                  <canvas ref={locChartRef}></canvas>
                </div>

                <div style={{ marginTop:10, fontSize:13, color:'#64748b' }}>
                  Last fetch: {lastFetch ? new Date(lastFetch).toLocaleString() : 'never'} {loading ? ' • loading…' : ''}
                </div>
              </div>

              {/* Month panel */}
              <div style={{ marginTop:12, background:'#fff', padding:12, borderRadius:10, boxShadow:'0 6px 18px rgba(2,6,23,0.04)' }}>
                <h3 style={{ marginTop:0 }}>Month-wise analysis</h3>

                <div className="month-panel">
                  <div style={{ marginLeft: 8 }}>
                    <button className="small-button" onClick={() => exportMonthByLocationCSV()}>Export Month Location CSV</button>
                  </div>
                </div>

                <div className="chart-wrap month-chart-wrap" style={{ marginTop:10 }}>
                  <canvas ref={monthChartRef}></canvas>
                </div>
              </div>

            </div>

            <aside style={{ width: 340 }}>
              <div className="card" style={{ padding:10 }}>
                <h4 style={{ marginTop:0 }}>Details</h4>
               
                 <hr />
                <div>
                  <b>Total rejections:</b> {total}
                </div>
                <div><b>Unique employees:</b> {uniqueEmployees}</div>
                <div><b>Repeaters:</b> {repeatersCount}</div>
                <hr />
                <div>
                  <h5 style={{ margin:'6px 0' }}>
                    Top locations{selectedMonth === 0 ? " — All months" : ` - ${MONTH_NAMES[selectedMonth-1]}`}
                  </h5>
                  <div style={{ maxHeight:300, overflow:'auto' }}>
                    <table className="compact-table">
                      <thead><tr><th>Location</th><th>Count</th></tr></thead>
                      <tbody>
                        {topForSelectedMonthByLocation(50).map((r,i) => (
                          <tr key={i}><td style={{ padding:'6px 8px' }}>{r.PartitionName2 || r.name || '-'}</td><td style={{ padding:'6px 8px' }}>{r.count}</td></tr>
                        ))}
                        {(topForSelectedMonthByLocation(50).length===0) && <tr><td colSpan="2" className="muted">No location data</td></tr>}
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>

              <div style={{ height:12 }} />

              {/* NEW: Top repeaters card (merged view) */}
              <div className="card" style={{ padding:10 }}>
                <h4 style={{ marginTop:0 }}>Top repeaters{selectedMonth === 0 ? " — All months" : ` - ${MONTH_NAMES[selectedMonth-1]}`}</h4>
                <div style={{ maxHeight:260, overflow:'auto' }}>
                  <table className="compact-table">
                    <thead><tr><th>EmployeeID</th><th>Name</th><th>Count</th></tr></thead>
                    <tbody>
                      {displayTopRepeaters.map((r,i)=>(
                        <tr key={i}>
                          <td style={{ padding:'6px 8px' }}>{r.id || '-'}</td>
                          <td style={{ padding:'6px 8px' }}>{r.name || '-'}</td>
                          <td style={{ padding:'6px 8px' }}>{r.count}</td>
                        </tr>
                      ))}
                      {(displayTopRepeaters.length===0) && <tr><td colSpan="3" className="muted">No repeaters data</td></tr>}
                    </tbody>
                  </table>
                </div>
              </div>

              <div style={{ height:12 }} />
              <div className="card" style={{ padding:10 }}>
                <h4 style={{ marginTop:0 }}>Actions</h4>
                <div style={{ display:'flex', gap:8 }}>
                  <button className="small-button" onClick={() => { setLocation('All locations'); setYear(new Date().getFullYear()); setSelectedMonth(0); }}>Reset</button>
                  <button className="small-button" onClick={() => downloadCSV((recent||[]).slice(0,200), `emea_pin_recent_${year}.csv`)}>Export Recent</button>
                  <button className="small-button" onClick={() => { setView('details'); setDetailsOffset(0); fetchDetails({ offset:0 }); }}>Details</button>
                </div>
              </div>

            </aside>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(EmeaPinApp));
  })();
  </script>
</body>
</html>




















Lets check file line by line and fix the issue and share me Fully updated file so i can easily swap file each other 

Uncaught ReferenceError: detailsOffset is not defined
    at DetailsPanel (<anonymous>:1351:17)
    at renderWithHooks (react-dom.development.js:15496:20)
    at mountIndeterminateComponent (react-dom.development.js:20113:15)
    at beginWork (react-dom.development.js:21636:18)
    at HTMLUnknownElement.callCallback (react-dom.development.js:4151:16)
    at Object.invokeGuardedCallbackDev (react-dom.development.js:4200:18)
    at invokeGuardedCallback (react-dom.development.js:4264:33)
    at beginWork$1 (react-dom.development.js:27500:9)
    at performUnitOfWork (react-dom.development.js:26609:14)
    at workLoopSync (react-dom.development.js:26515:7)Understand this error
react-dom.development.js:18714 The above error occurred in the <DetailsPanel> component:

    at DetailsPanel (<anonymous>:1351:17)
    at div
    at div
    at div
    at div
    at EmeaPinApp (<anonymous>:52:21)

Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.
logCapturedError @ react-dom.development.js:18714Understand this error
react-dom.development.js:12066 Uncaught ReferenceError: detailsOffset is not defined
    at DetailsPanel (<anonymous>:1351:17)
    at renderWithHooks (react-dom.development.js:15496:20)
    at mountIndeterminateComponent (react-dom.development.js:20113:15)
    at beginWork (react-dom.development.js:21636:18)
    at beginWork$1 (react-dom.development.js:27475:16)
    at performUnitOfWork (react-dom.development.js:26609:14)
    at workLoopSync (react-dom.development.js:26515:7)
    at renderRootSync (react-dom.development.js:26483:9)
    at recoverFromConcurrentError (react-dom.development.js:25899:22)
    at performSyncWorkOnRoot (react-dom.development.js:26145:22)Understand this error



<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>EMEA PIN Dashboard — Live</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <link rel="stylesheet" href="style.css">
  <style>
    .topbar { margin-bottom: 8px; }
    .small-card { padding: 12px; text-align: center; }
    .top-controls { display:flex; gap:8px; align-items:center; }
    .chart-small { height:220px; }
    .compact-table td { padding:6px; font-size:13px; }
    .muted { color:#9aa4b2; }
    .month-panel { display:flex; gap:12px; margin-top:12px; align-items:center; }
    .month-chart-wrap { height:200px; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
  (function () {
    const { useState, useEffect, useRef } = React;

    // CHANGE THESE as needed:
    const API_BASE = "http://localhost:8003";
    const API_ENDPOINT = API_BASE + "/api/emea_pin_live";

    const EMEA_PARTITIONS = ["LT.Vilnius","IT.Rome","UK.London","IE.DUblin","DU.Abu Dhab","ES.Madrid","AUT.Vienna","MA.Casablanca","RU.Moscow"];
    const MONTH_NAMES = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    

    function formatDateShort(d) {
      if (!d) return '-';
      try {
        const dt = new Date(d);
        if (isNaN(dt.getTime())) return String(d).slice(0,19);
        return dt.toLocaleString();
      } catch (e) { return String(d); }
    }

    function downloadCSV(rows, filename = 'export.csv') {
      if (!rows || rows.length === 0) { alert("No data to export"); return; }
      const cols = Object.keys(rows[0]);
      const lines = [];
      lines.push(cols.join(','));
      rows.forEach(r => {
        const line = cols.map(c => {
          const v = r[c] === null || r[c] === undefined ? '' : String(r[c]).replace(/\n/g,' ');
          return JSON.stringify(v);
        }).join(',');
        lines.push(line);
      });
      const blob = new Blob([lines.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = filename; a.click(); URL.revokeObjectURL(url);
    }

    function EmeaPinApp() {
      const [year, setYear] = useState(new Date().getFullYear());
      const [location, setLocation] = useState('All locations');
        // day-wise arrays returned by API when a specific month is requested

      // IMPORTANT: default live=false so no automatic polling starts on load.
      const [live, setLive] = useState(false);

      // month selector in header. 0 === All months, 1..12 specific month
      const [selectedMonth, setSelectedMonth] = useState(0);

      const [loading, setLoading] = useState(false);
      const [lastFetch, setLastFetch] = useState(null);

      const [total, setTotal] = useState(0);
      const [uniqueEmployees, setUniqueEmployees] = useState(0);
      const [repeatersCount, setRepeatersCount] = useState(0);

      // main lists (raw normalized arrays from API)
      const [byLocationRaw, setByLocationRaw] = useState([]); // array of {name, count}
      const [byEmployeeRaw, setByEmployeeRaw] = useState([]); // array of {id, count, EmployeeID, EmployeeName}
      const [recent, setRecent] = useState([]);

      // person map from API: { person_uid: { EmployeeID, EmployeeName } }
      const [personMap, setPersonMap] = useState({});

      // month-wise raw arrays from API
      const [monthTotalsRaw, setMonthTotalsRaw] = useState([]); // {Month, MonthName, count}
      const [monthByLocationRaw, setMonthByLocationRaw] = useState([]); // {Month, MonthName, PartitionName2, count}
      const [monthByEmployeeRaw, setMonthByEmployeeRaw] = useState([]); // {Month, MonthName, person_uid, count, EmployeeID, EmployeeName}

      // day-wise arrays returned by API when a specific month is requested
      const [dayTotalsRaw, setDayTotalsRaw] = useState([]); // {Day, count}
      const [dayByLocationRaw, setDayByLocationRaw] = useState([]); // {Day, PartitionName2, count}


      const pollingRef = useRef(null);
      const inFlightRef = useRef(false);

      // chart refs
      const locChartRef = useRef(null);
      const locChartInst = useRef(null);
      const monthChartRef = useRef(null);
      const monthChartInst = useRef(null);


            // which page to show: 'dashboard' or 'details'
      const [view, setView] = useState('dashboard');

      // details page state
      const [detailsEmployeeId, setDetailsEmployeeId] = useState('');
      const [detailsFromDate, setDetailsFromDate] = useState(''); // YYYY-MM-DD
      const [detailsToDate, setDetailsToDate] = useState('');     // YYYY-MM-DD
      const [detailsLimit, setDetailsLimit] = useState(200);
      const [detailsOffset, setDetailsOffset] = useState(0);
      const [detailsRows, setDetailsRows] = useState([]);
      const [detailsTotal, setDetailsTotal] = useState(0);
      const [detailsLoading, setDetailsLoading] = useState(false);


      // Helper: update (or create) a Chart.js instance cleanly (silent update)
      function updateOrCreateChart(instRef, canvas, config) {
        if (!canvas) return;
        try {
          if (instRef.current) {
            instRef.current.data = config.data;
            instRef.current.options = config.options || instRef.current.options;
            instRef.current.update();
            return instRef.current;
          } else {
            instRef.current = new Chart(canvas.getContext('2d'), config);
            return instRef.current;
          }
        } catch (e) {
          try { if (instRef.current) instRef.current.destroy(); } catch (_) {}
          instRef.current = new Chart(canvas.getContext('2d'), config);
          return instRef.current;
        }
      }

      // Utilities for client-side aggregation & filtering
      function aggregateMonthByLocationForAllMonths(raw) {
        const map = {};
        (raw || []).forEach(r => {
          const loc = r.PartitionName2 || r.Partition || r.location || '';
          const c = Number(r.count || 0);
          if (!map[loc]) map[loc] = 0;
          map[loc] += c;
        });
        return Object.keys(map).map(k => ({ PartitionName2: k, count: map[k] })).sort((a,b)=>b.count-a.count);
      }

      function aggregateMonthByEmployeeForAllMonths(raw) {
        const map = {};
        (raw || []).forEach(r => {
          const id = r.person_uid || r.EmployeeID || r.employee_id || r.id || '';
          const c = Number(r.count || 0);
          if (!map[id]) map[id] = 0;
          map[id] += c;
        });
        return Object.keys(map).map(k => ({ person_uid: k, count: map[k] })).sort((a,b)=>b.count-a.count);
      }

      // Build data for Location chart depending on selected month & location
      function buildLocationChartData(byLocation, monthByLocation, selMonth, selLocation) {
        if (selLocation && selLocation !== 'All locations') {
          const monthArr = Array.from({length:12}, (_,i) => {
            const m = i+1;
            let found = null;
            for (let i2=0;i2<monthByLocation.length;i2++){
              const r = monthByLocation[i2];
              if (Number(r.Month) === m) {
                const part = r.PartitionName2 || r.Partition || r.location || '';
                if (String(part) === String(selLocation)) {
                  found = r; break;
                }
              }
            }
            return found && Number(found.count) ? Number(found.count) : 0;
          });
          if (selMonth === 0) {
            return { labels: MONTH_NAMES, data: monthArr, type: 'line' };
          } else {
            const mIndex = selMonth - 1;
            const val = monthArr[mIndex] || 0;
            return { labels: [MONTH_NAMES[mIndex]], data: [val], type: 'bar' };
          }
        } else {
          if (selMonth === 0) {
            const top = (byLocation || []).slice(0,12);
            const labels = top.map(x => x.name || x.PartitionName2 || '');
            const values = top.map(x => Number(x.count || 0));
            return { labels, data: values, type: 'line' };
          } else {
            const rows = (monthByLocation || []).filter(r => Number(r.Month) === Number(selMonth));
            const ag = {};
            rows.forEach(r => {
              const loc = r.PartitionName2 || r.Partition || r.location || '';
              ag[loc] = (ag[loc] || 0) + Number(r.count || 0);
            });
            const arr = Object.keys(ag).map(k => ({ PartitionName2: k, count: ag[k] })).sort((a,b)=>b.count-a.count).slice(0,12);
            const labels = arr.map(x => x.PartitionName2 || '');
            const values = arr.map(x => x.count || 0);
            return { labels, data: values, type: 'line' };
          }
        }
      }

      // Core fetch — silent update pattern:
      async function fetchOnce() {
        if (inFlightRef.current) return;
        inFlightRef.current = true;
        setLoading(true);

        try {
          const params = new URLSearchParams();
          if (year) params.set('year', String(year));
          // send month only when a specific month is selected (selectedMonth: 1..12)
          if (selectedMonth && Number(selectedMonth) !== 0) params.set('month', String(selectedMonth));
          if (location && location !== 'All locations') params.set('location', location);
          const url = API_ENDPOINT + '?' + params.toString();



          const r = await fetch(url, { cache: 'no-store' });
          if (!r.ok) {
            const txt = await r.text().catch(()=>'');
            throw new Error('API error: ' + r.status + ' ' + txt);
          }
          const js = await r.json();

          // parse results into local variables first (do not mutate state yet)
          const total_rejections = (js.total_rejections !== undefined) ? js.total_rejections
            : (js.total !== undefined ? js.total : (js.totalRejections || 0));

          const rawByLoc = js.by_location || js.byLocation || js.location_counts || [];
          const normalizedByLoc = Array.isArray(rawByLoc) ? rawByLoc.map(function(x) {
            var k = x.PartitionName2 || x.partition || x.location || x.name || x.PartitionName || '';
            var c = x.count !== undefined ? x.count : (x.value !== undefined ? x.value : 0);
            return { name: String(k || '').trim(), count: Number(c || 0) };
          }) : [];

          const rawByEmp = js.by_employee || js.byEmployee || js.employee_counts || [];
          const normalizedByEmp = Array.isArray(rawByEmp) ? rawByEmp.map(function(x) {
            var id = x.person_uid || x.EmployeeID || x.employee_id || x.id || x.person || '';
            var c = x.count !== undefined ? x.count : (x.value !== undefined ? x.value : 0);
            var empIdCol = x.EmployeeID || x.EmployeeId || x.employee_id || '';
            var empNameCol = x.EmployeeName || x.Employee || x.EmployeeName || '';
            return { id: String(id || '').trim(), count: Number(c || 0), EmployeeID: empIdCol || '', EmployeeName: empNameCol || '' };
          }) : [];

          const rawRecent = js.recent || js.rows || js.events || js.recent_rows || [];

          // month-wise
          const rawMonthTotals = js.month_totals || js.monthTotals || [];
          const normalizedMonthTotals = Array.isArray(rawMonthTotals) ? rawMonthTotals.map(function(x) {
            return {
              Month: Number(x.Month || x.month || 0),
              MonthName: x.MonthName || x.monthName || x.monthname || "",
              count: Number(x.count || x.value || 0)
            };
          }) : [];


          const rawMonthByLoc = js.month_by_location || js.monthByLocation || [];
          const normalizedMonthByLoc = Array.isArray(rawMonthByLoc) ? rawMonthByLoc.map(function(x) {
            return {
              Month: Number(x.Month || x.month || 0),
              MonthName: x.MonthName || x.monthName || x.monthname || "",
              PartitionName2: x.PartitionName2 || x.Partition || x.location || "",
              count: Number(x.count || x.value || 0)
            };
          }) : [];

          const rawMonthByEmp = js.month_by_employee || js.monthByEmployee || [];
          const normalizedMonthByEmp = Array.isArray(rawMonthByEmp) ? rawMonthByEmp.map(function(x) {
            return {
              Month: Number(x.Month || x.month || 0),
              MonthName: x.MonthName || x.monthName || x.monthname || "",
              person_uid: x.person_uid || x.EmployeeID || x.employee_id || x.id || "",
              count: Number(x.count || x.value || 0),
              EmployeeID: x.EmployeeID || x.employee_id || '',
              EmployeeName: x.EmployeeName || ''
            };
          }) : [];


          // day-wise (for selected month) — optional
          const rawDayTotals = js.day_totals || js.dayTotals || [];
          const normalizedDayTotals = Array.isArray(rawDayTotals) ? rawDayTotals.map(function(x) {
            return {
              Day: Number(x.Day || x.day || 0),
              count: Number(x.count || x.value || 0)
            };
          }) : [];

          const rawDayByLoc = js.day_by_location || js.dayByLocation || [];
          const normalizedDayByLoc = Array.isArray(rawDayByLoc) ? rawDayByLoc.map(function(x) {
            return {
              Day: Number(x.Day || x.day || 0),
              PartitionName2: x.PartitionName2 || x.Partition || x.location || "",
              count: Number(x.count || x.value || 0)
            };
          }) : [];


          // parse person_map (if provided)
          const rawPersonMap = js.person_map || js.personMap || {};
          const normalizedPersonMap = {};
          Object.keys(rawPersonMap || {}).forEach(k => {
            const v = rawPersonMap[k] || {};
            normalizedPersonMap[String(k)] = {
              EmployeeID: v.EmployeeID || v.employeeId || v.EmployeeId || '',
              EmployeeName: v.EmployeeName || v.EmployeeName || v.name || ''
            };
          });

          // compute derived metrics locally
          const unique = new Set((normalizedByEmp || []).map(function(e){ return e.id; }).filter(Boolean));
          const repeaters = (normalizedByEmp || []).filter(function(e){ return e.count > 1; });

          // Now update React state in one go
          setTotal(Number(total_rejections || 0));
          setByLocation(normalizedByLoc);
          setByEmployee(normalizedByEmp);
          setRecent(Array.isArray(rawRecent) ? rawRecent : []);
          setUniqueEmployees(unique.size);
          setRepeatersCount(repeaters.length);

          setMonthTotals(normalizedMonthTotals);
          setMonthByLocation(normalizedMonthByLoc);
          setMonthByEmployee(normalizedMonthByEmp);

          setPersonMap(normalizedPersonMap);
        setDayTotals(normalizedDayTotals);
        setDayByLocation(normalizedDayByLoc);


          // update charts in-place (no flicker)
          if (locChartRef.current) {
            const topLoc = (normalizedByLoc || []).slice(0,12);
            const labels = topLoc.map(function(x){ return x.name || 'Unknown'; });
            const values = topLoc.map(function(x){ return x.count || 0; });
            updateOrCreateChart(locChartInst, locChartRef.current, {
              type: 'line',
              data: {
                labels: labels,
                datasets: [{
                  label: 'PIN rejections',
                  data: values,
                  borderColor: '#2563eb',
                  backgroundColor: 'rgba(37,99,235,0.2)',
                  fill: true,
                  tension: 0.3,
                  pointBackgroundColor: '#2563eb',
                  pointRadius: 5,
                  pointHoverRadius: 7,
                  borderWidth: 2
                }]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: { x: { type: 'category' }, y: { beginAtZero: true, ticks: { precision: 0 } } }
              }
            });
          }

     
     
    

          // Month / Day totals chart
          if (monthChartRef.current) {
            if (selectedMonth === 0) {
              // monthly view (12 month buckets)
              var monthArr = Array.from({length:12}, function(_,i) {
                var m = i + 1;
                var rec = null;
                for (var ri = 0; ri < normalizedMonthTotals.length; ri++) {
                  var cand = normalizedMonthTotals[ri];
                  if (Number(cand.Month) === m) { rec = cand; break; }
                }
                return rec && rec.count ? Number(rec.count) : 0;
              });
              updateOrCreateChart(monthChartInst, monthChartRef.current, {
                type: 'line',
                data: { labels: MONTH_NAMES, datasets: [{ label: 'Monthly PIN rejections', data: monthArr, fill:false, tension:0.3 }] },
                options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
              });
            } else {
              // day-wise view for the selected month
              // determine days in selected month
              const daysInMonth = new Date(Number(year), Number(selectedMonth), 0).getDate();
              const labels = Array.from({length: daysInMonth}, (_,i) => String(i+1));
              const dayArr = Array.from({length: daysInMonth}, function(_,i) {
                const d = i + 1;
                var rec = null;
                for (var ri = 0; ri < normalizedDayTotals.length; ri++) {
                  var cand = normalizedDayTotals[ri];
                  if (Number(cand.Day) === d) { rec = cand; break; }
                }
                return rec && rec.count ? Number(rec.count) : 0;
              });
              updateOrCreateChart(monthChartInst, monthChartRef.current, {
                type: 'line',
                data: { labels: labels, datasets: [{ label: `Day-wise for ${MONTH_NAMES[selectedMonth-1]}`, data: dayArr, fill:false, tension:0.3 }] },
                options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
              });
            }
          }





          setLastFetch(new Date().toISOString());

        } catch (err) {
          console.error("Fetch EMEA PIN failed", err);
        } finally {
          setLoading(false);
          inFlightRef.current = false;
        }
      }


      async function fetchDetails(opts = {}) {
        // opts can contain employeeId, fromDate, toDate, location, limit, offset, year
        const emp = opts.employeeId !== undefined ? opts.employeeId : detailsEmployeeId;
        const fromD = opts.fromDate !== undefined ? opts.fromDate : detailsFromDate;
        const toD = opts.toDate !== undefined ? opts.toDate : detailsToDate;
        const lim = opts.limit !== undefined ? opts.limit : detailsLimit;
        const off = opts.offset !== undefined ? opts.offset : detailsOffset;
        const loc = opts.location !== undefined ? opts.location : location;
        const yr = opts.year !== undefined ? opts.year : year;

        setDetailsLoading(true);
        try {
          const params = new URLSearchParams();
          if (yr) params.set('year', String(yr));
          if (loc && loc !== 'All locations') params.set('location', loc);
          if (emp) params.set('employee_id', emp);
          if (fromD) params.set('from_date', fromD);
          if (toD) params.set('to_date', toD);
          params.set('limit', String(lim));
          params.set('offset', String(off));

          const url = API_ENDPOINT.replace('/api/emea_pin_live','/api/emea_pin_details') + '?' + params.toString();
          const r = await fetch(url, { cache: 'no-store' });
          if (!r.ok) {
            const txt = await r.text().catch(()=> '');
            throw new Error('Details API error: ' + r.status + ' ' + txt);
          }
          const js = await r.json();
          setDetailsRows(js.rows || []);
          setDetailsTotal(js.total || 0);
          setDetailsLimit(js.limit || lim);
          setDetailsOffset(js.offset || off);
        } catch (err) {
          console.error("Fetch details failed", err);
          alert("Failed to load details: " + err.message);
        } finally {
          setDetailsLoading(false);
        }
      }



            function exportDetailsCSV() {
        const params = new URLSearchParams();
        if (year) params.set('year', String(year));
        if (location && location !== 'All locations') params.set('location', location);
        if (detailsEmployeeId) params.set('employee_id', detailsEmployeeId);
        if (detailsFromDate) params.set('from_date', detailsFromDate);
        if (detailsToDate) params.set('to_date', detailsToDate);
        // export=csv triggers backend CSV download
        params.set('export', 'csv');
        const url = API_ENDPOINT.replace('/api/emea_pin_live','/api/emea_pin_details') + '?' + params.toString();
        // trigger download
        window.open(url, '_blank');
      }



      // start / stop polling
      useEffect(function() {
        // single immediate fetch on mount or when filters change
        fetchOnce();

        if (live) {
          pollingRef.current = setInterval(fetchOnce, 1000); // silent updates
        }
        return function() {
          if (pollingRef.current) {
            clearInterval(pollingRef.current);
            pollingRef.current = null;
          }
        };
      }, [live, year, location, selectedMonth]); // re-fetch when these change

      // when page mounts create empty charts to avoid flash
      useEffect(function() {
        if (locChartRef.current && !locChartInst.current) {
          updateOrCreateChart(locChartInst, locChartRef.current, {
            type: 'line',
            data: { labels: [], datasets: [{ label: 'PIN rejections', data: [], borderColor:'#2563eb', backgroundColor:'rgba(37,99,235,0.2)', fill:true, tension:0.3 }]},
            options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
          });
        }
        if (monthChartRef.current && !monthChartInst.current) {
          updateOrCreateChart(monthChartInst, monthChartRef.current, {
            type: 'line',
            data: { labels: MONTH_NAMES, datasets: [{ label: 'Monthly PIN rejections', data: Array(12).fill(0), fill:false, tension:0.3 }]},
            options: { responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{ y:{beginAtZero:true} } }
          });
        }
      }, []);

      // helper to derive top locations/employees for selectedMonth (0=All months)
      function topForSelectedMonthByLocation(limit=20) {
        if (selectedMonth === 0) {
          const agg = aggregateMonthByLocationForAllMonths(monthByLocationRaw);
          return agg.slice(0,limit);
        } else {
          const rows = (monthByLocationRaw || []).filter(r => Number(r.Month) === Number(selectedMonth));
          const map = {};
          rows.forEach(r => {
            const loc = r.PartitionName2 || r.Partition || r.location || '';
            map[loc] = (map[loc] || 0) + Number(r.count || 0);
          });
          return Object.keys(map).map(k => ({ PartitionName2: k, count: map[k] })).sort((a,b)=>b.count-a.count).slice(0,limit);
        }
      }

      function topForSelectedMonthByEmployee(limit=20) {
        // returns [{person_uid, count, EmployeeID, EmployeeName}]
        if (selectedMonth === 0) {
          // aggregate across all months if monthByEmployeeRaw present
          if (monthByEmployeeRaw && monthByEmployeeRaw.length > 0) {
            const agg = aggregateMonthByEmployeeForAllMonths(monthByEmployeeRaw).slice(0,limit);
            return agg.map(x => ({
              person_uid: x.person_uid,
              count: x.count,
              EmployeeID: (personMap[String(x.person_uid)] || {}).EmployeeID || '',
              EmployeeName: (personMap[String(x.person_uid)] || {}).EmployeeName || ''
            }));
          } else {
            return (byEmployeeRaw || []).slice(0,limit).map(x => ({
              person_uid: x.id,
              count: x.count,
              EmployeeID: x.EmployeeID || ((personMap[String(x.id)] || {}).EmployeeID || ''),
              EmployeeName: x.EmployeeName || ((personMap[String(x.id)] || {}).EmployeeName || '')
            }));
          }
        } else {
          const rows = (monthByEmployeeRaw || []).filter(r => Number(r.Month) === Number(selectedMonth));
          const map = {};
          rows.forEach(r => {
            const id = r.person_uid || '';
            map[id] = (map[id] || 0) + Number(r.count || 0);
          });
          return Object.keys(map).map(k => ({
            person_uid: k,
            count: map[k],
            EmployeeID: (personMap[String(k)] || {}).EmployeeID || '',
            EmployeeName: (personMap[String(k)] || {}).EmployeeName || ''
          })).sort((a,b)=>b.count-a.count).slice(0,limit);
        }
      }




      
      function exportMonthByLocationCSV() {
        if (selectedMonth === 0) {
          const rows = topForSelectedMonthByLocation(500).map(r => ({
            Month: selectedMonth || 'All',
            MonthName: (selectedMonth === 0 ? 'All' : MONTH_NAMES[selectedMonth-1]),
            Location: r.PartitionName2 || r.name || '',
            Count: r.count
          }));
          if (rows.length===0) { alert("No month-by-location data for selected month"); return; }
          downloadCSV(rows, `emea_pin_month_${selectedMonth || 'all'}_by_location.csv`);
        } else {
          // day-by-location export if available
          const rows = (dayByLocationRaw || []).map(r => ({
            Month: selectedMonth,
            MonthName: MONTH_NAMES[selectedMonth-1],
            Day: r.Day,
            Location: r.PartitionName2 || '',
            Count: r.count
          }));
          if (rows.length===0) { alert("No day-by-location data for selected month"); return; }
          downloadCSV(rows, `emea_pin_month_${selectedMonth}_day_by_location.csv`);
        }
      }


      // produce final repeaters list to show in the sidebar (id, name, count)
      function getTopRepeatersForDisplay(limit=50) {
        // Use personMap to map id -> name reliably
        if (selectedMonth === 0) {
          let base = (byEmployeeRaw && byEmployeeRaw.length > 0) ? byEmployeeRaw.slice(0) : [];
          if (base.length === 0 && monthByEmployeeRaw && monthByEmployeeRaw.length > 0) {
            base = aggregateMonthByEmployeeForAllMonths(monthByEmployeeRaw).map(x => ({ id: x.person_uid, count: x.count }));
          } else {
            base = base.map(x => ({ id: x.id, count: x.count }));
          }
          return base.sort((a,b)=>b.count - a.count).slice(0,limit).map(x => {
            const pid = String(x.id || '');
            const mapping = personMap[pid] || {};
            return {
              id: mapping.EmployeeID || pid || '',
              name: mapping.EmployeeName || '',
              count: x.count || 0
            };
          });
        } else {
          const monthTop = topForSelectedMonthByEmployee(limit);
          return monthTop.map(x => ({
            id: x.EmployeeID || x.person_uid || '',
            name: x.EmployeeName || '',
            count: x.count || 0
          }));
        }
      }

      const displayTopRepeaters = getTopRepeatersForDisplay(50);

      // setState helper wrappers (avoid lint)
      function setByLocation(v){ setByLocationRaw(v); }
      function setByEmployee(v){ setByEmployeeRaw(v); }
      function setMonthTotals(v){ setMonthTotalsRaw(v); }
      function setMonthByLocation(v){ setMonthByLocationRaw(v); }
      function setMonthByEmployee(v){ setMonthByEmployeeRaw(v); }
      function setDayTotals(v){ setDayTotalsRaw(v); }
      function setDayByLocation(v){ setDayByLocationRaw(v); }

      return (
        <div className="container" >
          <div className="topbar" role="banner" style={{ marginBottom: 10 }}>

{ view === 'dashboard' ? (
            <div style={{ display:'flex', alignItems:'center', gap:12 }}>

              <div className="wu-logo">WU</div>
              <div>
                <h1 style={{ margin: 0, color: 'var(--wu-yellow)',fontSize: 18 }}>EMEA PIN — Live Dashboard</h1>
                <div style={{ fontSize: 13, color: '#e6e6e6' }}>Live PIN rejections</div>
              </div>
            </div>
            ) : (
  // Details view: keep same header but show details panel full-width
  <div style={{ display:'flex', gap:12 }}>
    <div style={{ flex:1 }}>
      <DetailsPanel />
    </div>
    <aside style={{ width: 340 }}>
      {/* keep the existing small details summary card on the right for context (optional) */}
      <div className="card" style={{ padding:10 }}>
        <h4 style={{ marginTop:0 }}>Summary</h4>
        <div><b>Total rejections:</b> {total}</div>
        <div><b>Unique employees:</b> {uniqueEmployees}</div>
        <div><b>Repeaters:</b> {repeatersCount}</div>
      </div>
    </aside>
  </div>
)}

            <div className="header-actions" style={{ alignItems:'center' }}>
              <div style={{ display:'flex', gap:8, alignItems:'center' }} className="top-controls">
                <label className="small" style={{ color:'#e6e6e6' }}>Year</label>
                <input type="number" value={year} onChange={(e)=>setYear(Number(e.target.value||new Date().getFullYear()))} style={{ width:100, padding:6, borderRadius:6 }} />

                <label className="small" style={{ color:'#e6e6e6' }}>Month</label>
                <select value={selectedMonth} onChange={e=>setSelectedMonth(Number(e.target.value))} style={{ padding:6, borderRadius:6 }}>
                  <option value={0}>All months</option>
                  {Array.from({length:12},(_,i)=>i+1).map(m => <option key={m} value={m}>{MONTH_NAMES[m-1]} ({m})</option>)}
                </select>

                <label className="small" style={{ color:'#e6e6e6' }}>Location</label>
                <select value={location} onChange={e=>setLocation(e.target.value)} style={{ padding:6, borderRadius:6 }}>
                  <option>All locations</option>
                  {EMEA_PARTITIONS.map(p => <option key={p} value={p}>{p}</option>)}
                </select>

                <button className="btn-ghost" onClick={() => { setLive(!live); }}>{live ? 'Pause' : 'Resume'}</button>
                <button className="btn-primary" onClick={fetchOnce} disabled={loading}>Refresh</button>
                <button className="small-button" onClick={() => exportMonthByLocationCSV()}>Export Month-By-Location</button>
              </div>
            </div>
          </div>

          <div style={{ display:'flex', gap:12 }}>
            <div style={{ flex:1 }}>
              <div className="cards" style={{ marginBottom:10 }}>
                <div className="card">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{total.toLocaleString()}</h3>
                      <p>Total rejections</p>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{uniqueEmployees.toLocaleString()}</h3>
                      <p>Unique employees</p>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-content">
                    <div className="card-text">
                      <h3>{repeatersCount.toLocaleString()}</h3>
                      <p>Repeat offenders</p>
                    </div>
                  </div>
                </div>
              </div>

              <div style={{ background:'#fff', padding:12, borderRadius:10, boxShadow:'0 6px 18px rgba(2,6,23,0.04)' }}>
                <h3 style={{ marginTop:0 }}>Location wise</h3>
                <div className="chart-wrap chart-small" style={{ marginBottom:12 }}>
                  <canvas ref={locChartRef}></canvas>
                </div>

                <div style={{ marginTop:10, fontSize:13, color:'#64748b' }}>
                  Last fetch: {lastFetch ? new Date(lastFetch).toLocaleString() : 'never'} {loading ? ' • loading…' : ''}
                </div>
              </div>

              {/* Month panel */}
              <div style={{ marginTop:12, background:'#fff', padding:12, borderRadius:10, boxShadow:'0 6px 18px rgba(2,6,23,0.04)' }}>
                <h3 style={{ marginTop:0 }}>Month-wise analysis</h3>

                <div className="month-panel">
                  <div style={{ marginLeft: 8 }}>
                    <button className="small-button" onClick={() => exportMonthByLocationCSV()}>Export Month Location CSV</button>
                  </div>
                </div>

                <div className="chart-wrap month-chart-wrap" style={{ marginTop:10 }}>
                  <canvas ref={monthChartRef}></canvas>
                </div>
              </div>

            </div>

            <aside style={{ width: 340 }}>
              <div className="card" style={{ padding:10 }}>
                <h4 style={{ marginTop:0 }}>Details</h4>
               
                 <hr />
                <div>
                  <b>Total rejections:</b> {total}
                </div>
                <div><b>Unique employees:</b> {uniqueEmployees}</div>
                <div><b>Repeaters:</b> {repeatersCount}</div>
                <hr />
                <div>
                  <h5 style={{ margin:'6px 0' }}>
                    Top locations{selectedMonth === 0 ? " — All months" : ` - ${MONTH_NAMES[selectedMonth-1]}`}
                  </h5>
                  <div style={{ maxHeight:300, overflow:'auto' }}>
                    <table className="compact-table">
                      <thead><tr><th>Location</th><th>Count</th></tr></thead>
                      <tbody>
                        {topForSelectedMonthByLocation(50).map((r,i) => (
                          <tr key={i}><td style={{ padding:'6px 8px' }}>{r.PartitionName2 || r.name || '-'}</td><td style={{ padding:'6px 8px' }}>{r.count}</td></tr>
                        ))}
                        {(topForSelectedMonthByLocation(50).length===0) && <tr><td colSpan="2" className="muted">No location data</td></tr>}
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>

              <div style={{ height:12 }} />

              {/* NEW: Top repeaters card (merged view) */}
              <div className="card" style={{ padding:10 }}>
                <h4 style={{ marginTop:0 }}>Top repeaters{selectedMonth === 0 ? " — All months" : ` - ${MONTH_NAMES[selectedMonth-1]}`}</h4>
                <div style={{ maxHeight:260, overflow:'auto' }}>
                  <table className="compact-table">
                    <thead><tr><th>EmployeeID</th><th>Name</th><th>Count</th></tr></thead>
                    <tbody>
                      {displayTopRepeaters.map((r,i)=>(
                        <tr key={i}>
                          <td style={{ padding:'6px 8px' }}>{r.id || '-'}</td>
                          <td style={{ padding:'6px 8px' }}>{r.name || '-'}</td>
                          <td style={{ padding:'6px 8px' }}>{r.count}</td>
                        </tr>
                      ))}
                      {(displayTopRepeaters.length===0) && <tr><td colSpan="3" className="muted">No repeaters data</td></tr>}
                    </tbody>
                  </table>
                </div>
              </div>

              <div style={{ height:12 }} />
              <div className="card" style={{ padding:10 }}>
                <h4 style={{ marginTop:0 }}>Actions</h4>
                <div style={{ display:'flex', gap:8 }}>

                    
<button className="small-button" onClick={() => { setLocation('All locations'); setYear(new Date().getFullYear()); setSelectedMonth(0); }}>Reset</button>
<button className="small-button" onClick={() => downloadCSV((recent||[]).slice(0,200), `emea_pin_recent_${year}.csv`)}>Export Recent</button>
<button className="small-button" onClick={() => { setView('details'); setDetailsOffset(0); fetchDetails({ offset:0 }); }}>Details</button>


                
                  </div>
              </div>

            </aside>
          </div>
        </div>
      );
    }


    // --- DetailsPanel: must be defined inside EmeaPinApp so it can access state ---
      const DetailsPanel = () => {
        const start = detailsOffset || 0;
        const end = Math.min(detailsTotal, start + detailsLimit);

        return (
          <div style={{ padding:12, background:'#fff', borderRadius:10 }}>
            <div style={{ display:'flex', gap:8, alignItems:'center', marginBottom:12 }}>
              <label style={{ fontSize:13 }}>Employee ID</label>
              <input type="text" value={detailsEmployeeId} onChange={e=>setDetailsEmployeeId(e.target.value)} style={{ padding:6, borderRadius:6 }} />
              <label style={{ fontSize:13 }}>From</label>
              <input type="date" value={detailsFromDate} onChange={e=>setDetailsFromDate(e.target.value)} style={{ padding:6, borderRadius:6 }} />
              <label style={{ fontSize:13 }}>To</label>
              <input type="date" value={detailsToDate} onChange={e=>setDetailsToDate(e.target.value)} style={{ padding:6, borderRadius:6 }} />
              <button className="btn-primary" onClick={() => { setDetailsOffset(0); fetchDetails({ employeeId: detailsEmployeeId, fromDate: detailsFromDate, toDate: detailsToDate, offset:0 }); }}>Search</button>
              <button className="small-button" onClick={() => { setDetailsEmployeeId(''); setDetailsFromDate(''); setDetailsToDate(''); setDetailsOffset(0); fetchDetails({ employeeId:'', fromDate:'', toDate:'', offset:0 }); }}>Reset</button>
              <button className="small-button" onClick={() => exportDetailsCSV()}>Export CSV</button>
              <button className="small-button" onClick={() => setView('dashboard')}>Back</button>
            </div>

            <div style={{ maxHeight:500, overflow:'auto', border:'1px solid #eee', padding:8 }}>
              <table className="compact-table" style={{ width:'100%', borderCollapse:'collapse' }}>
                <thead><tr style={{ background:'#fafafa' }}>
                  <th style={{ padding:6 }}>EmployeeID</th>
                  <th style={{ padding:6 }}>Name</th>
                  <th style={{ padding:6 }}>Date</th>
                  <th style={{ padding:6 }}>Time</th>
                  <th style={{ padding:6 }}>Card</th>
                  <th style={{ padding:6 }}>Direction</th>
                  <th style={{ padding:6 }}>Door</th>
                  <th style={{ padding:6 }}>Alert Type</th>
                  <th style={{ padding:6 }}>Location</th>
                </tr></thead>
                <tbody>
                  {detailsLoading && <tr><td colSpan="9" className="muted">Loading…</td></tr>}
                  {!detailsLoading && detailsRows.length===0 && <tr><td colSpan="9" className="muted">No rows</td></tr>}
                  {!detailsLoading && detailsRows.map((r,i)=>(
                    <tr key={i}>
                      <td style={{ padding:6 }}>{r.EmployeeID || r.person_uid || '-'}</td>
                      <td style={{ padding:6 }}>{r.EmployeeName || '-'}</td>
                      <td style={{ padding:6 }}>{r.Date || r.DateOnly || '-'}</td>
                      <td style={{ padding:6 }}>{r.Time || '-'}</td>
                      <td style={{ padding:6 }}>{r.CardNumber || '-'}</td>
                      <td style={{ padding:6 }}>{r.Direction || '-'}</td>
                      <td style={{ padding:6 }}>{r.DoorName || '-'}</td>
                      <td style={{ padding:6 }}>{r.Rejection_Type || r.RejectionType || '-'}</td>
                      <td style={{ padding:6 }}>{r.Location || r.PartitionName2 || '-'}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>

            <div style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginTop:8 }}>
              <div style={{ fontSize:13 }}>{`Showing ${start+1} - ${end} of ${detailsTotal}`}</div>
              <div style={{ display:'flex', gap:8 }}>
                <button className="small-button" onClick={() => { const no = Math.max(0, detailsOffset - detailsLimit); setDetailsOffset(no); fetchDetails({ offset: no }); }} disabled={detailsOffset <= 0}>Prev</button>
                <button className="small-button" onClick={() => { const no = detailsOffset + detailsLimit; if (no < detailsTotal) { setDetailsOffset(no); fetchDetails({ offset: no }); } }} disabled={detailsOffset + detailsLimit >= detailsTotal}>Next</button>
                <select value={detailsLimit} onChange={e=>{ const l = Number(e.target.value||200); setDetailsLimit(l); setDetailsOffset(0); fetchDetails({ limit: l, offset: 0 }); }}>
                  <option value={50}>50</option>
                  <option value={100}>100</option>
                  <option value={200}>200</option>
                  <option value={500}>500</option>
                </select>
              </div>
            </div>
          </div>
        );
      };




    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(EmeaPinApp));
  })();
  </script>
</body>
</html>
