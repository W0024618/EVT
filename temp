# Prefer the datetime normalized join if available, else fall back to string join
merged_metrics = None
try:
    merged_metrics = pd.merge(features, raw_metrics_df, how='left',
                              left_on=['person_uid', '_DisplayDate_for_merge'],
                              right_on=['person_uid', '_DisplayDate_for_merge'],
                              suffixes=('','_rawagg'))
except Exception:
    try:
        merged_metrics = pd.merge(features, raw_metrics_df, how='left',
                                  left_on=['person_uid', '_DisplayDate_for_merge_str'],
                                  right_on=['person_uid', '_DisplayDate_for_merge_str'],
                                  suffixes=('','_rawagg'))
    except Exception:
        logging.exception("Both merge attempts failed; continuing without raw-agg merge")
        merged_metrics = features.copy()

# --- small, targeted coalescing: preserve feature gap/direction values for shift locations ---
try:
    SHIFT_LOCATIONS = set(["LT.Vilnius", "Quezon City"])

    # defensive: ensure merged_metrics is at least a DataFrame
    if merged_metrics is None:
        merged_metrics = features.copy()

    # if PartitionName2 exists, build mask per-row indicating shift-site rows
    if 'PartitionName2' in merged_metrics.columns:
        try:
            shift_mask = merged_metrics['PartitionName2'].astype(str).isin(SHIFT_LOCATIONS)
        except Exception:
            shift_mask = pd.Series([False] * len(merged_metrics), index=merged_metrics.index)
    else:
        shift_mask = pd.Series([False] * len(merged_metrics), index=merged_metrics.index)

    # list of base/raw pairs to coalesce
    pairs = [
        ('FirstSwipe','FirstSwipe_raw'),
        ('LastSwipe','LastSwipe_raw'),
        ('CountSwipes','CountSwipes_raw'),
        ('DurationSeconds','DurationSeconds_raw'),
        ('DurationMinutes','DurationMinutes_raw'),
        ('MaxSwipeGapSeconds','MaxSwipeGapSeconds_raw'),
        ('ShortGapCount','ShortGapCount_raw'),
        ('UniqueDoors','UniqueDoors_raw'),
        ('UniqueLocations','UniqueLocations_raw'),
        ('CardNumber','CardNumber_raw'),
        ('EmployeeID','EmployeeID_raw'),
        ('EmployeeName','EmployeeName_raw')
    ]

    for base_col, raw_col in pairs:
        if raw_col not in merged_metrics.columns:
            # nothing to do for this pair
            continue
        try:
            # For rows that are SHIFT locations: prefer existing feature value (fill from raw only when feature missing)
            if shift_mask.any():
                # where shift=True -> base = feature_base.combine_first(raw)  (feature preferred)
                try:
                    merged_metrics.loc[shift_mask, base_col] = merged_metrics.loc[shift_mask, base_col].combine_first(
                        merged_metrics.loc[shift_mask, raw_col]
                    )
                except Exception:
                    # best-effort fallback: if combine_first on slice fails, try scalar combine
                    merged_metrics.loc[shift_mask, base_col] = merged_metrics.loc[shift_mask, base_col].fillna(
                        merged_metrics.loc[shift_mask, raw_col]
                    )

                # where shift=False -> raw takes precedence (original behavior)
                try:
                    merged_metrics.loc[~shift_mask, base_col] = merged_metrics.loc[~shift_mask, raw_col].combine_first(
                        merged_metrics.loc[~shift_mask, base_col]
                    )
                except Exception:
                    merged_metrics.loc[~shift_mask, base_col] = merged_metrics.loc[~shift_mask, raw_col].fillna(
                        merged_metrics.loc[~shift_mask, base_col]
                    )
            else:
                # no partition info -> keep old behaviour (raw fallback/override)
                try:
                    merged_metrics[base_col] = merged_metrics[raw_col].combine_first(merged_metrics.get(base_col))
                except Exception:
                    merged_metrics[base_col] = merged_metrics[base_col].fillna(merged_metrics[raw_col])
        except Exception:
            # best-effort: on any unexpected failure for this pair, continue
            logging.debug("Coalescing pair (%s, %s) failed for some rows; continuing.", base_col, raw_col)

    # Finalize features frame: keep original feature columns ordering where possible
    feature_cols = list(features.columns)
    if all(c in merged_metrics.columns for c in feature_cols):
        features = merged_metrics[feature_cols].copy()
    else:
        features = merged_metrics.copy()

    # drop helper merge keys if present
    for helper_col in ['_DisplayDate_for_merge', '_DisplayDate_for_merge_str']:
        if helper_col in features.columns:
            try:
                features.drop(columns=[helper_col], inplace=True)
            except Exception:
                pass

except Exception:
    logging.exception("Post-merge coalescing failed; leaving features as-is.")













Fix this indentation error caredfully and share me this updated block 


 File "C:\Users\W0024618\Desktop\Trend Analysis\backend\trend_runner.py", line 2525
    SHIFT_LOCATIONS = set(["LT.Vilnius", "Quezon City"])
SyntaxError: expected 'except' or 'finally' block
(.venv) PS C:\Users\W0024618\Desktop\Trend Analysis\backend> 



# Prefer the datetime normalized join if available, else fall back to string join
            merged_metrics = None
            try:
                merged_metrics = pd.merge(features, raw_metrics_df, how='left',
                                          left_on=['person_uid', '_DisplayDate_for_merge'],
                                          right_on=['person_uid', '_DisplayDate_for_merge'],
                                          suffixes=('','_rawagg'))
            except Exception:
                try:
                    merged_metrics = pd.merge(features, raw_metrics_df, how='left',
                                              left_on=['person_uid', '_DisplayDate_for_merge_str'],
                                              right_on=['person_uid', '_DisplayDate_for_merge_str'],
                                              suffixes=('','_rawagg'))
                except Exception:
                    logging.exception("Both merge attempts failed; continuing without raw-agg merge")
                    merged_metrics = features.copy()



# --- small, targeted coalescing: preserve feature gap/direction values for shift locations ---
SHIFT_LOCATIONS = set(["LT.Vilnius", "Quezon City"])

try:
    # if PartitionName2 exists, build mask per-row indicating shift-site rows
    if 'PartitionName2' in merged_metrics.columns:
        try:
            shift_mask = merged_metrics['PartitionName2'].astype(str).isin(SHIFT_LOCATIONS)
        except Exception:
            shift_mask = pd.Series([False] * len(merged_metrics), index=merged_metrics.index)
    else:
        shift_mask = pd.Series([False] * len(merged_metrics), index=merged_metrics.index)

    # list of base/raw pairs to coalesce
    pairs = [
        ('FirstSwipe','FirstSwipe_raw'),
        ('LastSwipe','LastSwipe_raw'),
        ('CountSwipes','CountSwipes_raw'),
        ('DurationSeconds','DurationSeconds_raw'),
        ('DurationMinutes','DurationMinutes_raw'),
        ('MaxSwipeGapSeconds','MaxSwipeGapSeconds_raw'),
        ('ShortGapCount','ShortGapCount_raw'),
        ('UniqueDoors','UniqueDoors_raw'),
        ('UniqueLocations','UniqueLocations_raw'),
        ('CardNumber','CardNumber_raw'),
        ('EmployeeID','EmployeeID_raw'),
        ('EmployeeName','EmployeeName_raw')
    ]

    for base_col, raw_col in pairs:
        if raw_col not in merged_metrics.columns:
            continue
        try:
            # For rows that are SHIFT locations: prefer existing feature value (fill from raw only when feature missing)
            if shift_mask.any():
                # where shift=True -> base = base.combine_first(raw)  (feature preferred)
                merged_metrics.loc[shift_mask, base_col] = merged_metrics.loc[shift_mask, base_col].combine_first(
                    merged_metrics.loc[shift_mask, raw_col]
                )
                # where shift=False -> raw takes precedence (original behavior)
                merged_metrics.loc[~shift_mask, base_col] = merged_metrics.loc[~shift_mask, raw_col].combine_first(
                    merged_metrics.loc[~shift_mask, base_col]
                )
            else:
                # no partition info -> keep old behaviour (raw fallback/override)
                merged_metrics[base_col] = merged_metrics[raw_col].combine_first(merged_metrics.get(base_col))
        except Exception:
            # best-effort: if combine fails, keep original
            pass

    feature_cols = list(features.columns)
    if all(c in merged_metrics.columns for c in feature_cols):
        features = merged_metrics[feature_cols].copy()
    else:
        features = merged_metrics.copy()
    for helper_col in ['_DisplayDate_for_merge', '_DisplayDate_for_merge_str']:
        if helper_col in features.columns:
            try:
                features.drop(columns=[helper_col], inplace=True)
            except Exception:
                pass
except Exception:
    logging.exception("Post-merge coalescing failed; leaving features as-is.")






                if all(c in merged_metrics.columns for c in feature_cols):
                    features = merged_metrics[feature_cols].copy()
                else:
                    features = merged_metrics.copy()
                for helper_col in ['_DisplayDate_for_merge', '_DisplayDate_for_merge_str']:
                    if helper_col in features.columns:
                        try:
                            features.drop(columns=[helper_col], inplace=True)
                        except Exception:
                            pass
            except Exception:
                logging.exception("Post-merge coalescing failed; leaving features as-is.")



    except Exception:
        logging.exception("Failed recomputing raw metrics (non-fatal)")
