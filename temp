from flask import send_file
import io
import base64

DEFAULT_IMAGE_PATH = "static/default.jpg"  # create or place a default image here

def _make_image_response(image_bytes, filename):
    return Response(
        image_bytes,
        mimetype="image/jpeg",
        headers={"Content-Disposition": f"inline; filename={filename}"}
    )

def try_find_image_bytes(employee_id):
    """
    Try multiple lookups and return bytes if found, else None.
    Strategy:
      1. Call your existing get_image(employee_id)
      2. If not found, try normalized/alternate forms:
         - strip whitespace
         - if numeric string, try int or zero-padded variants
         - try uppercase/lowercase (for prefixed ids like W0024618)
      3. Try local file path: ./images/{id}.jpg or {id}.png
    """
    # 1) Original form
    logger.debug(f"try_find_image_bytes: initial id='{employee_id}'")
    candidates = []
    if employee_id is None:
        return None

    eid = str(employee_id).strip()
    if eid == "":
        return None
    candidates.append(eid)

    # try uppercase/lowercase variants (useful for W-prefixed ids)
    candidates.append(eid.upper())
    candidates.append(eid.lower())

    # if purely digits: try int form and zero-pad (common in HR systems)
    if eid.isdigit():
        candidates.append(str(int(eid)))  # remove leading zeros
        # try common paddings (3, 6, 7)
        for pad in (6, 7, 8):
            candidates.append(eid.zfill(pad))

    # remove duplicates while preserving order
    seen = set()
    candidates = [c for c in candidates if not (c in seen or seen.add(c))]

    # 1a: call get_image for each candidate
    for c in candidates:
        try:
            logger.debug(f"try_find_image_bytes: calling get_image for candidate '{c}'")
            img = get_image(c)
            if img:
                logger.info(f"Image found by get_image() for id '{c}'")
                return img
        except Exception as e:
            logger.exception(f"Error calling get_image for '{c}': {e}")

    # 2) check local files (./images/{id}.jpg / .png)
    images_dir = "images"
    for c in candidates:
        for ext in (".jpg", ".jpeg", ".png"):
            path = os.path.join(images_dir, f"{c}{ext}")
            try:
                if os.path.exists(path):
                    logger.info(f"Found image on disk: {path}")
                    with open(path, "rb") as f:
                        return f.read()
            except Exception as e:
                logger.exception(f"Error reading local image {path}: {e}")

    # Not found
    logger.debug("try_find_image_bytes: none of the candidates returned an image")
    return None

@app.route("/get/images", methods=["GET"])
@require_api_key
def get_employee_image():
    employee_id = request.args.get("employee_id")
    logger.debug(f"Fetching image for EmployeeID raw param: {employee_id}")
    if not employee_id:
        logger.error("Missing employee_id in query parameters")
        return Response(
            json.dumps({"description": "Missing employee_id in query parameters"}, indent=2),
            status=400,
            mimetype="application/json"
        )

    try:
        image_bytes = try_find_image_bytes(employee_id)
        if image_bytes:
            logger.debug(f"Image found for EmployeeID: {employee_id}")
            # ensure bytes type (if get_image returns memoryview/bytes-like)
            if isinstance(image_bytes, memoryview):
                image_bytes = image_bytes.tobytes()
            filename = f"{employee_id}.jpg"
            return _make_image_response(image_bytes, filename)
        else:
            # Return placeholder default image (so UI shows image instead of broken icon)
            if os.path.exists(DEFAULT_IMAGE_PATH):
                logger.warning(f"No image found for {employee_id}. Returning default placeholder.")
                return send_file(DEFAULT_IMAGE_PATH, mimetype="image/jpeg")
            else:
                logger.warning(f"No image found for {employee_id} and no default placeholder present.")
                return Response(
                    json.dumps({"description": f"No image found for EmployeeID: {employee_id}"}, indent=2),
                    status=404,
                    mimetype="application/json"
                )
    except Exception as e:
        logger.exception(f"Error fetching image for EmployeeID {employee_id}: {str(e)}")
        return Response(
            json.dumps({"description": f"Error fetching image: {str(e)}"}, indent=2),
            status=500,
            mimetype="application/json"
        )













IST)" executed successfully
DEBUG:__main__:Fetching image for EmployeeID: W0024618
DEBUG:__main__:Fetching image for EmployeeID: 0
DEBUG:__main__:Fetching image for EmployeeID: 329057
DEBUG:__main__:Fetching image for EmployeeID: 174907
DEBUG:__main__:Fetching image for EmployeeID: 303472
WARNING:__main__:No image found for EmployeeID: 329057
WARNING:__main__:No image found for EmployeeID: 174907
WARNING:__main__:No image found for EmployeeID: W0024618
WARNING:__main__:No image found for EmployeeID: 0
WARNING:__main__:No image found for EmployeeID: 303472
DEBUG:__main__:Fetching image for EmployeeID: 65704065
WARNING:__main__:No image found for EmployeeID: 65704065
DEBUG:__main__:Fetching image for EmployeeID: 195824
WARNING:__main__:No image found for EmployeeID: 195824
DEBUG:__main__:Fetching image for EmployeeID: 301723
DEBUG:__main__:Fetching image for EmployeeID: 326118
DEBUG:__main__:Fetching image for EmployeeID: 326847
WARNING:__main__:No image found for EmployeeID: 301723
WARNING:__main__:No image found for EmployeeID: 326118
WARNING:__main__:No image found for EmployeeID: 326847
DEBUG:__main__:Fetching image for EmployeeID: 326548
WARNING:__main__:No image found for EmployeeID: 326548
DEBUG:__main__:Fetching image for EmployeeID: 324353
DEBUG:__main__:Fetching image for EmployeeID: 326817
WARNING:__main__:No image found for EmployeeID: 324353
WARNING:__main__:No image found for EmployeeID: 326817
DEBUG:__main__:Fetching image for EmployeeID: 324741
DEBUG:__main__:Fetching image for EmployeeID: 324401
DEBUG:__main__:Fetching image for EmployeeID: 47442537
WARNING:__main__:No image found for EmployeeID: 324741
WARNING:__main__:No image found for EmployeeID: 47442537


from flask import Flask, Response, request, jsonify
from flask_cors import CORS
from alerts import check_alerts_for_server
from config import Regional_Servers
from log_handler import (
    read_sqlite_alerts_by_date,
    read_email_logs_by_date,
    read_sqlite_alerts_set,
    start_database_writer,
    get_email_response_counts,
    manage_exceptions,
    update_acknowledgment,
    get_image,
    get_allowed_locations,
    manage_location_filter
)
from email_handler import fetch_inbox_emails, trigger_followup_action
import os
import csv
from dotenv import load_dotenv
from functools import wraps
import json
import logging
from apscheduler.schedulers.background import BackgroundScheduler
from filelock import FileLock, Timeout
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor

logging.basicConfig(
    level=logging.DEBUG,
    filename='log_file.log',
    filemode='a',
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logging.getLogger("filelock").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)

load_dotenv()
VALID_API_KEYS = os.getenv("API_KEYS", "").split(",")

start_database_writer()

app = Flask(__name__)
CORS(app)
scheduler = BackgroundScheduler()
log = logging.getLogger('werkzeug')
log.disabled = True

executor = ThreadPoolExecutor(max_workers=16)

def check_all_regions():
    job_lock = FileLock("check_all_regions.lock", timeout=10)
    try:
        with job_lock:
            logger.info("Master lock acquired. Starting check_all_regions job.")
            sent_alerts = read_sqlite_alerts_set()
            for server in Regional_Servers:
                check_alerts_for_server(server, sent_alerts)
            logger.info("Finished check_all_regions job. Releasing master lock.")
    except Timeout:
        logger.warning("Could not acquire master lock. Another instance is likely running. Skipping this run.")
    except Exception as e:
        logger.error(f"An exception occurred during check_all_regions: {e}", exc_info=True)

scheduler.add_job(check_all_regions, 'interval', seconds=60, id='check_all_regions_job', max_instances=1)

def require_api_key(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        api_key = request.headers.get("X-API-Key") or request.args.get("api_key")
        if not api_key or api_key not in VALID_API_KEYS:
            return jsonify({"description": "Invalid or missing API key"}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route("/alert-logs-sqlite", methods=["GET"])
@require_api_key
def get_alert_logs_sqlite():
    try:
        today = datetime.now()
        seven_days_ago = today - timedelta(days=7)
        from_date = request.args.get('from_date', seven_days_ago.strftime('%Y-%m-%d'))
        to_date = request.args.get('to_date', today.strftime('%Y-%m-%d'))

        future = executor.submit(read_sqlite_alerts_by_date, from_date, to_date)
        logs = future.result()

        return jsonify(logs)
    except Exception as e:
        logger.error(f"API Error fetching alert logs: {e}", exc_info=True)
        return jsonify({"description": "Error reading database"}), 500

@app.route('/get/email-logs', methods=['GET'])
@require_api_key
def get_email_logs():
    try:
        today = datetime.now()
        seven_days_ago = today - timedelta(days=7)
        from_date = request.args.get('from_date', seven_days_ago.strftime('%Y-%m-%d'))
        to_date = request.args.get('to_date', today.strftime('%Y-%m-%d'))

        future = executor.submit(read_email_logs_by_date, from_date, to_date)
        email_logs = future.result()

        return jsonify(email_logs)
    except Exception as e:
        logger.error(f"API Error fetching email logs: {e}", exc_info=True)
        return jsonify({"error": "Database error"}), 500

@app.route("/acknowledge", methods=["GET"])
def acknowledge_email():
    email_id = request.args.get("email_id")
    logger.debug(f"Acknowledge request received with email_id: {email_id}")
    if not email_id:
        logger.error("Missing 'email_id' in query parameters")
        return """
        <html>
        <body style="font-family: Arial, sans-serif; text-align: center; padding: 20px;">
        <h2>Acknowledgment Failed</h2>
        <p>Missing email ID in the request. Please check the link and try again.</p>
        </body>
        </html>
        """, 400
    try:
        result = update_acknowledgment(email_id)
        if not result:
            logger.error(f"Failed to acknowledge email {email_id}: email_id not found")
            return """
            <html>
            <body style="font-family: Arial, sans-serif; text-align: center; padding: 20px;">
            <h2>Acknowledgment Failed</h2>
            <p>The email ID is invalid or not found. Please check the link and try again.</p>
            </body>
            </html>
            """, 404
        logger.info(f"Email acknowledged successfully: {email_id}")
        return """
        <html>
        <body style="font-family: Arial, sans-serif; text-align: center; padding: 20px;">
        <h2>Acknowledgment Successful</h2>
        <p>Thank you for acknowledging the email (ID: {email_id}).</p>
        <p>You can close this page.</p>
        </body>
        </html>
        """.format(email_id=email_id), 200
    except Exception as e:
        logger.error(f"Error acknowledging email {email_id}: {str(e)}")
        return """
        <html>
        <body style="font-family: Arial, sans-serif; text-align: center; padding: 20px;">
        <h2>Error</h2>
        <p>An error occurred while acknowledging the email: {error}</p>
        <p>Please try again or contact support.</p>
        </body>
        </html>
        """.format(error=str(e)), 500

# (Add any other API routes you need here, following the same pattern)
@app.route("/email/trigger-action", methods=["POST"])
@require_api_key
def trigger_action():
    logger.debug("Triggering action for unacknowledged email")
    data = request.get_json()
    if not data or "email_id" not in data or "action" not in data:
        logger.error("Missing 'email_id' or 'action' in request body")
        return Response(
            json.dumps({"description": "Missing 'email_id' or 'action' in request body"}, indent=2),
            status=400,
            mimetype="application/json"
        )
    email_id = data["email_id"]
    action = data["action"]
    if action not in ["reminder", "hr", "regional_manager"]:
        logger.error(f"Invalid action: {action}")
        return Response(
            json.dumps({"description": f"Invalid action: {action}"}, indent=2),
            status=400,
            mimetype="application/json"
        )
    try:
        trigger_followup_action(email_id, action)
        logger.debug(f"Action triggered: {action} for email {email_id}")
        return Response(
            json.dumps({"status": "success", "message": f"Action {action} triggered for email {email_id}"}, indent=2),
            mimetype="application/json"
        )
    except Exception as e:
        logger.error(f"Error triggering action: {str(e)}")
        return Response(
            json.dumps({"description": f"Error triggering action: {str(e)}"}, indent=2),
            status=500,
            mimetype="application/json"
        )
        
app.route("/curl", methods=["POST"])
@require_api_key
def trigger_alert():
    logger.debug("Trigger alert requested")
    data = request.get_json()
    if not data or "region" not in data:
        logger.error("Missing 'region' in request body")
        return Response(
            json.dumps({"description": "Missing 'region' in request body"}, indent=2),
            status=400,
            mimetype="application/json"
        )
    region = data["region"].upper()
    server = next((s for s in Regional_Servers if s["NAME"] == region), None)
    if not server:
        logger.error(f"Invalid region: {region}")
        return Response(
            json.dumps({"description": f"Invalid region: {region}"}, indent=2),
            status=400,
            mimetype="application/json"
        )
    try:
        check_alerts_for_server(server)
        logger.debug(f"Alert check triggered for {region}")
        return Response(
            json.dumps({"status": "success", "message": f"Alert check triggered for {region}"}, indent=2),
            mimetype="application/json"
        )
    except Exception as e:
        logger.error(f"Error processing alert: {str(e)}")
        return Response(
            json.dumps({"description": f"Error processing alert: {str(e)}"}, indent=2),
            status=500,
            mimetype="application/json"
        )

@app.route("/email/responses-received", methods=["GET"])
@require_api_key
def get_responses_received():
    logger.debug("Fetching count of acknowledged emails")
    try:
        counts = get_email_response_counts()
        return Response(
            json.dumps({"acknowledged_count": counts["acknowledged"]}, indent=2),
            mimetype="application/json"
        )
    except Exception as e:
        logger.error(f"Error fetching acknowledged email count: {str(e)}")
        return Response(
            json.dumps({"description": f"Error fetching acknowledged email count: {str(e)}"}, indent=2),
            status=500,
            mimetype="application/json"
        )

@app.route("/email/responses-sent", methods=["GET"])
@require_api_key
def get_responses_sent():
    logger.debug("Fetching count of sent emails")
    try:
        counts = get_email_response_counts()
        return Response(
            json.dumps({"sent_count": counts["sent"]}, indent=2),
            mimetype="application/json"
        )
    except Exception as e:
        logger.error(f"Error fetching sent email count: {str(e)}")
        return Response(
            json.dumps({"description": f"Error fetching sent email count: {str(e)}"}, indent=2),
            status=500,
            mimetype="application/json"
        )

@app.route("/email/inbox", methods=["GET"])
@require_api_key
def get_inbox():
    logger.debug("Fetching inbox emails")
    try:
        top = int(request.args.get("top", 10))
        skip = int(request.args.get("skip", 0))
        folder = request.args.get("folder", "inbox")
        logger.debug(f"Fetching emails with top={top}, skip={skip}, folder={folder}")
        emails = fetch_inbox_emails(top=top, skip=skip, folder=folder)
        return Response(
            json.dumps({
                "emails": emails,
                "total": len(emails),
                "top": top,
                "skip": skip,
                "folder": folder,
                "has_more": len(emails) == top
            }, indent=2),
            mimetype="application/json"
        )
    except Exception as e:
        logger.error(f"Error fetching inbox emails: {str(e)}")
        return Response(
            json.dumps({"description": f"Error fetching inbox emails: {str(e)}"}, indent=2),
            status=500,
            mimetype="application/json"
        )

@app.route("/email/exceptions", methods=["GET"])
@require_api_key
def get_exceptions():
    logger.debug("Fetching exception list")
    try:
        exceptions = manage_exceptions(action="get")
        return Response(
            json.dumps({"exceptions": exceptions}, indent=2),
            mimetype="application/json"
        )
    except Exception as e:
        logger.error(f"Error fetching exception list: {str(e)}")
        return Response(
            json.dumps({"description": f"Error fetching exception list: {str(e)}"}, indent=2),
            status=500,
            mimetype="application/json"
        )

@app.route("/email/exceptions", methods=["POST"])
@require_api_key
def manage_exceptions_endpoint():
    logger.debug("Managing exception list")
    data = request.get_json()
    if not data or "action" not in data or "email" not in data:
        logger.error("Missing 'action' or 'email' in request body")
        return Response(
            json.dumps({"description": "Missing 'action' or 'email' in request body"}, indent=2),
            status=400,
            mimetype="application/json"
        )
    action = data["action"]
    email = data["email"]
    logger.debug(f"Processing {action} for email: {email}")
    try:
        result = manage_exceptions(action=action, email=email)
        if result is False:
            logger.error(f"Failed to {action} email {email} in exception list")
            return Response(
                json.dumps({"description": f"Failed to {action} email {email} (email not found or invalid)"}, indent=2),
                status=404 if action == "delete" else 400,
                mimetype="application/json"
            )
        logger.info(f"Successfully {action} email {email} in exception list")
        return Response(
            json.dumps({"status": "success", "message": f"Exception list updated: {action} {email}"}, indent=2),
            mimetype="application/json"
        )
    except Exception as e:
        logger.error(f"Error managing exception list for action {action}, email {email}: {str(e)}")
        return Response(
            json.dumps({"description": f"Error managing exception list: {str(e)}"}, indent=2),
            status=500,
            mimetype="application/json"
        )

@app.route("/email/templates", methods=["GET"])
@require_api_key
def get_templates():
    logger.debug("Fetching email templates")
    try:
        with open('templates.json', 'r',encoding='utf-8') as f:
            templates = json.load(f)
        return Response(
            json.dumps({"templates": templates}, indent=2),
            mimetype="application/json"
        )
    except Exception as e:
        logger.error(f"Error fetching email templates: {str(e)}")
        return Response(
            json.dumps({"description": f"Error fetching email templates: {str(e)}"}, indent=2),
            status=500,
            mimetype="application/json"
        )

@app.route("/email/templates", methods=["POST"])
@require_api_key
def manage_templates():
    logger.debug("Managing email templates")
    data = request.get_json()
    logger.debug(f"Received JSON data: {data}")
    if not data or "action" not in data:
        logger.error("Missing 'action' in request body")
        return Response(
            json.dumps({"description": "Missing 'action' in request body"}, indent=2),
            status=400,
            mimetype="application/json"
        )
    action = data["action"]
    if action == "update":
        if "region" not in data or "template_key" not in data or "template_content" not in data:
            logger.error("Missing 'region', 'template_key', or 'template_content' for update action")
            return Response(
                json.dumps({"description": "Missing 'region', 'template_key', or 'template_content' for update action"}, indent=2),
                status=400,
                mimetype="application/json"
            )
        region = data["region"].upper()
        template_key = data["template_key"]
        template_content = data["template_content"]
        logger.debug(f"Processing update: region={region}, template_key={template_key}, template_content={template_content}")
        if not template_content.strip():
            logger.error("Empty template_content provided")
            return Response(
                json.dumps({"description": "Template content cannot be empty"}, indent=2),
                status=400,
                mimetype="application/json"
            )
        try:
            templates = {}
            if os.path.exists('templates.json'):
                with open('templates.json', 'r',encoding='utf-8') as f:
                    templates = json.load(f)
            if region not in templates:
                templates[region] = {}
            templates[region][template_key] = template_content
            with open('templates.json', 'w',encoding='utf-8') as f:
                json.dump(templates, f, indent=2)
            logger.info(f"Successfully updated template for region {region}, key {template_key}")
            return Response(
                json.dumps({"status": "success", "message": f"Template updated for region {region}, key {template_key}"}, indent=2),
                mimetype="application/json"
            )
        except Exception as e:
            logger.error(f"Error updating template for region {region}, key {template_key}: {str(e)}")
            return Response(
                json.dumps({"description": f"Error updating template: {str(e)}"}, indent=2),
                status=500,
                mimetype="application/json"
            )
    elif action == "reset":
        try:
            if reset_templates():
                logger.info("Successfully reset all templates to default")
                return Response(
                    json.dumps({"status": "success", "message": "All templates reset to default"}, indent=2),
                    mimetype="application/json"
                )
            else:
                logger.error("Failed to reset templates to default")
                return Response(
                    json.dumps({"description": "Failed to reset templates to default"}, indent=2),
                    status=500,
                    mimetype="application/json"
                )
        except Exception as e:
            logger.error(f"Error resetting templates: {str(e)}")
            return Response(
                json.dumps({"description": f"Error resetting templates: {str(e)}"}, indent=2),
                status=500,
                mimetype="application/json"
            )
    else:
        logger.error(f"Invalid action: {action}")
        return Response(
            json.dumps({"description": f"Invalid action: {action}"}, indent=2),
            status=400,
            mimetype="application/json"
        )

@app.route("/get/images", methods=["GET"])
@require_api_key
def get_employee_image():
    employee_id = request.args.get("employee_id")
    logger.debug(f"Fetching image for EmployeeID: {employee_id}")
    if not employee_id:
        logger.error("Missing employee_id in query parameters")
        return Response(
            json.dumps({"description": "Missing employee_id in query parameters"}, indent=2),
            status=400,
            mimetype="application/json"
        )
    try:
        image = get_image(employee_id)
        if image:
            logger.debug(f"Image found for EmployeeID: {employee_id}")
            return Response(
                image,
                mimetype="image/jpeg",
                headers={"Content-Disposition": f"inline; filename={employee_id}.jpg"}
            )
        else:
            logger.warning(f"No image found for EmployeeID: {employee_id}")
            return Response(
                json.dumps({"description": f"No image found for EmployeeID: {employee_id}"}, indent=2),
                status=404,
                mimetype="application/json"
            )
    except Exception as e:
        logger.error(f"Error fetching image for EmployeeID {employee_id}: {str(e)}")
        return Response(
            json.dumps({"description": f"Error fetching image: {str(e)}"}, indent=2),
            status=500,
            mimetype="application/json"
        )

@app.route("/alert-logs", methods=["GET"])
@require_api_key
def get_alert_logs():
    log_file = "Book1.csv"
    logger.debug(f"Attempting to read log file: {log_file}")
    if not os.path.exists(log_file):
        logger.error(f"Log file not found: {log_file}")
        return Response(
            json.dumps({"description": "Log file not found"}, indent=2),
            status=404,
            mimetype="application/json"
        )
    try:
        with open(log_file, 'r') as f:
            reader = csv.DictReader(f)
            logs = [row for row in reader]
        logger.debug(f"Successfully read {len(logs)} logs from {log_file}")
        return Response(
            json.dumps(logs, indent=2),
            mimetype="application/json"
        )
    except Exception as e:
        logger.error(f"Error reading log file: {str(e)}")
        return Response(
            json.dumps({"description": f"Error reading log file: {str(e)}"}, indent=2),
            status=500,
            mimetype="application/json"
        )      

@app.route("/locations/filter", methods=["GET"])
@require_api_key
def get_location_filters():
    success, result = manage_location_filter(action="get")
    if success:
        return jsonify({"filters": result})
    else:
        return jsonify({"description": result}), 500

@app.route("/locations/filter", methods=["POST"])
@require_api_key
def add_or_remove_location_filter():
    data = request.get_json()
    if not data or "action" not in data or "region" not in data or "location" not in data:
        return jsonify({"description": "Missing 'action', 'region', or 'location' in request body"}), 400
    
    action = data["action"]
    region = data["region"]
    location = data["location"]

    success, message = manage_location_filter(action=action, region=region, location=location)

    if success:
        return jsonify({"status": "success", "message": message})
    else:
        return jsonify({"description": message}), 500


if __name__ == "__main__":
    # This stricter check ensures the scheduler is NEVER started in the parent
    # reloader process, only in the single, true worker process.
    if os.environ.get('WERKZEUG_RUN_MAIN') == 'true':
        logger.info("Starting scheduler in the main worker process ONLY.")
        if not scheduler.running:
            scheduler.start()
    
    app.run(host="0.0.0.0", port=5000, debug=True)
