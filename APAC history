/* ------------------ handleExport (Details) ------------------ */
const handleExport = async () => {
  if (!pickedDate) return;

  try {
    const excelModule = await import('exceljs');
    const Excel = excelModule.default || excelModule;
    let wb;

    if (Excel && Excel.Workbook) wb = new Excel.Workbook();
    else if (typeof Excel === 'function') wb = new Excel();
    else throw new Error('ExcelJS Workbook constructor not found');

    const wsDetails = wb.addWorksheet('WU Employee');

    // layout offsets: skip one row and one column before/after data
    const offsetRow = 2; // leave row 1 blank, put title in row 2
    const offsetCol = 2; // leave column A blank, start data at column B

    // Headers
    const detailsHeaders = [
      'Sr.No', 'Date', 'Time',
      'Employee Name', 'Employee ID', 'Personal Type',
      'Door Name', 'Location'
    ];
    const firstCol = offsetCol;
    const lastCol = offsetCol + detailsHeaders.length - 1;

    // Title row (at offsetRow)
    const titleStart = colLetter(firstCol) + offsetRow;
    const titleEnd = colLetter(lastCol) + offsetRow;
    wsDetails.mergeCells(`${titleStart}:${titleEnd}`);
    const detailsTitle = wsDetails.getCell(offsetRow, firstCol);
    detailsTitle.value = `${format(pickedDate, 'EEEE, d MMMM, yyyy')}`;
    // Colour & font for title (black bg, yellow text)
    detailsTitle.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF000000' } };
    detailsTitle.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FFFFC107' } };
    detailsTitle.alignment = { horizontal: 'center', vertical: 'middle' };

    // Make title row height tighter
    wsDetails.getRow(offsetRow).height = 14;

    // Also apply same fill & border to each cell in merged range for consistent appearance
    for (let c = firstCol; c <= lastCol; c++) {
      const cell = wsDetails.getCell(offsetRow, c);
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF000000' } };
      cell.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FFFFC107' } };
      // thick outside border for top header (we'll set medium around the title row cells)
      cell.border = {
        top: { style: 'medium' },
        bottom: { style: 'medium' },
        left: { style: 'medium' },
        right: { style: 'medium' }
      };
    }

    // Header row index
    const headerRowIndex = offsetRow + 1; // e.g., 3
    const headerRow = wsDetails.getRow(headerRowIndex);
    // reduce header row height
    headerRow.height = 13;

    // Insert header values at correct columns
    detailsHeaders.forEach((h, idx) => {
      const colIndex = firstCol + idx;
      const cell = wsDetails.getCell(headerRowIndex, colIndex);
      cell.value = h;
      // header style: yellow fill, bold, centered (except Door column data alignment)
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } };
      cell.font = { name: 'Calibri', size: 11, bold: true, color: { argb: 'FF000000' } };
      // medium border for header (thick)
      cell.border = {
        top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' }
      };
      // default header alignment center
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
    });

    // Data rows start at headerRowIndex + 1
    const dataStartRow = headerRowIndex + 1;
    (detailRows || []).forEach((r, i) => {
      const rowIndex = dataStartRow + i;
      const row = wsDetails.getRow(rowIndex);
      // reduce data row height for compactness
      row.height = 12;

      const dateVal = (r.LocaleMessageTime?.slice(0, 10)) || (r.SwipeDate?.slice(0, 10)) || '';
      const timeVal = formatApiTime12(r.LocaleMessageTime) || '';
      const name = r.ObjectName1 || '';
      const empId = r.EmployeeID || '';
      const ptype = r.PersonnelType || '';
      const door = r.Door || r.ObjectName2 || '';
      const location = r.PartitionNameFriendly || '';

      const values = [i + 1, dateVal, timeVal, name, empId, ptype, door, location];

      values.forEach((val, idx) => {
        const colIndex = firstCol + idx;
        const cell = wsDetails.getCell(rowIndex, colIndex);
        cell.value = val;
        // default inner cell border thin
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        // font + vertical center
        cell.font = { name: 'Calibri', size: 10, color: { argb: 'FF000000' } };
        // Door Name column (7th header) -> index 6 (0-based), column number = firstCol + 6
        const doorColIndex = firstCol + 6;
        if (colIndex === doorColIndex) {
          cell.alignment = { horizontal: 'left', vertical: 'middle' };
        } else {
          cell.alignment = { horizontal: 'center', vertical: 'middle' };
        }
      });

      // optional alternating fill for readability (keeps gridlines hidden but visual rows)
      if (i % 2 === 1) {
        values.forEach((_, idx) => {
          const colIndex = firstCol + idx;
          const cell = wsDetails.getCell(rowIndex, colIndex);
          cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF7F7F7' } };
        });
      }
    });

    // After data: add one empty row (skip one row after)
    const lastDataRow = (detailRows?.length ? dataStartRow + detailRows.length - 1 : headerRowIndex);
    wsDetails.addRow([]); // blank row after data

    // Hide gridlines and freeze panes so header stays visible
    wsDetails.views = [{ state: 'frozen', ySplit: headerRowIndex, showGridLines: false }];

    // Autosize columns for the used area (firstCol..lastCol)
    for (let c = firstCol; c <= lastCol; c++) {
      let maxLen = 0;
      for (let r = offsetRow; r <= lastDataRow; r++) {
        const cell = wsDetails.getCell(r, c);
        const v = cell.value === null || cell.value === undefined ? '' : String(cell.value);
        maxLen = Math.max(maxLen, v.length);
      }
      // add padding
      const width = Math.min(Math.max(maxLen + 2, 6), 50);
      wsDetails.getColumn(c).width = width;
    }

    // Ensure there's a blank column after the last column (skip one column after data)
    wsDetails.getColumn(lastCol + 1).width = 4;

    // Outer border: medium border around the occupied data area (header..lastDataRow, firstCol..lastCol)
    for (let r = headerRowIndex; r <= lastDataRow; r++) {
      for (let c = firstCol; c <= lastCol; c++) {
        const cell = wsDetails.getCell(r, c);
        const border = { ...cell.border };
        if (r === headerRowIndex) border.top = { style: 'medium' };
        if (r === lastDataRow) border.bottom = { style: 'medium' };
        if (c === firstCol) border.left = { style: 'medium' };
        if (c === lastCol) border.right = { style: 'medium' };
        cell.border = border;
      }
    }

    // Page setup similar to before
    wsDetails.pageSetup = {
      horizontalCentered: true,
      verticalCentered: false,
      orientation: 'landscape',
      fitToPage: true,
      fitToWidth: 1,
      fitToHeight: 0,
      margins: { left: 0.5, right: 0.5, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 }
    };

    // ---------- SHEET 2: WU Summary ----------
    const ws = wb.addWorksheet('WU Summary');
    // reuse same offset logic for summary sheet
    const sOffsetRow = 2;
    const sOffsetCol = 2;
    const sFirstCol = sOffsetCol;
    // Header cols: Country, City, Employee, Contractors, Total
    const sHeaders = ['Country', 'City', 'Employee', 'Contractors', 'Total'];
    const sLastCol = sFirstCol + sHeaders.length - 1;

    // Title at offsetRow (merged + coloured + thick border)
    ws.mergeCells(`${colLetter(sFirstCol)}${sOffsetRow}:${colLetter(sLastCol)}${sOffsetRow}`);
    const sDateCell = ws.getCell(sOffsetRow, sFirstCol);
    sDateCell.value = format(pickedDate, 'EEEE, d MMMM, yyyy');
    sDateCell.alignment = { horizontal: 'center', vertical: 'middle' };
    // Colour & font for summary title (black bg, yellow text)
    for (let c = sFirstCol; c <= sLastCol; c++) {
      const cell = ws.getCell(sOffsetRow, c);
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF000000' } };
      cell.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FFFFC107' } };
      // thick border around title row
      cell.border = { top: { style: 'medium' }, bottom: { style: 'medium' }, left: { style: 'medium' }, right: { style: 'medium' } };
    }
    ws.getRow(sOffsetRow).height = 14;

    const sHeaderRowIndex = sOffsetRow + 1;
    // reduce header row height
    ws.getRow(sHeaderRowIndex).height = 13;

    // write header values
    sHeaders.forEach((h, idx) => {
      const c = sFirstCol + idx;
      const cell = ws.getCell(sHeaderRowIndex, c);
      cell.value = h;
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } };
      cell.font = { name: 'Calibri', size: 11, bold: true };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      // medium border for header
      cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
    });

    // Data rows start
    const sDataStartRow = sHeaderRowIndex + 1;
    partitionRows.forEach((r, i) => {
      const rowIndex = sDataStartRow + i;
      ws.getRow(rowIndex).height = 12; // tighter
      sHeaders.forEach((_, idx) => {
        const c = sFirstCol + idx;
        const cell = ws.getCell(rowIndex, c);
        const val = idx === 0 ? (r.country || '') : idx === 1 ? (r.city || '') : idx === 2 ? (r.employee || 0) : idx === 3 ? (r.contractor || 0) : (r.total || 0);
        cell.value = val;
        // numeric columns center + number format
        const isNumeric = idx >= 2;
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        if (isNumeric && typeof val === 'number') cell.numFmt = '#,##0';
        // thin border
        cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
        cell.font = { name: 'Calibri', size: 10 };
      });
    });

    // totals row: add thick border + coloured background (dark gray with white text)
    const sLastDataRow = (partitionRows?.length ? sDataStartRow + partitionRows.length - 1 : sHeaderRowIndex);
    const totalsRowIndex = sLastDataRow + 1;
    const totalEmployees = (partitionRows || []).reduce((s, r) => s + (r.employee || 0), 0);
    const totalContractors = (partitionRows || []).reduce((s, r) => s + (r.contractor || 0), 0);
    const totalTotals = (partitionRows || []).reduce((s, r) => s + (r.total || 0), 0);

    const totalsFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF666666' } };
    const totalsFont = { name: 'Calibri', size: 11, bold: true, color: { argb: 'FFFFFFFF' } };

    // write totals cells and style
    for (let c = sFirstCol; c <= sLastCol; c++) {
      const cell = ws.getCell(totalsRowIndex, c);
      if (c === sFirstCol) cell.value = 'Total';
      else if (c === sFirstCol + 2) cell.value = totalEmployees;
      else if (c === sFirstCol + 3) cell.value = totalContractors;
      else if (c === sFirstCol + 4) cell.value = totalTotals;
      cell.fill = totalsFill;
      cell.font = totalsFont;
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      // medium border around totals row
      cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
      if ((c === sFirstCol + 2 || c === sFirstCol + 3 || c === sFirstCol + 4) && typeof cell.value === 'number') {
        cell.numFmt = '#,##0';
      }
    }
    ws.getRow(totalsRowIndex).height = 12;

    // add one blank row & blank column after data
    ws.addRow([]);
    ws.getColumn(sLastCol + 1).width = 4;

    // hide gridlines & freeze
    ws.views = [{ state: 'frozen', ySplit: sHeaderRowIndex, showGridLines: false }];

    // autosize for summary sheet (sFirstCol..sLastCol)
    for (let c = sFirstCol; c <= sLastCol; c++) {
      let maxLen = 0;
      for (let r = sOffsetRow; r <= totalsRowIndex; r++) {
        const v = ws.getCell(r, c).value === undefined || ws.getCell(r, c).value === null ? '' : String(ws.getCell(r, c).value);
        maxLen = Math.max(maxLen, v.length);
      }
      ws.getColumn(c).width = Math.min(Math.max(maxLen + 2, 6), 40);
    }

    ws.pageSetup = {
      orientation: 'landscape',
      fitToPage: true,
      fitToWidth: 1,
      fitToHeight: 0,
      horizontalCentered: true,
      verticalCentered: false,
      margins: { left: 0.5, right: 0.5, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 }
    };

    // save file (filename logic preserved)
    let cityName = '';
    if (backendFilterKey) {
      const fe = Object.keys(apacPartitionDisplay).find(
        code => apacForwardKey[code] === backendFilterKey || code === backendFilterKey
      );
      cityName = fe ? apacPartitionDisplay[fe].city : backendFilterKey;
    }
    const filename = cityName
      ? `Western Union APAC (${cityName}) Headcount Report - ${format(pickedDate, 'd MMMM yyyy')}.xlsx`
      : `Western Union APAC Headcount Report - ${format(pickedDate, 'd MMMM yyyy')}.xlsx`;

    const buf = await wb.xlsx.writeBuffer();
    saveAs(new Blob([buf]), filename);

  } catch (err) {
    console.error('handleExport error:', err);
  }
};

/* ------------------ handleExportSummary ------------------ */
const handleExportSummary = async () => {
  if (!pickedDate) return;

  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Summary');

  const offsetRow = 2;
  const offsetCol = 2;
  const firstCol = offsetCol;
  const headers = ['Country', 'City', 'Employees', 'Contractors', 'Total'];
  const lastCol = firstCol + headers.length - 1;

  // Title (merged) with colour + thick border
  ws.mergeCells(`${colLetter(firstCol)}${offsetRow}:${colLetter(lastCol)}${offsetRow}`);
  for (let c = firstCol; c <= lastCol; c++) {
    const cell = ws.getCell(offsetRow, c);
    cell.value = c === firstCol ? format(pickedDate, 'EEEE, d MMMM, yyyy') : ''; // only set on first, merged will show
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF000000' } }; // black
    cell.font = { name: 'Calibri', size: 14, bold: true, color: { argb: 'FFFFC107' } }; // yellow text
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    // thick border around title row
    cell.border = { top: { style: 'medium' }, bottom: { style: 'medium' }, left: { style: 'medium' }, right: { style: 'medium' } };
  }
  ws.getRow(offsetRow).height = 14;

  // Header row
  const headerRowIndex = offsetRow + 1;
  headers.forEach((h, idx) => {
    const c = firstCol + idx;
    const cell = ws.getCell(headerRowIndex, c);
    cell.value = h;
    cell.height = 18;
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } };
    cell.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FF000000' } };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    // medium border for header
    cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
  });
  ws.getRow(headerRowIndex).height = 13;

  // Data rows
  const dataStartRow = headerRowIndex + 1;
  partitionRows.forEach((r, i) => {
    const rowIndex = dataStartRow + i;
    ws.getRow(rowIndex).height = 12; // tighter rows
    headers.forEach((_, idx) => {
      const c = firstCol + idx;
      const cell = ws.getCell(rowIndex, c);
      const val = idx === 0 ? (r.country || '') : idx === 1 ? (r.city || '') : idx === 2 ? (r.employee || 0) : idx === 3 ? (r.contractor || 0) : (r.total || 0);
      cell.value = val;
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      if (idx >= 2 && typeof val === 'number') cell.numFmt = '#,##0';
      cell.font = { name: 'Calibri', size: 10 };
      cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
    });
  });

  // Totals row: thick border + coloured background
  const lastDataRow = (partitionRows?.length ? dataStartRow + partitionRows.length - 1 : headerRowIndex);
  const totalsRowIndex = lastDataRow + 1;
  const totalEmployees = partitionRows.reduce((s, r) => s + r.employee, 0);
  const totalContractors = partitionRows.reduce((s, r) => s + r.contractor, 0);
  const totalTotal = partitionRows.reduce((s, r) => s + r.total, 0);

  const totalsFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF666666' } };
  const totalsFont = { name: 'Calibri', size: 11, bold: true, color: { argb: 'FFFFFFFF' } };

  for (let c = firstCol; c <= lastCol; c++) {
    const cell = ws.getCell(totalsRowIndex, c);
    if (c === firstCol) cell.value = 'Total';
    if (c === firstCol + 2) cell.value = totalEmployees;
    if (c === firstCol + 3) cell.value = totalContractors;
    if (c === firstCol + 4) cell.value = totalTotal;
    cell.fill = totalsFill;
    cell.font = totalsFont;
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
    if ((c === firstCol + 2 || c === firstCol + 3 || c === firstCol + 4) && typeof cell.value === 'number') {
      cell.numFmt = '#,##0';
    }
  }
  ws.getRow(totalsRowIndex).height = 12;

  // add blank row after and blank column after
  ws.addRow([]);
  ws.getColumn(lastCol + 1).width = 4;

  // hide gridlines & freeze header
  ws.views = [{ state: 'frozen', ySplit: headerRowIndex, showGridLines: false }];

  // autosize columns
  for (let c = firstCol; c <= lastCol; c++) {
    let maxLen = 0;
    for (let r = offsetRow; r <= totalsRowIndex; r++) {
      const v = ws.getCell(r, c).value === undefined || ws.getCell(r, c).value === null ? '' : String(ws.getCell(r, c).value);
      maxLen = Math.max(maxLen, v.length);
    }
    ws.getColumn(c).width = Math.min(Math.max(maxLen + 2, 6), 40);
  }

  // export
  const buf = await wb.xlsx.writeBuffer();
  const safeDate = format(pickedDate, 'yyyyMMdd');
  const filename = `apac_summary_${safeDate}.xlsx`;
  saveAs(new Blob([buf]), filename);
};

/* ------------------ handleExportCompanies ------------------ */
const handleExportCompanies = async () => {
  if (!pickedDate || !companyRows.length) return;

  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Company Summary');

  const offsetRow = 2;
  const offsetCol = 2;
  const firstCol = offsetCol;
  const headers = ['Country', 'City', 'Company', 'Total'];
  const lastCol = firstCol + headers.length - 1;

  // Title (merged) with colour + thick border
  ws.mergeCells(`${colLetter(firstCol)}${offsetRow}:${colLetter(lastCol)}${offsetRow}`);
  for (let c = firstCol; c <= lastCol; c++) {
    const cell = ws.getCell(offsetRow, c);
    cell.value = c === firstCol ? format(pickedDate, 'EEEE, d MMMM, yyyy') : '';
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF000000' } };
    cell.font = { name: 'Calibri', size: 14, bold: true, color: { argb: 'FFFFC107' } };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.border = { top: { style: 'medium' }, bottom: { style: 'medium' }, left: { style: 'medium' }, right: { style: 'medium' } };
  }
  ws.getRow(offsetRow).height = 14;

  // header row
  const headerRowIndex = offsetRow + 1;
  headers.forEach((h, idx) => {
    const c = firstCol + idx;
    const cell = ws.getCell(headerRowIndex, c);
    cell.value = h;
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } };
    cell.font = { name: 'Calibri', size: 11, bold: true, color: { argb: 'FF000000' } };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
  });
  ws.getRow(headerRowIndex).height = 13;

  // data rows
  const dataStartRow = headerRowIndex + 1;
  companyRows.forEach((r, i) => {
    const rowIndex = dataStartRow + i;
    ws.getRow(rowIndex).height = 12;
    const rowValues = [r.country, r.city, r.company, r.total];
    rowValues.forEach((val, idx) => {
      const c = firstCol + idx;
      const cell = ws.getCell(rowIndex, c);
      cell.value = val;
      cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      if (idx === 3 && typeof val === 'number') cell.numFmt = '#,##0';
      cell.font = { name: 'Calibri', size: 10 };
    });
  });

  // totals row: thick border + coloured background
  const lastDataRow = dataStartRow + companyRows.length - 1;
  const totalsRowIndex = lastDataRow + 1;
  const total = companyRows.reduce((s, r) => s + r.total, 0);

  const totalsFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF666666' } };
  const totalsFont = { name: 'Calibri', size: 11, bold: true, color: { argb: 'FFFFFFFF' } };

  for (let c = firstCol; c <= lastCol; c++) {
    const cell = ws.getCell(totalsRowIndex, c);
    if (c === firstCol) cell.value = 'Total';
    if (c === firstCol + 3) cell.value = total;
    cell.fill = totalsFill;
    cell.font = totalsFont;
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
    if (c === firstCol + 3 && typeof cell.value === 'number') cell.numFmt = '#,##0';
  }
  ws.getRow(totalsRowIndex).height = 12;

  // blank row/col after
  ws.addRow([]);
  ws.getColumn(lastCol + 1).width = 4;

  // hide gridlines & freeze
  ws.views = [{ state: 'frozen', ySplit: headerRowIndex, showGridLines: false }];

  // autosize columns
  for (let c = firstCol; c <= lastCol; c++) {
    let maxLen = 0;
    for (let r = offsetRow; r <= totalsRowIndex; r++) {
      const v = ws.getCell(r, c).value === undefined || ws.getCell(r, c).value === null ? '' : String(ws.getCell(r, c).value);
      maxLen = Math.max(maxLen, v.length);
    }
    ws.getColumn(c).width = Math.min(Math.max(maxLen + 2, 6), 50);
  }

  // save
  const buf = await wb.xlsx.writeBuffer();
  saveAs(new Blob([buf]), `apac_companies_${format(pickedDate, "yyyyMMdd")}.xlsx`);
};

















Ok  good now below code works perfectly ,
now only update few add thick outside border for yop Header where we display day date in both table Wu Employee and WU Summary...also add Colour in t5his section
...where we display like ex- Wednesday 15 October 2025.

In Wu Summary for both Total Section Add thick border and colour for background...

and Row size need to reduce very close ...


// helper: convert 1-based column number to Excel letter (works for up to Z)
const colLetter = (n) => String.fromCharCode(64 + n);

/* ------------------ handleExport (Details) ------------------ */
const handleExport = async () => {
  if (!pickedDate) return;

  try {
    const excelModule = await import('exceljs');
    const Excel = excelModule.default || excelModule;
    let wb;

    if (Excel && Excel.Workbook) wb = new Excel.Workbook();
    else if (typeof Excel === 'function') wb = new Excel();
    else throw new Error('ExcelJS Workbook constructor not found');

    const wsDetails = wb.addWorksheet('WU Employee');

    // layout offsets: skip one row and one column before/after data
    const offsetRow = 2; // leave row 1 blank, put title in row 2
    const offsetCol = 2; // leave column A blank, start data at column B

    // Headers
    const detailsHeaders = [
      'Sr.No', 'Date', 'Time',
      'Employee Name', 'Employee ID', 'Personal Type',
      'Door Name', 'Location'
    ];
    const firstCol = offsetCol;
    const lastCol = offsetCol + detailsHeaders.length - 1;

    // Title row (at offsetRow)
    const titleStart = colLetter(firstCol) + offsetRow;
    const titleEnd = colLetter(lastCol) + offsetRow;
    wsDetails.mergeCells(`${titleStart}:${titleEnd}`);
    const detailsTitle = wsDetails.getCell(offsetRow, firstCol);
    detailsTitle.value = `${format(pickedDate, 'EEEE, d MMMM, yyyy')}`;
    detailsTitle.alignment = { horizontal: 'center', vertical: 'middle' };
    detailsTitle.font = { name: 'Calibri', size: 12, bold: true };

    // Header row index
    const headerRowIndex = offsetRow + 1; // e.g., 3
    const headerRow = wsDetails.getRow(headerRowIndex);
    // Insert header values at correct columns
    detailsHeaders.forEach((h, idx) => {
      const colIndex = firstCol + idx;
      const cell = wsDetails.getCell(headerRowIndex, colIndex);
      cell.value = h;
      // header style: yellow fill, bold, centered (except we will left align door later)
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } };
      cell.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FF000000' } };
      // medium border for header (thick)
      cell.border = {
        top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' }
      };
      // default header alignment center (Door column will be left aligned for data)
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
    });

    // Data rows start at headerRowIndex + 1
    const dataStartRow = headerRowIndex + 1;
    (detailRows || []).forEach((r, i) => {
      const rowIndex = dataStartRow + i;
      const row = wsDetails.getRow(rowIndex);
      const dateVal = (r.LocaleMessageTime?.slice(0, 10)) || (r.SwipeDate?.slice(0, 10)) || '';
      const timeVal = formatApiTime12(r.LocaleMessageTime) || '';
      const name = r.ObjectName1 || '';
      const empId = r.EmployeeID || '';
      const ptype = r.PersonnelType || '';
      const door = r.Door || r.ObjectName2 || '';
      const location = r.PartitionNameFriendly || '';

      const values = [i + 1, dateVal, timeVal, name, empId, ptype, door, location];

      values.forEach((val, idx) => {
        const colIndex = firstCol + idx;
        const cell = wsDetails.getCell(rowIndex, colIndex);
        cell.value = val;
        // default inner cell border thin
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        // font + vertical center
        cell.font = { name: 'Calibri', size: 11, color: { argb: 'FF000000' } };
        // Door Name column (7th header) -> index 6 (0-based), column number = firstCol + 6
        const doorColIndex = firstCol + 6;
        if (colIndex === doorColIndex) {
          cell.alignment = { horizontal: 'left', vertical: 'middle' };
        } else {
          cell.alignment = { horizontal: 'center', vertical: 'middle' };
        }
      });

      // optional alternating fill for readability (keeps gridlines hidden but visual rows)
      if (i % 2 === 1) {
        values.forEach((_, idx) => {
          const colIndex = firstCol + idx;
          const cell = wsDetails.getCell(rowIndex, colIndex);
          cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF7F7F7' } };
        });
      }
    });

    // After data: add one empty row (skip one row after)
    const lastDataRow = (detailRows?.length ? dataStartRow + detailRows.length - 1 : headerRowIndex);
    wsDetails.addRow([]); // blank row after data

    // Hide gridlines and freeze panes so header stays visible
    wsDetails.views = [{ state: 'frozen', ySplit: headerRowIndex, showGridLines: false }];

    // Autosize columns for the used area (firstCol..lastCol)
    for (let c = firstCol; c <= lastCol; c++) {
      let maxLen = 0;
      for (let r = offsetRow; r <= lastDataRow; r++) {
        const cell = wsDetails.getCell(r, c);
        const v = cell.value === null || cell.value === undefined ? '' : String(cell.value);
        maxLen = Math.max(maxLen, v.length);
      }
      // add padding
      const width = Math.min(Math.max(maxLen + 2, 8), 50);
      wsDetails.getColumn(c).width = width;
    }

    // Ensure there's a blank column after the last column (skip one column after data)
    // (we already left an empty physical column A before; ensure lastCol+1 exists)
    wsDetails.getColumn(lastCol + 1).width = 4;

    // Outer border: medium border around the occupied data area (header..lastDataRow, firstCol..lastCol)
    for (let r = headerRowIndex; r <= lastDataRow; r++) {
      for (let c = firstCol; c <= lastCol; c++) {
        const cell = wsDetails.getCell(r, c);
        const border = { ...cell.border };
        if (r === headerRowIndex) border.top = { style: 'medium' };
        if (r === lastDataRow) border.bottom = { style: 'medium' };
        if (c === firstCol) border.left = { style: 'medium' };
        if (c === lastCol) border.right = { style: 'medium' };
        cell.border = border;
      }
    }

    // Page setup similar to before
    wsDetails.pageSetup = {
      horizontalCentered: true,
      verticalCentered: false,
      orientation: 'landscape',
      fitToPage: true,
      fitToWidth: 1,
      fitToHeight: 0,
      margins: { left: 0.5, right: 0.5, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 }
    };

    // ---------- SHEET 2: WU Summary ----------
    const ws = wb.addWorksheet('WU Summary');
    // reuse same offset logic for summary sheet
    const sOffsetRow = 2;
    const sOffsetCol = 2;
    const sFirstCol = sOffsetCol;
    // Header cols: Country, City, Employee, Contractors, Total
    const sHeaders = ['Country', 'City', 'Employee', 'Contractors', 'Total'];
    const sLastCol = sFirstCol + sHeaders.length - 1;

    // Title at offsetRow
    ws.mergeCells(`${colLetter(sFirstCol)}${sOffsetRow}:${colLetter(sLastCol)}${sOffsetRow}`);
    const sDateCell = ws.getCell(sOffsetRow, sFirstCol);
    sDateCell.value = format(pickedDate, 'EEEE, d MMMM, yyyy');
    sDateCell.alignment = { horizontal: 'center', vertical: 'middle' };
    sDateCell.font = { name: 'Calibri', size: 12, bold: true };

    const sHeaderRowIndex = sOffsetRow + 1;
    // write header values
    sHeaders.forEach((h, idx) => {
      const c = sFirstCol + idx;
      const cell = ws.getCell(sHeaderRowIndex, c);
      cell.value = h;
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } };
      cell.font = { name: 'Calibri', size: 12, bold: true };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      // medium border for header
      cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
    });

    // Data rows start
    const sDataStartRow = sHeaderRowIndex + 1;
    partitionRows.forEach((r, i) => {
      const rowIndex = sDataStartRow + i;
      sHeaders.forEach((_, idx) => {
        const c = sFirstCol + idx;
        const cell = ws.getCell(rowIndex, c);
        const val = idx === 0 ? (r.country || '') : idx === 1 ? (r.city || '') : idx === 2 ? (r.employee || 0) : idx === 3 ? (r.contractor || 0) : (r.total || 0);
        cell.value = val;
        // numeric columns center + number format
        const isNumeric = idx >= 2;
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        if (isNumeric && typeof val === 'number') cell.numFmt = '#,##0';
        // thin border
        cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
        cell.font = { name: 'Calibri', size: 11 };
      });
    });

    // totals row (leave one blank row before totals only if you want spacing) - we will keep as contiguous
    const sLastDataRow = (partitionRows?.length ? sDataStartRow + partitionRows.length - 1 : sHeaderRowIndex);
    const totalsRowIndex = sLastDataRow + 1;
    const totalEmployees = (partitionRows || []).reduce((s, r) => s + (r.employee || 0), 0);
    const totalContractors = (partitionRows || []).reduce((s, r) => s + (r.contractor || 0), 0);
    const totalTotals = (partitionRows || []).reduce((s, r) => s + (r.total || 0), 0);

    // write totals
    ws.getCell(totalsRowIndex, sFirstCol).value = 'Total';
    ws.getCell(totalsRowIndex, sFirstCol).font = { name: 'Calibri', bold: true };
    ws.getCell(totalsRowIndex, sFirstCol).alignment = { horizontal: 'center', vertical: 'middle' };
    ws.getCell(totalsRowIndex, sFirstCol + 2).value = totalEmployees;
    ws.getCell(totalsRowIndex, sFirstCol + 3).value = totalContractors;
    ws.getCell(totalsRowIndex, sFirstCol + 4).value = totalTotals;
    [sFirstCol + 2, sFirstCol + 3, sFirstCol + 4].forEach(c => {
      const cell = ws.getCell(totalsRowIndex, c);
      cell.numFmt = '#,##0';
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.font = { name: 'Calibri', bold: true };
    });

    // add one blank row & blank column after data
    ws.addRow([]);
    ws.getColumn(sLastCol + 1).width = 4;

    // hide gridlines & freeze
    ws.views = [{ state: 'frozen', ySplit: sHeaderRowIndex, showGridLines: false }];

    // autosize for summary sheet (sFirstCol..sLastCol)
    for (let c = sFirstCol; c <= sLastCol; c++) {
      let maxLen = 0;
      for (let r = sOffsetRow; r <= totalsRowIndex; r++) {
        const v = ws.getCell(r, c).value === undefined || ws.getCell(r, c).value === null ? '' : String(ws.getCell(r, c).value);
        maxLen = Math.max(maxLen, v.length);
      }
      ws.getColumn(c).width = Math.min(Math.max(maxLen + 2, 8), 40);
    }

    // medium outer border around occupied summary area (header..totalsRowIndex)
    for (let r = sHeaderRowIndex; r <= totalsRowIndex; r++) {
      for (let c = sFirstCol; c <= sLastCol; c++) {
        const cell = ws.getCell(r, c);
        const border = { ...cell.border };
        if (r === sHeaderRowIndex) border.top = { style: 'medium' };
        if (r === totalsRowIndex) border.bottom = { style: 'medium' };
        if (c === sFirstCol) border.left = { style: 'medium' };
        if (c === sLastCol) border.right = { style: 'medium' };
        cell.border = border;
      }
    }

    ws.pageSetup = {
      orientation: 'landscape',
      fitToPage: true,
      fitToWidth: 1,
      fitToHeight: 0,
      horizontalCentered: true,
      verticalCentered: false,
      margins: { left: 0.5, right: 0.5, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 }
    };

    // save file (filename logic preserved)
    let cityName = '';
    if (backendFilterKey) {
      const fe = Object.keys(apacPartitionDisplay).find(
        code => apacForwardKey[code] === backendFilterKey || code === backendFilterKey
      );
      cityName = fe ? apacPartitionDisplay[fe].city : backendFilterKey;
    }
    const filename = cityName
      ? `Western Union APAC (${cityName}) Headcount Report - ${format(pickedDate, 'd MMMM yyyy')}.xlsx`
      : `Western Union APAC Headcount Report - ${format(pickedDate, 'd MMMM yyyy')}.xlsx`;

    const buf = await wb.xlsx.writeBuffer();
    saveAs(new Blob([buf]), filename);

  } catch (err) {
    console.error('handleExport error:', err);
  }
};


/* ------------------ handleExportSummary ------------------ */
const handleExportSummary = async () => {
  if (!pickedDate) return;

  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Summary');

  const offsetRow = 2;
  const offsetCol = 2;
  const firstCol = offsetCol;
  const headers = ['Country', 'City', 'Employees', 'Contractors', 'Total'];
  const lastCol = firstCol + headers.length - 1;

  // Title
  ws.mergeCells(`${colLetter(firstCol)}${offsetRow}:${colLetter(lastCol)}${offsetRow}`);
  const dateCell = ws.getCell(offsetRow, firstCol);
  dateCell.value = format(pickedDate, 'EEEE, d MMMM, yyyy');
  dateCell.alignment = { horizontal: 'center', vertical: 'middle' };
  dateCell.font = { name: 'Calibri', size: 14, bold: true };

  // Header row
  const headerRowIndex = offsetRow + 1;
  headers.forEach((h, idx) => {
    const c = firstCol + idx;
    const cell = ws.getCell(headerRowIndex, c);
    cell.value = h;
    cell.height = 20;
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } };
    cell.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FF000000' } };
    // center align all headers
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    // medium border for header
    cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
  });

  // Data rows
  const dataStartRow = headerRowIndex + 1;
  partitionRows.forEach((r, i) => {
    const rowIndex = dataStartRow + i;
    headers.forEach((_, idx) => {
      const c = firstCol + idx;
      const cell = ws.getCell(rowIndex, c);
      const val = idx === 0 ? (r.country || '') : idx === 1 ? (r.city || '') : idx === 2 ? (r.employee || 0) : idx === 3 ? (r.contractor || 0) : (r.total || 0);
      cell.value = val;
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      if (idx >= 2 && typeof val === 'number') cell.numFmt = '#,##0';
      cell.font = { name: 'Calibri', size: 11 };
      cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
    });
  });

  // Totals row
  const lastDataRow = (partitionRows?.length ? dataStartRow + partitionRows.length - 1 : headerRowIndex);
  const totalsRowIndex = lastDataRow + 1;
  const totalEmployees = partitionRows.reduce((s, r) => s + r.employee, 0);
  const totalContractors = partitionRows.reduce((s, r) => s + r.contractor, 0);
  const totalTotal = partitionRows.reduce((s, r) => s + r.total, 0);

  const totalRow = ws.getRow(totalsRowIndex);
  ws.getCell(totalsRowIndex, firstCol).value = 'Total';
  ws.getCell(totalsRowIndex, firstCol).font = { name: 'Calibri', size: 12, bold: true };
  ws.getCell(totalsRowIndex, firstCol).alignment = { horizontal: 'center', vertical: 'middle' };

  ws.getCell(totalsRowIndex, firstCol + 2).value = totalEmployees;
  ws.getCell(totalsRowIndex, firstCol + 3).value = totalContractors;
  ws.getCell(totalsRowIndex, firstCol + 4).value = totalTotal;
  [firstCol + 2, firstCol + 3, firstCol + 4].forEach(c => {
    ws.getCell(totalsRowIndex, c).numFmt = '#,##0';
    ws.getCell(totalsRowIndex, c).alignment = { horizontal: 'center', vertical: 'middle' };
    ws.getCell(totalsRowIndex, c).font = { name: 'Calibri', size: 12, bold: true };
  });

  // add blank row after and blank column after
  ws.addRow([]);
  ws.getColumn(lastCol + 1).width = 4;

  // hide gridlines & freeze header
  ws.views = [{ state: 'frozen', ySplit: headerRowIndex, showGridLines: false }];

  // autosize columns
  for (let c = firstCol; c <= lastCol; c++) {
    let maxLen = 0;
    for (let r = offsetRow; r <= totalsRowIndex; r++) {
      const v = ws.getCell(r, c).value === undefined || ws.getCell(r, c).value === null ? '' : String(ws.getCell(r, c).value);
      maxLen = Math.max(maxLen, v.length);
    }
    ws.getColumn(c).width = Math.min(Math.max(maxLen + 2, 8), 40);
  }

  // medium outer border for data area (header..totalsRowIndex)
  for (let r = headerRowIndex; r <= totalsRowIndex; r++) {
    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(r, c);
      const border = { ...cell.border };
      if (r === headerRowIndex) border.top = { style: 'medium' };
      if (r === totalsRowIndex) border.bottom = { style: 'medium' };
      if (c === firstCol) border.left = { style: 'medium' };
      if (c === lastCol) border.right = { style: 'medium' };
      cell.border = border;
    }
  }

  // freeze panes so header is visible (freeze above data rows)
  ws.views = [{ state: 'frozen', ySplit: headerRowIndex, showGridLines: false }];

  // export
  const buf = await wb.xlsx.writeBuffer();
  const safeDate = format(pickedDate, 'yyyyMMdd');
  const filename = `apac_summary_${safeDate}.xlsx`;
  saveAs(new Blob([buf]), filename);
};


/* ------------------ handleExportCompanies ------------------ */
const handleExportCompanies = async () => {
  if (!pickedDate || !companyRows.length) return;

  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('Company Summary');

  const offsetRow = 2;
  const offsetCol = 2;
  const firstCol = offsetCol;
  const headers = ['Country', 'City', 'Company', 'Total'];
  const lastCol = firstCol + headers.length - 1;

  // Title (merged)
  ws.mergeCells(`${colLetter(firstCol)}${offsetRow}:${colLetter(lastCol)}${offsetRow}`);
  const dateCell = ws.getCell(offsetRow, firstCol);
  dateCell.value = format(pickedDate, 'EEEE, d MMMM, yyyy');
  dateCell.alignment = { horizontal: 'center', vertical: 'middle' };
  dateCell.font = { name: 'Calibri', size: 14, bold: true };

  // header row
  const headerRowIndex = offsetRow + 1;
  headers.forEach((h, idx) => {
    const c = firstCol + idx;
    const cell = ws.getCell(headerRowIndex, c);
    cell.value = h;
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } };
    cell.font = { bold: true, color: { argb: 'FF000000' } };
    cell.alignment = { horizontal: 'center', vertical: 'middle' };
    // medium border for header
    cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
  });

  // data rows
  const dataStartRow = headerRowIndex + 1;
  companyRows.forEach((r, i) => {
    const rowIndex = dataStartRow + i;
    const rowValues = [r.country, r.city, r.company, r.total];
    rowValues.forEach((val, idx) => {
      const c = firstCol + idx;
      const cell = ws.getCell(rowIndex, c);
      cell.value = val;
      cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
      // center align all columns except Company (keep Company center as requested)
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      if (idx === 3 && typeof val === 'number') cell.numFmt = '#,##0';
      cell.font = { name: 'Calibri', size: 11 };
    });
  });

  // totals row
  const lastDataRow = dataStartRow + companyRows.length - 1;
  const totalsRowIndex = lastDataRow + 1;
  const total = companyRows.reduce((s, r) => s + r.total, 0);
  ws.getCell(totalsRowIndex, firstCol).value = 'Total';
  ws.getCell(totalsRowIndex, firstCol).font = { bold: true };
  ws.getCell(totalsRowIndex, firstCol).alignment = { horizontal: 'center', vertical: 'middle' };
  ws.getCell(totalsRowIndex, firstCol + 3).value = total;
  ws.getCell(totalsRowIndex, firstCol + 3).numFmt = '#,##0';
  ws.getCell(totalsRowIndex, firstCol + 3).alignment = { horizontal: 'center', vertical: 'middle' };

  // blank row/col after
  ws.addRow([]);
  ws.getColumn(lastCol + 1).width = 4;

  // hide gridlines & freeze
  ws.views = [{ state: 'frozen', ySplit: headerRowIndex, showGridLines: false }];

  // autosize columns
  for (let c = firstCol; c <= lastCol; c++) {
    let maxLen = 0;
    for (let r = offsetRow; r <= totalsRowIndex; r++) {
      const v = ws.getCell(r, c).value === undefined || ws.getCell(r, c).value === null ? '' : String(ws.getCell(r, c).value);
      maxLen = Math.max(maxLen, v.length);
    }
    ws.getColumn(c).width = Math.min(Math.max(maxLen + 2, 8), 50);
  }

  // medium outer border for company area
  for (let r = headerRowIndex; r <= totalsRowIndex; r++) {
    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(r, c);
      const border = { ...cell.border };
      if (r === headerRowIndex) border.top = { style: 'medium' };
      if (r === totalsRowIndex) border.bottom = { style: 'medium' };
      if (c === firstCol) border.left = { style: 'medium' };
      if (c === lastCol) border.right = { style: 'medium' };
      cell.border = border;
    }
  }

  // save
  const buf = await wb.xlsx.writeBuffer();
  saveAs(new Blob([buf]), `apac_companies_${format(pickedDate, "yyyyMMdd")}.xlsx`);
};








