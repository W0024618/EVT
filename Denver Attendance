Now Update in Frontend When DenverMonthly is Selected Dont Display slect region and Location Tab ..
Only Display Select Start date and End date 
and Export tab ....
also Check Backend API endPoint and Update in Frontend carefully.....


C:\Users\W0024618\Desktop\global-page\backend\attendance-analytics\app.py

@app.get("/api/reports/denver-attendance")
@app.get("/reports/denver-attendance")
async def api_denver_attendance(
    year: Optional[int] = Query(None),
    month: Optional[int] = Query(None),
    from_date: Optional[str] = Query(None),
    to_date: Optional[str] = Query(None),
):
    request_id = uuid.uuid4().hex[:8]
    logger.info("[%s] denver-attendance request received: year=%s month=%s from_date=%s to_date=%s",
                request_id, year, month, from_date, to_date)
    try:
        denver_mod = importlib.import_module("denverAttendance")
    except Exception as e:
        logger.exception("denverAttendance import failed")
        raise HTTPException(status_code=500, detail=f"denverAttendance import failed: {e}")

    # resolve date range:
    if year and month:
        try:
            start_dt = date(year, month, 1)
            # last day of month:
            next_month = (start_dt.replace(day=28) + timedelta(days=4)).replace(day=1)
            end_dt = (next_month - timedelta(days=1)).date()
        except Exception:
            raise HTTPException(status_code=400, detail="Invalid year/month")
    elif from_date and to_date:
        try:
            start_dt = datetime.strptime(from_date[:10], "%Y-%m-%d").date()
            end_dt = datetime.strptime(to_date[:10], "%Y-%m-%d").date()
        except Exception:
            raise HTTPException(status_code=400, detail="Invalid from_date/to_date format. Use YYYY-MM-DD")
    else:
        # default: full range from 2025-01-01 to today (keeps previous behavior)
        start_dt = date(2025, 1, 1)
        end_dt = datetime.now().date()

    logger.info("[%s] generating denver report for range %s -> %s", request_id, start_dt, end_dt)

    # call generator (ensure it returns an absolute path)
    try:
        path = denver_mod.generate_monthly_denver_report(start_date=start_dt, end_date=end_dt, outdir=str(OUTPUT_DIR))
    except Exception as ex:
        logger.exception("[%s] Report generation failed", request_id)
        raise HTTPException(status_code=500, detail=f"Report generation failed: {ex}")

    p = Path(path)
    if not p.exists() or not p.is_file():
        logger.error("[%s] Generated file missing: %s", request_id, path)
        raise HTTPException(status_code=500, detail="Generated file not found")

    # compute media type
    media, _ = mimetypes.guess_type(str(p))
    if not media:
        media = "application/octet-stream"

    # compute stable file size AFTER file is fully written (generate_monthly_denver_report now writes atomically)
    try:
        size = p.stat().st_size
    except Exception:
        size = None

    def file_iterator(path_obj, chunk_size=64 * 1024):
        with open(path_obj, "rb") as fh:
            while True:
                chunk = fh.read(chunk_size)
                if not chunk:
                    break
                yield chunk

    headers = {"Content-Disposition": f'attachment; filename="{p.name}"'}
    if size is not None:
        headers["Content-Length"] = str(size)

    logger.info("[%s] Serving file %s size=%s", request_id, p.name, size)
    return StreamingResponse(file_iterator(str(p)), media_type=media, headers=headers)









# denverAttendance_no_quarters.py
# Based on denverAttendance_updated_quarters.py but with all Q# Avg columns removed.
# Kept all other logic, formatting, and thick outside border behavior identical.

import os
from datetime import date, datetime, timedelta
from pathlib import Path
import pandas as pd
import re

ODBC_DRIVER = os.getenv("ODBC_DRIVER", "ODBC Driver 17 for SQL Server")
DB_SERVER = os.getenv("DB_SERVER", "SRVWUDEN0890V")
DB_USER = os.getenv("DB_USER", "GSOC_Test")
DB_PASSWORD = os.getenv("DB_PASSWORD", "Westernuniongsoc@2025")

DB_LIST = [
    "ACVSUJournal_00010021",
    "ACVSUJournal_00010020",
    "ACVSUJournal_00010019",
]

SQL_TEMPLATE = r"""
SELECT
    t1.[ObjectName1] AS EmployeeName,
    t1.[ObjectName2] AS Door,
    CASE WHEN t2.[Int1] = 0 THEN t2.[Text12] ELSE CAST(t2.[Int1] AS NVARCHAR(200)) END AS EmployeeID,
    t3.[Name] AS PersonnelTypeName,
    CAST(t1.ObjectIdentity1 AS NVARCHAR(200)) AS EmployeeIdentity,
    t1.PartitionName2,
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    t2.Text5 AS PrimaryLocation,
    CASE
        WHEN t1.[ObjectName2] LIKE '%HQ%' THEN 'Denver'
        WHEN t1.[ObjectName2] LIKE '%Austin%' THEN 'Austin'
        WHEN t1.[ObjectName2] LIKE '%Miami%' THEN 'Miami'
        WHEN t1.[ObjectName2] LIKE '%NYC%' THEN 'New York'
        WHEN t1.[ObjectName2] LIKE 'APAC_PI%' THEN 'Taguig City'
        WHEN t1.[ObjectName2] LIKE 'APAC_PH%' THEN 'Quezon City'
        WHEN t1.[ObjectName2] LIKE '%PUN%' THEN 'Pune'
        WHEN t1.[ObjectName2] LIKE '%HYD%' THEN 'Hyderabad'
        ELSE t1.[PartitionName2]
    END AS LogicalLocation
FROM [{db}].dbo.ACVSUJournalLog AS t1
INNER JOIN ACVSCore.Access.Personnel AS t2 ON t1.ObjectIdentity1 = t2.GUID
INNER JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeID = t3.ObjectID
WHERE
    t1.MessageType = 'CardAdmitted'
    AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) BETWEEN '{start}' AND '{end}'
    AND (
        t1.[ObjectName2] LIKE '%HQ%'
        OR (t2.Text5 IS NOT NULL AND LOWER(t2.Text5) LIKE '%denver%' AND LOWER(t2.Text5) LIKE '%hq%')
        OR t1.[PartitionName2] = 'Denver'
    )
    AND LOWER(LTRIM(RTRIM(t3.[Name]))) IN ('employee','terminated personnel')
"""

def _get_engine(database: str) -> 'sqlalchemy.engine.Engine':
    from sqlalchemy import create_engine
    from urllib.parse import quote_plus
    odbc_str = (
        f"DRIVER={{{ODBC_DRIVER}}};"
        f"SERVER={DB_SERVER};"
        f"DATABASE={database};"
        f"UID={DB_USER};"
        f"PWD={DB_PASSWORD};"
        "TrustServerCertificate=Yes;Connection Timeout=30;"
    )
    quoted = quote_plus(odbc_str)
    url = f"mssql+pyodbc:///?odbc_connect={quoted}"
    return create_engine(url, pool_pre_ping=True, fast_executemany=True)

def _fetch_swipes_between(start_date: date, end_date: date) -> pd.DataFrame:
    start_s = start_date.strftime("%Y-%m-%d")
    end_s = end_date.strftime("%Y-%m-%d")
    frames = []
    for db in DB_LIST:
        sql = SQL_TEMPLATE.format(db=db, start=start_s, end=end_s)
        try:
            engine = _get_engine(db)
            with engine.connect() as conn:
                df = pd.read_sql(sql, conn)
            if not df.empty:
                df["SourceDB"] = db
                frames.append(df)
        except Exception:
            continue
    if not frames:
        return pd.DataFrame()
    out = pd.concat(frames, ignore_index=True)
    out.columns = [c.strip() for c in out.columns]
    out["LocaleMessageTime"] = pd.to_datetime(out.get("LocaleMessageTime"), errors="coerce")
    return out

def generate_monthly_denver_report(start_date: date = None, end_date: date = None, outdir: str = None) -> str:
    if start_date is None:
        start_date = date(2025, 1, 1)
    if end_date is None:
        end_date = datetime.now().date()
    swipes = _fetch_swipes_between(start_date, end_date)

    # Deduplicate and filter (keep original logic intent)
    swipes["DateOnly"] = swipes["LocaleMessageTime"].dt.date.fillna(pd.NaT)
    def _dedupe_key(row):
        for col in ("EmployeeIdentity", "EmployeeID", "EmployeeName"):
            val = str(row.get(col)).strip() if row.get(col) else None
            if val and val.lower() not in ('', 'nan', 'none', 'null'):
                return val
        return None
    if swipes.empty:
        ordered_days = []
        cur = start_date
        while cur <= end_date:
            ordered_days.append(cur)
            cur += timedelta(days=1)
        return _write_excel([], ordered_days, {}, outdir, start_date, end_date)

    swipes["dedupe_key"] = swipes.apply(_dedupe_key, axis=1)
    swipes = swipes[swipes["dedupe_key"].notna()]
    swipes = swipes[swipes["PersonnelTypeName"].str.strip().str.lower().isin(["employee", "terminated personnel"])]
    swipes = swipes[swipes["LogicalLocation"].str.strip().str.lower() == "denver"]
    swipes = swipes.sort_values(["dedupe_key", "DateOnly", "LocaleMessageTime"], ascending=[True, True, False])
    swipes = swipes.drop_duplicates(subset=["dedupe_key", "DateOnly"], keep="first")

    # ordered days list
    ordered_days = []
    cur = start_date
    while cur <= end_date:
        ordered_days.append(cur)
        cur += timedelta(days=1)

    # presence matrix (index = dedupe_key, columns = date objects)
    presence = pd.DataFrame(0, index=sorted(swipes["dedupe_key"].unique()), columns=ordered_days)
    for _, r in swipes.iterrows():
        uid = r["dedupe_key"]
        d = r["DateOnly"]
        if pd.isna(d):
            continue
        try:
            presence.at[uid, d] = 1
        except Exception:
            continue

    meta = swipes.groupby("dedupe_key", as_index=True).agg({
        "EmployeeName": "first",
        "EmployeeID": "first",
        "PersonnelTypeName": "first"
    })

    # Build rows (list of dicts)
    rows = []
    for uid in sorted(meta.index):
        empid = meta.loc[uid, "EmployeeID"]
        empname = meta.loc[uid, "EmployeeName"]
        row = {"Emp ID": empid, "Emp Name": empname}
        for d in ordered_days:
            key = d.strftime("%Y-%m-%d")
            value = int(presence.at[uid, d]) if (uid in presence.index and d in presence.columns) else 0
            row[key] = value
        rows.append(row)
    df = pd.DataFrame(rows)

    # Create months mapping maintaining chronological order
    months = {}
    for d in ordered_days:
        mon_key = d.strftime("%b")  # e.g., Jan, Feb
        months.setdefault(mon_key, []).append(d.strftime("%Y-%m-%d"))

    return _write_excel(df, ordered_days, months, outdir, start_date, end_date)

def _write_excel(df, ordered_days, months, outdir, start_date, end_date):
    outdir = Path(outdir or Path.cwd() / "output")
    outdir.mkdir(parents=True, exist_ok=True)
    fname = outdir / f"denver_attendance_{start_date.strftime('%Y%m%d')}_{end_date.strftime('%Y%m%d')}.xlsx"

    import xlsxwriter
    workbook = xlsxwriter.Workbook(str(fname))
    worksheet = workbook.add_worksheet("Attendance")
    worksheet.hide_gridlines(2)

    # Base style dicts (so we can reuse and add thick borders later)
    center_style = {"border": 1, "align": "center", "valign": "vcenter"}
    header_style = {"bold": True, **center_style, "bg_color": "#87CEEB"}
    present_style = {**center_style, "bg_color": "#C6EFCE"}     # light green
    absent_style = {**center_style, "bg_color": "#FFC7CE"}      # light red for absent
    weekend_header_style = {**center_style, "bg_color": "#FFDADA", "bold": True}
    weekend_cell_style = {**center_style, "bg_color": "#FFDADA"}
    month_total_header_style = {**center_style, "bg_color": "#FFEB9C", "bold": True}
    month_total_cell_style = {**center_style, "bg_color": "#FFEB9C"}
    grand_total_style = {**center_style, "bg_color": "#FFEB9C", "bold": True}
    empname_style = {**center_style}

    # Create formats from styles
    header_fmt = workbook.add_format(header_style)
    present_fmt = workbook.add_format(present_style)
    absent_fmt = workbook.add_format(absent_style)
    weekend_header_fmt = workbook.add_format(weekend_header_style)
    weekend_cell_fmt = workbook.add_format(weekend_cell_style)
    month_total_header_fmt = workbook.add_format(month_total_header_style)
    month_total_cell_fmt = workbook.add_format(month_total_cell_style)
    grand_total_fmt = workbook.add_format(grand_total_style)
    empname_fmt = workbook.add_format(empname_style)

    # Build final columns in desired order (no Q Avg columns)
    final_columns = ["Emp ID", "Emp Name"]
    # ensure months chronological
    seen = []
    for d in ordered_days:
        m = d.strftime("%b")
        if m not in seen:
            seen.append(m)
    month_order = seen
    month_day_lists = [months.get(m, []) for m in month_order]

    for m, day_list in zip(month_order, month_day_lists):
        final_columns.extend(day_list)
        final_columns.append(f"{m} Total")

    final_columns.append("Grand Total")

    # Write header row with formatted date strings and capture header labels
    header_labels = []
    for col_idx, col_name in enumerate(final_columns):
        if re.match(r"\d{4}-\d{2}-\d{2}", str(col_name)):
            d = datetime.strptime(col_name, "%Y-%m-%d").date()
            header_label = f"{d.strftime('%a')}, {d.day} {d.strftime('%B')}, {d.year}"
            header_labels.append(header_label)
            if d.weekday() >= 5:
                worksheet.write(0, col_idx, header_label, weekend_header_fmt)
            else:
                worksheet.write(0, col_idx, header_label, header_fmt)
        elif str(col_name).endswith("Total") or str(col_name) == "Grand Total":
            header_labels.append(col_name)
            worksheet.write(0, col_idx, col_name, month_total_header_fmt)
        else:
            header_labels.append(col_name)
            worksheet.write(0, col_idx, col_name, header_fmt)

    # Set column widths
    worksheet.set_column(0, 0, 15)  # Emp ID
    worksheet.set_column(1, 1, 30)  # Emp Name
    worksheet.set_column(2, len(final_columns)-1, 12)

    # Write employee rows
    df_rows = [] if isinstance(df, (list, tuple)) else (df.to_dict(orient="records") if not df.empty else [])
    start_row = 1
    for r_idx, row in enumerate(df_rows):
        excel_row = start_row + r_idx
        worksheet.write(excel_row, 0, row.get("Emp ID"), empname_fmt)
        worksheet.write(excel_row, 1, row.get("Emp Name"), empname_fmt)
        col_ptr = 2
        # iterate months and insert month totals
        for m, day_list in zip(month_order, month_day_lists):
            for day in day_list:
                val = int(row.get(day, 0) or 0)
                d = datetime.strptime(day, "%Y-%m-%d").date()
                if val == 1:
                    worksheet.write(excel_row, col_ptr, val, present_fmt)
                else:
                    if d.weekday() >= 5:
                        worksheet.write(excel_row, col_ptr, val, weekend_cell_fmt)
                    else:
                        worksheet.write(excel_row, col_ptr, val, absent_fmt)
                col_ptr += 1
            # month total
            month_total = sum(int(row.get(day, 0) or 0) for day in day_list)
            worksheet.write(excel_row, col_ptr, month_total, month_total_cell_fmt)
            col_ptr += 1

        # grand total
        all_date_cols = [c for c in row.keys() if re.match(r"\d{4}-\d{2}-\d{2}", str(c))]
        grand = sum(int(row.get(day, 0) or 0) for day in all_date_cols)
        worksheet.write(excel_row, col_ptr, grand, grand_total_fmt)

    # After all employees, write summary row (Total) with day sums and month sums
    summary_row = start_row + len(df_rows)
    worksheet.write(summary_row, 0, "Total", month_total_header_fmt)
    worksheet.write(summary_row, 1, "", month_total_header_fmt)
    col_ptr = 2
    for m, day_list in zip(month_order, month_day_lists):
        for day in day_list:
            if isinstance(df, (list, tuple)) or df.empty:
                day_sum = 0
            else:
                day_sum = int(df.get(day, pd.Series(dtype=int)).sum())
            worksheet.write(summary_row, col_ptr, day_sum, month_total_cell_fmt)
            col_ptr += 1
        # month total (sum of day sums)
        if isinstance(df, (list, tuple)) or df.empty:
            msum = 0
        else:
            msum = int(df[[d for d in day_list]].sum(axis=1).sum())
        worksheet.write(summary_row, col_ptr, msum, month_total_cell_fmt)
        col_ptr += 1

    # Grand total cell
    grand_col_idx = len(final_columns) - 1
    if isinstance(df, (list, tuple)) or df.empty:
        grand_total_val = 0
    else:
        day_cols = [c for c in df.columns if re.match(r"\d{4}-\d{2}-\d{2}", c)]
        grand_total_val = int(df[day_cols].sum(axis=1).sum()) if day_cols else 0
    worksheet.write(summary_row, grand_col_idx, grand_total_val, grand_total_fmt)

    # Freeze header
    worksheet.freeze_panes(1, 2)

    # Apply thick outer border: top row (header), bottom row (summary), leftmost col, rightmost col
    last_row = summary_row
    last_col = len(final_columns) - 1

    # helper to create format dicts preserving bg and borders
    def make_fmt(base_style, extra=None):
        s = dict(base_style)
        s["border"] = s.get("border", 1)
        if extra:
            s.update(extra)
        return workbook.add_format(s)

    # Top border: rewrite header row with top border thick
    for c_idx, col_name in enumerate(final_columns):
        base_style = header_style if not (str(col_name).endswith("Total") or str(col_name) == "Grand Total") else month_total_header_style
        if re.match(r"\d{4}-\d{2}-\d{2}", str(col_name)):
            d = datetime.strptime(col_name, "%Y-%m-%d").date()
            if d.weekday() >= 5:
                base_style = weekend_header_style
        extra = {"top": 2}
        fmt = make_fmt(base_style, extra)
        worksheet.write(0, c_idx, header_labels[c_idx], fmt)

    # Bottom border: rewrite summary row with bottom thick
    for c_idx, col_name in enumerate(final_columns):
        base_style = month_total_cell_style
        extra = {"bottom": 2}
        fmt = make_fmt(base_style, extra)
        # compute value similar to earlier
        if c_idx == 0:
            value = "Total"
        elif c_idx == 1:
            value = ""
        else:
            name = col_name
            if re.match(r"\d{4}-\d{2}-\d{2}", str(name)):
                if isinstance(df, (list, tuple)) or df.empty:
                    value = 0
                else:
                    value = int(df.get(name, pd.Series(dtype=int)).sum())
            elif str(name).endswith("Total") and str(name) != "Grand Total":
                mon = str(name).replace(" Total", "")
                day_list = months.get(mon, [])
                if isinstance(df, (list, tuple)) or df.empty:
                    value = 0
                else:
                    value = int(df[[d for d in day_list]].sum(axis=1).sum()) if day_list else 0
            elif str(name) == "Grand Total":
                if isinstance(df, (list, tuple)) or df.empty:
                    value = 0
                else:
                    day_cols = [c for c in df.columns if re.match(r"\d{4}-\d{2}-\d{2}", c)]
                    value = int(df[day_cols].sum(axis=1).sum()) if day_cols else 0
            else:
                value = ""
        worksheet.write(summary_row, c_idx, value, fmt)

    # Left border: add thick left border to first column for all rows from 0..last_row
    for r in range(0, last_row + 1):
        if r == 0:
            base = header_style
        elif r == summary_row:
            base = month_total_cell_style
        else:
            base = empname_style
        fmt = make_fmt(base, {"left": 2})
        if r == 0:
            val = header_labels[0]
        elif r == summary_row:
            val = "Total"
        else:
            idx = r - start_row
            if 0 <= idx < len(df_rows):
                val = df_rows[idx].get("Emp ID")
            else:
                val = ""
        worksheet.write(r, 0, val, fmt)

    # Right border: add thick right border to last column for all rows 0..last_row
    for r in range(0, last_row + 1):
        if r == 0:
            base = header_style
        elif r == summary_row:
            base = month_total_cell_style
        else:
            base = grand_total_style
        fmt = make_fmt(base, {"right": 2})
        c = last_col
        if r == 0:
            val = header_labels[c]
        elif r == summary_row:
            if isinstance(df, (list, tuple)) or df.empty:
                val = 0
            else:
                day_cols = [c for c in df.columns if re.match(r"\d{4}-\d{2}-\d{2}", c)]
                val = int(df[day_cols].sum(axis=1).sum()) if day_cols else 0
        else:
            idx = r - start_row
            if 0 <= idx < len(df_rows):
                row = df_rows[idx]
                all_date_cols = [c for c in row.keys() if re.match(r"\d{4}-\d{2}-\d{2}", str(c))]
                val = sum(int(row.get(day, 0) or 0) for day in all_date_cols)
            else:
                val = ""
        worksheet.write(r, c, val, fmt)

    workbook.close()
    return str(fname)

if __name__ == "__main__":
    path = generate_monthly_denver_report()
    print("Wrote:", path)







// frontend/vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

const BACKEND_PY_PORT = process.env.BACKEND_PORT || 8000;
const BACKEND_PY_HOST = `http://localhost:${BACKEND_PY_PORT}`; // Python (ccure)
const NODE_BACKEND = 'http://localhost:3008';                 // Node (headcount + other legacy endpoints)

export default defineConfig({
  plugins: [react()],
  publicDir: path.resolve(__dirname, '../public'),
  resolve: {
    alias: {
      // Do NOT alias @mui/material (let package resolution work normally)
      // Keep emotion aliases to avoid duplicate emotion runtime instances:
      '@emotion/react': path.resolve(__dirname, 'node_modules/@emotion/react'),
      '@emotion/styled': path.resolve(__dirname, 'node_modules/@emotion/styled'),
    },
    // Prevent duplicate copies of MUI / emotion being bundled
    dedupe: ['@mui/material', '@mui/system', '@mui/styled-engine', '@emotion/react']
  },
  optimizeDeps: {
    // help vite pre-bundle these so ESM exports resolve correctly
    include: [
      '@mui/material',
      '@mui/material/styles',
      '@mui/icons-material',
      '@emotion/react',
      '@emotion/styled'
    ]
  },
  server: {
    port: 5173,
    hmr: { overlay: false },
    proxy: {
      '/api/ccure': {
        target: BACKEND_PY_HOST,
        changeOrigin: true,
        secure: false,
        rewrite: (path) => path.replace(/^\/api/, ''),
        timeout: 120000
      },


       // <-- add this block so /api/reports goes to Python (FastAPI)
     '/api/reports': {
       target: BACKEND_PY_HOST,
       changeOrigin: true,
       secure: false,
       timeout: 120000,
       // no rewrite: forward path as-is so Python sees /api/reports/...
       rewrite: (path) => path.replace(/^\/api\/reports/, '/reports')
     },

      // Python (FastAPI) under a dedicated prefix
      '/api-py': {
        target: BACKEND_PY_HOST,
        changeOrigin: true,
        secure: false,
        timeout: 120000,
        rewrite: (path) => path.replace(/^\/api-py/, '/api') // adjust target path if FastAPI lives at /api or /
      },

      // Node backend (legacy)
      '/api': {
        target: NODE_BACKEND,
        changeOrigin: true,
        secure: false,
        timeout: 120000
      }
    }
  }

});











// frontend/src/App.jsx
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import { Box } from '@mui/material';

import GlobalPage   from './pages/GlobalPage.jsx';
import VipPage      from './pages/VipPage.jsx';
import ReportsPage  from './pages/ReportsPage.jsx';
import DurationPage from "./pages/DurationPage";
import { AuthProvider, useAuth } from './context/AuthContext';
import LoginPage from './pages/LoginPage';
import ProtectedRoute from './components/ProtectedRoute';
import AccessManager from './pages/AccessManager';

// Optional: small wrapper to redirect authed users from /login
function LoginGuard() {
  const auth = useAuth();
  if (auth.loading) return null;
  if (auth.user) return <Navigate to="/" replace />;
  return <LoginPage />;
}

export default function App() {
  return (
    <AuthProvider>
      <Routes>
        <Route path="/login" element={<LoginGuard />} />

        <Route path="/" element={
          <ProtectedRoute>
            <GlobalPage />
          </ProtectedRoute>
        } />

        <Route path="/vip" element={
          <ProtectedRoute>
            <VipPage />
          </ProtectedRoute>
        } />

        <Route path="/reports" element={
          <ProtectedRoute>
            <ReportsPage />
          </ProtectedRoute>
        } />

        <Route path="/duration" element={
          <ProtectedRoute permission="global_duration">
            <DurationPage />
          </ProtectedRoute>
        } />

        <Route path="/access-manager" element={
          <ProtectedRoute permission="can_grant">
            <AccessManager />
          </ProtectedRoute>
        } />



    <Route path="/denver-attendance" element={
          <ProtectedRoute permission="denver-attendance">
            <AccessManager />
          </ProtectedRoute>
        } />


        {/* fallback */}
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </AuthProvider>
  );
}










//C:\Users\W0024618\Desktop\global-page\frontend\src\api.js

import axios from 'axios';

export const api = axios.create({
  baseURL: '/api',         // Node backend (legacy)
  timeout: 12000000,
  headers: { 'Accept': 'application/json' }
});

export const pyApi = axios.create({
  baseURL: '/api-py',      // NEW: dedicated prefix for Python (FastAPI)
  timeout: 12000000,
  headers: { 'Accept': 'application/json' }
});

api.interceptors.response.use(
  (r) => r,
  (err) => {
    console.error('[API ERROR]', err?.config?.method?.toUpperCase(), err?.config?.url, err?.response?.status, err?.message);
    return Promise.reject(err);
  }
);

pyApi.interceptors.response.use(
  (r) => r,
  (err) => {
    console.error('[PY-API ERROR]', err?.config?.method?.toUpperCase(), err?.config?.url, err?.response?.status, err?.message);
    return Promise.reject(err);
  }
);

export default api;







//C:\Users\W0024618\Desktop\global-page\frontend\src\pages\ReportsPage.jsx
//import React, { useState } from 'react';
import React, { useState, useEffect, useRef } from 'react';
import {
  Box, FormControl, InputLabel, Select, OutlinedInput,
  Checkbox, ListItemText, MenuItem, Button,
  CircularProgress, Typography, TextField, Tabs, Tab, Grid, Paper, IconButton, Divider,Autocomplete
} from '@mui/material';
;

import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import axios from 'axios';
import ExcelJS from 'exceljs';
import * as XLSX from 'xlsx';
import { useAuth } from '../context/AuthContext';

import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import PlaceIcon from '@mui/icons-material/Place';
import PeopleIcon from '@mui/icons-material/People';
import DownloadIcon from '@mui/icons-material/CloudDownload';
import FilterListIcon from '@mui/icons-material/FilterList';
import Avatar from '@mui/material/Avatar';
import { generateDailyAccessExcelFromRows } from './DailyAccessReport';

// Static lists
const EMPLOYEE_OPTIONS = [
  'Vainilaitis, Valdas',
  'Tomasevic, Kazimez',
  'Sesickis, Janas',
  'Valiunas, Sigitas',
  'JANCUKOVIC, VACLAVA',
  'Kalpokiene, Alina',
  'Korkus, Vanda',
  'Kvaraciejiene, Maryte',
  'ZNAMEROVSKIS, DARIUS'
];

const REGION_OPTIONS = ['global', 'apac', 'emea', 'laca', 'namer'];
const LOCATION_MAP = {
  apac: ['APAC.Default', 'JP.Tokyo', 'PH.Manila', 'MY.Kuala Lumpur','IN.HYD'],
  emea: ['AUT.Vienna', 'DU.Abu Dhab', 'IE.Dublin', 'IT.Rome', 'LT.Vilnius', 'MA.Casablanca', 'RU.Moscow', 'UK.London', 'ES.Madrid'],
  laca: ['AR.Cordoba', 'CR.Costa Rica Partition', 'MX.Mexico City', 'PE.Lima', 'BR.Sao Paulo', 'PA.Panama City'],
  namer: ['US.NYC', 'US.FL.Miami', 'USA/Canada Default', 'US.CO.OBS','denver'],
  global: []
};

function formatDisplayDate(date) {
  const d = new Date(date);
  const day = d.getDate();
  const suf = day % 10 === 1 && day !== 11 ? 'st'
    : day % 10 === 2 && day !== 12 ? 'nd'
      : day % 10 === 3 && day !== 13 ? 'rd' : 'th';
  const mon = d.toLocaleString('default', { month: 'long' });
  return `${day}${suf} ${mon} ${d.getFullYear()}`;
}

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');

// --- Helper: parse server "ISO like" / "YYYY-MM-DD[ T]HH:MM:SS(.mmm)[Z|+..]" as literal parts
function _extractServerDateTimeParts(iso) {
  if (!iso) return null;
  const s = String(iso);
  let datePart = '', timePart = '';
  if (s.includes('T')) {
    [datePart, timePart] = s.split('T');
  } else if (s.includes(' ')) {
    [datePart, timePart] = s.split(' ');
  } else {
    return null;
  }
  datePart = datePart.slice(0, 10);
  timePart = (timePart || '').replace(/Z|[+-]\d{2}:\d{2}$/, '').replace(/\.\d+$/, '');
  const dParts = datePart.split('-').map(p => parseInt(p, 10));
  const tParts = timePart.split(':').map(p => parseInt(p || '0', 10));
  return {
    year: dParts[0] || 0,
    month: dParts[1] || 0,
    day: dParts[2] || 0,
    hour: tParts[0] || 0,
    minute: tParts[1] || 0,
    second: tParts[2] || 0
  };
}



function formatDateFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  const y = dt.getUTCFullYear();
  const m = dt.getUTCMonth(); // 0..11
  const d = dt.getUTCDate();
  const yrShort = String(y).slice(-2);
  return `${pad2(d)}-${MONTH_ABBR[m]}-${yrShort}`;         // e.g. "12-Aug-25"
}



function formatTimeFromServerISO(iso) {
  if (!iso) return '';
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const hh = p.hour;
  const mm = p.minute || 0;
  const ss = p.second || 0;
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1;
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`; // e.g. "3:23:46 PM"
}



function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10);
  if (!swipeIso) {
    return `${datePart}T00:00:00.000`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000`;
  }
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000`;
}






// returns a server-wall-clock ISO for a row: prefer LocaleMessageTime, else DateOnly+Swipe_Time
const getServerISO = (r) => {
  if (!r) return '';
  if (r.LocaleMessageTime) return r.LocaleMessageTime;
  if (r.DateOnly) return buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  return '';
};

// returns YYYY-MM-DD for server wall-clock (used for filtering)
const getServerYMD = (r) => {
  const iso = getServerISO(r);
  if (!iso) return '';
  return iso.slice(0, 10);
};

// Helper — convert "YYYY-MM-DD..." (ISO) into a local midnight Date (avoids UTC shift)
const isoDateOnlyToLocalDate = (iso) => {
  if (!iso) return null;
  const s = iso.toString().slice(0, 10);
  const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
  return new Date(y, m - 1, d);
};

// Build a Date that preserves the server-provided wall-clock values.
// If swipeTime is an ISO (with Z), read UTC components and use them as local values.
const buildLocalDateFromDateOnlyAndSwipe = (dateOnly, swipeTime) => {
  if (!dateOnly) return null;
  const dateStr = dateOnly.toString().slice(0, 10);
  const [yy, mm, dd] = dateStr.split('-').map(n => parseInt(n, 10));

  let hh = 0, min = 0, ss = 0;
  if (swipeTime) {
    const parsed = new Date(swipeTime);
    if (!isNaN(parsed.getTime())) {
      hh = parsed.getUTCHours();
      min = parsed.getUTCMinutes();
      ss = parsed.getUTCSeconds();
    } else {
      const parts = swipeTime.split(':').map(p => parseInt(p, 10));
      if (parts.length >= 2) {
        hh = parts[0] || 0;
        min = parts[1] || 0;
        ss = parts[2] || 0;
      }
    }
  }
  return new Date(yy, mm - 1, dd, hh, min, ss);
};

export default function ReportsPage() {
  const auth = useAuth();

  // --- state ---
  const [tab, setTab] = useState(0);

  const [region, setRegion] = useState('emea');
  const [location, setLocation] = useState('');
  const [from, setFrom] = useState(null);
  const [to, setTo] = useState(null);
  const [showFromCal, setShowFromCal] = useState(false);
  const [showToCal, setShowToCal] = useState(false);
  const [selectedEmps, setSelectedEmps] = useState([]);
  const [loading, setLoading] = useState(false);

  const [rawSearch, setRawSearch] = useState('');
  const [rawAdmitFilter, setRawAdmitFilter] = useState('all');
  const [newEmployee, setNewEmployee] = useState(''); // text field for adding name or ID

  //new usestste

  // locations fetched from backend for current region (strings like "APAC.Default")
  const [availableLocations, setAvailableLocations] = useState([]);
  // selected locations for Raw (multiple)
  const [selectedLocations, setSelectedLocations] = useState([]);
   // employee-autocomplete state specifically for Raw tab
  const [rawEmpOptions, setRawEmpOptions] = useState([]); // suggestions from backend
  const [selectedRawEmps, setSelectedRawEmps] = useState([]); // array of strings (name or ID)
  const empQueryRef = useRef(null); // debounce timer




// Helper: fetch locations for a single region key (backend endpoint: GET /api/locations?region=apac)
const fetchLocationsForRegion = async (r) => {
  try {
    if (!r) return [];
    // pass region param exactly as frontend holds it (lowercase like 'apac','emea')
    const resp = await axios.get('/api/locations', { params: { region: r } });
    const listRaw = (resp.data && (resp.data.data || resp.data)) || [];

    // Accept multiple shapes:
    //  - array of strings: ["APAC.Default", "IN.HYD"]
    //  - array of objects: [{ PartitionName2: "APAC.Default" }, { partition: "IN.HYD" }]
    // Normalize to strings.
    const list = Array.isArray(listRaw)
      ? listRaw.map(item => {
          if (typeof item === 'string') return item;
          // common property names we might receive
          return item.PartitionName2 || item.partition || item.location || item.name || (item.label ? item.label : null);
        }).filter(Boolean)
      : [];

    // Fallback: if backend returned nothing, use static map (best-effort)
    if (!list.length) {
      const key = (r || '').toLowerCase();
      return (LOCATION_MAP[key] || []).slice();
    }

    // dedupe & sort
    return Array.from(new Set(list)).sort();
  } catch (e) {
    console.warn('fetchLocationsForRegion error', r, e);
    // fallback to static map
    const key = (r || '').toLowerCase();
    return (LOCATION_MAP[key] || []).slice();
  }
};





// fetch availableLocations for the currently selected region (runs on region change)
useEffect(() => {
  let mounted = true;
  const load = async () => {
    setAvailableLocations([]);
    if (!region) return;

    const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];

    try {
      if (region === 'global') {
        const promises = MULTI_REGIONS.map(r => fetchLocationsForRegion(r));
        const results = await Promise.all(promises);
        const merged = results.flat();
        if (!mounted) return;
        setAvailableLocations(Array.from(new Set(merged)).sort());
      } else {
        const list = await fetchLocationsForRegion(region);
        if (!mounted) return;
        setAvailableLocations(Array.from(new Set(list)).sort());
      }
    } catch (err) {
      console.error('load locations error', err);
      // fallback to static map handled below when rendering
    }
  };

  load();
  return () => { mounted = false; };
}, [region]);





  // Handle tab switch (Daily / Raw / Rejection)
  const handleTabChange = (_, v) => {
    setTab(v);
    // reset filters
    setRegion('emea');
    setLocation('');
    setFrom(null);
    setTo(null);
    setSelectedEmps([]);
    setRawSearch('');
    setRawAdmitFilter('all');
  };

  /** Time Duration Excel generator */
  const generateTimeDurationExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Time Duration');

    ws.mergeCells('A1:M1');
    ws.getCell('A1').value =
      `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };

    const headers = [
      'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
      'Partition', 'Text5', 'Year', 'Week', 'Date',
      'First Swipe', 'Last Swipe', 'Duration', 'Category',
      'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'ptype', width: 18 },
      { key: 'part', width: 15 },
      { key: 'txt5', width: 20 },
      { key: 'year', width: 8 },
      { key: 'week', width: 6 },
      { key: 'date', width: 12 },
      { key: 'first', width: 16 },
      { key: 'last', width: 16 },
      { key: 'dur', width: 10 },
      { key: 'cat', width: 12 },
      { key: 'dpw', width: 12 },
      { key: 'vdw', width: 14 },
      { key: 'cdw', width: 12 },
      { key: 'def', width: 10 }
    ];

    data.forEach((r, idx) => {
      const first = new Date(r.FirstSwipeTime);
      const last = new Date(r.LastSwipeTime);
      const date = new Date(r.ShiftedDate);
      const row = ws.addRow([
        idx + 1,
        r.ObjectName1,
        r.EmployeeID,
        r.PersonnelType,
        r.PartitionName2,
        r.text5,
        r.YearNumber,
        r.WeekNumber,
        date,
        first,
        last,
        r.DurationHHMM,
        r.TimeDiffCategory,
        r.DaysPresentInWeek,
        r.ViolationDaysInWeek,
        r.CleanDaysInWeek,
        r.Defaulter
      ]);

      row.getCell(9).numFmt = 'dd-mmm-yy';
      row.getCell(10).numFmt = 'h:mm:ss AM/PM';
      row.getCell(11).numFmt = 'h:mm:ss AM/PM';

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    ws.autoFilter = 'A2:Q2';

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    const filename =
      `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;

    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  // Rejection Excel
  const generateRejectionExcel = async data => {
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Rejection');

    const title = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}`;
    ws.mergeCells('A1:J1');
    ws.getCell('A1').value = title;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };

    const headers = [
      'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
      'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'date', width: 12 },
      { key: 'time', width: 12 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'card', width: 15 },
      { key: 'type', width: 15 },
      { key: 'door', width: 40 },
      { key: 'loc', width: 15 },
      { key: 'swipe', width: 10 }
    ];

    data.forEach((r, idx) => {
      const iso = getServerISO(r);
      const dateStr = iso ? formatDateFromServerISO(iso) : '';
      const timeStr = iso ? formatTimeFromServerISO(iso) : '';

      const row = ws.addRow([
        idx + 1,
        dateStr,
        timeStr,
        r.ObjectName1 || '',
        r.EmployeeID || '',
        r.CardNumber || '',
        r.Rejection_Type || '',
        r.Door || r.ObjectName2 || '',
        r.location || '',
        r.Direction || r.Swipe || ''
      ]);

      row.getCell(2).alignment = { horizontal: 'left' };
      row.getCell(3).alignment = { horizontal: 'left' };

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    const counts = data.reduce((a, r) => {
      const k = r.Rejection_Type || 'Unknown';
      a[k] = (a[k] || 0) + 1; return a;
    }, {});
    let rowIdx = 3;
    ws.getCell(rowIdx, 11).value = 'Rejection';
    ws.getCell(rowIdx, 12).value = 'Count';
    [11, 12].forEach(c => {
      const cell = ws.getCell(rowIdx, c);
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'center' };
      cell.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });
    rowIdx++;
    Object.entries(counts).forEach(([type, cnt]) => {
      ws.getCell(rowIdx, 11).value = type;
      ws.getCell(rowIdx, 12).value = cnt;
      [11, 12].forEach(c => {
        const cell = ws.getCell(rowIdx, c);
        cell.alignment = { horizontal: 'left' };
        cell.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
      });
      rowIdx++;
    });
    ws.getCell(rowIdx, 11).value = 'Total';
    ws.getCell(rowIdx, 12).value = data.length;
    [11, 12].forEach(c => {
      const cell = ws.getCell(rowIdx, c);
      cell.font = { bold: true };
      cell.alignment = { horizontal: 'left' };
      cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
    });

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const filename = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}.xlsx`;
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };



// helper: safe filename builder used by generateRawExcel (prevents ReferenceError)
function buildRawFileName(opts = {}) {
  const safe = s => (s === undefined || s === null) ? '' : String(s).replace(/[\/\\:?<>|"]/g, '_').trim();
  const regionPart = opts.region ? safe(opts.region).toUpperCase() : 'RAW';
  const locationPart = opts.location ? `_${safe(opts.location).replace('.', '_')}` : '';
  const admitPart = opts.rawAdmitFilter ? `_${safe(opts.rawAdmitFilter)}` : '';
  const searchPart = opts.rawSearch ? `_${safe(opts.rawSearch).replace(/\s+/g, '_')}` : '';

  // from/to might be Date objects (frontend passes Date), or strings — handle both
  const formatDateForName = d => {
    if (!d) return '';
    try {
      if (d instanceof Date) return `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}`;
      const dt = new Date(d);
      if (!isNaN(dt.getTime())) return `${dt.getFullYear()}${pad2(dt.getMonth()+1)}${pad2(dt.getDate())}`;
    } catch (e) { /* ignore */ }
    return safe(d).slice(0,10).replace(/[-\s:]/g,'');
  };

  const fromPart = opts.from ? `_from_${formatDateForName(opts.from)}` : '';
  const toPart   = opts.to   ? `_to_${formatDateForName(opts.to)}` : '';

  const filename = `Raw_${regionPart}${locationPart}${fromPart}${toPart}${admitPart}${searchPart}.xlsx`;
  return filename;
}


  // generateRawExcel
  const generateRawExcel = async (rows, opts = {}) => {
    const formatTimeFromSwipe = (swipeIso) => {
      if (!swipeIso) return '';
      const dt = new Date(swipeIso);
      if (!isNaN(dt.getTime())) {
        return formatTimeFromServerISO(swipeIso);
      }
      const parts = ('' + swipeIso).split(':').map(p => parseInt(p || 0, 10));
      const hh = parts[0] || 0;
      const mm = parts[1] || 0;
      const ss = parts[2] || 0;
      const ampm = hh >= 12 ? 'PM' : 'AM';
      const hh12 = ((hh + 11) % 12) + 1;
      return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
    };

    const admitFilter = (opts.rawAdmitFilter || 'all').toString().toLowerCase();

    const baseHeaders = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber'];
    const admitCol = 'AdmitCode';
    const rejCol = 'Rejection_Type';
    const tailCols = ['Direction','Door'];

    let headers = [...baseHeaders];
    if (admitFilter === 'all') {
      headers.push(admitCol);
      headers.push(...tailCols);
      headers.push(rejCol);
    } else if (admitFilter === 'admit') {
      headers.push(admitCol);
      headers.push(...tailCols);
    } else if (admitFilter === 'reject') {
      headers.push(...tailCols);
      headers.push(rejCol);
    } else {
      headers.push(admitCol);
      headers.push(...tailCols);
      headers.push(rejCol);
    }

    if (!rows || !rows.length) {
      const wbEmpty = XLSX.utils.book_new();
      const wsEmpty = XLSX.utils.aoa_to_sheet([headers]);
      XLSX.utils.book_append_sheet(wbEmpty, wsEmpty, 'Raw');
      const fileNameEmpty = buildRawFileName(opts);
      XLSX.writeFile(wbEmpty, fileNameEmpty);
      return;
    }

    const rowsForSheet = rows.map(r => {
      const iso = getServerISO(r);
      const dateStr = iso ? formatDateFromServerISO(iso) : '';
      const timeStr = iso ? formatTimeFromServerISO(iso) : '';
      const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');
      const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';
      const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

      const fullObj = {
        LocaleMessageTime: localeMsgFormatted,
        DateOnly: dateOnlyFormatted,
        Swipe_Time: swipeTimeFormatted,
        EmployeeID: r.EmployeeID || '',
        ObjectName1: r.ObjectName1 || '',
        PersonnelType: r.PersonnelType || '',
        location: r.location || '',
        CardNumber: r.CardNumber || '',
        AdmitCode: r.AdmitCode || r.Messagetype || '',
        Direction: r.Direction || r.Swipe || '',
        Door: r.Door || r.ObjectName2 || '',
        Rejection_Type: r.Rejection_Type || ''
      };

      const picked = {};
      headers.forEach(h => {
        picked[h] = (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '';
      });
      return picked;
    });

    const ws = XLSX.utils.json_to_sheet(rowsForSheet, { header: headers });
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Raw');

    const filename = buildRawFileName(opts);
    XLSX.writeFile(wb, filename);
  };

  // --- Permission helpers ---
  const exportPermsForTab = () => {
    if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
    if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
    if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
    if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
    if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
    if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
    if (tab === 6) return ['gsoc_reports.denver_monthly', 'gsoc_reports'];

    return ['gsoc_reports'];
  };

  // disabled conditions - UI-level validations (permission gating done separately)
  // const disabled = loading
  //   || !region
  //   || (tab === 0 && (!from || !to || selectedEmps.length === 0))
  //   || (tab === 1 && (!from || !to))
  //   || (tab === 2 && (!from || !to))
  //   || (tab === 3 && !from)
  //   || (tab === 4 && (!from || !to));


  const disabled = loading
    || !region
    || (tab === 0 && (!from || !to || selectedEmps.length === 0))
    || (tab === 1 && (!from || !to))
    || (tab === 2 && (!from || !to))
    || (tab === 3 && !from)
    || (tab === 4 && (!from || !to));



  const navDisabled = !region || loading;

  const exportAllowed = auth.hasPermission(exportPermsForTab());

  // --- Generate handler with permission check up-front ---
  const handleGenerate = async () => {
    // Permission gating: determine required permission for each tab
    const requirePermissionForTab = () => {
      if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
      if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
      if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
      if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
      if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
      if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
      if (tab === 6) return ['gsoc_reports.denver_monthly', 'gsoc_reports'];
      return ['gsoc_reports'];
    };

    if (!auth.hasPermission(requirePermissionForTab())) {
      alert('You do not have permission to generate this report.');
      return;
    }

    setLoading(true);
    try {
      const baseParams = { region, location: location || undefined };

      // Helper: format dates in local time without timezone conversion for API parameters
      const formatLocalDate = (date, endOfDay = false) => {
        const d = new Date(date);
        if (endOfDay) d.setHours(23, 59, 59, 999);
        else d.setHours(0, 0, 0, 0);
        const pad = n => n.toString().padStart(2, '0');
        return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}` +
               `T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      };

      const toLocalYMD = date => `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`;

      // ----- 0: Daily Access -----
      if (tab === 0) {
        // IMPORTANT: backend daily access expects DATE (no time) for from/to.
        // Send YYYY-MM-DD (date-only) to avoid SQL server timezone/cast issues.
        const fromDateOnly = `${from.getFullYear()}-${pad2(from.getMonth() + 1)}-${pad2(from.getDate())}`;
        const toDateOnly = `${to.getFullYear()}-${pad2(to.getMonth() + 1)}-${pad2(to.getDate())}`;

        const params = {
          ...baseParams,
          from: fromDateOnly,
          to: toDateOnly,
          employees: selectedEmps.join(',')
        };
        const resp = await axios.get('/api/reports/daily-access', { params });

        // rows as returned by backend (backend now returns LocaleMessageTime as text)
        const rows = (resp.data && resp.data.data) || [];

        // pass rows and current options; the new module writes Excel using server wall-clock text
        await generateDailyAccessExcelFromRows(rows, { from: fromDateOnly, to: toDateOnly, selectedEmps, region });
        return;
      }




 // ----- 1: Raw -----
      if (tab === 1) {
        const startISO = formatLocalDate(from);
        const endISO = formatLocalDate(to, true);
        const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];

        // Build a list of requests to perform (region + optional location)
        const requests = [];

        // Helper: push a request for given region and optional location
        const pushReq = (r, locationParam = undefined) => {
          const params = {
            startDate: startISO,
            endDate: endISO,
            admitFilter: rawAdmitFilter
          };
          // only include region if not global per-call (we will explicitly call per-region)
          if (r) params.region = r;
          if (locationParam) params.location = locationParam;
          requests.push(axios.get('/api/reports/raw', { params }));
        };

        if (region === 'global') {
          // if user selected specific locations, group them by their region prefix (e.g. "APAC.Default")
          if (selectedLocations && selectedLocations.length) {
            // map: regionKey -> [loc, loc, ...]
            const regionMap = {};
            selectedLocations.forEach(loc => {
              // loc might be "APAC.Default" or just "IN.HYD" or "LT.Vilnius".
              // derive region key as lowercased prefix before first dot, fallback to 'unknown'
              const parts = String(loc).split('.');
              const rKey = (parts[0] || '').toString().toLowerCase();
              regionMap[rKey] = regionMap[rKey] || [];
              regionMap[rKey].push(loc);
            });
            // for each region group add per-location requests
            Object.entries(regionMap).forEach(([rKey, locs]) => {
              // if rKey is not one of MULTI_REGIONS, treat these locations by calling without region
              const isKnown = MULTI_REGIONS.includes(rKey);
              if (isKnown) {
                locs.forEach(loc => pushReq(rKey, loc));
              } else {
                // unknown prefix: send requests without region but with the location param
                locs.forEach(loc => pushReq(undefined, loc));
              }
            });
          } else {
            // no specific locations -> call backend once per sub-region (broad request)
            MULTI_REGIONS.forEach(r => pushReq(r));
          }
        } else {
          // single region chosen
          if (selectedLocations && selectedLocations.length) {
            // user selected multiple locations within this region -> request per location
            selectedLocations.forEach(loc => pushReq(region, loc));
          } else {
            // no locations selected -> single call for the region (all partitions)
            pushReq(region);
          }
        }

        // perform requests in parallel (bounded by number of calls we generated)
        let rowsSrcCombined = [];
        try {
          // rate-limit: if no requests created (should not happen), make a single request for region
          if (!requests.length) {
            pushReq(region === 'global' ? MULTI_REGIONS[0] : region);
          }
          const responses = await Promise.all(requests);
          rowsSrcCombined = responses.flatMap(r => (r.data && (r.data.data || r.data)) || []);
        } catch (err) {
          console.error('raw fetch error', err);
          throw err; // handled by outer catch which shows message
        }

        // client-side date window filter — ensure row dates are inside selected date range
        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

        const rows = rowsSrcCombined.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          // defensive: if date is null, skip
          if (!date) return false;
          return (date >= startDate && date <= endDate);
        });

        // apply free-text search (rawSearch) if present
        let filtered = rows;
        if (rawSearch && rawSearch.trim() !== '') {
          const s = rawSearch.trim().toLowerCase();
          filtered = filtered.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            return id.includes(s) || name.includes(s);
          });
        }

        // apply selected employees filter (selectedRawEmps) if present
        if (selectedRawEmps && selectedRawEmps.length) {
          const setSel = new Set(selectedRawEmps.map(x => String(x).toLowerCase()));
          filtered = filtered.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            // support numeric or name matches
            return setSel.has(id) || setSel.has(name) || selectedRawEmps.some(sel => id.includes(String(sel).toLowerCase()) || name.includes(String(sel).toLowerCase()));
          });
        }

        // optional: remove duplicates (same LocaleMessageTime+EmployeeID+Door) to avoid duplicates from multi-requests
        const keySet = new Set();
        const deduped = [];
        filtered.forEach(r => {
          const key = `${getServerISO(r)}|${r.EmployeeID}|${r.Door}|${r.CardNumber}`;
          if (!keySet.has(key)) {
            keySet.add(key);
            deduped.push(r);
          }
        });

        await generateRawExcel(deduped, { region, location: selectedLocations && selectedLocations.join(',') || location, rawSearch, from, to, rawAdmitFilter });
        return;
      }










      // ----- 2: Rejection -----
      if (tab === 2) {
        const params = { ...baseParams, startDate: formatLocalDate(from), endDate: formatLocalDate(to, true) };
        const resp = await axios.get('/api/reports/rejection', { params });

        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

        const rowsSrc = (resp.data && resp.data.data) || [];
        const rows = rowsSrc.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          return date >= startDate && date <= endDate;
        });

        await generateRejectionExcel(rows);
        return;
      }

      // ----- 3: EUROC Admit-Reject (single day) -----
      if (tab === 3) {
        if (region.toLowerCase() !== 'emea') {
          alert('EUROC report is only available for region EMEA. Please select EMEA.');
          return;
        }
        if (!from) {
          alert('Please select a date (From) for EUROC report.');
          return;
        }

        const dateParam = toLocalYMD(new Date(from));
        const params = { region: 'emea', date: dateParam };
        const resp = await axios.get('/api/reports/euroc-admit-rejection', { params });
        const { data } = resp.data || {};

        const wb = new ExcelJS.Workbook();

        // Admit sheet
        const admitTitle = `EUROC Admit Report - ${formatDisplayDate(from)}`;
        const ws1 = wb.addWorksheet('EUROC Admit');
        ws1.mergeCells('A1:I1');
        ws1.getCell('A1').value = admitTitle;
        ws1.getCell('A1').font = { bold: true, size: 14 };
        ws1.getCell('A1').alignment = { horizontal: 'center' };

        const admitHeaders = [
          'Sr. No.', 'Date', 'Time', 'Employee Name',
          'Access Card No.', 'Personnel Type', 'Door Name', 'Location', 'Swipe'
        ];
        const hdrRow1 = ws1.addRow(admitHeaders);
        hdrRow1.font = { bold: true };
        hdrRow1.alignment = { vertical: 'middle', horizontal: 'center' };
        hdrRow1.eachCell(c => {
          c.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
        });

        ws1.columns = [
          { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
          { key:'name', width:30 }, { key:'card', width:15 }, { key:'ptype', width:20 },
          { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
        ];

        (data.admit || []).forEach((r, idx) => {
          let iso;
          if (r.LocaleMessageTime) {
            iso = r.LocaleMessageTime;
          } else if (r.DateOnly) {
            iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
          } else {
            iso = '';
          }

          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws1.addRow([
            idx + 1,
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.CardNumber || '',
            r.PersonnelType || '',
            r.Door || r.ObjectName2 || '',
            r.location || '',
            r.Direction || ''
          ]);

          row.getCell(2).alignment = { horizontal: 'left' };
          row.getCell(3).alignment = { horizontal: 'left' };
          row.eachCell(c => {
            c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        // Rejection sheet
        const ws2 = wb.addWorksheet('EUROC Rejection');
        ws2.mergeCells('A1:J1');
        ws2.getCell('A1').value = `EUROC Rejection Report - ${formatDisplayDate(from)}`;
        ws2.getCell('A1').font = { bold: true, size: 14 };
        ws2.getCell('A1').alignment = { horizontal: 'center' };

        const headerRow2 = ws2.addRow(['Sr. No.', 'Date', 'Time', 'Employee Name', 'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe']);
        headerRow2.font = { bold: true };
        headerRow2.alignment = { vertical: 'middle', horizontal: 'center' };
        headerRow2.eachCell(c => {
          c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });

        ws2.columns = [
          { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
          { key:'name', width:30 }, { key:'card', width:15 }, { key:'type', width:15 },
          { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
        ];

        (data.rejection || []).forEach((r, idx) => {
          let iso;
          if (r.LocaleMessageTime) {
            iso = r.LocaleMessageTime;
          } else if (r.DateOnly) {
            iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
          } else {
            iso = '';
          }

          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws2.addRow([
            idx + 1,
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.CardNumber || '',
            r.Rejection_Type || '',
            r.Door || '',
            r.location || '',
            r.Direction || ''
          ]);

          row.getCell(2).alignment = { horizontal: 'left' };
          row.getCell(3).alignment = { horizontal: 'left' };
          row.eachCell(c => {
            c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        // Summary block
        const counts = data.summary || [];
        let startRow = 3;
        ws2.getCell(startRow, 11).value = 'Rejection';
        ws2.getCell(startRow, 12).value = 'Count';
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.font = { bold: true };
          cell.alignment = { horizontal: 'center' };
          cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });
        startRow++;
        counts.forEach(c => {
          ws2.getCell(startRow, 11).value = c.Rejection_Type || 'Unknown';
          ws2.getCell(startRow, 12).value = c.Count || 0;
          [11, 12].forEach(col => {
            const cell = ws2.getCell(startRow, col);
            cell.alignment = { horizontal: 'left' };
            cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
          });
          startRow++;
        });
        ws2.getCell(startRow, 11).value = 'Grand Total';
        ws2.getCell(startRow, 12).value = (data.rejection || []).length;
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.font = { bold: true };
          cell.alignment = { horizontal: 'left' };
          cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });

        const buf = await wb.xlsx.writeBuffer();
        const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const filename = `EUROC_Admit_Rejection_${dateParam}.xlsx`;
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        return;
      }

      // ----- 4: Time Duration -----
      if (tab === 4) {
        if (!from || !to) {
          alert('Please select both Start Date and End Date for Time Duration report.');
          return;
        }
        const startParam = toLocalYMD(new Date(from));
        const endParam = toLocalYMD(new Date(to));
        const params = {
          region,
          startDate: startParam,
          endDate: endParam,
          partition: location ? location.split('.').pop() : 'Default'
        };
        const resp = await axios.get('/api/reports/time-duration', { params });
        await generateTimeDurationExcel(resp.data.data || []);
        return;
      }

      // ----- 5: HeadCount / External navigation -----
      if (tab === 5) {
        // final permission check (region specific)
        const permCandidates = [`headcount.${region}`, 'headcount', 'global_access'];
        if (!auth.hasPermission(permCandidates)) {
          alert(`You do not have permission to view HeadCount for ${region.toUpperCase()}.`);
          setLoading(false);
          return;
        }

        let url = '';

        if (region === 'laca') {
          if (!location) url = 'http://10.199.22.57:3003/history';
          else {
            const LACA_URLS = {
              'CR.Costa Rica Partition': 'http://10.199.22.57:3003/partition/CR.Costa%20Rica%20Partition/history',
              'MX.Mexico City': 'http://10.199.22.57:3003/partition/MX.Mexico%20City/history',
              'AR.Cordoba': 'http://10.199.22.57:3003/partition/AR.Cordoba/history',
              'PA.Panama City': 'http://10.199.22.57:3003/partition/PA.Panama%20City/history',
              'PE.Lima': 'http://10.199.22.57:3003/partition/PE.Lima/history',
              'BR.Sao Paulo': 'http://10.199.22.57:3003/partition/BR.Sao%20Paulo/history'
            };
            url = LACA_URLS[location] || 'http://10.199.22.57:3003/history';
          }
        } else if (region === 'namer') {
          if (!location) url = 'http://10.199.22.57:3002/history';
          else {
            const NAMER_URLS = {
              'US.Denver': 'http://10.199.22.57:3002/partition/US.CO.OBS/history',
              'US.Miami': 'http://10.199.22.57:3002/partition/US.FL.Miami/history',
              'US.NYC': 'http://10.199.22.57:3002/partition/US.NYC/history',
              'US.Austin': 'http://10.199.22.57:3002/partition/USA%2FCanada%20Default/history'
            };
            url = NAMER_URLS[location] || 'http://10.199.22.57:3002/history';
          }
        } else if (region === 'apac') {
          if (!location) url = 'http://10.199.22.57:3000/history';
          else {
            const APAC_URLS = {
              'APAC.Default': 'http://10.199.22.57:3000/partition/Pune/history',
              'IN.HYD':'http://10.199.22.57:3000/partition/IN.HYD/history',
              'MY.Kuala Lumpur': 'http://10.199.22.57:3000/partition/MY.Kuala Lumpur/history',
              'PH.Manila': 'http://10.199.22.57:3000/partition/PH.Manila/history',
              'JP.Tokyo': 'http://10.199.22.57:3000/history',
              'CN.Beijing': 'http://10.199.22.57:3000/history'
            };
            url = APAC_URLS[location] || 'http://10.199.22.57:3000/history';
          }
        } else if (region === 'emea') {
          if (!location) url = 'http://10.199.22.57:3001/history';
          else {
            const EMEA_URLS = {
              'AUT.Vienna': 'http://10.199.22.57:3001/history',
              'DU.Abu Dhabi': 'http://10.199.22.57:3001/history',
              'IE.Dublin': 'http://10.199.22.57:3001/history',
              'IT.Rome': 'http://10.199.22.57:3001/history',
              'LT.Vilnius': 'http://10.199.22.57:3001/history',
              'MA.Casablanca': 'http://10.199.22.57:3001/history',
              'RU.Moscow': 'http://10.199.22.57:3001/history',
              'UK.London': 'http://10.199.22.57:3001/history',
              'ES.Madrid': 'http://10.199.22.57:3001/history'
            };
            url = EMEA_URLS[location] || 'http://10.199.22.57:3001/history';
          }
        }

        if (url) window.location.href = url;
        else alert('Invalid region or location selected.');
        return;
      }




// ----- Denver Monthly Attendance (new tab index 6) -----
if (tab === 6) {
  // permission check already done above
  // Determine month/year to request:
  let useYear = null;
  let useMonth = null;
  if (from) {
    const d = new Date(from);
    useYear = d.getFullYear();
    useMonth = d.getMonth() + 1;
  } else {
    // default: request previous month relative to client local (backend also defaults)
    const dt = new Date();
    dt.setDate(1); dt.setHours(0,0,0,0);
    dt.setMonth(dt.getMonth() - 1);
    useYear = dt.getFullYear();
    useMonth = dt.getMonth() + 1;
  }

  try {
    setLoading(true);
    const resp = await axios.get('/api/reports/denver-attendance', {
      params: { year: useYear, month: useMonth },
      responseType: 'blob'
    });

    // Get filename from content-disposition if provided
    let filename = `denver_attendance_${useYear}${String(useMonth).padStart(2,'0')}.xlsx`;
    const cd = resp.headers['content-disposition'];
    if (cd) {
      const m = cd.match(/filename\*?=(?:UTF-8'')?["']?([^;"']+)/);
      if (m && m[1]) filename = decodeURIComponent(m[1]);
    }

    const blob = new Blob([resp.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const link = document.createElement('a');
    link.href = window.URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  } catch (err) {
    console.error('Denver attendance download error', err);
    let msg = 'Failed to download Denver attendance report';
    if (err?.response?.data) {
      msg += `: ${err.response?.data?.detail || err.message || JSON.stringify(err.response.data)}`;
    } else if (err?.message) {
      msg += `: ${err.message}`;
    }
    alert(msg);
  } finally {
    setLoading(false);
  }
  return;
}




} catch (err) {
      console.error('handleGenerate error:', err);
      // Show backend message when available (axios)
      let msg = 'Failed to generate report';
      if (err?.response?.data) {
        // backend may returned { error: "..." } or full HTML — try to extract
        const d = err.response.data;
        const serverMsg = (typeof d === 'string') ? d
                          : (d.error || d.message || JSON.stringify(d));
        msg += `: ${serverMsg}`;
      } else if (err?.message) {
        msg += `: ${err.message}`;
      }
      // small friendly alert for the UI
      alert(msg);
    } finally {
      setLoading(false);
    }
  };


  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
        {/* Topbar / Header */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            px: 3,
            py: 2,
            borderBottom: '1px solid rgba(255,204,0,0.08)',
            background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
          }}
        >
          <Avatar sx={{ bgcolor: '#000', border: '3px solid #FFCC00', width: 56, height: 56 }}>
            <Typography sx={{ color: '#FFCC00', fontWeight: 900 }}>WU</Typography>
          </Avatar>

          <Box sx={{ flex: 1 }}>
            <Typography variant="h5" sx={{ fontWeight: 900, letterSpacing: 0.6 }}>
              Global Security Operation Center
            </Typography>
            <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
              Reports & Exports — Secure access, fast insights
            </Typography>
          </Box>

          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
            <Button
              startIcon={<DownloadIcon />}
              onClick={handleGenerate}
              disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
              sx={{
                bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                color: '#000',
                fontWeight: 800,
                px: 3,
                py: 1,
                borderRadius: 3,
                boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
                transformOrigin: 'center',
                '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-2px)' : 'none' }
              }}
            >
              {loading ? 'Loading…'
                : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
            </Button>
          </Box>
        </Box>

        {/* Main content: Sidebar + Content */}
        <Grid container sx={{ px: 3, py: 4 }} spacing={3}>
          {/* Sidebar */}
          <Grid item xs={12} md={3}>
            <Paper
              elevation={8}
              sx={{
                p: 2.5,
                borderRadius: 3,
                height: { xs: 'auto', md: 'calc(100vh - 150px)' },
                overflow: 'auto',
                background: 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015))',
                border: '1px solid rgba(255,204,0,0.06)'
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
                <Box>
                  <Typography variant="subtitle1" sx={{ fontWeight: 800, color: '#FFCC00' }}>Filters</Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Narrow down by region, date and employees
                  </Typography>
                </Box>
                <IconButton size="small" sx={{ color: '#FFCC00' }}>
                  <FilterListIcon />
                </IconButton>
              </Box>

              <Divider sx={{ my: 1, borderColor: 'rgba(255,204,0,0.06)' }} />

              {/* Region */}
              <Box sx={{ mt: 1 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Region</InputLabel>
                  <Select
                    value={region}
                    onChange={e => { setRegion(e.target.value); setLocation(''); }}
                    input={<OutlinedInput label="Region" />}
                    sx={{
                      color: '#fff',
                      '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.24)' }
                    }}
                  >
                    {REGION_OPTIONS.map(r => <MenuItem key={r} value={r}>{r.toUpperCase()}</MenuItem>)}
                  </Select>
                </FormControl>
              </Box>



           
 <Box sx={{ mt: 2 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Location</InputLabel>

                  {/* If Raw tab, show multi-select Autocomplete populated from backend.
                      For other tabs, keep previous single-select behavior. */}
                  {tab === 1 ? (
                    <Autocomplete
                      multiple
                      freeSolo={false}
                      options={availableLocations}
                      value={selectedLocations}
                      onChange={(e, v) => setSelectedLocations(v)}
                      renderInput={(params) => (
                        <TextField
                          {...params}
                           //label="Location(s)"
                          placeholder="Choose 0..n locations (leave empty = all)"
                           InputLabelProps={{ style: { color: '#FFCC00' } }}
                          sx={{
                            '& .MuiInputBase-input': { color: '#fff' },
                            '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                          }}
                        />
                      )}
                      getOptionLabel={(opt) => String(opt)}
                      isOptionEqualToValue={(opt, val) => opt === val}
                      disabled={!region}
                    />
                  ) : (


                 


<Select
  value={location}
  onChange={e => setLocation(e.target.value)}
  input={<OutlinedInput label="Location" />}
  disabled={!region}
  sx={{
    color: '#fff',
    '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
  }}
>
  {(
    (availableLocations && availableLocations.length) 
      ? availableLocations 
      : (LOCATION_MAP[region] || [])
  ).map(loc => (
    <MenuItem key={loc} value={loc}>
      {String(loc).split('.').pop()}
    </MenuItem>
  ))}
</Select>
            
                  )}
                </FormControl>
              </Box>





              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />


  {tab === 1 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employee (name or ID) — multiple
                  </Typography>

{tab === 6 && (
  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)', mt: 1 }}>
    Denver Monthly report: pick any date inside the month you want (or leave empty to export previous month).
  </Typography>
)}


                  <Autocomplete
                    multiple
                    freeSolo
                    filterSelectedOptions
                    options={rawEmpOptions}
                    value={selectedRawEmps}
                    onChange={(e, v) => setSelectedRawEmps(v)}

onInputChange={async (e, value, reason) => {
  if (empQueryRef.current) clearTimeout(empQueryRef.current);

  // only query for 2+ chars
  if (!value || value.length < 2) {
    empQueryRef.current = setTimeout(() => setRawEmpOptions([]), 150);
    return;
  }

  empQueryRef.current = setTimeout(async () => {
    try {
      // pass region so backend can search right DB; if region === 'global' send nothing (server can choose default)
      const params = { q: value };
      if (region && region !== 'global') params.region = region;

      const resp = await axios.get('/api/employees', { params });

      // resp.data.data || resp.data may be:
      //  - array of strings like ["W00246", "W00247"]
      //  - array of objects like [{ EmployeeID: "W00246", Name: "Lloyd, John" }, ...]
      const raw = (resp.data && (resp.data.data || resp.data)) || [];

      const normalized = Array.isArray(raw) ? raw.map(item => {
        if (typeof item === 'string') return item;
        // object shape normalization
        const id = item.EmployeeID || item.id || item.NumericEmployeeID || item.Employee || '';
        const name = item.Name || item.name || item.ObjectName1 || '';
        if (name && id) return `${name} (${id})`;
        if (id) return String(id);
        if (name) return String(name);
        // fallback stringify small object to avoid empty option
        return JSON.stringify(item);
      }) : [];

      setRawEmpOptions(Array.from(new Set(normalized)));
    } catch (err) {
      console.warn('employee suggestions error', err);
      setRawEmpOptions([]);
    }
  }, 300); // 300ms debounce
}}



                    renderInput={(params) => (
                      <TextField
                        {...params}
                        placeholder="Type name or ID (2+ chars) — select multiple"
                        InputLabelProps={{ style: { color: '#FFCC00' } }}
                        sx={{
                          '& .MuiInputBase-input': { color: '#fff' },
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                        }}
                      />
                    )}
                    // renderOption={(props, option) => <li {...props}>{String(option)}</li>}
                    // getOptionLabel={(opt) => String(opt)}

getOptionLabel={(opt) => (typeof opt === 'string' ? opt : (opt.label || opt.name || String(opt)))}
renderOption={(props, option) => <li {...props}>{typeof option === 'string' ? option : (option.label || option.name || String(option))}</li>}




                    ListboxProps={{ style: { maxHeight: 240 } }}
                  />

                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                    Leave empty to export all raw rows for the date range. Type 2+ chars to get suggestions for employee names or IDs.
                  </Typography>

                  <Box sx={{ mt: 2 }}>
                    <FormControl fullWidth>
                      <InputLabel sx={{ color: '#FFCC00' }}>Admit / Reject</InputLabel>
                      <Select
                        value={rawAdmitFilter}
                        onChange={(e) => setRawAdmitFilter(e.target.value)}
                        input={<OutlinedInput label="Admit / Reject" />}
                        sx={{
                          color: '#fff',
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                        }}
                      >
                        <MenuItem value="all">All (Admitted + Rejected)</MenuItem>
                        <MenuItem value="admit">Admitted only</MenuItem>
                        <MenuItem value="reject">Rejected only</MenuItem>
                      </Select>
                    </FormControl>
                    <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                      Default = All.
                    </Typography>
                  </Box>
                </Box>
              )}




              {/* Dates */}
              {tab !== 5 && (
                <Box>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Date Range
                  </Typography>
                  <Box sx={{ display: 'grid', gap: 1.25 }}>
                    <TextField
                      label={tab === 0 ? 'From Date' : 'Start Date'}
                      value={from ? from.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowFromCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                    <TextField
                      label={tab === 0 ? 'To Date' : 'End Date'}
                      value={to ? to.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowToCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                  </Box>

                  {showFromCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={from}
                        onChange={(newValue) => setFrom(newValue)}
                        onAccept={() => setShowFromCal(false)}
                        onClose={() => setShowFromCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                  {showToCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={to}
                        onChange={(newValue) => setTo(newValue)}
                        onAccept={() => setShowToCal(false)}
                        onClose={() => setShowToCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                </Box>
              )}

{tab === 0 && (
  <Box>
    <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
      Employees
    </Typography>

    {/* Add employee by name or ID */}
    <Box sx={{ display: 'flex', gap: 1, mb: 1 }}>
      <TextField
        fullWidth
        placeholder="Add name or ID (e.g. 'Vainilaitis, Valdas' or '323471')"
        value={newEmployee}
        onChange={(e) => setNewEmployee(e.target.value)}
        sx={{
          '& .MuiInputBase-input': { color: '#fff' },
          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
        }}
        InputLabelProps={{ style: { color: '#FFCC00' } }}
      />
      <Button
        variant="contained"
        onClick={() => {
          const v = (newEmployee || '').toString().trim();
          if (!v) return;
          if (!selectedEmps.includes(v)) {
            setSelectedEmps(prev => [...prev, v]);
          }
          setNewEmployee('');
        }}
        sx={{
          bgcolor: '#FFCC00',
          color: '#000',
          fontWeight: 800,
          px: 2,
          '&:hover': { bgcolor: '#ffd84d' }
        }}
      >
        Add
      </Button>
    </Box>

    <FormControl fullWidth>
      <InputLabel sx={{ color: '#FFCC00' }}>Employees</InputLabel>

      <Select
        multiple
        value={selectedEmps}
        onChange={e => setSelectedEmps(e.target.value)}
        input={<OutlinedInput label="Employees" />}
        renderValue={vals => vals.join(', ')}
        sx={{
          color: '#fff',
          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
        }}
      >
        {[
          ...EMPLOYEE_OPTIONS,
          ...selectedEmps.filter(s => !EMPLOYEE_OPTIONS.includes(s))
        ].map(n => (
          <MenuItem key={n} value={n}>
            <Checkbox checked={selectedEmps.includes(n)} />
            <ListItemText primary={n} />
          </MenuItem>
        ))}
      </Select>
    </FormControl>
  </Box>
)}

              <Box sx={{ mt: 3, p: 2, borderRadius: 2, background: 'rgba(255,255,255,0.02)' }}>
                <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                  Tip: For daily exports pick employees & a single day range. For Time Duration choose the required partition via Location.
                </Typography>
              </Box>
            </Paper>
          </Grid>

          {/* Main panel */}
          <Grid item xs={12} md={9}>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              <Paper
                elevation={3}
                sx={{
                  px: 2,
                  py: 1,
                  borderRadius: 2,
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  gap: 2,
                  border: '1px solid rgba(255,204,0,0.04)'
                }}
              >
                <Tabs
                  value={tab}
                  onChange={handleTabChange}
                  sx={{
                    '& .MuiTab-root': {
                      textTransform: 'none',
                      minWidth: 120,
                      fontWeight: 700,
                      color: 'rgba(255,255,255,0.8)'
                    },
                    '& .Mui-selected': { color: '#FFCC00' }
                  }}
                >
                  <Tab icon={<CalendarTodayIcon />} label="Daily Access" />
                  <Tab icon={<PeopleIcon />} label="Raw" />
                  <Tab icon={<PlaceIcon />} label="Rejection" />
                  <Tab icon={<PeopleIcon />} label="EUROC Admit-Reject" />
                  <Tab icon={<CalendarTodayIcon />} label="Time Duration" />
                  <Tab icon={<PeopleIcon />} label="HeadCount" />
                  <Tab icon={<PeopleIcon />} label="Denver Monthly" />

                </Tabs>

                <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                  <Button
                    variant="text"
                    startIcon={<FilterListIcon />}
                    sx={{ color: 'rgba(255,255,255,0.65)', textTransform: 'none' }}
                    onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}
                  >
                    Reset View
                  </Button>
                </Box>
              </Paper>

              <Paper elevation={6} sx={{ p: 3, borderRadius: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 2 }}>
                <Box>
                  <Typography variant="h6" sx={{ fontWeight: 900 }}>Export Center</Typography>
                  <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                    Selected Region: <strong style={{ color: '#FFCC00' }}>{region.toUpperCase()}</strong> {location ? `• ${location.split('.').pop()}` : ''}
                  </Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Choose tab, select filters and export reports in Excel.
                  </Typography>
                </Box>

                <Box>
                  <Button
                    startIcon={loading ? <CircularProgress size={20} /> : <DownloadIcon />}
                    disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
                    onClick={handleGenerate}
                    sx={{
                      bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                      color: '#000',
                      fontWeight: 900,
                      px: 4,
                      py: 1,
                      borderRadius: 3,
                      boxShadow: '0 8px 30px rgba(255,204,0,0.22)',
                      '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-3px)' : 'none' }
                    }}
                  >
                    {loading
                      ? 'Loading…'
                      : (tab === 5
                          ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`)
                          : 'Export to Excel')}
                  </Button>
                </Box>
              </Paper>

            </Box>
          </Grid>

        </Grid>
      </Box>
    </LocalizationProvider>
  );
}












