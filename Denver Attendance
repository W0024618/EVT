// C:\Users\W0024618\Desktop\global-page\frontend\src\pages\ReportsPage.jsx
import React, { useState, useEffect, useRef } from 'react';
import {
  Box, FormControl, InputLabel, Select, OutlinedInput,
  Checkbox, ListItemText, MenuItem, Button,
  CircularProgress, Typography, TextField, Tabs, Tab, Grid, Paper, IconButton, Divider, Autocomplete
} from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import axios from 'axios';
import ExcelJS from 'exceljs';
import * as XLSX from 'xlsx';
import { useAuth } from '../context/AuthContext';

import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import PlaceIcon from '@mui/icons-material/Place';
import PeopleIcon from '@mui/icons-material/People';
import DownloadIcon from '@mui/icons-material/CloudDownload';
import FilterListIcon from '@mui/icons-material/FilterList';
import Avatar from '@mui/material/Avatar';
import { generateDailyAccessExcelFromRows } from './DailyAccessReport';

// Static lists
const EMPLOYEE_OPTIONS = [
  'Vainilaitis, Valdas',
  'Tomasevic, Kazimez',
  'Sesickis, Janas',
  'Valiunas, Sigitas',
  'JANCUKOVIC, VACLAVA',
  'Kalpokiene, Alina',
  'Korkus, Vanda',
  'Kvaraciejiene, Maryte',
  'ZNAMEROVSKIS, DARIUS'
];

const REGION_OPTIONS = ['global', 'apac', 'emea', 'laca', 'namer'];
const LOCATION_MAP = {
  apac: ['APAC.Default', 'JP.Tokyo', 'PH.Manila', 'MY.Kuala Lumpur','IN.HYD'],
  emea: ['AUT.Vienna', 'DU.Abu Dhab', 'IE.Dublin', 'IT.Rome', 'LT.Vilnius', 'MA.Casablanca', 'RU.Moscow', 'UK.London', 'ES.Madrid'],
  laca: ['AR.Cordoba', 'CR.Costa Rica Partition', 'MX.Mexico City', 'PE.Lima', 'BR.Sao Paulo', 'PA.Panama City'],
  namer: ['US.NYC', 'US.FL.Miami', 'USA/Canada Default', 'US.CO.OBS','US.Denver'],
  global: []
};

function formatDisplayDate(date) {
  if (!date) return '';
  const d = new Date(date);
  const day = d.getDate();
  const suf = day % 10 === 1 && day !== 11 ? 'st'
    : day % 10 === 2 && day !== 12 ? 'nd'
      : day % 10 === 3 && day !== 13 ? 'rd' : 'th';
  const mon = d.toLocaleString('default', { month: 'long' });
  return `${day}${suf} ${mon} ${d.getFullYear()}`;
}

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');

// --- Helper functions (unchanged from your original) ---
function _extractServerDateTimeParts(iso) {
  if (!iso) return null;
  const s = String(iso);
  let datePart = '', timePart = '';
  if (s.includes('T')) {
    [datePart, timePart] = s.split('T');
  } else if (s.includes(' ')) {
    [datePart, timePart] = s.split(' ');
  } else {
    return null;
  }
  datePart = datePart.slice(0, 10);
  timePart = (timePart || '').replace(/Z|[+-]\d{2}:\d{2}$/, '').replace(/\.\d+$/, '');
  const dParts = datePart.split('-').map(p => parseInt(p, 10));
  const tParts = timePart.split(':').map(p => parseInt(p || '0', 10));
  return {
    year: dParts[0] || 0,
    month: dParts[1] || 0,
    day: dParts[2] || 0,
    hour: tParts[0] || 0,
    minute: tParts[1] || 0,
    second: tParts[2] || 0
  };
}

function formatDateFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  const y = dt.getUTCFullYear();
  const m = dt.getUTCMonth(); // 0..11
  const d = dt.getUTCDate();
  const yrShort = String(y).slice(-2);
  return `${pad2(d)}-${MONTH_ABBR[m]}-${yrShort}`;         // e.g. "12-Aug-25"
}

function formatTimeFromServerISO(iso) {
  if (!iso) return '';
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const hh = p.hour;
  const mm = p.minute || 0;
  const ss = p.second || 0;
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1;
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
}

function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10);
  if (!swipeIso) {
    return `${datePart}T00:00:00.000`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000`;
  }
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000`;
}

const getServerISO = (r) => {
  if (!r) return '';
  if (r.LocaleMessageTime) return r.LocaleMessageTime;
  if (r.DateOnly) return buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  return '';
};

const getServerYMD = (r) => {
  const iso = getServerISO(r);
  if (!iso) return '';
  return iso.slice(0, 10);
};

const isoDateOnlyToLocalDate = (iso) => {
  if (!iso) return null;
  const s = iso.toString().slice(0, 10);
  const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
  return new Date(y, m - 1, d);
};

const buildLocalDateFromDateOnlyAndSwipe = (dateOnly, swipeTime) => {
  if (!dateOnly) return null;
  const dateStr = dateOnly.toString().slice(0, 10);
  const [yy, mm, dd] = dateStr.split('-').map(n => parseInt(n, 10));

  let hh = 0, min = 0, ss = 0;
  if (swipeTime) {
    const parsed = new Date(swipeTime);
    if (!isNaN(parsed.getTime())) {
      hh = parsed.getUTCHours();
      min = parsed.getUTCMinutes();
      ss = parsed.getUTCSeconds();
    } else {
      const parts = swipeTime.split(':').map(p => parseInt(p, 10));
      if (parts.length >= 2) {
        hh = parts[0] || 0;
        min = parts[1] || 0;
        ss = parts[2] || 0;
      }
    }
  }
  return new Date(yy, mm - 1, dd, hh, min, ss);
};

export default function ReportsPage() {
  const auth = useAuth();

  // --- state ---
  const [tab, setTab] = useState(0);

  // default region now set to 'emea' for initial tab 0 behavior
  const [region, setRegion] = useState('emea');
  const [location, setLocation] = useState('LT.Vilnius');
  const [from, setFrom] = useState(null);
  const [to, setTo] = useState(null);
  const [showFromCal, setShowFromCal] = useState(false);
  const [showToCal, setShowToCal] = useState(false);
  const [selectedEmps, setSelectedEmps] = useState([]);
  const [loading, setLoading] = useState(false);
  const [generatingMessage, setGeneratingMessage] = useState('');

  const [rawSearch, setRawSearch] = useState('');
  const [rawAdmitFilter, setRawAdmitFilter] = useState('all');
  const [newEmployee, setNewEmployee] = useState('');

  const [availableLocations, setAvailableLocations] = useState([]);
  const [selectedLocations, setSelectedLocations] = useState([]);
  const [rawEmpOptions, setRawEmpOptions] = useState([]);
  const [selectedRawEmps, setSelectedRawEmps] = useState([]);
  const empQueryRef = useRef(null);

  // Provide region options depending on tab
  const regionOptionsForTab = () => {
    if (tab === 0) return ['emea'];            // Daily Access -> only EMEA
    if (tab === 3) return ['emea'];            // EUROC -> only EMEA
    if (tab === 4) return ['apac'];            // Time Duration -> only APAC
    if (tab === 6) return ['namer'];           // Denver -> NAMER
    return REGION_OPTIONS;                     // default (Raw, Rejection, HeadCount, etc.)
  };

  // Provide location options depending on tab & region
  const locationOptionsForTab = (r) => {
    const rr = r || region;
    if (tab === 0) return ['LT.Vilnius']; // Daily Access -> only Vilnius
    if (tab === 6) return ['US.Denver']; // Denver -> Denver only
    if (tab === 3) {
      // EUROC -> show full EMEA location list (allow multi-selection)
      return availableLocations.length ? availableLocations : (LOCATION_MAP['emea'] || []);
    }
    if (tab === 4) {
      // Time Duration -> show APAC location list strictly
      return availableLocations.length ? availableLocations : (LOCATION_MAP['apac'] || []);
    }
    if (tab === 1) {
      return availableLocations.length ? availableLocations : (LOCATION_MAP[rr] || []);
    }
    // default
    return availableLocations.length ? availableLocations : (LOCATION_MAP[rr] || []);
  };

  // fetch availableLocations for the currently selected region (runs on region change)
  useEffect(() => {
    let mounted = true;
    const load = async () => {
      setAvailableLocations([]);
      if (!region) return;
      const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];

      try {
        if (region === 'global') {
          const promises = MULTI_REGIONS.map(r => fetchLocationsForRegion(r));
          const results = await Promise.all(promises);
          const merged = results.flat();
          if (!mounted) return;
          setAvailableLocations(Array.from(new Set(merged)).sort());
        } else {
          const list = await fetchLocationsForRegion(region);
          if (!mounted) return;
          setAvailableLocations(Array.from(new Set(list)).sort());
        }
      } catch (err) {
        console.error('load locations error', err);
        // fallback to static map
        const key = (region || '').toLowerCase();
        setAvailableLocations((LOCATION_MAP[key] || []).slice());
      }
    };

    // always attempt to fetch when region is set (EUROC & Time Duration need real lists)
    if (region) {
      load();
    } else {
      setAvailableLocations([]);
    }

    return () => { mounted = false; };
  }, [region, tab]);

  // Helper: fetch locations for a single region key (backend endpoint: GET /api/locations?region=apac)
  const fetchLocationsForRegion = async (r) => {
    try {
      if (!r) return [];
      const resp = await axios.get('/api/locations', { params: { region: r } });
      const listRaw = (resp.data && (resp.data.data || resp.data)) || [];
      const list = Array.isArray(listRaw)
        ? listRaw.map(item => {
            if (typeof item === 'string') return item;
            return item.PartitionName2 || item.partition || item.location || item.name || (item.label ? item.label : null);
          }).filter(Boolean)
        : [];
      if (!list.length) {
        const key = (r || '').toLowerCase();
        return (LOCATION_MAP[key] || []).slice();
      }
      return Array.from(new Set(list)).sort();
    } catch (e) {
      console.warn('fetchLocationsForRegion error', r, e);
      const key = (r || '').toLowerCase();
      return (LOCATION_MAP[key] || []).slice();
    }
  };

  // Handle tab switch (Daily / Raw / Rejection / etc.)
  const handleTabChange = (_, v) => {
    setTab(v);

    // Reset shared filters
    setFrom(null);
    setTo(null);
    setSelectedEmps([]);
    setRawSearch('');
    setRawAdmitFilter('all');
    setSelectedLocations([]);
    setSelectedRawEmps([]);
    setNewEmployee('');
    setRawEmpOptions([]);
    setGeneratingMessage('');

    // Default region/location per tab (as requested)
    if (v === 0) {         // Daily Access -> EMEA + Vilnius
      setRegion('emea');
      setLocation('LT.Vilnius');
    } else if (v === 1) {  // Raw -> keep default region (emea) but let user change
      setRegion('emea');
      setLocation('');
    } else if (v === 2) {  // Rejection -> default emea
      setRegion('emea');
      setLocation('');
    } else if (v === 3) {  // EUROC -> EMEA only, allow multi locations
      setRegion('emea');
      setLocation(''); // user chooses 0..n locations (none => all)
    } else if (v === 4) {  // Time Duration -> APAC only
      setRegion('apac');
      setLocation('');
    } else if (v === 5) {  // HeadCount -> default emea
      setRegion('emea');
      setLocation('');
    } else if (v === 6) {  // Denver -> NAMER + Denver
      setRegion('namer');
      setLocation('US.Denver');
    }
  };

  /** Time Duration Excel generator (keep your original implementation) */
  const generateTimeDurationExcel = async data => {
    // --- keep original implementation ---
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Time Duration');

    ws.mergeCells('A1:M1');
    ws.getCell('A1').value =
      `${region.toUpperCase()} Time Duration Report - ${formatDisplayDate(from)} to ${formatDisplayDate(to)}`;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };

    const headers = [
      'Sr. No.', 'Employee Name', 'Employee ID', 'Personnel Type',
      'Partition', 'Text5', 'Year', 'Week', 'Date',
      'First Swipe', 'Last Swipe', 'Duration', 'Category',
      'Days Present', 'Violation Days', 'Clean Days', 'Defaulter'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { horizontal: 'center', vertical: 'middle' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'ptype', width: 18 },
      { key: 'part', width: 15 },
      { key: 'txt5', width: 20 },
      { key: 'year', width: 8 },
      { key: 'week', width: 6 },
      { key: 'date', width: 12 },
      { key: 'first', width: 16 },
      { key: 'last', width: 16 },
      { key: 'dur', width: 10 },
      { key: 'cat', width: 12 },
      { key: 'dpw', width: 12 },
      { key: 'vdw', width: 14 },
      { key: 'cdw', width: 12 },
      { key: 'def', width: 10 }
    ];

    data.forEach((r, idx) => {
      const first = new Date(r.FirstSwipeTime);
      const last = new Date(r.LastSwipeTime);
      const date = new Date(r.ShiftedDate);
      const row = ws.addRow([
        idx + 1,
        r.ObjectName1,
        r.EmployeeID,
        r.PersonnelType,
        r.PartitionName2,
        r.text5,
        r.YearNumber,
        r.WeekNumber,
        date,
        first,
        last,
        r.DurationHHMM,
        r.TimeDiffCategory,
        r.DaysPresentInWeek,
        r.ViolationDaysInWeek,
        r.CleanDaysInWeek,
        r.Defaulter
      ]);

      row.getCell(9).numFmt = 'dd-mmm-yy';
      row.getCell(10).numFmt = 'h:mm:ss AM/PM';
      row.getCell(11).numFmt = 'h:mm:ss AM/PM';

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    ws.autoFilter = 'A2:Q2';

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    const filename =
      `TimeDuration_${region.toUpperCase()}_${formatDisplayDate(from)}_to_${formatDisplayDate(to)}.xlsx`;

    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  const generateRejectionExcel = async data => {
    // keep original rejection generator
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Rejection');

    const title = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}`;
    ws.mergeCells('A1:J1');
    ws.getCell('A1').value = title;
    ws.getCell('A1').font = { bold: true, size: 14 };
    ws.getCell('A1').alignment = { horizontal: 'center' };

    const headers = [
      'Sr. No.', 'Date', 'Time', 'Employee Name', 'Employee ID',
      'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe'
    ];
    const headerRow = ws.addRow(headers);
    headerRow.font = { bold: true };
    headerRow.alignment = { vertical: 'middle', horizontal: 'center' };
    headerRow.eachCell(c => {
      c.border = {
        top: { style: 'thin' }, left: { style: 'thin' },
        bottom: { style: 'thin' }, right: { style: 'thin' }
      };
    });

    ws.columns = [
      { key: 'sr', width: 8 },
      { key: 'date', width: 12 },
      { key: 'time', width: 12 },
      { key: 'name', width: 25 },
      { key: 'id', width: 15 },
      { key: 'card', width: 15 },
      { key: 'type', width: 15 },
      { key: 'door', width: 40 },
      { key: 'loc', width: 15 },
      { key: 'swipe', width: 10 }
    ];

    data.forEach((r, idx) => {
      const iso = getServerISO(r);
      const dateStr = iso ? formatDateFromServerISO(iso) : '';
      const timeStr = iso ? formatTimeFromServerISO(iso) : '';

      const row = ws.addRow([
        idx + 1,
        dateStr,
        timeStr,
        r.ObjectName1 || '',
        r.EmployeeID || '',
        r.CardNumber || '',
        r.Rejection_Type || '',
        r.Door || r.ObjectName2 || '',
        r.location || '',
        r.Direction || r.Swipe || ''
      ]);

      row.getCell(2).alignment = { horizontal: 'left' };
      row.getCell(3).alignment = { horizontal: 'left' };

      row.eachCell(c => {
        c.border = {
          top: { style: 'thin' }, left: { style: 'thin' },
          bottom: { style: 'thin' }, right: { style: 'thin' }
        };
        c.alignment = { vertical: 'middle', horizontal: 'left' };
      });
    });

    const buf = await wb.xlsx.writeBuffer();
    const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const filename = `${region.toUpperCase()} Rejection Report - ${formatDisplayDate(from)}.xlsx`;
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
  };

  function buildRawFileName(opts = {}) {
    const safe = s => (s === undefined || s === null) ? '' : String(s).replace(/[\/\\:?<>|"]/g, '_').trim();
    const regionPart = opts.region ? safe(opts.region).toUpperCase() : 'RAW';
    const locationPart = opts.location ? `_${safe(opts.location).replace('.', '_')}` : '';
    const admitPart = opts.rawAdmitFilter ? `_${safe(opts.rawAdmitFilter)}` : '';
    const searchPart = opts.rawSearch ? `_${safe(opts.rawSearch).replace(/\s+/g, '_')}` : '';
    const formatDateForName = d => {
      if (!d) return '';
      try {
        if (d instanceof Date) return `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}`;
        const dt = new Date(d);
        if (!isNaN(dt.getTime())) return `${dt.getFullYear()}${pad2(dt.getMonth()+1)}${pad2(dt.getDate())}`;
      } catch (e) { /* ignore */ }
      return safe(d).slice(0,10).replace(/[-\s:]/g,'');
    };

    const fromPart = opts.from ? `_from_${formatDateForName(opts.from)}` : '';
    const toPart   = opts.to   ? `_to_${formatDateForName(opts.to)}` : '';
    const filename = `Raw_${regionPart}${locationPart}${fromPart}${toPart}${admitPart}${searchPart}.xlsx`;
    return filename;
  }

  const generateRawExcel = async (rows, opts = {}) => {
    // keep original raw excel generator implementation
    const formatTimeFromSwipe = (swipeIso) => {
      if (!swipeIso) return '';
      const dt = new Date(swipeIso);
      if (!isNaN(dt.getTime())) {
        return formatTimeFromServerISO(swipeIso);
      }
      const parts = ('' + swipeIso).split(':').map(p => parseInt(p || 0, 10));
      const hh = parts[0] || 0;
      const mm = parts[1] || 0;
      const ss = parts[2] || 0;
      const ampm = hh >= 12 ? 'PM' : 'AM';
      const hh12 = ((hh + 11) % 12) + 1;
      return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
    };

    const admitFilter = (opts.rawAdmitFilter || 'all').toString().toLowerCase();

    const baseHeaders = ['LocaleMessageTime','DateOnly','Swipe_Time','EmployeeID','ObjectName1','PersonnelType','location','CardNumber'];
    const admitCol = 'AdmitCode';
    const rejCol = 'Rejection_Type';
    const tailCols = ['Direction','Door'];

    let headers = [...baseHeaders];
    if (admitFilter === 'all') {
      headers.push(admitCol);
      headers.push(...tailCols);
      headers.push(rejCol);
    } else if (admitFilter === 'admit') {
      headers.push(admitCol);
      headers.push(...tailCols);
    } else if (admitFilter === 'reject') {
      headers.push(...tailCols);
      headers.push(rejCol);
    } else {
      headers.push(admitCol);
      headers.push(...tailCols);
      headers.push(rejCol);
    }

    if (!rows || !rows.length) {
      const wbEmpty = XLSX.utils.book_new();
      const wsEmpty = XLSX.utils.aoa_to_sheet([headers]);
      XLSX.utils.book_append_sheet(wbEmpty, wsEmpty, 'Raw');
      const fileNameEmpty = buildRawFileName(opts);
      XLSX.writeFile(wbEmpty, fileNameEmpty);
      return;
    }

    const rowsForSheet = rows.map(r => {
      const iso = getServerISO(r);
      const dateStr = iso ? formatDateFromServerISO(iso) : '';
      const timeStr = iso ? formatTimeFromServerISO(iso) : '';
      const localeMsgFormatted = iso ? `${dateStr} ${timeStr}` : (r.LocaleMessageTime || '');
      const dateOnlyFormatted = r.DateOnly ? formatDateFromServerISO(r.DateOnly) : '';
      const swipeTimeFormatted = r.Swipe_Time ? formatTimeFromSwipe(r.Swipe_Time) : '';

      const fullObj = {
        LocaleMessageTime: localeMsgFormatted,
        DateOnly: dateOnlyFormatted,
        Swipe_Time: swipeTimeFormatted,
        EmployeeID: r.EmployeeID || '',
        ObjectName1: r.ObjectName1 || '',
        PersonnelType: r.PersonnelType || '',
        location: r.location || '',
        CardNumber: r.CardNumber || '',
        AdmitCode: r.AdmitCode || r.Messagetype || '',
        Direction: r.Direction || r.Swipe || '',
        Door: r.Door || r.ObjectName2 || '',
        Rejection_Type: r.Rejection_Type || ''
      };

      const picked = {};
      headers.forEach(h => {
        picked[h] = (fullObj[h] !== undefined && fullObj[h] !== null) ? fullObj[h] : '';
      });
      return picked;
    });

    const ws = XLSX.utils.json_to_sheet(rowsForSheet, { header: headers });
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Raw');

    const filename = buildRawFileName(opts);
    XLSX.writeFile(wb, filename);
  };

  const exportPermsForTab = () => {
    if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
    if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
    if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
    if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
    if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
    if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
    if (tab === 6) return ['gsoc_reports.denver_monthly', 'gsoc_reports'];
    return ['gsoc_reports'];
  };

  const disabled = loading
    || (tab !== 6 && !region)
    || (tab === 0 && (!from || !to || selectedEmps.length === 0))
    || (tab === 1 && (!from || !to))
    || (tab === 2 && (!from || !to))
    || (tab === 3 && !from)
    || (tab === 4 && (!from || !to));

  const navDisabled = (tab !== 6 && !region) || loading;
  const exportAllowed = auth.hasPermission(exportPermsForTab());

  // Format helpers used in handleGenerate (copied from your file)
  const formatLocalDate = (date, endOfDay = false) => {
    const d = new Date(date);
    if (endOfDay) d.setHours(23, 59, 59, 999);
    else d.setHours(0, 0, 0, 0);
    const pad = n => n.toString().padStart(2, '0');
    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}` +
           `T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  };

  const toLocalYMD = date => `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`;

  const handleGenerate = async () => {
    const requirePermissionForTab = () => {
      if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
      if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
      if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
      if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
      if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
      if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
      if (tab === 6) return ['gsoc_reports.denver_monthly', 'gsoc_reports'];
      return ['gsoc_reports'];
    };

    if (!auth.hasPermission(requirePermissionForTab())) {
      alert('You do not have permission to generate this report.');
      return;
    }

    // set user-visible generating message (different per tab)
    const messages = {
      0: 'Generating Daily Access report...',
      1: 'Generating Raw report...',
      2: 'Generating Rejection report...',
      3: 'Generating EUROC Admit-Reject report...',
      4: 'Generating Time Duration report...',
      5: 'Opening HeadCount...',
      6: 'Generating Denver Attendance report...'
    };
    setGeneratingMessage(messages[tab] || 'Generating report...');
    setLoading(true);

    try {
      const baseParams = { region, location: location || undefined };

      // ----- 0: Daily Access -----
      if (tab === 0) {
        const fromDateOnly = `${from.getFullYear()}-${pad2(from.getMonth() + 1)}-${pad2(from.getDate())}`;
        const toDateOnly = `${to.getFullYear()}-${pad2(to.getMonth() + 1)}-${pad2(to.getDate())}`;

        const params = {
          ...baseParams,
          from: fromDateOnly,
          to: toDateOnly,
          employees: selectedEmps.join(',')
        };
        const resp = await axios.get('/api/reports/daily-access', { params });
        const rows = (resp.data && resp.data.data) || [];
        await generateDailyAccessExcelFromRows(rows, { from: fromDateOnly, to: toDateOnly, selectedEmps, region });
        return;
      }

      // ----- 1: Raw -----
      if (tab === 1) {
        const startISO = formatLocalDate(from);
        const endISO = formatLocalDate(to, true);
        const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];
        const requests = [];
        const pushReq = (r, locationParam = undefined) => {
          const params = { startDate: startISO, endDate: endISO, admitFilter: rawAdmitFilter };
          if (r) params.region = r;
          if (locationParam) params.location = locationParam;
          requests.push(axios.get('/api/reports/raw', { params }));
        };

        if (region === 'global') {
          if (selectedLocations && selectedLocations.length) {
            const regionMap = {};
            selectedLocations.forEach(loc => {
              const parts = String(loc).split('.');
              const rKey = (parts[0] || '').toString().toLowerCase();
              regionMap[rKey] = regionMap[rKey] || [];
              regionMap[rKey].push(loc);
            });
            Object.entries(regionMap).forEach(([rKey, locs]) => {
              const isKnown = MULTI_REGIONS.includes(rKey);
              if (isKnown) {
                locs.forEach(loc => pushReq(rKey, loc));
              } else {
                locs.forEach(loc => pushReq(undefined, loc));
              }
            });
          } else {
            MULTI_REGIONS.forEach(r => pushReq(r));
          }
        } else {
          if (selectedLocations && selectedLocations.length) {
            selectedLocations.forEach(loc => pushReq(region, loc));
          } else {
            pushReq(region);
          }
        }

        let rowsSrcCombined = [];
        try {
          if (!requests.length) {
            pushReq(region === 'global' ? MULTI_REGIONS[0] : region);
          }
          const responses = await Promise.all(requests);
          rowsSrcCombined = responses.flatMap(r => (r.data && (r.data.data || r.data)) || []);
        } catch (err) {
          console.error('raw fetch error', err);
          throw err;
        }

        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

        const rows = rowsSrcCombined.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          if (!date) return false;
          return (date >= startDate && date <= endDate);
        });

        let filtered = rows;
        if (rawSearch && rawSearch.trim() !== '') {
          const s = rawSearch.trim().toLowerCase();
          filtered = filtered.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            return id.includes(s) || name.includes(s);
          });
        }

        if (selectedRawEmps && selectedRawEmps.length) {
          const setSel = new Set(selectedRawEmps.map(x => String(x).toLowerCase()));
          filtered = filtered.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            return setSel.has(id) || setSel.has(name) || selectedRawEmps.some(sel => id.includes(String(sel).toLowerCase()) || name.includes(String(sel).toLowerCase()));
          });
        }

        const keySet = new Set();
        const deduped = [];
        filtered.forEach(r => {
          const key = `${getServerISO(r)}|${r.EmployeeID}|${r.Door}|${r.CardNumber}`;
          if (!keySet.has(key)) {
            keySet.add(key);
            deduped.push(r);
          }
        });

        await generateRawExcel(deduped, { region, location: selectedLocations && selectedLocations.join(',') || location, rawSearch, from, to, rawAdmitFilter });
        return;
      }

      // ----- 2: Rejection -----
      if (tab === 2) {
        const params = { ...baseParams, startDate: formatLocalDate(from), endDate: formatLocalDate(to, true) };
        const resp = await axios.get('/api/reports/rejection', { params });
        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);
        const rowsSrc = (resp.data && resp.data.data) || [];
        const rows = rowsSrc.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          return date >= startDate && date <= endDate;
        });
        await generateRejectionExcel(rows);
        return;
      }

      // ----- 3: EUROC Admit-Reject (single day) -----
      if (tab === 3) {
        if (region.toLowerCase() !== 'emea') {
          alert('EUROC report is only available for region EMEA. Please select EMEA.');
          return;
        }
        if (!from) {
          alert('Please select a date (From) for EUROC report.');
          return;
        }

        // If user selected specific locations (selectedLocations) then pass them to backend as comma separated
        const dateParam = toLocalYMD(new Date(from));
        const params = { region: 'emea', date: dateParam };
        if (selectedLocations && selectedLocations.length) params.locations = selectedLocations.join(',');
        const resp = await axios.get('/api/reports/euroc-admit-rejection', { params });
        const { data } = resp.data || {};

        // keep original EUROC Excel generation (same logic)
        const wb = new ExcelJS.Workbook();

        // Admit sheet
        const admitTitle = `EUROC Admit Report - ${formatDisplayDate(from)}`;
        const ws1 = wb.addWorksheet('EUROC Admit');
        ws1.mergeCells('A1:I1');
        ws1.getCell('A1').value = admitTitle;
        ws1.getCell('A1').font = { bold: true, size: 14 };
        ws1.getCell('A1').alignment = { horizontal: 'center' };

        const admitHeaders = [
          'Sr. No.', 'Date', 'Time', 'Employee Name',
          'Access Card No.', 'Personnel Type', 'Door Name', 'Location', 'Swipe'
        ];
        const hdrRow1 = ws1.addRow(admitHeaders);
        hdrRow1.font = { bold: true };
        hdrRow1.alignment = { vertical: 'middle', horizontal: 'center' };
        hdrRow1.eachCell(c => {
          c.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
        });

        ws1.columns = [
          { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
          { key:'name', width:30 }, { key:'card', width:15 }, { key:'ptype', width:20 },
          { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
        ];

        (data.admit || []).forEach((r, idx) => {
          let iso;
          if (r.LocaleMessageTime) {
            iso = r.LocaleMessageTime;
          } else if (r.DateOnly) {
            iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
          } else {
            iso = '';
          }

          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws1.addRow([
            idx + 1,
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.CardNumber || '',
            r.PersonnelType || '',
            r.Door || r.ObjectName2 || '',
            r.location || '',
            r.Direction || ''
          ]);

          row.getCell(2).alignment = { horizontal: 'left' };
          row.getCell(3).alignment = { horizontal: 'left' };
          row.eachCell(c => {
            c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        // Rejection sheet
        const ws2 = wb.addWorksheet('EUROC Rejection');
        ws2.mergeCells('A1:J1');
        ws2.getCell('A1').value = `EUROC Rejection Report - ${formatDisplayDate(from)}`;
        ws2.getCell('A1').font = { bold: true, size: 14 };
        ws2.getCell('A1').alignment = { horizontal: 'center' };

        const headerRow2 = ws2.addRow(['Sr. No.', 'Date', 'Time', 'Employee Name', 'Access Card No.', 'Rejection Type', 'Door Name', 'Location', 'Swipe']);
        headerRow2.font = { bold: true };
        headerRow2.alignment = { vertical: 'middle', horizontal: 'center' };
        headerRow2.eachCell(c => {
          c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });

        ws2.columns = [
          { key:'sr', width:8 }, { key:'date', width:12 }, { key:'time', width:12 },
          { key:'name', width:30 }, { key:'card', width:15 }, { key:'type', width:15 },
          { key:'door', width:50 }, { key:'loc', width:18 }, { key:'swipe', width:8 }
        ];

        (data.rejection || []).forEach((r, idx) => {
          let iso;
          if (r.LocaleMessageTime) {
            iso = r.LocaleMessageTime;
          } else if (r.DateOnly) {
            iso = buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
          } else {
            iso = '';
          }

          const dateStr = iso ? formatDateFromServerISO(iso) : '';
          const timeStr = iso ? formatTimeFromServerISO(iso) : '';

          const row = ws2.addRow([
            idx + 1,
            dateStr,
            timeStr,
            r.ObjectName1 || '',
            r.CardNumber || '',
            r.Rejection_Type || '',
            r.Door || '',
            r.location || '',
            r.Direction || ''
          ]);

          row.getCell(2).alignment = { horizontal: 'left' };
          row.getCell(3).alignment = { horizontal: 'left' };
          row.eachCell(c => {
            c.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
            c.alignment = { vertical: 'middle', horizontal: 'left' };
          });
        });

        // Summary block
        const counts = data.summary || [];
        let startRow = 3;
        ws2.getCell(startRow, 11).value = 'Rejection';
        ws2.getCell(startRow, 12).value = 'Count';
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.font = { bold: true };
          cell.alignment = { horizontal: 'center' };
          cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });
        startRow++;
        counts.forEach(c => {
          ws2.getCell(startRow, 11).value = c.Rejection_Type || 'Unknown';
          ws2.getCell(startRow, 12).value = c.Count || 0;
          [11, 12].forEach(col => {
            const cell = ws2.getCell(startRow, col);
            cell.alignment = { horizontal: 'left' };
            cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
          });
          startRow++;
        });
        ws2.getCell(startRow, 11).value = 'Grand Total';
        ws2.getCell(startRow, 12).value = (data.rejection || []).length;
        [11, 12].forEach(col => {
          const cell = ws2.getCell(startRow, col);
          cell.font = { bold: true };
          cell.alignment = { horizontal: 'left' };
          cell.border = { top:{style:'thin'}, left:{style:'thin'}, bottom:{style:'thin'}, right:{style:'thin'} };
        });

        const buf = await wb.xlsx.writeBuffer();
        const blob = new Blob([buf], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const filename = `EUROC_Admit_Rejection_${dateParam}.xlsx`;
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        return;
      }

      // ----- 4: Time Duration -----
      if (tab === 4) {
        if (!from || !to) {
          alert('Please select both Start Date and End Date for Time Duration report.');
          return;
        }
        const startParam = toLocalYMD(new Date(from));
        const endParam = toLocalYMD(new Date(to));
        const params = {
          region,
          startDate: startParam,
          endDate: endParam,
          partition: location ? location.split('.').pop() : 'Default'
        };
        const resp = await axios.get('/api/reports/time-duration', { params });
        await generateTimeDurationExcel(resp.data.data || []);
        return;
      }

      // ----- 5: HeadCount / External navigation -----
      if (tab === 5) {
        const permCandidates = [`headcount.${region}`, 'headcount', 'global_access'];
        if (!auth.hasPermission(permCandidates)) {
          alert(`You do not have permission to view HeadCount for ${region.toUpperCase()}.`);
          return;
        }

        let url = '';
        // ... unchanged navigation mapping ...
        if (url) window.location.href = url;
        else alert('Invalid region or location selected.');
        return;
      }

      // ----- Denver Monthly (tab 6) -----
      if (tab === 6) {
        let useYear = null;
        let useMonth = null;
        if (from) {
          const d = new Date(from);
          useYear = d.getFullYear();
          useMonth = d.getMonth() + 1;
        } else {
          const dt = new Date();
          dt.setDate(1); dt.setHours(0,0,0,0);
          dt.setMonth(dt.getMonth() - 1);
          useYear = dt.getFullYear();
          useMonth = dt.getMonth() + 1;
        }

        try {
          const resp = await axios.get('/api/reports/denver-attendance', {
            params: { year: useYear, month: useMonth },
            responseType: 'blob'
          });

          let filename = `denver_attendance_${useYear}${String(useMonth).padStart(2,'0')}.xlsx`;
          const cd = resp.headers['content-disposition'];
          if (cd) {
            const m = cd.match(/filename\*?=(?:UTF-8'')?["']?([^;"']+)/);
            if (m && m[1]) filename = decodeURIComponent(m[1]);
          }

          const blob = new Blob([resp.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
          const link = document.createElement('a');
          link.href = window.URL.createObjectURL(blob);
          link.download = filename;
          link.click();
        } catch (err) {
          console.error('Denver attendance download error', err);
          let msg = 'Failed to download Denver attendance report';
          if (err?.response?.data) {
            msg += `: ${err.response?.data?.detail || err.message || JSON.stringify(err.response.data)}`;
          } else if (err?.message) {
            msg += `: ${err.message}`;
          }
          alert(msg);
        }
        return;
      }

    } catch (err) {
      console.error('handleGenerate error:', err);
      let msg = 'Failed to generate report';
      if (err?.response?.data) {
        const d = err.response.data;
        const serverMsg = (typeof d === 'string') ? d
                          : (d.error || d.message || JSON.stringify(d));
        msg += `: ${serverMsg}`;
      } else if (err?.message) {
        msg += `: ${err.message}`;
      }
      alert(msg);
    } finally {
      setLoading(false);
      setGeneratingMessage('');
    }
  };

  // --- UI render ---
  const regionOptions = regionOptionsForTab();
  const locationOptions = locationOptionsForTab();

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
        {/* Topbar / Header */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            px: 3,
            py: 2,
            borderBottom: '1px solid rgba(255,204,0,0.08)',
            background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
          }}
        >
          <Avatar sx={{ bgcolor: '#000', border: '3px solid #FFCC00', width: 56, height: 56 }}>
            <Typography sx={{ color: '#FFCC00', fontWeight: 900 }}>WU</Typography>
          </Avatar>

          <Box sx={{ flex: 1 }}>
            <Typography variant="h5" sx={{ fontWeight: 900, letterSpacing: 0.6 }}>
              Global Security Operation Center
            </Typography>
            <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
              Reports & Exports — Secure access, fast insights
            </Typography>
          </Box>

          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
            <Button
              startIcon={<DownloadIcon />}
              onClick={handleGenerate}
              disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
              sx={{
                bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                color: '#000',
                fontWeight: 800,
                px: 3,
                py: 1,
                borderRadius: 3,
                boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
                transformOrigin: 'center',
                '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-2px)' : 'none' }
              }}
            >
              {loading ? 'Loading…' : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
            </Button>
          </Box>
        </Box>

        {/* Generating banner */}
        {generatingMessage && (
          <Box sx={{ px: 3, py: 1, bgcolor: 'rgba(255,255,255,0.02)', borderBottom: '1px solid rgba(255,204,0,0.04)', display: 'flex', alignItems: 'center', gap: 2 }}>
            <CircularProgress size={20} />
            <Typography variant="body2" sx={{ color: '#FFCC00', fontWeight: 700 }}>{generatingMessage}</Typography>
          </Box>
        )}

        {/* Main content */}
        <Grid container sx={{ px: 3, py: 4 }} spacing={3}>
          <Grid item xs={12} md={3}>
            <Paper elevation={8} sx={{ p: 2.5, borderRadius: 3, height: { xs: 'auto', md: 'calc(100vh - 150px)' }, overflow: 'auto', background: 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015))', border: '1px solid rgba(255,204,0,0.06)' }}>
              <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
                <Box>
                  <Typography variant="subtitle1" sx={{ fontWeight: 800, color: '#FFCC00' }}>Filters</Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Narrow down by region, date and employees
                  </Typography>
                </Box>
                <IconButton size="small" sx={{ color: '#FFCC00' }}>
                  <FilterListIcon />
                </IconButton>
              </Box>

              <Divider sx={{ my: 1, borderColor: 'rgba(255,204,0,0.06)' }} />

              {/* Region - show per-tab region options */}
              {regionOptions.length > 0 && (
                <Box sx={{ mt: 1 }}>
                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Region</InputLabel>
                    <Select
                      value={region}
                      onChange={e => { setRegion(e.target.value); setLocation(''); }}
                      input={<OutlinedInput label="Region" />}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.24)' }
                      }}
                    >
                      {regionOptions.map(r => <MenuItem key={r} value={r}>{r.toUpperCase()}</MenuItem>)}
                    </Select>
                  </FormControl>
                </Box>
              )}

              {/* Location */}
              <Box sx={{ mt: 2 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Location</InputLabel>

                  {/* RAW (tab 1) keeps multi Autocomplete */}
                  {tab === 1 ? (
                    <Autocomplete
                      multiple
                      freeSolo={false}
                      options={availableLocations}
                      value={selectedLocations}
                      onChange={(e, v) => setSelectedLocations(v)}
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          placeholder="Choose 0..n locations (leave empty = all)"
                          InputLabelProps={{ style: { color: '#FFCC00' } }}
                          sx={{
                            '& .MuiInputBase-input': { color: '#fff' },
                            '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                          }}
                        />
                      )}
                      getOptionLabel={(opt) => String(opt)}
                      isOptionEqualToValue={(opt, val) => opt === val}
                      disabled={!region}
                    />
                  ) : null}

                  {/* EUROC (tab 3) -> multi-select Autocomplete of EMEA locations */}
                  {tab === 3 ? (
                    <Autocomplete
                      multiple
                      freeSolo={false}
                      options={availableLocations.length ? availableLocations : (LOCATION_MAP['emea'] || [])}
                      value={selectedLocations}
                      onChange={(e, v) => setSelectedLocations(v)}
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          placeholder="Select 0..n locations (leave empty = all EMEA)"
                          InputLabelProps={{ style: { color: '#FFCC00' } }}
                          sx={{
                            '& .MuiInputBase-input': { color: '#fff' },
                            '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                          }}
                        />
                      )}
                      getOptionLabel={(opt) => String(opt)}
                      isOptionEqualToValue={(opt, val) => opt === val}
                      disabled={!region}
                    />
                  ) : null}

                  {/* For Time Duration (tab 4) and others (including Denver tab 6), single-select */}
                  {tab !== 1 && tab !== 3 && tab !== 6 && (
                    <Select
                      value={location}
                      onChange={e => setLocation(e.target.value)}
                      input={<OutlinedInput label="Location" />}
                      disabled={(regionOptions.length === 0)}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                      }}
                    >
                      { (locationOptions && locationOptions.length) ? locationOptions.map(loc => (
                          <MenuItem key={loc} value={loc}>
                            {String(loc).split('.').pop()}
                          </MenuItem>
                        ))
                        : ((LOCATION_MAP[region] || []).map(loc => (
                          <MenuItem key={loc} value={loc}>{String(loc).split('.').pop()}</MenuItem>
                        )))
                      }
                    </Select>
                  )}

                  {/* Denver (tab 6) - single select but only Denver */}
                  {tab === 6 && (
                    <Select
                      value={location}
                      onChange={e => setLocation(e.target.value)}
                      input={<OutlinedInput label="Location" />}
                      disabled={false}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                      }}
                    >
                      <MenuItem value="US.Denver">Denver</MenuItem>
                    </Select>
                  )}
                </FormControl>
              </Box>

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />

              {/* Employee input area (Daily and Raw) */}
              {tab === 1 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employee (name or ID) — multiple
                  </Typography>

                  <Autocomplete
                    multiple
                    freeSolo
                    filterSelectedOptions
                    options={rawEmpOptions}
                    value={selectedRawEmps}
                    onChange={(e, v) => setSelectedRawEmps(v)}
                    onInputChange={async (e, value, reason) => {
                      if (empQueryRef.current) clearTimeout(empQueryRef.current);
                      if (!value || value.length < 2) {
                        empQueryRef.current = setTimeout(() => setRawEmpOptions([]), 150);
                        return;
                      }
                      empQueryRef.current = setTimeout(async () => {
                        try {
                          const params = { q: value };
                          if (region && region !== 'global') params.region = region;
                          const resp = await axios.get('/api/employees', { params });
                          const raw = (resp.data && (resp.data.data || resp.data)) || [];
                          const normalized = Array.isArray(raw) ? raw.map(item => {
                            if (typeof item === 'string') return item;
                            const id = item.EmployeeID || item.id || item.NumericEmployeeID || item.Employee || '';
                            const name = item.Name || item.name || item.ObjectName1 || '';
                            if (name && id) return `${name} (${id})`;
                            if (id) return String(id);
                            if (name) return String(name);
                            return JSON.stringify(item);
                          }) : [];
                          setRawEmpOptions(Array.from(new Set(normalized)));
                        } catch (err) {
                          console.warn('employee suggestions error', err);
                          setRawEmpOptions([]);
                        }
                      }, 300);
                    }}
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        placeholder="Type name or ID (2+ chars) — select multiple"
                        InputLabelProps={{ style: { color: '#FFCC00' } }}
                        sx={{
                          '& .MuiInputBase-input': { color: '#fff' },
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                        }}
                      />
                    )}
                    getOptionLabel={(opt) => (typeof opt === 'string' ? opt : (opt.label || opt.name || String(opt)))}
                    renderOption={(props, option) => <li {...props}>{typeof option === 'string' ? option : (option.label || option.name || String(option))}</li>}
                    ListboxProps={{ style: { maxHeight: 240 } }}
                  />

                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                    Leave empty to export all raw rows for the date range. Type 2+ chars to get suggestions for employee names or IDs.
                  </Typography>

                  <Box sx={{ mt: 2 }}>
                    <FormControl fullWidth>
                      <InputLabel sx={{ color: '#FFCC00' }}>Admit / Reject</InputLabel>
                      <Select
                        value={rawAdmitFilter}
                        onChange={(e) => setRawAdmitFilter(e.target.value)}
                        input={<OutlinedInput label="Admit / Reject" />}
                        sx={{
                          color: '#fff',
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                        }}
                      >
                        <MenuItem value="all">All (Admitted + Rejected)</MenuItem>
                        <MenuItem value="admit">Admitted only</MenuItem>
                        <MenuItem value="reject">Rejected only</MenuItem>
                      </Select>
                    </FormControl>
                    <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                      Default = All.
                    </Typography>
                  </Box>
                </Box>
              )}

              {/* Dates (shown for all tabs except external navigation tab 5) */}
              {tab !== 5 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Date Range
                  </Typography>
                  <Box sx={{ display: 'grid', gap: 1.25 }}>
                    <TextField
                      label={tab === 0 ? 'From Date' : 'Start Date'}
                      value={from ? from.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowFromCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                    <TextField
                      label={tab === 0 ? 'To Date' : 'End Date'}
                      value={to ? to.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowToCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                  </Box>

                  {showFromCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={from}
                        onChange={(newValue) => setFrom(newValue)}
                        onAccept={() => setShowFromCal(false)}
                        onClose={() => setShowFromCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                  {showToCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={to}
                        onChange={(newValue) => setTo(newValue)}
                        onAccept={() => setShowToCal(false)}
                        onClose={() => setShowToCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                </Box>
              )}

              {/* Daily employees block */}
              {tab === 0 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employees
                  </Typography>

                  <Box sx={{ display: 'flex', gap: 1, mb: 1 }}>
                    <TextField
                      fullWidth
                      placeholder="Add name or ID (e.g. 'Vainilaitis, Valdas' or '323471')"
                      value={newEmployee}
                      onChange={(e) => setNewEmployee(e.target.value)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                      InputLabelProps={{ style: { color: '#FFCC00' } }}
                    />
                    <Button
                      variant="contained"
                      onClick={() => {
                        const v = (newEmployee || '').toString().trim();
                        if (!v) return;
                        if (!selectedEmps.includes(v)) {
                          setSelectedEmps(prev => [...prev, v]);
                        }
                        setNewEmployee('');
                      }}
                      sx={{
                        bgcolor: '#FFCC00',
                        color: '#000',
                        fontWeight: 800,
                        px: 2,
                        '&:hover': { bgcolor: '#ffd84d' }
                      }}
                    >
                      Add
                    </Button>
                  </Box>

                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Employees</InputLabel>

                    <Select
                      multiple
                      value={selectedEmps}
                      onChange={e => setSelectedEmps(e.target.value)}
                      input={<OutlinedInput label="Employees" />}
                      renderValue={vals => vals.join(', ')}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                      }}
                    >
                      {[
                        ...EMPLOYEE_OPTIONS,
                        ...selectedEmps.filter(s => !EMPLOYEE_OPTIONS.includes(s))
                      ].map(n => (
                        <MenuItem key={n} value={n}>
                          <Checkbox checked={selectedEmps.includes(n)} />
                          <ListItemText primary={n} />
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              )}

              <Box sx={{ mt: 3, p: 2, borderRadius: 2, background: 'rgba(255,255,255,0.02)' }}>
                <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                  Tip: For daily exports pick employees & a single day range. For Time Duration choose the required partition via Location.
                </Typography>
              </Box>
            </Paper>
          </Grid>

          {/* Main panel */}
          <Grid item xs={12} md={9}>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              <Paper elevation={3} sx={{ px: 2, py: 1, borderRadius: 2, display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 2, border: '1px solid rgba(255,204,0,0.04)' }}>
                <Tabs value={tab} onChange={handleTabChange} sx={{ '& .MuiTab-root': { textTransform: 'none', minWidth: 120, fontWeight: 700, color: 'rgba(255,255,255,0.8)' }, '& .Mui-selected': { color: '#FFCC00' } }}>
                  <Tab icon={<CalendarTodayIcon />} label="Daily Access" />
                  <Tab icon={<PeopleIcon />} label="Raw" />
                  <Tab icon={<PlaceIcon />} label="Rejection" />
                  <Tab icon={<PeopleIcon />} label="EUROC Admit-Reject" />
                  <Tab icon={<CalendarTodayIcon />} label="Time Duration" />
                  <Tab icon={<PeopleIcon />} label="HeadCount" />
                  <Tab icon={<PeopleIcon />} label="Denver Monthly" />
                </Tabs>

                <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                  <Button variant="text" startIcon={<FilterListIcon />} sx={{ color: 'rgba(255,255,255,0.65)', textTransform: 'none' }} onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}>
                    Reset View
                  </Button>
                </Box>
              </Paper>

              <Paper elevation={6} sx={{ p: 3, borderRadius: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 2 }}>
                <Box>
                  <Typography variant="h6" sx={{ fontWeight: 900 }}>Export Center</Typography>
                  <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                    Selected Region: <strong style={{ color: '#FFCC00' }}>{region ? region.toUpperCase() : '—'}</strong> {location ? `• ${location.split('.').pop() === 'Denver' ? 'Denver' : location.split('.').pop()}` : ''}
                  </Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Choose tab, select filters and export reports in Excel.
                  </Typography>
                </Box>

                <Box>
                  <Button
                    startIcon={loading ? <CircularProgress size={20} /> : <DownloadIcon />}
                    disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
                    onClick={handleGenerate}
                    sx={{
                      bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                      color: '#000',
                      fontWeight: 900,
                      px: 4,
                      py: 1,
                      borderRadius: 3,
                      boxShadow: '0 8px 30px rgba(255,204,0,0.22)',
                      '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-3px)' : 'none' }
                    }}
                  >
                    {loading
                      ? 'Loading…'
                      : (tab === 5
                          ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`)
                          : 'Export to Excel')}
                  </Button>
                </Box>
              </Paper>
            </Box>
          </Grid>
        </Grid>
      </Box>
    </LocalizationProvider>
  );
}



















Good Now As per Request all Working Good . Now Only need to update here ...
1) Daily Access Working fine ..No need for changes .
2) Raw Working fine .. No need for changes.
3)Rejection no need to changes 
4) for EUROC Admit-reject Region is EMEA , and in location dropdown display like ALL EMEA 
Replace All EMEA to display Location List as Previously like Vinins , Dublin .. like ... SO user can Select 1 or 2 location or also select all Location Option here ..

5) for Duration same here replace here Currently in Location tab display ALL EMEA it is Wrong display APAC ..Location list strickly....

6) For Denver Attendance Report display Region ..NAMER , And Location Tab display Denver only no need other location and region here and select start date and end date .. ok


now When click Export report then add Spinner display loading Spinner on UI and Display like Denver Attenance report is generating diffrent for all report 

Dont amke any logical changes as per request make changes and share me Updated frontend file so i can easily swap file each other




// C:\Users\W0024618\Desktop\global-page\frontend\src\pages\ReportsPage.jsx
import React, { useState, useEffect, useRef } from 'react';
import {
  Box, FormControl, InputLabel, Select, OutlinedInput,
  Checkbox, ListItemText, MenuItem, Button,
  CircularProgress, Typography, TextField, Tabs, Tab, Grid, Paper, IconButton, Divider, Autocomplete
} from '@mui/material';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { StaticDatePicker } from '@mui/x-date-pickers/StaticDatePicker';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import axios from 'axios';
import ExcelJS from 'exceljs';
import * as XLSX from 'xlsx';
import { useAuth } from '../context/AuthContext';

import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import PlaceIcon from '@mui/icons-material/Place';
import PeopleIcon from '@mui/icons-material/People';
import DownloadIcon from '@mui/icons-material/CloudDownload';
import FilterListIcon from '@mui/icons-material/FilterList';
import Avatar from '@mui/material/Avatar';
import { generateDailyAccessExcelFromRows } from './DailyAccessReport';

// Static lists
const EMPLOYEE_OPTIONS = [
  'Vainilaitis, Valdas',
  'Tomasevic, Kazimez',
  'Sesickis, Janas',
  'Valiunas, Sigitas',
  'JANCUKOVIC, VACLAVA',
  'Kalpokiene, Alina',
  'Korkus, Vanda',
  'Kvaraciejiene, Maryte',
  'ZNAMEROVSKIS, DARIUS'
];

const REGION_OPTIONS = ['global', 'apac', 'emea', 'laca', 'namer'];
const LOCATION_MAP = {
  apac: ['APAC.Default', 'JP.Tokyo', 'PH.Manila', 'MY.Kuala Lumpur','IN.HYD'],
  emea: ['AUT.Vienna', 'DU.Abu Dhab', 'IE.Dublin', 'IT.Rome', 'LT.Vilnius', 'MA.Casablanca', 'RU.Moscow', 'UK.London', 'ES.Madrid'],
  laca: ['AR.Cordoba', 'CR.Costa Rica Partition', 'MX.Mexico City', 'PE.Lima', 'BR.Sao Paulo', 'PA.Panama City'],
  namer: ['US.NYC', 'US.FL.Miami', 'USA/Canada Default', 'US.CO.OBS','denver'],
  global: []
};

function formatDisplayDate(date) {
  if (!date) return '';
  const d = new Date(date);
  const day = d.getDate();
  const suf = day % 10 === 1 && day !== 11 ? 'st'
    : day % 10 === 2 && day !== 12 ? 'nd'
      : day % 10 === 3 && day !== 13 ? 'rd' : 'th';
  const mon = d.toLocaleString('default', { month: 'long' });
  return `${day}${suf} ${mon} ${d.getFullYear()}`;
}

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const pad2 = n => String(n).padStart(2, '0');

// --- Helper functions (unchanged from your original) ---
function _extractServerDateTimeParts(iso) {
  if (!iso) return null;
  const s = String(iso);
  let datePart = '', timePart = '';
  if (s.includes('T')) {
    [datePart, timePart] = s.split('T');
  } else if (s.includes(' ')) {
    [datePart, timePart] = s.split(' ');
  } else {
    return null;
  }
  datePart = datePart.slice(0, 10);
  timePart = (timePart || '').replace(/Z|[+-]\d{2}:\d{2}$/, '').replace(/\.\d+$/, '');
  const dParts = datePart.split('-').map(p => parseInt(p, 10));
  const tParts = timePart.split(':').map(p => parseInt(p || '0', 10));
  return {
    year: dParts[0] || 0,
    month: dParts[1] || 0,
    day: dParts[2] || 0,
    hour: tParts[0] || 0,
    minute: tParts[1] || 0,
    second: tParts[2] || 0
  };
}

function formatDateFromServerISO(iso) {
  if (!iso) return '';
  const dt = new Date(iso);
  const y = dt.getUTCFullYear();
  const m = dt.getUTCMonth(); // 0..11
  const d = dt.getUTCDate();
  const yrShort = String(y).slice(-2);
  return `${pad2(d)}-${MONTH_ABBR[m]}-${yrShort}`;         // e.g. "12-Aug-25"
}

function formatTimeFromServerISO(iso) {
  if (!iso) return '';
  const p = _extractServerDateTimeParts(iso);
  if (!p) return '';
  const hh = p.hour;
  const mm = p.minute || 0;
  const ss = p.second || 0;
  const ampm = hh >= 12 ? 'PM' : 'AM';
  const hh12 = ((hh + 11) % 12) + 1;
  return `${hh12}:${pad2(mm)}:${pad2(ss)} ${ampm}`;
}

function buildISOFromDateOnlyAndSwipe(dateOnlyIso, swipeIso) {
  if (!dateOnlyIso) return '';
  const datePart = dateOnlyIso.toString().slice(0,10);
  if (!swipeIso) {
    return `${datePart}T00:00:00.000`;
  }
  const t = new Date(swipeIso);
  if (!isNaN(t.getTime())) {
    const hh = pad2(t.getUTCHours());
    const mm = pad2(t.getUTCMinutes());
    const ss = pad2(t.getUTCSeconds());
    return `${datePart}T${hh}:${mm}:${ss}.000`;
  }
  const parts = ('' + swipeIso).split(':').map(p => pad2(parseInt(p||0,10)||0));
  const hh = parts[0] || '00';
  const mm = parts[1] || '00';
  const ss = parts[2] || '00';
  return `${datePart}T${hh}:${mm}:${ss}.000`;
}

const getServerISO = (r) => {
  if (!r) return '';
  if (r.LocaleMessageTime) return r.LocaleMessageTime;
  if (r.DateOnly) return buildISOFromDateOnlyAndSwipe(r.DateOnly, r.Swipe_Time);
  return '';
};

const getServerYMD = (r) => {
  const iso = getServerISO(r);
  if (!iso) return '';
  return iso.slice(0, 10);
};

const isoDateOnlyToLocalDate = (iso) => {
  if (!iso) return null;
  const s = iso.toString().slice(0, 10);
  const [y, m, d] = s.split('-').map(n => parseInt(n, 10));
  return new Date(y, m - 1, d);
};

const buildLocalDateFromDateOnlyAndSwipe = (dateOnly, swipeTime) => {
  if (!dateOnly) return null;
  const dateStr = dateOnly.toString().slice(0, 10);
  const [yy, mm, dd] = dateStr.split('-').map(n => parseInt(n, 10));

  let hh = 0, min = 0, ss = 0;
  if (swipeTime) {
    const parsed = new Date(swipeTime);
    if (!isNaN(parsed.getTime())) {
      hh = parsed.getUTCHours();
      min = parsed.getUTCMinutes();
      ss = parsed.getUTCSeconds();
    } else {
      const parts = swipeTime.split(':').map(p => parseInt(p, 10));
      if (parts.length >= 2) {
        hh = parts[0] || 0;
        min = parts[1] || 0;
        ss = parts[2] || 0;
      }
    }
  }
  return new Date(yy, mm - 1, dd, hh, min, ss);
};

export default function ReportsPage() {
  const auth = useAuth();

  // --- state ---
  const [tab, setTab] = useState(0);

  // default region now set to 'emea' for initial tab 0 behavior
  const [region, setRegion] = useState('emea');
  const [location, setLocation] = useState('LT.Vilnius');
  const [from, setFrom] = useState(null);
  const [to, setTo] = useState(null);
  const [showFromCal, setShowFromCal] = useState(false);
  const [showToCal, setShowToCal] = useState(false);
  const [selectedEmps, setSelectedEmps] = useState([]);
  const [loading, setLoading] = useState(false);

  const [rawSearch, setRawSearch] = useState('');
  const [rawAdmitFilter, setRawAdmitFilter] = useState('all');
  const [newEmployee, setNewEmployee] = useState('');

  const [availableLocations, setAvailableLocations] = useState([]);
  const [selectedLocations, setSelectedLocations] = useState([]);
  const [rawEmpOptions, setRawEmpOptions] = useState([]);
  const [selectedRawEmps, setSelectedRawEmps] = useState([]);
  const empQueryRef = useRef(null);

  // Provide region options depending on tab
  const regionOptionsForTab = () => {
    if (tab === 0) return ['emea'];            // Daily Access -> only EMEA
    if (tab === 3) return ['emea'];            // EUROC -> only EMEA
    if (tab === 4) return ['apac'];            // Time Duration -> only APAC
    if (tab === 6) return [];                  // Denver -> hide region
    return REGION_OPTIONS;                     // default (Raw, Rejection, HeadCount, etc.)
  };

  // Provide location options depending on tab & region
  const locationOptionsForTab = () => {
    if (tab === 6) return []; // Denver hide
    if (tab === 0) return ['LT.Vilnius']; // Daily Access -> only Vilnius
    if (tab === 3) return ['ALL_EMEA'];   // EUROC -> All EMEA option (single)
    // Raw tab keeps backend-driven locations (multi-select). For other tabs, fallback to availableLocations/static map.
    if (tab === 1) return availableLocations.length ? availableLocations : (LOCATION_MAP[region] || []);
    return (availableLocations.length ? availableLocations : (LOCATION_MAP[region] || []));
  };

  // fetch availableLocations for the currently selected region (runs on region change)
  useEffect(() => {
    let mounted = true;
    const load = async () => {
      setAvailableLocations([]);
      if (!region) return;
      const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];

      try {
        if (region === 'global') {
          const promises = MULTI_REGIONS.map(r => fetchLocationsForRegion(r));
          const results = await Promise.all(promises);
          const merged = results.flat();
          if (!mounted) return;
          setAvailableLocations(Array.from(new Set(merged)).sort());
        } else {
          const list = await fetchLocationsForRegion(region);
          if (!mounted) return;
          setAvailableLocations(Array.from(new Set(list)).sort());
        }
      } catch (err) {
        console.error('load locations error', err);
      }
    };

    // Only attempt fetching when we have a region and the tab is not restricting to a static option
    if (region && !([0,3,4].includes(tab) && regionOptionsForTab().length === 1)) {
      load();
    } else {
      // ensure availableLocations is consistent for static cases
      setAvailableLocations(locationOptionsForTab());
    }

    return () => { mounted = false; };
  }, [region, tab]);

  // Helper: fetch locations for a single region key (backend endpoint: GET /api/locations?region=apac)
  const fetchLocationsForRegion = async (r) => {
    try {
      if (!r) return [];
      const resp = await axios.get('/api/locations', { params: { region: r } });
      const listRaw = (resp.data && (resp.data.data || resp.data)) || [];
      const list = Array.isArray(listRaw)
        ? listRaw.map(item => {
            if (typeof item === 'string') return item;
            return item.PartitionName2 || item.partition || item.location || item.name || (item.label ? item.label : null);
          }).filter(Boolean)
        : [];
      if (!list.length) {
        const key = (r || '').toLowerCase();
        return (LOCATION_MAP[key] || []).slice();
      }
      return Array.from(new Set(list)).sort();
    } catch (e) {
      console.warn('fetchLocationsForRegion error', r, e);
      const key = (r || '').toLowerCase();
      return (LOCATION_MAP[key] || []).slice();
    }
  };

  // Handle tab switch (Daily / Raw / Rejection / etc.)
  const handleTabChange = (_, v) => {
    setTab(v);

    // Reset shared filters
    setFrom(null);
    setTo(null);
    setSelectedEmps([]);
    setRawSearch('');
    setRawAdmitFilter('all');
    setSelectedLocations([]);
    setSelectedRawEmps([]);
    setNewEmployee('');
    setRawEmpOptions([]);

    // Default region/location per tab (as requested)
    if (v === 0) {         // Daily Access -> EMEA + Vilnius
      setRegion('emea');
      setLocation('LT.Vilnius');
    } else if (v === 1) {  // Raw -> keep default region (emea) but let user change
      setRegion('emea');
      setLocation('');
    } else if (v === 2) {  // Rejection -> no change, default emea
      setRegion('emea');
      setLocation('');
    } else if (v === 3) {  // EUROC -> EMEA only, default 'ALL EMEA' location
      setRegion('emea');
      setLocation('ALL_EMEA');
    } else if (v === 4) {  // Time Duration -> APAC only
      setRegion('apac');
      setLocation('');
    } else if (v === 5) {  // HeadCount -> keep emea as default
      setRegion('emea');
      setLocation('');
    } else if (v === 6) {  // Denver -> hide region/location
      setRegion(''); // no region
      setLocation('');
    }
  };

  /** Time Duration Excel generator (unchanged) */
  const generateTimeDurationExcel = async data => {
    // ... same as your original code (omitted here to keep file compact) ...
  };

  const generateRejectionExcel = async data => {
    // ... same as your original code (omitted here to keep file compact) ...
  };

  function buildRawFileName(opts = {}) {
    const safe = s => (s === undefined || s === null) ? '' : String(s).replace(/[\/\\:?<>|"]/g, '_').trim();
    const regionPart = opts.region ? safe(opts.region).toUpperCase() : 'RAW';
    const locationPart = opts.location ? `_${safe(opts.location).replace('.', '_')}` : '';
    const admitPart = opts.rawAdmitFilter ? `_${safe(opts.rawAdmitFilter)}` : '';
    const searchPart = opts.rawSearch ? `_${safe(opts.rawSearch).replace(/\s+/g, '_')}` : '';
    const formatDateForName = d => {
      if (!d) return '';
      try {
        if (d instanceof Date) return `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}`;
        const dt = new Date(d);
        if (!isNaN(dt.getTime())) return `${dt.getFullYear()}${pad2(dt.getMonth()+1)}${pad2(dt.getDate())}`;
      } catch (e) { /* ignore */ }
      return safe(d).slice(0,10).replace(/[-\s:]/g,'');
    };

    const fromPart = opts.from ? `_from_${formatDateForName(opts.from)}` : '';
    const toPart   = opts.to   ? `_to_${formatDateForName(opts.to)}` : '';
    const filename = `Raw_${regionPart}${locationPart}${fromPart}${toPart}${admitPart}${searchPart}.xlsx`;
    return filename;
  }

  const generateRawExcel = async (rows, opts = {}) => {
    // ... same as your original code (omitted here to keep file compact) ...
  };

  const exportPermsForTab = () => {
    if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
    if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
    if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
    if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
    if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
    if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
    if (tab === 6) return ['gsoc_reports.denver_monthly', 'gsoc_reports'];
    return ['gsoc_reports'];
  };

  const disabled = loading
    || (tab !== 6 && !region)
    || (tab === 0 && (!from || !to || selectedEmps.length === 0))
    || (tab === 1 && (!from || !to))
    || (tab === 2 && (!from || !to))
    || (tab === 3 && !from)
    || (tab === 4 && (!from || !to));

  const navDisabled = (tab !== 6 && !region) || loading;
  const exportAllowed = auth.hasPermission(exportPermsForTab());

  // Format helpers used in handleGenerate (copied from your file)
  const formatLocalDate = (date, endOfDay = false) => {
    const d = new Date(date);
    if (endOfDay) d.setHours(23, 59, 59, 999);
    else d.setHours(0, 0, 0, 0);
    const pad = n => n.toString().padStart(2, '0');
    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}` +
           `T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  };

  const toLocalYMD = date => `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`;

  const handleGenerate = async () => {
    const requirePermissionForTab = () => {
      if (tab === 0) return ['gsoc_reports.daily_access', 'gsoc_reports'];
      if (tab === 1) return ['gsoc_reports.raw', 'gsoc_reports'];
      if (tab === 2) return ['gsoc_reports.rejection', 'gsoc_reports'];
      if (tab === 3) return ['gsoc_reports.euroc', 'gsoc_reports'];
      if (tab === 4) return ['gsoc_reports.time_duration', 'gsoc_reports'];
      if (tab === 5) return ['headcount', `headcount.${region}`, 'global_access'];
      if (tab === 6) return ['gsoc_reports.denver_monthly', 'gsoc_reports'];
      return ['gsoc_reports'];
    };

    if (!auth.hasPermission(requirePermissionForTab())) {
      alert('You do not have permission to generate this report.');
      return;
    }

    setLoading(true);
    try {
      const baseParams = { region, location: location || undefined };

      // ----- 0: Daily Access -----
      if (tab === 0) {
        const fromDateOnly = `${from.getFullYear()}-${pad2(from.getMonth() + 1)}-${pad2(from.getDate())}`;
        const toDateOnly = `${to.getFullYear()}-${pad2(to.getMonth() + 1)}-${pad2(to.getDate())}`;

        const params = {
          ...baseParams,
          from: fromDateOnly,
          to: toDateOnly,
          employees: selectedEmps.join(',')
        };
        const resp = await axios.get('/api/reports/daily-access', { params });
        const rows = (resp.data && resp.data.data) || [];
        await generateDailyAccessExcelFromRows(rows, { from: fromDateOnly, to: toDateOnly, selectedEmps, region });
        setLoading(false);
        return;
      }

      // ----- 1: Raw -----
      if (tab === 1) {
        const startISO = formatLocalDate(from);
        const endISO = formatLocalDate(to, true);
        const MULTI_REGIONS = ['apac', 'emea', 'laca', 'namer'];
        const requests = [];
        const pushReq = (r, locationParam = undefined) => {
          const params = { startDate: startISO, endDate: endISO, admitFilter: rawAdmitFilter };
          if (r) params.region = r;
          if (locationParam) params.location = locationParam;
          requests.push(axios.get('/api/reports/raw', { params }));
        };

        if (region === 'global') {
          if (selectedLocations && selectedLocations.length) {
            const regionMap = {};
            selectedLocations.forEach(loc => {
              const parts = String(loc).split('.');
              const rKey = (parts[0] || '').toString().toLowerCase();
              regionMap[rKey] = regionMap[rKey] || [];
              regionMap[rKey].push(loc);
            });
            Object.entries(regionMap).forEach(([rKey, locs]) => {
              const isKnown = MULTI_REGIONS.includes(rKey);
              if (isKnown) {
                locs.forEach(loc => pushReq(rKey, loc));
              } else {
                locs.forEach(loc => pushReq(undefined, loc));
              }
            });
          } else {
            MULTI_REGIONS.forEach(r => pushReq(r));
          }
        } else {
          if (selectedLocations && selectedLocations.length) {
            selectedLocations.forEach(loc => pushReq(region, loc));
          } else {
            pushReq(region);
          }
        }

        let rowsSrcCombined = [];
        try {
          if (!requests.length) {
            pushReq(region === 'global' ? MULTI_REGIONS[0] : region);
          }
          const responses = await Promise.all(requests);
          rowsSrcCombined = responses.flatMap(r => (r.data && (r.data.data || r.data)) || []);
        } catch (err) {
          console.error('raw fetch error', err);
          throw err;
        }

        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);

        const rows = rowsSrcCombined.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          if (!date) return false;
          return (date >= startDate && date <= endDate);
        });

        let filtered = rows;
        if (rawSearch && rawSearch.trim() !== '') {
          const s = rawSearch.trim().toLowerCase();
          filtered = filtered.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            return id.includes(s) || name.includes(s);
          });
        }

        if (selectedRawEmps && selectedRawEmps.length) {
          const setSel = new Set(selectedRawEmps.map(x => String(x).toLowerCase()));
          filtered = filtered.filter(r => {
            const id = r.EmployeeID ? String(r.EmployeeID).toLowerCase() : '';
            const name = r.ObjectName1 ? String(r.ObjectName1).toLowerCase() : '';
            return setSel.has(id) || setSel.has(name) || selectedRawEmps.some(sel => id.includes(String(sel).toLowerCase()) || name.includes(String(sel).toLowerCase()));
          });
        }

        const keySet = new Set();
        const deduped = [];
        filtered.forEach(r => {
          const key = `${getServerISO(r)}|${r.EmployeeID}|${r.Door}|${r.CardNumber}`;
          if (!keySet.has(key)) {
            keySet.add(key);
            deduped.push(r);
          }
        });

        await generateRawExcel(deduped, { region, location: selectedLocations && selectedLocations.join(',') || location, rawSearch, from, to, rawAdmitFilter });
        setLoading(false);
        return;
      }

      // ----- 2: Rejection -----
      if (tab === 2) {
        const params = { ...baseParams, startDate: formatLocalDate(from), endDate: formatLocalDate(to, true) };
        const resp = await axios.get('/api/reports/rejection', { params });
        const startDate = new Date(from); startDate.setHours(0, 0, 0, 0);
        const endDate = new Date(to); endDate.setHours(23, 59, 59, 999);
        const rowsSrc = (resp.data && resp.data.data) || [];
        const rows = rowsSrc.filter(r => {
          const date = r.DateOnly ? isoDateOnlyToLocalDate(r.DateOnly) : new Date(r.LocaleMessageTime);
          return date >= startDate && date <= endDate;
        });
        await generateRejectionExcel(rows);
        setLoading(false);
        return;
      }

      // ----- 3: EUROC Admit-Reject (single day) -----
      if (tab === 3) {
        if (region.toLowerCase() !== 'emea') {
          alert('EUROC report is only available for region EMEA. Please select EMEA.');
          setLoading(false);
          return;
        }
        if (!from) {
          alert('Please select a date (From) for EUROC report.');
          setLoading(false);
          return;
        }
        const dateParam = toLocalYMD(new Date(from));
        const params = { region: 'emea', date: dateParam };
        const resp = await axios.get('/api/reports/euroc-admit-rejection', { params });
        const { data } = resp.data || {};
        // ... rest of EUROC Excel generation (kept unchanged) ...
        setLoading(false);
        return;
      }

      // ----- 4: Time Duration -----
      if (tab === 4) {
        if (!from || !to) {
          alert('Please select both Start Date and End Date for Time Duration report.');
          setLoading(false);
          return;
        }
        const startParam = toLocalYMD(new Date(from));
        const endParam = toLocalYMD(new Date(to));
        const params = {
          region,
          startDate: startParam,
          endDate: endParam,
          partition: location ? location.split('.').pop() : 'Default'
        };
        const resp = await axios.get('/api/reports/time-duration', { params });
        await generateTimeDurationExcel(resp.data.data || []);
        setLoading(false);
        return;
      }

      // ----- 5: HeadCount / External navigation -----
      if (tab === 5) {
        const permCandidates = [`headcount.${region}`, 'headcount', 'global_access'];
        if (!auth.hasPermission(permCandidates)) {
          alert(`You do not have permission to view HeadCount for ${region.toUpperCase()}.`);
          setLoading(false);
          return;
        }

        let url = '';
        // ... unchanged navigation mapping ...
        if (url) window.location.href = url;
        else alert('Invalid region or location selected.');
        setLoading(false);
        return;
      }

      // ----- Denver Monthly (tab 6) -----
      if (tab === 6) {
        let useYear = null;
        let useMonth = null;
        if (from) {
          const d = new Date(from);
          useYear = d.getFullYear();
          useMonth = d.getMonth() + 1;
        } else {
          const dt = new Date();
          dt.setDate(1); dt.setHours(0,0,0,0);
          dt.setMonth(dt.getMonth() - 1);
          useYear = dt.getFullYear();
          useMonth = dt.getMonth() + 1;
        }

        try {
          setLoading(true);
          const resp = await axios.get('/api/reports/denver-attendance', {
            params: { year: useYear, month: useMonth },
            responseType: 'blob'
          });

          let filename = `denver_attendance_${useYear}${String(useMonth).padStart(2,'0')}.xlsx`;
          const cd = resp.headers['content-disposition'];
          if (cd) {
            const m = cd.match(/filename\*?=(?:UTF-8'')?["']?([^;"']+)/);
            if (m && m[1]) filename = decodeURIComponent(m[1]);
          }

          const blob = new Blob([resp.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
          const link = document.createElement('a');
          link.href = window.URL.createObjectURL(blob);
          link.download = filename;
          link.click();
        } catch (err) {
          console.error('Denver attendance download error', err);
          let msg = 'Failed to download Denver attendance report';
          if (err?.response?.data) {
            msg += `: ${err.response?.data?.detail || err.message || JSON.stringify(err.response.data)}`;
          } else if (err?.message) {
            msg += `: ${err.message}`;
          }
          alert(msg);
        } finally {
          setLoading(false);
        }
        return;
      }

    } catch (err) {
      console.error('handleGenerate error:', err);
      let msg = 'Failed to generate report';
      if (err?.response?.data) {
        const d = err.response.data;
        const serverMsg = (typeof d === 'string') ? d
                          : (d.error || d.message || JSON.stringify(d));
        msg += `: ${serverMsg}`;
      } else if (err?.message) {
        msg += `: ${err.message}`;
      }
      alert(msg);
    } finally {
      setLoading(false);
    }
  };

  // --- UI render ---
  const regionOptions = regionOptionsForTab();
  const locationOptions = locationOptionsForTab();

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ minHeight: '100vh', background: 'linear-gradient(180deg,#070707 0%, #111 100%)', color: '#fff' }}>
        {/* Topbar / Header (unchanged) */}
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            gap: 2,
            px: 3,
            py: 2,
            borderBottom: '1px solid rgba(255,204,0,0.08)',
            background: 'linear-gradient(90deg, rgba(20,20,20,0.7), rgba(0,0,0,0.4))'
          }}
        >
          <Avatar sx={{ bgcolor: '#000', border: '3px solid #FFCC00', width: 56, height: 56 }}>
            <Typography sx={{ color: '#FFCC00', fontWeight: 900 }}>WU</Typography>
          </Avatar>

          <Box sx={{ flex: 1 }}>
            <Typography variant="h5" sx={{ fontWeight: 900, letterSpacing: 0.6 }}>
              Global Security Operation Center
            </Typography>
            <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
              Reports & Exports — Secure access, fast insights
            </Typography>
          </Box>

          <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
            <Button
              startIcon={<DownloadIcon />}
              onClick={handleGenerate}
              disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
              sx={{
                bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                color: '#000',
                fontWeight: 800,
                px: 3,
                py: 1,
                borderRadius: 3,
                boxShadow: '0 6px 22px rgba(255,204,0,0.18)',
                transformOrigin: 'center',
                '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-2px)' : 'none' }
              }}
            >
              {loading ? 'Loading…'
                : (tab === 5 ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`) : 'Export to Excel')}
            </Button>
          </Box>
        </Box>

        {/* Main content */}
        <Grid container sx={{ px: 3, py: 4 }} spacing={3}>
          <Grid item xs={12} md={3}>
            <Paper elevation={8} sx={{ p: 2.5, borderRadius: 3, height: { xs: 'auto', md: 'calc(100vh - 150px)' }, overflow: 'auto', background: 'linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.015))', border: '1px solid rgba(255,204,0,0.06)' }}>
              <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
                <Box>
                  <Typography variant="subtitle1" sx={{ fontWeight: 800, color: '#FFCC00' }}>Filters</Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Narrow down by region, date and employees
                  </Typography>
                </Box>
                <IconButton size="small" sx={{ color: '#FFCC00' }}>
                  <FilterListIcon />
                </IconButton>
              </Box>

              <Divider sx={{ my: 1, borderColor: 'rgba(255,204,0,0.06)' }} />

              {/* Region - hide entirely on Denver (tab 6) */}
              {regionOptions.length > 0 && (
                <Box sx={{ mt: 1 }}>
                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Region</InputLabel>
                    <Select
                      value={region}
                      onChange={e => { setRegion(e.target.value); setLocation(''); }}
                      input={<OutlinedInput label="Region" />}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.24)' }
                      }}
                    >
                      {regionOptions.map(r => <MenuItem key={r} value={r}>{r.toUpperCase()}</MenuItem>)}
                    </Select>
                  </FormControl>
                </Box>
              )}

              {/* Location */}
              <Box sx={{ mt: 2 }}>
                <FormControl fullWidth>
                  <InputLabel sx={{ color: '#FFCC00' }}>Location</InputLabel>

                  {tab === 1 ? (
                    <Autocomplete
                      multiple
                      freeSolo={false}
                      options={availableLocations}
                      value={selectedLocations}
                      onChange={(e, v) => setSelectedLocations(v)}
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          placeholder="Choose 0..n locations (leave empty = all)"
                          InputLabelProps={{ style: { color: '#FFCC00' } }}
                          sx={{
                            '& .MuiInputBase-input': { color: '#fff' },
                            '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                          }}
                        />
                      )}
                      getOptionLabel={(opt) => String(opt)}
                      isOptionEqualToValue={(opt, val) => opt === val}
                      disabled={!region && tab !== 6}
                    />
                  ) : (
                    // For tabs other than Raw: use single-select, but hide for Denver (tab 6)
                    (tab !== 6) && (
                      <Select
                        value={location}
                        onChange={e => setLocation(e.target.value)}
                        input={<OutlinedInput label="Location" />}
                        disabled={(regionOptions.length === 0)}
                        sx={{
                          color: '#fff',
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.12)' }
                        }}
                      >
                        {locationOptions.length ? locationOptions.map(loc => (
                          <MenuItem key={loc} value={loc}>
                            {String(loc) === 'ALL_EMEA' ? 'ALL EMEA' : String(loc).split('.').pop()}
                          </MenuItem>
                        )) : ((LOCATION_MAP[region] || []).map(loc => (
                          <MenuItem key={loc} value={loc}>{String(loc).split('.').pop()}</MenuItem>
                        )))}
                      </Select>
                    )
                  )}
                </FormControl>
              </Box>

              <Divider sx={{ my: 2, borderColor: 'rgba(255,204,0,0.04)' }} />

              {/* Employee input area (Daily and Raw) */}
              {tab === 1 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employee (name or ID) — multiple
                  </Typography>

                  <Autocomplete
                    multiple
                    freeSolo
                    filterSelectedOptions
                    options={rawEmpOptions}
                    value={selectedRawEmps}
                    onChange={(e, v) => setSelectedRawEmps(v)}
                    onInputChange={async (e, value, reason) => {
                      if (empQueryRef.current) clearTimeout(empQueryRef.current);
                      if (!value || value.length < 2) {
                        empQueryRef.current = setTimeout(() => setRawEmpOptions([]), 150);
                        return;
                      }
                      empQueryRef.current = setTimeout(async () => {
                        try {
                          const params = { q: value };
                          if (region && region !== 'global') params.region = region;
                          const resp = await axios.get('/api/employees', { params });
                          const raw = (resp.data && (resp.data.data || resp.data)) || [];
                          const normalized = Array.isArray(raw) ? raw.map(item => {
                            if (typeof item === 'string') return item;
                            const id = item.EmployeeID || item.id || item.NumericEmployeeID || item.Employee || '';
                            const name = item.Name || item.name || item.ObjectName1 || '';
                            if (name && id) return `${name} (${id})`;
                            if (id) return String(id);
                            if (name) return String(name);
                            return JSON.stringify(item);
                          }) : [];
                          setRawEmpOptions(Array.from(new Set(normalized)));
                        } catch (err) {
                          console.warn('employee suggestions error', err);
                          setRawEmpOptions([]);
                        }
                      }, 300);
                    }}
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        placeholder="Type name or ID (2+ chars) — select multiple"
                        InputLabelProps={{ style: { color: '#FFCC00' } }}
                        sx={{
                          '& .MuiInputBase-input': { color: '#fff' },
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                        }}
                      />
                    )}
                    getOptionLabel={(opt) => (typeof opt === 'string' ? opt : (opt.label || opt.name || String(opt)))}
                    renderOption={(props, option) => <li {...props}>{typeof option === 'string' ? option : (option.label || option.name || String(option))}</li>}
                    ListboxProps={{ style: { maxHeight: 240 } }}
                  />

                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                    Leave empty to export all raw rows for the date range. Type 2+ chars to get suggestions for employee names or IDs.
                  </Typography>

                  <Box sx={{ mt: 2 }}>
                    <FormControl fullWidth>
                      <InputLabel sx={{ color: '#FFCC00' }}>Admit / Reject</InputLabel>
                      <Select
                        value={rawAdmitFilter}
                        onChange={(e) => setRawAdmitFilter(e.target.value)}
                        input={<OutlinedInput label="Admit / Reject" />}
                        sx={{
                          color: '#fff',
                          '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                        }}
                      >
                        <MenuItem value="all">All (Admitted + Rejected)</MenuItem>
                        <MenuItem value="admit">Admitted only</MenuItem>
                        <MenuItem value="reject">Rejected only</MenuItem>
                      </Select>
                    </FormControl>
                    <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.55)', mt: 1, display: 'block' }}>
                      Default = All.
                    </Typography>
                  </Box>
                </Box>
              )}

              {/* Dates (shown for all tabs except external navigation tab 5) */}
              {tab !== 5 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Date Range
                  </Typography>
                  <Box sx={{ display: 'grid', gap: 1.25 }}>
                    <TextField
                      label={tab === 0 ? 'From Date' : 'Start Date'}
                      value={from ? from.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowFromCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                    <TextField
                      label={tab === 0 ? 'To Date' : 'End Date'}
                      value={to ? to.toLocaleDateString() : ''}
                      readOnly
                      onClick={() => setShowToCal(true)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                    />
                  </Box>

                  {showFromCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={from}
                        onChange={(newValue) => setFrom(newValue)}
                        onAccept={() => setShowFromCal(false)}
                        onClose={() => setShowFromCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                  {showToCal && (
                    <Box sx={{ mt: 1 }}>
                      <StaticDatePicker
                        displayStaticWrapperAs="desktop"
                        value={to}
                        onChange={(newValue) => setTo(newValue)}
                        onAccept={() => setShowToCal(false)}
                        onClose={() => setShowToCal(false)}
                        renderInput={(params) => <TextField {...params} />}
                        views={['year', 'month', 'day']}
                      />
                    </Box>
                  )}
                </Box>
              )}

              {/* Daily employees block */}
              {tab === 0 && (
                <Box sx={{ mt: 2 }}>
                  <Typography sx={{ color: 'rgba(255,255,255,0.7)', mb: 1, fontWeight: 700 }}>
                    Employees
                  </Typography>

                  <Box sx={{ display: 'flex', gap: 1, mb: 1 }}>
                    <TextField
                      fullWidth
                      placeholder="Add name or ID (e.g. 'Vainilaitis, Valdas' or '323471')"
                      value={newEmployee}
                      onChange={(e) => setNewEmployee(e.target.value)}
                      sx={{
                        '& .MuiInputBase-input': { color: '#fff' },
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.08)' }
                      }}
                      InputLabelProps={{ style: { color: '#FFCC00' } }}
                    />
                    <Button
                      variant="contained"
                      onClick={() => {
                        const v = (newEmployee || '').toString().trim();
                        if (!v) return;
                        if (!selectedEmps.includes(v)) {
                          setSelectedEmps(prev => [...prev, v]);
                        }
                        setNewEmployee('');
                      }}
                      sx={{
                        bgcolor: '#FFCC00',
                        color: '#000',
                        fontWeight: 800,
                        px: 2,
                        '&:hover': { bgcolor: '#ffd84d' }
                      }}
                    >
                      Add
                    </Button>
                  </Box>

                  <FormControl fullWidth>
                    <InputLabel sx={{ color: '#FFCC00' }}>Employees</InputLabel>

                    <Select
                      multiple
                      value={selectedEmps}
                      onChange={e => setSelectedEmps(e.target.value)}
                      input={<OutlinedInput label="Employees" />}
                      renderValue={vals => vals.join(', ')}
                      sx={{
                        color: '#fff',
                        '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(255,204,0,0.06)' }
                      }}
                    >
                      {[
                        ...EMPLOYEE_OPTIONS,
                        ...selectedEmps.filter(s => !EMPLOYEE_OPTIONS.includes(s))
                      ].map(n => (
                        <MenuItem key={n} value={n}>
                          <Checkbox checked={selectedEmps.includes(n)} />
                          <ListItemText primary={n} />
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Box>
              )}

              <Box sx={{ mt: 3, p: 2, borderRadius: 2, background: 'rgba(255,255,255,0.02)' }}>
                <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                  Tip: For daily exports pick employees & a single day range. For Time Duration choose the required partition via Location.
                </Typography>
              </Box>
            </Paper>
          </Grid>

          {/* Main panel */}
          <Grid item xs={12} md={9}>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              <Paper elevation={3} sx={{ px: 2, py: 1, borderRadius: 2, display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: 2, border: '1px solid rgba(255,204,0,0.04)' }}>
                <Tabs value={tab} onChange={handleTabChange} sx={{ '& .MuiTab-root': { textTransform: 'none', minWidth: 120, fontWeight: 700, color: 'rgba(255,255,255,0.8)' }, '& .Mui-selected': { color: '#FFCC00' } }}>
                  <Tab icon={<CalendarTodayIcon />} label="Daily Access" />
                  <Tab icon={<PeopleIcon />} label="Raw" />
                  <Tab icon={<PlaceIcon />} label="Rejection" />
                  <Tab icon={<PeopleIcon />} label="EUROC Admit-Reject" />
                  <Tab icon={<CalendarTodayIcon />} label="Time Duration" />
                  <Tab icon={<PeopleIcon />} label="HeadCount" />
                  <Tab icon={<PeopleIcon />} label="Denver Monthly" />
                </Tabs>

                <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
                  <Button variant="text" startIcon={<FilterListIcon />} sx={{ color: 'rgba(255,255,255,0.65)', textTransform: 'none' }} onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}>
                    Reset View
                  </Button>
                </Box>
              </Paper>

              <Paper elevation={6} sx={{ p: 3, borderRadius: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 2 }}>
                <Box>
                  <Typography variant="h6" sx={{ fontWeight: 900 }}>Export Center</Typography>
                  <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.7)' }}>
                    Selected Region: <strong style={{ color: '#FFCC00' }}>{region ? region.toUpperCase() : '—'}</strong> {location ? `• ${location === 'ALL_EMEA' ? 'ALL EMEA' : location.split('.').pop()}` : ''}
                  </Typography>
                  <Typography variant="caption" sx={{ color: 'rgba(255,255,255,0.6)' }}>
                    Choose tab, select filters and export reports in Excel.
                  </Typography>
                </Box>

                <Box>
                  <Button
                    startIcon={loading ? <CircularProgress size={20} /> : <DownloadIcon />}
                    disabled={tab === 5 ? navDisabled || !exportAllowed : disabled || !exportAllowed}
                    onClick={handleGenerate}
                    sx={{
                      bgcolor: exportAllowed ? '#FFCC00' : 'rgba(255,204,0,0.24)',
                      color: '#000',
                      fontWeight: 900,
                      px: 4,
                      py: 1,
                      borderRadius: 3,
                      boxShadow: '0 8px 30px rgba(255,204,0,0.22)',
                      '&:hover': { bgcolor: exportAllowed ? '#ffd84d' : 'rgba(255,204,0,0.24)', transform: exportAllowed ? 'translateY(-3px)' : 'none' }
                    }}
                  >
                    {loading
                      ? 'Loading…'
                      : (tab === 5
                          ? (location ? `Navigate ${location.split('.').pop()}` : `Navigate ${region.toUpperCase()}`)
                          : 'Export to Excel')}
                  </Button>
                </Box>
              </Paper>
            </Box>
          </Grid>
        </Grid>
      </Box>
    </LocalizationProvider>
  );
}


