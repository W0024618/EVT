Good Now Above File Works perfect Now I Want to Calculate Average Quter Wise 
Add Column after 3 Month Q1 Avg and calculate Average for Each Employee using Attendance data 
Please find below Quater Details Carefully ..
also Apply All Border and All Thick outside Border for excel Sheet only and share me Fully updated file .
below File Working exactely as per Requirnment so dont make unnecessary changes ....
make only Necessary changes ...

Q1: January 1 – March 31
Q2: April 1 – June 30
Q3: July 1 – September 30
Q4: October 1 – December 31

after 31st march add Q1 Avg column 
after 30 june add Q1 Avg Column 
....like ...




# Updated denverAttendance.py
# Changes implemented:
# - Interleave monthly "Mon Total" columns after each month's day columns in header (e.g., Jan Total).
# - Date header formatted as "Wed, 1 January, 2025".
# - Weekend (Sat/Sun) columns highlighted with light red background.
# - Presence cells: 1 => green background, 0 => light red background.
# - Month total and Grand total columns/rows use light yellow background.
# - All cells aligned center.
# - Removed any stray/garbled rows; only employee rows + monthly totals + grand total are written.
# - Kept original DB fetching & dedupe logic intact.
#
# Note: This file depends on sqlalchemy, pandas, xlsxwriter. It writes an xlsx file and returns its path.

import os
from datetime import date, datetime, timedelta
from pathlib import Path
import pandas as pd
import re

ODBC_DRIVER = os.getenv("ODBC_DRIVER", "ODBC Driver 17 for SQL Server")
DB_SERVER = os.getenv("DB_SERVER", "SRVWUDEN0890V")
DB_USER = os.getenv("DB_USER", "GSOC_Test")
DB_PASSWORD = os.getenv("DB_PASSWORD", "Westernuniongsoc@2025")

DB_LIST = [
    "ACVSUJournal_00010021",
    "ACVSUJournal_00010020",
    "ACVSUJournal_00010019",
]

SQL_TEMPLATE = r"""
SELECT
    t1.[ObjectName1] AS EmployeeName,
    t1.[ObjectName2] AS Door,
    CASE WHEN t2.[Int1] = 0 THEN t2.[Text12] ELSE CAST(t2.[Int1] AS NVARCHAR(200)) END AS EmployeeID,
    t3.[Name] AS PersonnelTypeName,
    CAST(t1.ObjectIdentity1 AS NVARCHAR(200)) AS EmployeeIdentity,
    t1.PartitionName2,
    DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC]) AS LocaleMessageTime,
    t2.Text5 AS PrimaryLocation,
    CASE
        WHEN t1.[ObjectName2] LIKE '%HQ%' THEN 'Denver'
        WHEN t1.[ObjectName2] LIKE '%Austin%' THEN 'Austin'
        WHEN t1.[ObjectName2] LIKE '%Miami%' THEN 'Miami'
        WHEN t1.[ObjectName2] LIKE '%NYC%' THEN 'New York'
        WHEN t1.[ObjectName2] LIKE 'APAC_PI%' THEN 'Taguig City'
        WHEN t1.[ObjectName2] LIKE 'APAC_PH%' THEN 'Quezon City'
        WHEN t1.[ObjectName2] LIKE '%PUN%' THEN 'Pune'
        WHEN t1.[ObjectName2] LIKE '%HYD%' THEN 'Hyderabad'
        ELSE t1.[PartitionName2]
    END AS LogicalLocation
FROM [{db}].dbo.ACVSUJournalLog AS t1
INNER JOIN ACVSCore.Access.Personnel AS t2 ON t1.ObjectIdentity1 = t2.GUID
INNER JOIN ACVSCore.Access.PersonnelType AS t3 ON t2.PersonnelTypeID = t3.ObjectID
WHERE
    t1.MessageType = 'CardAdmitted'
    AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.[MessageLocaleOffset], t1.[MessageUTC])) BETWEEN '{start}' AND '{end}'
    AND (
        t1.[ObjectName2] LIKE '%HQ%'
        OR (t2.Text5 IS NOT NULL AND LOWER(t2.Text5) LIKE '%denver%' AND LOWER(t2.Text5) LIKE '%hq%')
        OR t1.[PartitionName2] = 'Denver'
    )
    AND LOWER(LTRIM(RTRIM(t3.[Name]))) IN ('employee','terminated personnel')
"""

def _get_engine(database: str) -> 'sqlalchemy.engine.Engine':
    from sqlalchemy import create_engine
    from urllib.parse import quote_plus
    odbc_str = (
        f"DRIVER={{{ODBC_DRIVER}}};"
        f"SERVER={DB_SERVER};"
        f"DATABASE={database};"
        f"UID={DB_USER};"
        f"PWD={DB_PASSWORD};"
        "TrustServerCertificate=Yes;Connection Timeout=30;"
    )
    quoted = quote_plus(odbc_str)
    url = f"mssql+pyodbc:///?odbc_connect={quoted}"
    return create_engine(url, pool_pre_ping=True, fast_executemany=True)

def _fetch_swipes_between(start_date: date, end_date: date) -> pd.DataFrame:
    start_s = start_date.strftime("%Y-%m-%d")
    end_s = end_date.strftime("%Y-%m-%d")
    frames = []
    for db in DB_LIST:
        sql = SQL_TEMPLATE.format(db=db, start=start_s, end=end_s)
        try:
            engine = _get_engine(db)
            with engine.connect() as conn:
                df = pd.read_sql(sql, conn)
            if not df.empty:
                df["SourceDB"] = db
                frames.append(df)
        except Exception:
            # keep going if a DB can't be reached
            continue
    if not frames:
        return pd.DataFrame()
    out = pd.concat(frames, ignore_index=True)
    out.columns = [c.strip() for c in out.columns]
    out["LocaleMessageTime"] = pd.to_datetime(out.get("LocaleMessageTime"), errors="coerce")
    return out

def generate_monthly_denver_report(start_date: date = None, end_date: date = None, outdir: str = None) -> str:
    if start_date is None:
        start_date = date(2025, 1, 1)
    if end_date is None:
        end_date = datetime.now().date()
    swipes = _fetch_swipes_between(start_date, end_date)

    # Deduplicate and filter (keep original logic intent)
    swipes["DateOnly"] = swipes["LocaleMessageTime"].dt.date.fillna(pd.NaT)
    def _dedupe_key(row):
        for col in ("EmployeeIdentity", "EmployeeID", "EmployeeName"):
            val = str(row.get(col)).strip() if row.get(col) else None
            if val and val.lower() not in ('', 'nan', 'none', 'null'):
                return val
        return None
    if swipes.empty:
        # prepare empty but valid xlsx with header layout
        ordered_days = []
        cur = start_date
        while cur <= end_date:
            ordered_days.append(cur)
            cur += timedelta(days=1)
        # still create file with headers
        return _write_excel([], ordered_days, {}, outdir, start_date, end_date)

    swipes["dedupe_key"] = swipes.apply(_dedupe_key, axis=1)
    swipes = swipes[swipes["dedupe_key"].notna()]
    swipes = swipes[swipes["PersonnelTypeName"].str.strip().str.lower().isin(["employee", "terminated personnel"])]
    swipes = swipes[swipes["LogicalLocation"].str.strip().str.lower() == "denver"]
    swipes = swipes.sort_values(["dedupe_key", "DateOnly", "LocaleMessageTime"], ascending=[True, True, False])
    swipes = swipes.drop_duplicates(subset=["dedupe_key", "DateOnly"], keep="first")

    # ordered days list
    ordered_days = []
    cur = start_date
    while cur <= end_date:
        ordered_days.append(cur)
        cur += timedelta(days=1)

    # presence matrix (index = dedupe_key, columns = date objects)
    presence = pd.DataFrame(0, index=sorted(swipes["dedupe_key"].unique()), columns=ordered_days)
    for _, r in swipes.iterrows():
        uid = r["dedupe_key"]
        d = r["DateOnly"]
        if pd.isna(d):
            continue
        try:
            presence.at[uid, d] = 1
        except Exception:
            continue

    meta = swipes.groupby("dedupe_key", as_index=True).agg({
        "EmployeeName": "first",
        "EmployeeID": "first",
        "PersonnelTypeName": "first"
    })

    # Build rows (list of dicts)
    rows = []
    for uid in sorted(meta.index):
        empid = meta.loc[uid, "EmployeeID"]
        empname = meta.loc[uid, "EmployeeName"]
        row = {"Emp ID": empid, "Emp Name": empname}
        for d in ordered_days:
            key = d.strftime("%Y-%m-%d")
            value = int(presence.at[uid, d]) if (uid in presence.index and d in presence.columns) else 0
            row[key] = value
        rows.append(row)
    df = pd.DataFrame(rows)

    # Create months mapping maintaining chronological order
    months = {}
    for d in ordered_days:
        mon_key = d.strftime("%b")  # e.g., Jan, Feb
        months.setdefault(mon_key, []).append(d.strftime("%Y-%m-%d"))

    return _write_excel(df, ordered_days, months, outdir, start_date, end_date)

def _write_excel(df, ordered_days, months, outdir, start_date, end_date):
    """
    df: DataFrame with columns 'Emp ID', 'Emp Name', and day columns named 'YYYY-MM-DD'
    ordered_days: list of date objects (chronological)
    months: dict mapping month short name -> list of 'YYYY-MM-DD' strings
    """
    outdir = Path(outdir or Path.cwd() / "output")
    outdir.mkdir(parents=True, exist_ok=True)
    fname = outdir / f"denver_attendance_{start_date.strftime('%Y%m%d')}_{end_date.strftime('%Y%m%d')}.xlsx"

    import xlsxwriter
    workbook = xlsxwriter.Workbook(str(fname))
    worksheet = workbook.add_worksheet("Attendance")
    worksheet.hide_gridlines(2)

    # Formats
    header_fmt = workbook.add_format({"bold": True, "border": 1, "align": "center", "valign": "vcenter", "bg_color": "#87CEEB"})
    center_fmt = {"border": 1, "align": "center", "valign": "vcenter"}

    cell_fmt = workbook.add_format({**center_fmt})
    present_fmt = workbook.add_format({**center_fmt, "bg_color": "#C6EFCE"})     # light green
    absent_fmt = workbook.add_format({**center_fmt, "bg_color": "#FFC7CE"})      # light red for absent
    weekend_header_fmt = workbook.add_format({**center_fmt, "bg_color": "#FFDADA", "bold": True})
    weekend_cell_fmt = workbook.add_format({**center_fmt, "bg_color": "#FFDADA"})
    month_total_header_fmt = workbook.add_format({**center_fmt, "bg_color": "#FFEB9C", "bold": True})
    month_total_cell_fmt = workbook.add_format({**center_fmt, "bg_color": "#FFEB9C"})
    grand_total_fmt = workbook.add_format({**center_fmt, "bg_color": "#FFEB9C", "bold": True})
    empname_fmt = workbook.add_format({**center_fmt})

    # Build final columns in desired order: Emp ID, Emp Name, [Jan days..., Jan Total], [Feb days..., Feb Total], ..., Grand Total
    final_columns = ["Emp ID", "Emp Name"]
    month_order = list(months.keys())
    # Ensure months are in chronological order by scanning ordered_days
    # Build ordered month list by unique month abbrev in ordered_days
    seen = []
    for d in ordered_days:
        m = d.strftime("%b")
        if m not in seen:
            seen.append(m)
    month_order = seen

    month_day_lists = [months[m] for m in month_order]

    for m, day_list in zip(month_order, month_day_lists):
        final_columns.extend(day_list)
        final_columns.append(f"{m} Total")
    final_columns.append("Grand Total")

    # Write header row with formatted date strings
    for col_idx, col_name in enumerate(final_columns):
        if re.match(r"\d{4}-\d{2}-\d{2}", str(col_name)):
            # parse date string to nice format: "Wed, 1 January, 2025"
            d = datetime.strptime(col_name, "%Y-%m-%d").date()
            # Weekday short name (Mon/Tue...) or full? user wanted like "Wed, 1 January, 2025"
            header_label = f"{d.strftime('%a')}, {d.day} {d.strftime('%B')}, {d.year}"
            # Highlight weekend headers
            if d.weekday() >= 5:  # Sat=5, Sun=6
                worksheet.write(0, col_idx, header_label, weekend_header_fmt)
            else:
                worksheet.write(0, col_idx, header_label, header_fmt)
        elif col_name.endswith("Total"):
            # month total or grand total header
            worksheet.write(0, col_idx, col_name, month_total_header_fmt)
        else:
            worksheet.write(0, col_idx, col_name, header_fmt)

    # Set column widths a bit
    worksheet.set_column(0, 0, 15)  # Emp ID
    worksheet.set_column(1, 1, 30)  # Emp Name
    # other columns set to small width
    worksheet.set_column(2, len(final_columns)-1, 12)

    # Write employee rows
    if isinstance(df, (list, tuple)):
        df_rows = []
    else:
        df_rows = df.to_dict(orient="records") if not df.empty else []

    start_row = 1
    for r_idx, row in enumerate(df_rows):
        excel_row = start_row + r_idx
        # Emp ID and name
        worksheet.write(excel_row, 0, row.get("Emp ID"), empname_fmt)
        worksheet.write(excel_row, 1, row.get("Emp Name"), empname_fmt)
        # iterate months/days in same order as header
        col_ptr = 2
        for m, day_list in zip(month_order, month_day_lists):
            for day in day_list:
                val = int(row.get(day, 0) or 0)
                # If weekend column
                d = datetime.strptime(day, "%Y-%m-%d").date()
                if val == 1:
                    # present -> green even on weekends (user wanted green for present)
                    worksheet.write(excel_row, col_ptr, val, present_fmt)
                else:
                    # absent -> if weekend, light red (weekend highlight), else absent red
                    if d.weekday() >= 5:
                        worksheet.write(excel_row, col_ptr, val, weekend_cell_fmt)
                    else:
                        worksheet.write(excel_row, col_ptr, val, absent_fmt)
                col_ptr += 1
            # month total per employee
            month_total = sum(int(row.get(day, 0) or 0) for day in day_list)
            worksheet.write(excel_row, col_ptr, month_total, month_total_cell_fmt)
            col_ptr += 1

        # Grand total per employee
        # sum across all date columns
        all_date_cols = [c for c in row.keys() if re.match(r"\d{4}-\d{2}-\d{2}", str(c))]
        grand = sum(int(row.get(day, 0) or 0) for day in all_date_cols)
        worksheet.write(excel_row, col_ptr, grand, grand_total_fmt)

    # After all employees, write monthly totals row(s) (one row that summarizes column sums)
    summary_row = start_row + len(df_rows)  # next empty row
    # label cell: use "Total" as requested (no month-year suffix). To avoid repeated identical labels being confusing,
    # we will prefix with blank row and then write per-month totals with appropriate first col label "Total".
    worksheet.write(summary_row, 0, "Total", month_total_header_fmt)
    worksheet.write(summary_row, 1, "", month_total_header_fmt)
    col_ptr = 2
    for m, day_list in zip(month_order, month_day_lists):
        for day in day_list:
            # compute column sum for day
            if isinstance(df, (list, tuple)) or df.empty:
                day_sum = 0
            else:
                day_sum = int(df.get(day, pd.Series(dtype=int)).sum())
            # weekend header style for sum? treat as month total cell style for visibility
            d = datetime.strptime(day, "%Y-%m-%d").date()
            if d.weekday() >= 5:
                worksheet.write(summary_row, col_ptr, day_sum, month_total_cell_fmt)
            else:
                worksheet.write(summary_row, col_ptr, day_sum, month_total_cell_fmt)
            col_ptr += 1
        # write month total (sum of day sums)
        if isinstance(df, (list, tuple)) or df.empty:
            msum = 0
        else:
            msum = int(df[[d for d in day_list]].sum(axis=1).sum())
        worksheet.write(summary_row, col_ptr, msum, month_total_cell_fmt)
        col_ptr += 1

    # Final grand total cell (sum of all day columns)
    grand_col_idx = len(final_columns) - 1
    # compute grand total (sum of all day columns in df)
    if isinstance(df, (list, tuple)) or df.empty:
        grand_total_val = 0
    else:
        day_cols = [c for c in df.columns if re.match(r"\d{4}-\d{2}-\d{2}", c)]
        grand_total_val = int(df[day_cols].sum(axis=1).sum()) if day_cols else 0
    worksheet.write(summary_row, grand_col_idx, grand_total_val, grand_total_fmt)

    # Optional: Freeze header row
    worksheet.freeze_panes(1, 2)

    workbook.close()
    return str(fname)

if __name__ == "__main__":
    # quick local test path generation (won't connect to DB when run without DB)
    path = generate_monthly_denver_report()
    print("Wrote:", path)
