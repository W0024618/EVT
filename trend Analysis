(.venv) PS C:\Users\W0024618\Desktop\Trend Analysis\backend> python app.py
WARNING:root:Historical profile file current_analysis.csv not found; history-based scenarios will fallback.
 * Serving Flask app 'app'
 * Debug mode: on
INFO:werkzeug:WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Running on all addresses (0.0.0.0)
 * Running on http://127.0.0.1:8002
 * Running on http://10.199.46.101:8002
INFO:werkzeug:Press CTRL+C to quit
INFO:werkzeug: * Restarting with stat
WARNING:root:Historical profile file current_analysis.csv not found; history-based scenarios will fallback.
WARNING:werkzeug: * Debugger is active!
INFO:werkzeug: * Debugger PIN: 134-209-644
C:\Users\W0024618\Desktop\Trend Analysis\backend\trend_runner.py:112: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.
  grouped = gb.apply(agg_swipe_group).reset_index()
INFO:werkzeug:10.199.46.101 - - [27/Oct/2025 17:49:55] "GET /run?date=2025-10-26 HTTP/1.1" 200 -
C:\Users\W0024618\Desktop\Trend Analysis\backend\trend_runner.py:112: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.
  grouped = gb.apply(agg_swipe_group).reset_index()
INFO:werkzeug:10.199.46.101 - - [27/Oct/2025 17:50:16] "GET /run?date=2025-09-01 HTTP/1.1" 200 -
INFO:werkzeug:10.199.46.101 - - [27/Oct/2025 17:50:40] "GET /latest HTTP/1.1" 200 -






check frontend console details 

react-dom.development.js:29905 Download the React DevTools for a better development experience: https://reactjs.org/link/react-devtools
babel.min.js:24 You are using the in-browser Babel transformer. Be sure to precompile your scripts for production - https://babeljs.io/docs/setup/
u @ babel.min.js:24
react-dom.development.js:73 Warning: ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot
printWarning @ react-dom.development.js:73
Inline Babel script:109 SyntaxError: Unexpected token 'N', ..."anyName": NaN,
     "... is not valid JSON
loadLatest @ Inline Babel script:109




<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Trend Analysis — Dashboard</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- React + ReactDOM + Babel (for quick prototyping) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      body { font-family: Inter, Roboto, Arial, sans-serif; margin: 0; padding: 0; background:#f6f7fb; color:#1f2937; }
      .container { max-width:1200px; margin:24px auto; padding:20px; background:#fff; border-radius:8px; box-shadow:0 6px 18px rgba(16,24,40,0.06);}
      header { display:flex; align-items:center; justify-content:space-between; gap:12px; }
      header h1 { margin:0; font-size:20px; }
      .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
      input[type="date"] { padding:8px; border-radius:6px; border:1px solid #e2e8f0; }
      button { padding:8px 12px; border-radius:6px; border:0; background:#2563eb; color:#fff; cursor:pointer; }
      button.secondary { background:#64748b; }
      .cards { display:flex; gap:12px; margin-top:16px; }
      .card { flex:1; background:#f8fafc; padding:12px; border-radius:8px; text-align:center; }
      .card h3 { margin:4px 0; font-size:18px; }
      .card p { margin:0; color:#6b7280; }
      .main { display:flex; gap:18px; margin-top:18px; }
      .left { flex: 2; }
      .right { flex: 1; }
      .chart-wrap { background:#fff; padding:10px; border-radius:8px; box-shadow: inset 0 0 0 1px #f1f5f9; }
      table { width:100%; border-collapse:collapse; margin-top:12px; }
      th, td { padding:8px 6px; border-bottom:1px solid #eef2f7; font-size:13px; }
      th { background:#fafafa; position:sticky; top:0; z-index:1; text-align:left; }
      .small { font-size:12px; color:#475569; }
      .pill { display:inline-block; padding:4px 8px; border-radius:999px; background:#e6f2ff; color:#075985; font-size:12px; }
      .searchbar { margin-top:12px; display:flex; gap:8px; align-items:center; }
      .searchbar input { padding:8px; border-radius:6px; border:1px solid #e2e8f0; width:240px;}
      .pagination { margin-top:10px; display:flex; gap:8px; align-items:center; }
      .muted { color:#64748b; font-size:13px; }
      pre { white-space:pre-wrap; word-wrap:break-word; background:#0f172a; color:#fff; padding:12px; border-radius:8px; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const {useState, useRef} = React;

      // CONFIG: API host (change if your flask server is elsewhere)
      const API_BASE = "http://10.199.46.101:8002";

      function formatDateISO(d) {
        if (!d) return "";
        const pad = (n) => n.toString().padStart(2,'0');
        return d.getFullYear() + "-" + pad(d.getMonth()+1) + "-" + pad(d.getDate());
      }

      function datesBetween(start, end) {
        var out = [];
        var cur = new Date(start);
        while (cur <= end) {
          out.push(new Date(cur));
          cur.setDate(cur.getDate()+1);
        }
        return out;
      }

      function safeDateDisplay(dateStrOrObj) {
        if (!dateStrOrObj && dateStrOrObj !== 0) return "";
        try {
          var d = (dateStrOrObj instanceof Date) ? dateStrOrObj : new Date(dateStrOrObj);
          if (isNaN(d.getTime())) return String(dateStrOrObj);
          return d.toLocaleString();
        } catch (e) {
          return String(dateStrOrObj);
        }
      }

      function App() {
        var yesterday = new Date();
        yesterday.setDate(yesterday.getDate()-1);

        const [dateFrom, setDateFrom] = useState(formatDateISO(yesterday));
        const [dateTo, setDateTo] = useState(formatDateISO(new Date()));
        const [loading, setLoading] = useState(false);
        const [summary, setSummary] = useState({rows:0, flagged_rows:0, files:[], end_date:null});
        const [rows, setRows] = useState([]);
        const [reasonsCount, setReasonsCount] = useState({});
        const [filterText, setFilterText] = useState("");
        const [page, setPage] = useState(1);
        const pageSize = 25;
        const chartRef = useRef(null);
        const chartInst = useRef(null);

        async function runForRange() {
          setLoading(true);
          setRows([]);
          setSummary({rows:0, flagged_rows:0, files:[], end_date:null});
          setReasonsCount({});
          try {
            var start = new Date(dateFrom);
            var end = new Date(dateTo);
            var dates = datesBetween(start, end).map(d => formatDateISO(d));
            var accRows = [];
            var totalRows = 0, totalFlagged = 0, files = [];
            for (var i=0;i<dates.length;i++) {
              var d = dates[i];
              var url = API_BASE + "/run?date=" + d;
              var r = await fetch(url, {method:'GET'});
              if (!r.ok) {
                var text = await r.text();
                throw new Error("API returned " + r.status + ": " + text);
              }
              var js = await r.json();
              var sample = js.sample || [];
              if (Array.isArray(sample) && sample.length) {
                accRows = accRows.concat(sample);
              }
              // handle rows possibly missing
              if (typeof js.rows === 'number') {
                totalRows += js.rows;
              } else {
                totalRows += (Array.isArray(sample) ? sample.length : 0);
              }
              totalFlagged += (js.flagged_rows || 0);
              if (js.files) files = files.concat(js.files);
            }

            setRows(accRows);
            setSummary({rows: totalRows, flagged_rows: totalFlagged, files: files, end_date: formatDateISO(end)});
            computeReasons(accRows);
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message);
            console.error(err);
          } finally {
            setLoading(false);
          }
        }

        async function loadLatest() {
          setLoading(true);
          try {
            var r = await fetch(API_BASE + "/latest");
            if (!r.ok) throw new Error("latest failed: " + r.status);
            var js = await r.json();
            var sample = js.sample || [];
            setRows(sample);
            setSummary({rows: (js.rows || sample.length || 0), flagged_rows: (sample.filter(function(x){return !!x.Reasons}).length || 0), files:[js.file]});
            computeReasons(sample);
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message);
            console.error(err);
          } finally {
            setLoading(false);
          }
        }

        function computeReasons(dataRows) {
          var counts = {};
          (dataRows || []).forEach(function(r){
            if (!r.Reasons) return;
            var parts = String(r.Reasons).split(";").map(function(s){return s.trim()}).filter(Boolean);
            parts.forEach(function(p){ counts[p] = (counts[p] || 0) + 1; });
          });
          setReasonsCount(counts);
          buildChart(counts);
        }

        function buildChart(counts) {
          var labels = Object.keys(counts).sort(function(a,b){return counts[b]-counts[a]});
          var values = labels.map(function(l){return counts[l]});
          var ctx = chartRef.current && chartRef.current.getContext ? chartRef.current.getContext('2d') : null;
          if (!ctx) return;
          try { if (chartInst.current) chartInst.current.destroy(); } catch(e){}
          chartInst.current = new Chart(ctx, {
            type:'bar',
            data:{ labels: labels, datasets:[{ label:'Events', data:values, backgroundColor:'rgba(37,99,235,0.8)' }]},
            options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{y:{beginAtZero:true}} }
          });
        }

        // table helpers
        var filtered = (rows || []).filter(function(r){
          if (!filterText) return true;
          var s = filterText.toLowerCase();
          var hay = (String(r.EmployeeName||"") + " " + String(r.EmployeeName_x||"") + " " + String(r.EmployeeName_y||"") + " " + String(r.EmployeeID||"") + " " + String(r.CardNumber||"") + " " + String(r.Reasons||"")).toLowerCase();
          return hay.indexOf(s) !== -1;
        });
        var totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
        var pageRows = filtered.slice((page-1)*pageSize, page*pageSize);

        function exportCSV() {
          if (!rows || !rows.length) { alert("No data to export"); return; }
          var cols = Object.keys(rows[0]);
          var lines = [cols.join(",")];
          rows.forEach(function(r){
            var row = cols.map(function(c){
              var v = (r[c] === undefined || r[c] === null) ? "" : String(r[c]).replace(/\n/g,' ');
              return JSON.stringify(v);
            }).join(",");
            lines.push(row);
          });
          var csv = lines.join("\n");
          var blob = new Blob([csv], {type:'text/csv'});
          var url = URL.createObjectURL(blob);
          var a = document.createElement('a'); a.href = url; a.download = 'trend_export.csv'; a.click(); URL.revokeObjectURL(url);
        }

        // Small convenience: compute displayed counts for cards
        var rowsCount = (summary && typeof summary.rows === 'number') ? summary.rows : (rows ? rows.length : 0);
        var flaggedCount = (summary && typeof summary.flagged_rows === 'number') ? summary.flagged_rows : (rows ? rows.filter(function(r){return !!r.Reasons}).length : 0);
        var flaggedPct = rowsCount ? Math.round((flaggedCount*100)/(rowsCount||1)) : 0;

        return (
          <div className="container">
            <header>
              <h1>Trend Analysis — Pune (High level)</h1>
              <div className="controls">
                <label className="small">From</label>
                <input type="date" value={dateFrom} onChange={function(e){ setDateFrom(e.target.value); }} />
                <label className="small">To</label>
                <input type="date" value={dateTo} onChange={function(e){ setDateTo(e.target.value); }} />
                <button onClick={runForRange} disabled={loading}>{loading ? 'Running...' : 'Run (date/range)'}</button>
                <button className="secondary" onClick={loadLatest}>Load latest</button>
                <button className="secondary" onClick={exportCSV}>Export CSV</button>
              </div>
            </header>

            <div className="cards">
              <div className="card">
                <h3>{ (rowsCount !== undefined && rowsCount !== null) ? rowsCount : 0 }</h3>
                <p>Rows analysed</p>
              </div>
              <div className="card">
                <h3>{ (flaggedCount !== undefined && flaggedCount !== null) ? flaggedCount : 0 }</h3>
                <p>Flagged rows</p>
              </div>
              <div className="card">
                <h3>{ flaggedPct }%</h3>
                <p>Flagged rate</p>
              </div>
            </div>

            <div className="main">
              <div className="left">
                <div className="chart-wrap" style={{height:240}}>
                  <canvas ref={chartRef}></canvas>
                </div>

                <div className="searchbar">
                  <input placeholder="Search name, employee id, card or reason..." value={filterText} onChange={function(e){ setFilterText(e.target.value); setPage(1); }} />
                  <div className="muted">Showing {filtered.length} / {rows.length} rows</div>
                </div>

                <table>
                  <thead>
                    <tr>
                      <th>Employee</th>
                      <th className="small">ID</th>
                      <th className="small">Card</th>
                      <th className="small">Date</th>
                      <th className="small">Duration</th>
                      <th className="small">Reasons</th>
                      <th className="small">Overlap</th>
                    </tr>
                  </thead>
                  <tbody>
                    {pageRows.map(function(r, idx) {
                      var empName = r.EmployeeName || r.EmployeeName_x || r.EmployeeName_y || r.person_uid || "";
                      var displayDate = safeDateDisplay(r.Date);
                      var durText = r.Duration || (r.DurationMinutes ? Math.round(r.DurationMinutes) + " min" : "");
                      var overlap = r.OverlapWith || r.swipe_overlap || "";
                      return (
                        <tr key={idx}>
                          <td>{ empName || <span className="muted">—</span> }</td>
                          <td className="small">{ r.EmployeeID || "" }</td>
                          <td className="small">{ r.CardNumber || "" }</td>
                          <td className="small">{ displayDate }</td>
                          <td className="small">{ durText }</td>
                          <td className="small">{ r.Reasons ? <span className="pill">{r.Reasons}</span> : <span className="muted">OK</span> }</td>
                          <td className="small">{ overlap ? <span title={String(overlap)}>{String(overlap).split(";").slice(0,3).join(", ")}</span> : <span className="muted">—</span> }</td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>

                <div className="pagination">
                  <button onClick={function(){ setPage(function(p){ return Math.max(1,p-1); }); }} disabled={page<=1}>Prev</button>
                  <div className="muted">Page {page} / {totalPages}</div>
                  <button onClick={function(){ setPage(function(p){ return Math.min(totalPages,p+1); }); }} disabled={page>=totalPages}>Next</button>
                </div>
              </div>

              <aside className="right">
                <div style={{marginBottom:12}}>
                  <strong>Files:</strong>
                  <div className="muted">{ (summary.files || []).join(", ") }</div>
                </div>

                <div style={{marginBottom:12}}>
                  <strong>Top reasons</strong>
                  <ul>
                    { Object.entries(reasonsCount).sort(function(a,b){ return b[1]-a[1]; }).slice(0,10).map(function(kv){
                      return <li key={kv[0]}><b>{kv[1]}</b> — <span className="small">{kv[0]}</span></li>;
                    })}
                    { Object.keys(reasonsCount).length === 0 && <div className="muted">No flags found</div> }
                  </ul>
                </div>

                <div>
                  <strong>Help</strong>
                  <div className="small muted" style={{marginTop:6}}>
                    - Click <b>Run</b> to trigger analysis for the chosen date(s).<br/>
                    - Range calls `/run?date=YYYY-MM-DD` for each date in the range sequentially.<br/>
                    - Overlap details live in <code>OverlapWith</code> field (semicolon-separated person_uids).<br/>
                    - If CORS errors occur, enable CORS in Flask or host this file on same host as API.
                  </div>
                </div>

                <div style={{marginTop:12}}>
                  <strong>Raw JSON preview (first row)</strong>
                  <pre>{ rows[0] ? JSON.stringify(rows[0], null, 2) : "No sample yet" }</pre>
                </div>
              </aside>
            </div>
          </div>
        );
      }

      ReactDOM.render(React.createElement(App), document.getElementById('root'));
    </script>
  </body>
</html>











C:\Users\W0024618\Desktop\Trend Analysis\backend\app.py

from flask import Flask, jsonify, request
from datetime import datetime, timedelta
from pathlib import Path
import logging
import pandas as pd

# Try to enable CORS if available; otherwise continue without it.
try:
    from flask_cors import CORS
    _HAS_CORS = True
except Exception:
    CORS = None
    _HAS_CORS = False

# import runner (local)
from trend_runner import run_trend_for_date

app = Flask(__name__)
if _HAS_CORS:
    CORS(app)
else:
    logging.warning("flask_cors not available; continuing without CORS. Install Flask-Cors to enable cross-origin access from browser.")

logging.basicConfig(level=logging.INFO)

# Resolve output directory relative to this file
BASE_DIR = Path(__file__).parent.resolve()
DEFAULT_OUTDIR = BASE_DIR / "outputs"
DEFAULT_OUTDIR.mkdir(parents=True, exist_ok=True)


def _clean_sample_df(df: pd.DataFrame, max_rows: int = 10):
    """
    Return a clean JSON-serializable sample. Drop any _x/_y duplicates and convert datetimes.
    """
    if df is None or df.empty:
        return []
    # drop _x/_y columns
    cols_to_drop = [c for c in df.columns if c.endswith('_x') or c.endswith('_y')]
    if cols_to_drop:
        # prefer base name (already present) otherwise rename _x/_y -> base
        for c in cols_to_drop:
            base = c[:-2]
            if base in df.columns:
                try:
                    df = df.drop(columns=[c])
                except Exception:
                    pass
            else:
                try:
                    df = df.rename(columns={c: base})
                except Exception:
                    pass
    df = df.loc[:, ~df.columns.duplicated()]
    # convert datetimes if present
    for dtcol in ('FirstSwipe','LastSwipe','LocaleMessageTime'):
        if dtcol in df.columns:
            try:
                df[dtcol] = pd.to_datetime(df[dtcol], errors='coerce')
            except Exception:
                pass
    return df.head(max_rows).to_dict(orient='records')


@app.route('/')
def root():
    return "Trend Analysis API — Pune test"

@app.route('/run', methods=['GET', 'POST'])
def run_trend():
    """
    /run?date=YYYY-MM-DD                 -> single date
    /run?start=YYYY-MM-DD&end=YYYY-MM-DD -> date range inclusive
    POST json: { "date": "..."} or { "start": "...", "end":"..." }
    Returns summary + sample rows + list of generated files.
    """
    params = {}
    if request.method == 'GET':
        params = request.args.to_dict()
    else:
        if request.is_json:
            params = request.json or {}

    # parse date(s)
    date_str = params.get('date')
    start_str = params.get('start')
    end_str = params.get('end')

    dates = []
    try:
        if date_str:
            dt = datetime.strptime(date_str, "%Y-%m-%d").date()
            dates = [dt]
        elif start_str and end_str:
            s = datetime.strptime(start_str, "%Y-%m-%d").date()
            e = datetime.strptime(end_str, "%Y-%m-%d").date()
            if e < s:
                return jsonify({"error":"end must be >= start"}), 400
            cur = s
            while cur <= e:
                dates.append(cur)
                cur = cur + timedelta(days=1)
        else:
            # default: today
            dates = [datetime.now().date()]
    except Exception as e:
        return jsonify({"error": f"Invalid date format: {e}"}), 400

    combined_rows = []
    files = []
    total_rows = 0
    total_flagged = 0
    samples = []

    for d in dates:
        try:
            df = run_trend_for_date(d, outdir=str(DEFAULT_OUTDIR))
        except Exception as e:
            logging.exception("run_trend_for_date failed for %s", d)
            return jsonify({"error": f"runner failed for {d}: {e}"}), 500

        csv_path = DEFAULT_OUTDIR / f"trend_pune_{d.strftime('%Y%m%d')}.csv"
        files.append(csv_path.name if csv_path.exists() else None)

        if df is None or df.empty:
            continue

        # ensure Reasons column exists
        if 'Reasons' not in df.columns:
            df['Reasons'] = None

        # count
        total_rows += len(df)
        total_flagged += int(df['Reasons'].notna().sum())

        # sample top flagged first, else top rows
        flagged = df[df['Reasons'].notna()]
        sample_df = flagged.head(10) if not flagged.empty else df.head(10)
        samples.extend(_clean_sample_df(sample_df, max_rows=10))

        # keep combined rows if user wants full (we won't return full by default)
        combined_rows.append(df)

    # combine for convenience if needed
    combined_df = pd.concat(combined_rows, ignore_index=True) if combined_rows else pd.DataFrame()

    # produce response
    resp = {
        "start_date": dates[0].isoformat() if dates else None,
        "end_date": dates[-1].isoformat() if dates else None,
        "files": [f for f in files if f],
        "rows": int(total_rows),
        "flagged_rows": int(total_flagged),
        "sample": samples[:20]  # limit sample size
    }
    return jsonify(resp)


@app.route('/latest', methods=['GET'])
def latest_results():
    p = Path(DEFAULT_OUTDIR)
    csvs = sorted(p.glob("trend_pune_*.csv"), reverse=True)
    if not csvs:
        return jsonify({"error": "no outputs found"}), 404
    latest = csvs[0]
    try:
        df = pd.read_csv(latest)
    except Exception:
        df = pd.read_csv(latest, dtype=str)
    sample = _clean_sample_df(df, max_rows=5)
    return jsonify({
        "file": latest.name,
        "rows": int(len(df)),
        "sample": sample
    })


@app.route('/record', methods=['GET'])
def get_record():
    """
    /record?employee_id=... or /record?person_uid=...
    Returns matching rows from latest output (cleaned).
    """
    q = request.args.get('employee_id') or request.args.get('person_uid')
    p = Path(DEFAULT_OUTDIR)
    csvs = sorted(p.glob("trend_pune_*.csv"), reverse=True)
    if not csvs:
        return jsonify({'error':'no outputs'}), 404
    try:
        df = pd.read_csv(csvs[0], parse_dates=['FirstSwipe','LastSwipe'], infer_datetime_format=True)
    except Exception:
        df = pd.read_csv(csvs[0])
    # clean suffixes
    df_clean = pd.DataFrame(_clean_sample_df(df, max_rows=len(df)))
    if q is None:
        return jsonify(df_clean.head(10).to_dict(orient='records'))
    mask = (df_clean.get('EmployeeID', '').astype(str) == str(q)) | (df_clean.get('person_uid', '').astype(str) == str(q))
    rows = df_clean[mask]
    if rows.empty:
        return jsonify({'error':'not found'}), 404
    return jsonify(rows.to_dict(orient='records'))


if __name__ == "__main__":
    # bind 0.0.0.0 so it is reachable on LAN (if firewall / network allows)
    app.run(host="0.0.0.0", port=8002, debug=True)







