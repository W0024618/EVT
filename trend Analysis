When i Update this we got 


react-dom.development.js:29905 Download the React DevTools for a better development experience: https://reactjs.org/link/react-devtools
babel.min.js:24 You are using the in-browser Babel transformer. Be sure to precompile your scripts for production - https://babeljs.io/docs/setup/
u @ babel.min.js:24
f @ babel.min.js:1
(anonymous) @ babel.min.js:1
babel.min.js:7 Uncaught SyntaxError: Inline Babel script: Unexpected token (174:35) (at babel.min.js:7:10099)
  172 |             <div className="cards">
  173 |               <div className="card">
> 174 |                 <h3>{summary.rows ?? 0}</h3>
      |                                    ^
  175 |                 <p>Rows analysed</p>
  176 |               </div>
  177 |               <div className="card">
    at J.raise (babel.min.js:7:10099)
    at X.unexpected (babel.min.js:5:27476)
    at te.parseExprAtom (babel.min.js:6:30787)
    at t.parseExprAtom (babel.min.js:8:22540)
    at te.parseExprSubscripts (babel.min.js:6:25684)
    at te.parseMaybeUnary (babel.min.js:6:25267)
    at te.parseExprOps (babel.min.js:6:23839)
    at te.parseMaybeConditional (babel.min.js:6:23430)
    at te.parseMaybeAssign (babel.min.js:6:22650)
    at t.parseMaybeAssign (babel.min.js:8:12561)
J.raise @ babel.min.js:7
X.unexpected @ babel.min.js:5
te.parseExprAtom @ babel.min.js:6
(anonymous) @ babel.min.js:8
te.parseExprSubscripts @ babel.min.js:6
te.parseMaybeUnary @ babel.min.js:6
te.parseExprOps @ babel.min.js:6
te.parseMaybeConditional @ babel.min.js:6
te.parseMaybeAssign @ babel.min.js:6
(anonymous) @ babel.min.js:8
te.parseConditional @ babel.min.js:6
(anonymous) @ babel.min.js:8
te.parseMaybeConditional @ babel.min.js:6
te.parseMaybeAssign @ babel.min.js:6
(anonymous) @ babel.min.js:8
te.parseExpression @ babel.min.js:6
ge.jsxParseExpressionContainer @ babel.min.js:8
ge.jsxParseElementAt @ babel.min.js:8
ge.jsxParseElementAt @ babel.min.js:8
ge.jsxParseElementAt @ babel.min.js:8
ge.jsxParseElementAt @ babel.min.js:8
ge.jsxParseElement @ babel.min.js:8
(anonymous) @ babel.min.js:8
te.parseExprSubscripts @ babel.min.js:6
te.parseMaybeUnary @ babel.min.js:6
te.parseExprOps @ babel.min.js:6
te.parseMaybeConditional @ babel.min.js:6
te.parseMaybeAssign @ babel.min.js:6
(anonymous) @ babel.min.js:8
te.parseParenAndDistinguishExpression @ babel.min.js:7
te.parseExprAtom @ babel.min.js:6
(anonymous) @ babel.min.js:8
te.parseExprSubscripts @ babel.min.js:6
te.parseMaybeUnary @ babel.min.js:6
te.parseExprOps @ babel.min.js:6
te.parseMaybeConditional @ babel.min.js:6
te.parseMaybeAssign @ babel.min.js:6
(anonymous) @ babel.min.js:8
te.parseExpression @ babel.min.js:6
z.parseReturnStatement @ babel.min.js:6
z.parseStatement @ babel.min.js:5
(anonymous) @ babel.min.js:8
z.parseBlockBody @ babel.min.js:6
z.parseBlock @ babel.min.js:6
te.parseFunctionBody @ babel.min.js:7
(anonymous) @ babel.min.js:8
z.parseFunction @ babel.min.js:6
z.parseFunctionStatement @ babel.min.js:6
z.parseStatement @ babel.min.js:5
(anonymous) @ babel.min.js:8
z.parseBlockBody @ babel.min.js:6
z.parseTopLevel @ babel.min.js:5
t.parse @ babel.min.js:5
h @ babel.min.js:4
n.parse @ babel.min.js:2
n.parseCode @ babel.min.js:2
(anonymous) @ babel.min.js:14
n.wrap @ babel.min.js:2
e.transform @ babel.min.js:14
s @ babel.min.js:1
r @ babel.min.js:24
i @ babel.min.js:24
r @ babel.min.js:24
o @ babel.min.js:24
u @ babel.min.js:24
f @ babel.min.js:1
(anonymous) @ babel.min.js:1






C:\Users\W0024618\Desktop\Trend Analysis\frontend\index.html

<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Trend Analysis — Dashboard</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- React + ReactDOM + Babel (for quick prototyping) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script crossorigin src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      body { font-family: Inter, Roboto, Arial, sans-serif; margin: 0; padding: 0; background:#f6f7fb; color:#1f2937; }
      .container { max-width:1200px; margin:24px auto; padding:20px; background:#fff; border-radius:8px; box-shadow:0 6px 18px rgba(16,24,40,0.06);}
      header { display:flex; align-items:center; justify-content:space-between; gap:12px; }
      header h1 { margin:0; font-size:20px; }
      .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
      input[type="date"] { padding:8px; border-radius:6px; border:1px solid #e2e8f0; }
      button { padding:8px 12px; border-radius:6px; border:0; background:#2563eb; color:#fff; cursor:pointer; }
      button.secondary { background:#64748b; }
      .cards { display:flex; gap:12px; margin-top:16px; }
      .card { flex:1; background:#f8fafc; padding:12px; border-radius:8px; text-align:center; }
      .card h3 { margin:4px 0; font-size:18px; }
      .card p { margin:0; color:#6b7280; }
      .main { display:flex; gap:18px; margin-top:18px; }
      .left { flex: 2; }
      .right { flex: 1; }
      .chart-wrap { background:#fff; padding:10px; border-radius:8px; box-shadow: inset 0 0 0 1px #f1f5f9; }
      table { width:100%; border-collapse:collapse; margin-top:12px; }
      th, td { padding:8px 6px; border-bottom:1px solid #eef2f7; font-size:13px; }
      th { background:#fafafa; position:sticky; top:0; z-index:1; text-align:left; }
      .small { font-size:12px; color:#475569; }
      .pill { display:inline-block; padding:4px 8px; border-radius:999px; background:#e6f2ff; color:#075985; font-size:12px; }
      .searchbar { margin-top:12px; display:flex; gap:8px; align-items:center; }
      .searchbar input { padding:8px; border-radius:6px; border:1px solid #e2e8f0; width:240px;}
      .pagination { margin-top:10px; display:flex; gap:8px; align-items:center; }
      .muted { color:#64748b; font-size:13px; }
      pre { white-space:pre-wrap; word-wrap:break-word; background:#0f172a; color:#fff; padding:12px; border-radius:8px; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const {useState, useEffect, useRef} = React;

      // CONFIG: API host (change if your flask server is elsewhere)
      const API_BASE = "http://10.199.46.101:8002";

      function formatDateISO(d) {
        if (!d) return "";
        const pad = (n) => n.toString().padStart(2,'0');
        return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
      }

      // helper to iterate date range inclusive
      function datesBetween(start, end) {
        const out = [];
        const cur = new Date(start);
        while (cur <= end) {
          out.push(new Date(cur));
          cur.setDate(cur.getDate()+1);
        }
        return out;
      }

      function App() {
        const [dateFrom, setDateFrom] = useState(() => {
          const d = new Date(); d.setDate(d.getDate()-1); return formatDateISO(d);
        });
        const [dateTo, setDateTo] = useState(() => formatDateISO(new Date()));
        const [loading, setLoading] = useState(false);
        const [summary, setSummary] = useState({rows:0, flagged_rows:0, files:[], end_date:null});
        const [rows, setRows] = useState([]);
        const [reasonsCount, setReasonsCount] = useState({});
        const [filterText, setFilterText] = useState("");
        const [page, setPage] = useState(1);
        const pageSize = 25;
        const chartRef = useRef(null);
        const chartInst = useRef(null);

        // fetch for a single date or range
        async function runForRange() {
          setLoading(true);
          setRows([]);
          setSummary({rows:0, flagged_rows:0, files:[], end_date:null});
          setReasonsCount({});
          try {
            const start = new Date(dateFrom);
            const end = new Date(dateTo);
            // if range is same day, run once; otherwise iterate (careful on large ranges)
            const dates = datesBetween(start, end).map(d => formatDateISO(d));

            // call /run for each date sequentially (to avoid hammering DB); you can parallelize if safe.
            let accRows = [];
            let totalRows = 0, totalFlagged = 0, files = [];
            for (const d of dates) {
              const url = `${API_BASE}/run?date=${d}`;
              // GET
              const r = await fetch(url, {method:'GET'});
              if (!r.ok) {
                const text = await r.text();
                throw new Error(`API returned ${r.status}: ${text}`);
              }
              const js = await r.json();
              // API shape varies in your project — handle both patterns:
              // - {"date":"2025-10-08","rows":..,"flagged_rows":..,"sample":[...],"files":[...]}
              // - {"end_date":..., "rows":.., "flagged_rows":..,"sample":[...], "files":[...]}
              // - Or older shape {"date":..,"rows":..,"flagged_rows":..}
              const sample = js.sample || js.sample || [];
              if (Array.isArray(sample) && sample.length) {
                accRows = accRows.concat(sample);
              }
              totalRows += js.rows || js.rows === 0 ? js.rows : (Array.isArray(sample) ? sample.length : 0);
              totalFlagged += js.flagged_rows || 0;
              if (js.files) files = files.concat(js.files);
            }

            setRows(accRows);
            setSummary({rows: totalRows, flagged_rows: totalFlagged, files: files, end_date: formatDateISO(end)});
            computeReasons(accRows);
            setPage(1);
          } catch (err) {
            alert("Error: " + err.message);
            console.error(err);
          } finally {
            setLoading(false);
          }
        }

        // fetch latest (convenience)
        async function loadLatest() {
          setLoading(true);
          try {
            const r = await fetch(`${API_BASE}/latest`);
            if (!r.ok) throw new Error("latest failed: " + r.status);
            const js = await r.json();
            // latest returns "sample" and file name
            const sample = js.sample || [];
            setRows(sample);
            setSummary({rows: js.rows || sample.length, flagged_rows: sample.filter(x=>x.Reasons).length, files:[js.file]});
            computeReasons(sample);
            setPage(1);
          } catch (err) {
            alert("Error: "+err.message);
            console.error(err);
          } finally {
            setLoading(false);
          }
        }

        function computeReasons(dataRows) {
          const counts = {};
          (dataRows||[]).forEach(r => {
            if (!r.Reasons) return;
            const parts = String(r.Reasons).split(";").map(s=>s.trim()).filter(Boolean);
            parts.forEach(p => counts[p] = (counts[p]||0)+1);
          });
          setReasonsCount(counts);

          // build chart
          buildChart(counts);
        }

        function buildChart(counts) {
          const labels = Object.keys(counts).sort((a,b)=>counts[b]-counts[a]);
          const values = labels.map(l => counts[l]);
          const ctx = chartRef.current.getContext('2d');
          if (chartInst.current) chartInst.current.destroy();
          chartInst.current = new Chart(ctx, {
            type:'bar',
            data:{ labels, datasets:[{ label:'Events', data:values, backgroundColor:'rgba(37,99,235,0.8)' }]},
            options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{y:{beginAtZero:true}} }
          });
        }

        // table helpers: filtering + pagination
        const filtered = rows.filter(r => {
          if (!filterText) return true;
          const s = filterText.toLowerCase();
          // search relevant fields
          return (String(r.EmployeeName||"") + " " + String(r.EmployeeID||"") + " " + String(r.CardNumber||"") + " " + String(r.Reasons||"")).toLowerCase().includes(s);
        });
        const totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
        const pageRows = filtered.slice((page-1)*pageSize, page*pageSize);

        // table export CSV
        function exportCSV() {
          if (!rows.length) { alert("No data to export"); return; }
          const cols = Object.keys(rows[0]);
          const csv = [
            cols.join(","),
            ...rows.map(r => cols.map(c=>JSON.stringify(r[c]===undefined? "": String(r[c]).replace(/\n/g,' '))).join(","))
          ].join("\n");
          const blob = new Blob([csv], {type:'text/csv'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = url; a.download = 'trend_export.csv'; a.click(); URL.revokeObjectURL(url);
        }

        return (
          <div className="container">
            <header>
              <h1>Trend Analysis — Pune (High level)</h1>
              <div className="controls">
                <label className="small">From</label>
                <input type="date" value={dateFrom} onChange={e=>setDateFrom(e.target.value)} />
                <label className="small">To</label>
                <input type="date" value={dateTo} onChange={e=>setDateTo(e.target.value)} />
                <button onClick={runForRange} disabled={loading}>{loading ? 'Running...' : 'Run (date/range)'}</button>
                <button className="secondary" onClick={loadLatest}>Load latest</button>
                <button className="secondary" onClick={exportCSV}>Export CSV</button>
              </div>
            </header>

            <div className="cards">
              <div className="card">
                <h3>{summary.rows ?? 0}</h3>
                <p>Rows analysed</p>
              </div>
              <div className="card">
                <h3>{summary.flagged_rows ?? 0}</h3>
                <p>Flagged rows</p>
              </div>
              <div className="card">
                <h3>{summary.rows ? Math.round((summary.flagged_rows||0)*100/(summary.rows||1)) : 0}%</h3>
                <p>Flagged rate</p>
              </div>
            </div>

            <div className="main">
              <div className="left">
                <div className="chart-wrap" style={{height:240}}>
                  <canvas ref={chartRef}></canvas>
                </div>

                <div className="searchbar">
                  <input placeholder="Search name, employee id, card or reason..." value={filterText} onChange={e=>{setFilterText(e.target.value); setPage(1);}} />
                  <div className="muted">Showing {filtered.length} / {rows.length} rows</div>
                </div>

                <table>
                  <thead>
                    <tr>
                      <th>Employee</th>
                      <th className="small">ID</th>
                      <th className="small">Card</th>
                      <th className="small">Date</th>
                      <th className="small">Duration</th>
                      <th className="small">Reasons</th>
                      <th className="small">Overlap</th>
                    </tr>
                  </thead>
                  <tbody>
                    {pageRows.map((r, idx) => (
                      <tr key={idx}>
                        <td>{r.EmployeeName || r.EmployeeName || r.person_uid || <span className="muted">—</span>}</td>
                        <td className="small">{r.EmployeeID || ""}</td>
                        <td className="small">{r.CardNumber || ""}</td>
                        <td className="small">{new Date(r.Date).toLocaleDateString()}</td>
                        <td className="small">{r.Duration || (r.DurationMinutes ? Math.round(r.DurationMinutes)+" min" : "")}</td>
                        <td className="small">{r.Reasons ? <span className="pill">{r.Reasons}</span> : <span className="muted">OK</span>}</td>
                        <td className="small">{r.OverlapWith ? <span title={r.OverlapWith}>{r.OverlapWith.split(";").slice(0,3).join(", ")}</span> : <span className="muted">—</span>}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>

                <div className="pagination">
                  <button onClick={()=>setPage(p=>Math.max(1,p-1))} disabled={page<=1}>Prev</button>
                  <div className="muted">Page {page} / {totalPages}</div>
                  <button onClick={()=>setPage(p=>Math.min(totalPages,p+1))} disabled={page>=totalPages}>Next</button>
                </div>
              </div>

              <aside className="right">
                <div style={{marginBottom:12}}>
                  <strong>Files:</strong>
                  <div className="muted">{(summary.files || []).join(", ")}</div>
                </div>

                <div style={{marginBottom:12}}>
                  <strong>Top reasons</strong>
                  <ul>
                    {Object.entries(reasonsCount).sort((a,b)=>b[1]-a[1]).slice(0,10).map(([k,v])=>(
                      <li key={k}><b>{v}</b> — <span className="small">{k}</span></li>
                    ))}
                    {Object.keys(reasonsCount).length===0 && <div className="muted">No flags found</div>}
                  </ul>
                </div>

                <div>
                  <strong>Help</strong>
                  <div className="small muted" style={{marginTop:6}}>
                    - Click <b>Run</b> to trigger analysis for the chosen date(s).<br/>
                    - Range calls `/run?date=YYYY-MM-DD` for each date in the range sequentially.<br/>
                    - Overlap details live in <code>OverlapWith</code> field (semicolon-separated person_uids).<br/>
                    - If CORS errors occur, enable CORS in Flask or host this file on same host as API.
                  </div>
                </div>

                <div style={{marginTop:12}}>
                  <strong>Raw JSON preview (first row)</strong>
                  <pre>{rows[0] ? JSON.stringify(rows[0], null, 2) : "No sample yet"}</pre>
                </div>
              </aside>
            </div>
          </div>
        );
      }

      ReactDOM.render(<App />, document.getElementById('root'));
    </script>
  </body>
</html>
